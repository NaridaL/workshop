(self.webpackChunkworkshop=self.webpackChunkworkshop||[]).push([[311],{9764:(n,e,t)=>{"use strict";t.d(e,{V:()=>a});var o=t(3121),r=t(9526);function a({state:n,prop:e,setStatePartial:t,...a}){return r.createElement(o.Z,{variant:"outlined",size:"small",type:"number",value:n[e],onChange:n=>t({[e]:+n.target.value}),label:e,...a})}},9248:(n,e,t)=>{"use strict";t.d(e,{q:()=>o});class o{__init(){this.count=0}__init2(){this.lastTime=performance.now()}constructor(n,e=10){this.notify=n,this.window=e,o.prototype.__init.call(this),o.prototype.__init2.call(this)}tick(n=performance.now()){const e=this.window;if(this.count=(this.count+1)%e,0===this.count){const t=Math.floor(1e3*e/(n-this.lastTime));this.notify(t),this.lastTime=n}}}},9874:(n,e,t)=>{"use strict";t.d(e,{q:()=>f});var o=t(6897),r=t.n(o),a=t(508),c=t.n(a),i=t(9526);const s=n=>"#"+Object.entries(n).map((([n,e])=>encodeURIComponent(n)+"="+encodeURIComponent(e))).join("&"),l=n=>c()(n,(n=>"true"===n||"false"!==n&&("NaN"===n?NaN:"undefined"===n?void 0:"null"===n?null:""===n?"":isNaN(+n)?n:+n))),v=n=>c()(n,(n=>""+n));function f(n,{deserialize:e=l,serialize:t=v,wait:o=1e3}={}){const a=(0,i.useCallback)((()=>{const o="function"==typeof n?n():n,r=e(Object.assign(t(o),(a=document.location.hash)?a.substring(1).split("&").map((n=>{const[e,t]=n.split("=");return[decodeURIComponent(e),decodeURIComponent(t)]})).reduce(((n,[e,t])=>(n[e]=t,n)),{}):{}));var a;return history.pushState(void 0,document.title,s(t(r))),r}),[e,n,t]),[c,f]=(0,i.useState)(a),d=(0,i.useRef)();return d.current||(d.current=r()((function(n){history.pushState(void 0,document.title,s(t(n)))}),o)),(0,i.useEffect)((()=>d.current(c)),[c]),(0,i.useEffect)((()=>{const n=()=>{f(a())};return window.addEventListener("hashchange",n),()=>{window.removeEventListener("hashchange",n)}}),[a]),[c,f]}},3671:(n,e,t)=>{"use strict";t.d(e,{PM:()=>a,Qn:()=>s,X$:()=>c,XJ:()=>i,YQ:()=>x,_x:()=>f,hv:()=>d,kC:()=>p,li:()=>m,nl:()=>h,oe:()=>v,q3:()=>l,t1:()=>u});var o=t(9526),r=t(2182);const a=25.4,c=n=>(0,r.At)(n/r.Co,-1)+"°",i=(n,e)=>e/2/Math.sin(r.gc/n/2),s=(n,e)=>2*e*Math.sin(r.gc/n/2),l=(n,e)=>e/2/Math.tan(r.gc/n/2),v=(n,e)=>e/Math.cos(r.gc/n/2),f=(n,e)=>2*e*Math.tan(r.gc/n/2);function d({sides:n,radius:e,startAngle:t=0,sideLength:a,...c}){if(void 0!==a==(void 0!==e))throw new Error("must set either sideLength or radius");void 0===e&&(e=i(n,a));const{x:s,y:l}=r.V3.polar(e,t);return o.createElement("path",{d:h`
        M${s},${l}
        ${(0,r.hS)(0,n).map((o=>h`L${r.V3.polar(e,t+o*(r.gc/n))}`))}Z`,...c})}function p({id:n,children:e,count:t,stepDeg:a}){return o.createElement(o.Fragment,null,o.createElement("g",{id:n},e),(0,r.hS)(0,t-1).map((e=>o.createElement("use",{key:e,href:"#"+n,transform:`rotate(${(e+1)*a} 0 0)`}))))}const m=[[841,1189,"A0"],[594,841,"A1"],[420,594,"A2"],[297,420,"A3"],[210,297,"A4"],[148,210,"A5"],[105,148,"A6"],[74,105,"A7"],[52,74,"A8"],[37,52,"A9"],[26,37,"A10"],[150,150,"Origami 15cm"],[100,100,"Origami 10cm"],[75,75,"Origami 7.5cm"],[215.9,279.4,"Letter"],[215.9,355.6,"Legal"]],u=m.find((([,,n])=>n.includes("A4")));function h(n,...e){const t=n=>"number"==typeof n?""+n:"string"==typeof n?n:Array.isArray(n)?n.map(t).join(" "):n.x+","+n.y;let o=n[0];for(let r=0;r<e.length;r++)o+=t(e[r]),o+=n[r+1];return o}const x=n=>{const e=window.open(n,"_blank","noopener,noreferrer");e&&(e.opener=null)}},6810:(n,e,t)=>{"use strict";t.d(e,{k:()=>a});var o=t(2182);function r(n){let e,t=n[0],o=1;for(;o<n.length;){const r=n[o],a=n[o+1];if(o+=2,("optionalAccess"===r||"optionalCall"===r)&&null==t)return;"access"===r||"optionalAccess"===r?(e=t,t=a(t)):"call"!==r&&"optionalCall"!==r||(t=a(((...n)=>t.call(e,...n))),e=void 0)}return t}class a{__init(){this.lastPos=o.V3.O}__init2(){this.pressedKeys={}}__init3(){this.pauseCam=!1}constructor(n,e,t){this.state=n,this.onChange=e,this.lockUp=t,a.prototype.__init.call(this),a.prototype.__init2.call(this),a.prototype.__init3.call(this),a.prototype.__init4.call(this),a.prototype.__init5.call(this),a.prototype.__init6.call(this),a.prototype.__init7.call(this)}__init4(){this.setState=n=>{n!==this.state&&o.M4.copy(n,this.state)}}registerListeners(n,e=n){return r([this,"access",n=>n.unregister,"optionalCall",n=>n()]),n.addEventListener("mousemove",this.mousemove),e.addEventListener("keydown",this.keydown),e.addEventListener("keyup",this.keyup),this.unregister=()=>{n.removeEventListener("mousemove",this.mousemove),e.removeEventListener("keydown",this.keydown),e.removeEventListener("keyup",this.keyup)}}unregisterListeners(){r([this,"access",n=>n.unregister,"optionalCall",n=>n()])}tick(){const n=new o.V3(+!!this.pressedKeys.a-+!!this.pressedKeys.d,+!!this.pressedKeys.q+ +!!this.pressedKeys.Control-+!!this.pressedKeys.e-+!!this.pressedKeys[" "],+!!this.pressedKeys.w-+!!this.pressedKeys.s);n.likeO()||(this.state=this.state.translate(n.toLength(.05)),r([this,"access",n=>n.onChange,"optionalCall",n=>n(this.state)]))}__init5(){this.mousemove=n=>{const e=(0,o.V)(n.pageX,n.pageY),t=this.lastPos.to(e);if(1&n.buttons&&!this.pauseCam){const n=o.M4.rotateY(.25*t.x*o.Co).rotateX(.25*t.y*o.Co);this.state=n.times(this.state),r([this,"access",n=>n.onChange,"optionalCall",n=>n(this.state)])}this.lastPos=e}}__init6(){this.keydown=n=>{this.pressedKeys[n.key]=!0,n.preventDefault()}}__init7(){this.keyup=n=>{this.pressedKeys[n.key]=void 0,n.preventDefault()}}getLookAt(){return this.state}static invertLookAt(n){const e=n.transposed().scale(-1);return{eye:e.transformVector(n.getTranslation(),!1),dir:e.transformVector(o.V3.Z,!1),up:e.transformVector(o.V3.Y.negated(),!1)}}static toShortString(n,e=100){const t=(n,e)=>[n.x,n.y,n.z].map((n=>Math.floor(n*e))).join("."),{eye:o,dir:r,up:c}=a.invertLookAt(n);return t(o,e)+"~"+t(r.unit(),100)+"~"+t(c,100)}static fromShortString(n,e=100){const t=(n,e)=>(0,o.V)(n.split(".").map((n=>+n/e))),[r,a,c]=n.split("~"),i=t(r,e);return o.M4.lookAt(i,i.plus(t(a,100)),t(c,100))}}},7044:(n,e,t)=>{"use strict";t.d(e,{j:()=>c});var o=t(2182);function r(n){let e,t=n[0],o=1;for(;o<n.length;){const r=n[o],a=n[o+1];if(o+=2,("optionalAccess"===r||"optionalCall"===r)&&null==t)return;"access"===r||"optionalAccess"===r?(e=t,t=a(t)):"call"!==r&&"optionalCall"!==r||(t=a(((...n)=>t.call(e,...n))),e=void 0)}return t}const a=["zoomIn","zoomOut","left","right","up","down"];class c{__init(){this.lastPos=o.V3.O}__init2(){this.pressedKeys={zoomIn:!1,zoomOut:!1,left:!1,right:!1,up:!1,down:!1}}__init3(){this.pauseCam=!1}__init4(){this.udRot=.1}__init5(){this.rot=0}__init6(){this.dist=10}constructor(n,e={zoomIn:"w",zoomOut:"s",left:"a",right:"d",up:" ",down:"Control"}){this.onChange=n,this.keys=e,c.prototype.__init.call(this),c.prototype.__init2.call(this),c.prototype.__init3.call(this),c.prototype.__init4.call(this),c.prototype.__init5.call(this),c.prototype.__init6.call(this),c.prototype.__init7.call(this),c.prototype.__init8.call(this),c.prototype.__init9.call(this),c.prototype.__init10.call(this),c.prototype.__init11.call(this),c.prototype.__init12.call(this)}__init7(){this.setState=n=>{console.log("setStaet"),[this.udRot,this.rot,this.dist]=c.toOrbitCameraState(n)}}static toOrbitCameraState(n){if(n instanceof o.M4){const e=n.transposed().scale(-1).transformVector(n.getTranslation(),!1);return[Math.atan(e.z/e.lengthXY()),e.angleXY(),e.length()]}return n}registerListeners(n,e=n){return r([this,"access",n=>n.unregister,"optionalCall",n=>n()]),n.addEventListener("mousemove",this.mousemove),n.addEventListener("wheel",this.wheel),e.addEventListener("keydown",this.keydown),e.addEventListener("keyup",this.keyup),e.addEventListener("blur",this.keyup),this.unregister=()=>{n.removeEventListener("mousemove",this.mousemove),n.removeEventListener("wheel",this.wheel),e.removeEventListener("keydown",this.keydown),e.removeEventListener("keyup",this.keyup),e.removeEventListener("keyup",this.keyup)}}__init8(){this.blur=()=>{}}unregisterListeners(){r([this,"access",n=>n.unregister,"optionalCall",n=>n()])}tick(){const n=.1*(+this.pressedKeys.zoomOut-+this.pressedKeys.zoomIn),e=.1*(-+this.pressedKeys.left+ +this.pressedKeys.right),t=(0,o.uZ)(this.udRot+.1*(+this.pressedKeys.up-+this.pressedKeys.down),.5*-Math.PI,.5*Math.PI);0===n&&0===e&&t===this.udRot||(this.dist+=n,this.rot+=e,this.udRot=t,r([this,"access",n=>n.onChange,"optionalCall",n=>n(this.ss)]))}__init9(){this.mousemove=n=>{const e=(0,o.V)(n.pageX,n.pageY),t=this.lastPos.to(e);if(1&n.buttons&&!this.pauseCam){const e=t.x/100,a=(0,o.uZ)(this.udRot+t.y/100,.5*-Math.PI,.5*Math.PI);a===this.udRot&&0===e||(this.udRot=a,this.rot+=e,r([this,"access",n=>n.onChange,"optionalCall",n=>n(this.ss)]),n.stopImmediatePropagation(),n.preventDefault())}this.lastPos=e}}__init10(){this.wheel=n=>{const e=(0,o.uZ)(this.dist+n.deltaY,.1,1e3);e!==this.dist&&(this.dist=e,n.stopImmediatePropagation(),n.preventDefault(),r([this,"access",n=>n.onChange,"optionalCall",n=>n(this.ss)]))}}get ss(){return[this.udRot,this.rot,this.dist]}__init11(){this.keydown=n=>{for(const e of a)if(this.keys[e]===n.key)return this.pressedKeys[e]=!0,n.stopImmediatePropagation(),void n.preventDefault()}}__init12(){this.keyup=n=>{for(const e of a)if(this.keys[e]===n.key)return this.pressedKeys[e]=!1,n.stopImmediatePropagation(),void n.preventDefault()}}getLookAt(){return c.getLookAt(this.ss)}static getLookAt([n,e,t]){return o.M4.rotateZ(e).rotateY(n).transform(o.M4.lookAt((0,o.V)(t,0,0),o.V3.O,o.V3.Z))}static invertLookAt(n){const e=n.transposed().scale(-1);return{eye:e.transformVector(n.getTranslation(),!1),dir:e.transformVector(o.V3.Z,!1),up:e.transformVector(o.V3.Y.negated(),!1)}}static toShortString(n,e=100){const[t,o,r]=this.toOrbitCameraState(n),a=(n,e)=>Math.floor(n*e);return a(t,100)+"~"+a(o,100)+"~"+a(r,100)}static fromShortString(n,e=100){const t=(n,e)=>+n/e,[o,r,a]=n.split("~");return[t(o,100),t(r,100),t(a,100)]}}},3192:(n,e,t)=>{"use strict";t.d(e,{XM:()=>y,tz:()=>b,A0:()=>R});var o=t(4625),r=t(8356),a=t(5069),c=t(4353),i=t(3120),s=t(8105),l=t(9309),v=t(897),f=t(8051),d=t(7392),p=t(9526),m=t(5583),u=t(2004),h=t(9248),x=t(3671);function g(n){let e,t=n[0],o=1;for(;o<n.length;){const r=n[o],a=n[o+1];if(o+=2,("optionalAccess"===r||"optionalCall"===r)&&null==t)return;"access"===r||"optionalAccess"===r?(e=t,t=a(t)):"call"!==r&&"optionalCall"!==r||(t=a(((...n)=>t.call(e,...n))),e=void 0)}return t}function y({sx:n,animate:e,state:t,Renderer:f,focusable:d,rendererRef:m}){const u=(0,p.useRef)(),[h,g]=(0,p.useState)(),[y,R]=(0,p.useState)(),T=(0,p.useCallback)((async n=>{const e=n.currentTarget.dataset.dim.split("x").map((n=>+n));if(g(void 0),u.current)try{const n=URL.createObjectURL(await u.current.renderImage(e,R));R(void 0),(0,x.YQ)(n)}catch(n){console.error(n)}}),[]);(0,p.useEffect)((()=>{m&&(m.current=u.current)}),[m]);const E=(0,p.useCallback)((n=>g(n.currentTarget)),[]),S=(0,p.useCallback)((()=>g(void 0)),[]);return p.createElement(a.Z,{sx:{...n,position:"relative"}},p.createElement(l.Z,{open:!!h,anchorEl:h,onClose:S},p.createElement(v.Z,{"data-dim":"1920x1080",onClick:T},"Render HD"),p.createElement(v.Z,{"data-dim":"3840x2160 ",onClick:T},"Render 4K")),p.createElement(r.Z,{sx:{position:"absolute",margin:1,right:0}},void 0!==y?p.createElement(i.Z,{variant:"determinate",value:100*y}):p.createElement(s.Z,{size:"small",onClick:E},p.createElement(o.Z,null))),p.createElement(c.Z,{component:b,Renderer:f,animate:e,state:t,rendererRef:u,focusable:d,sx:{width:"100%",height:"100%"}}))}const b=({Renderer:n,onFps:e,animate:t,state:o,rendererRef:r,focusable:a})=>{const c=(0,p.useRef)(null),i=(0,p.useRef)();(0,p.useEffect)((()=>(c.current&&(i.current=new n(c.current,e),i.current.start(),r&&(r.current=i.current)),()=>{i.current&&i.current.destroy()})),[n,e,r]);const s=(0,f.Z)();return(0,p.useEffect)((()=>{i.current&&Object.assign(i.current.dyn,{colorBackground:d.iv(s.palette.background.default).gl(),colorPrimary:d.iv(s.palette.primary.main).gl(),colorSecondary:d.iv(s.palette.secondary.main).gl()})}),[s.palette]),(0,p.useEffect)((()=>{i.current&&(i.current.animate=t)}),[t]),(0,p.useEffect)((()=>{i.current&&Object.assign(i.current.dyn,o)}),[o]),p.createElement("canvas",{ref:c,style:{width:"100%",height:"100%"}})};class R{__init(){this.mousePos=[-1,-1]}__init2(){this.dyn={}}__init3(){this.animate=!0}constructor(n,e,t){this.fragShader=n,this.canvas=e,R.prototype.__init.call(this),R.prototype.__init2.call(this),R.prototype.__init3.call(this),R.prototype.__init4.call(this);const o=u.ZG.create({canvas:e,alpha:!0,premultipliedAlpha:!0});this.gl=o,console.log("this.canvas.clientWidth",this.canvas.clientWidth),0!==this.canvas.clientWidth&&o.fixCanvasRes(1),o.canvas.addEventListener("mouseleave",(n=>{this.mousePos=[-1,-1]})),o.canvas.addEventListener("mousemove",(n=>{const e=n.currentTarget,{width:t,height:o}=e.getBoundingClientRect();this.mousePos=[e.width*(n.offsetX/t),e.height*(1-n.offsetY/o)]})),this.planeMesh=u.Kj.plane({startX:-1,startY:-1,width:2,height:2}),this.planeMesh.compile(o),this.fpsController=t&&new h.q(t),this.updateShader()}updateShader(){this.buildShader(t(7962).Z,this.fragShader())}__init4(){this.buildShader=function(n){let e,t=[];return function(...o){return(t.length!==o.length||t.some(((n,e)=>n!==o[e])))&&(t=o,e=n(...o)),e}}(((n,e)=>{try{this.shader&&this.gl.deleteProgram(this.shader.program),this.shader=u.ex.create(n,e)}catch(n){if(console.clear(),console.error(n),!this.shader)throw n}}))}start(){this.gl.animate(this.render.bind(this))}render(n){this.gl.makeCurrent(),this.updateShader(),g([this,"access",n=>n.fpsController,"optionalAccess",n=>n.tick,"call",e=>e(n)]),this.shader&&this.shader.uniforms({iResolution:[this.gl.canvas.width,this.gl.canvas.height],iMouse:this.mousePos,iTime:this.animate?n/1e3:0}).uniforms(this.dyn).uniforms(this.uniforms()).draw(this.planeMesh)}destroy(){}async renderImage([n,e],t){g([t,"optionalCall",n=>n(0)]),await(0,m.Z)(10);const o=document.createElement("canvas");o.width=n,o.height=e;const r=new this.constructor(o);Object.assign(r.dyn,this.dyn);const a=256,c=r.gl;c.enable(c.SCISSOR_TEST);let i=0;for(let o=0;o<n;o+=a)for(let s=0;s<e;s+=a){const l=Math.min(a,n-o),v=Math.min(a,e-s);c.scissor(o,s,l,v),r.render(0),await(0,m.Z)(0),i+=l*v,g([t,"optionalCall",t=>t(i/(n*e))])}return new Promise(((n,e)=>o.toBlob((t=>t?n(t):e("error creating png from canvas")),"png")))}uniforms(){return{}}}},9746:(n,e,t)=>{"use strict";t.r(e),t.d(e,{default:()=>g});var o=t(6726),r=t(8864),a=t(5069),c=t(4353),i=t(871),s=t(897),l=t(882),v=t(8051),f=t(492),d=t(9526),p=t(9764),m=t(9874),u=(t(6810),t(7044),t(3192));const h={a:.2,b:.2,c:.2,d:.2,animate:!0};function x({frag:n,sx:e,animate:o,state:r}){const i=(0,d.useCallback)(u.A0.bind(void 0,(()=>t(8261)("./"+n+".frag").default)),[n]);return d.createElement(a.Z,{sx:e},d.createElement(c.Z,{component:u.tz,Renderer:i,animate:o,state:r,sx:{width:"100%",height:"100%"}}))}const g=()=>{const[n,e]=(0,d.useState)(void 0),[t,a]=(0,d.useState)(512),[c,u]=(0,m.q)(h),g=(0,d.useCallback)((n=>u((e=>({...e,...n})))),[u]),y=(0,d.useRef)(void 0);(0,d.useEffect)((()=>{}),[c.cam]),(0,v.Z)(),(0,d.useEffect)((()=>{y.current&&Object.assign(y.current.dyn,c)}),[c]);return(0,d.useCallback)((({dim:e,children:t})=>{return d.createElement(r.Z,{variant:"contained",onClick:()=>{},disabled:void 0!==n},void 0===n?t:"Rendering... "+(o=""+Math.floor(100*n),f.Z.format(o,"monospace")).padStart(3," ")+"%");var o}),[()=>{},n]),d.createElement(i.ZP,{container:!0,style:{height:"99%"},spacing:2,padding:2},d.createElement(i.ZP,{item:!0,xs:12},d.createElement(x,{frag:"demoTemple",sx:{height:500},animate:c.animate,state:c})),d.createElement(i.ZP,{item:!0,xs:12,md:6,lg:4},d.createElement(o.Z,{checked:c.animate,onChange:(n,e)=>g({animate:e})}),d.createElement(l.Z,{onChange:n=>a(+n.target.value),value:t},d.createElement(s.Z,{value:256},"256x256"),d.createElement(s.Z,{value:512},"512x512")),d.createElement(p.V,{state:c,setStatePartial:g,prop:"a",inputProps:{step:.05}}),d.createElement(p.V,{state:c,setStatePartial:g,prop:"b",inputProps:{step:.05}}),d.createElement(p.V,{state:c,setStatePartial:g,prop:"c",inputProps:{step:.05}}),d.createElement(p.V,{state:c,setStatePartial:g,prop:"d",inputProps:{step:.05}})))}},7962:(n,e,t)=>{"use strict";t.d(e,{Z:()=>o});const o="#version 300 es\nprecision highp float;\n\nin vec4 ts_Vertex;\nin vec2 ts_TexCoord;\nout vec2 coord;\nvoid main() {\n  gl_Position = ts_Vertex;\n  coord = ts_TexCoord;\n}\n"},2699:(n,e,t)=>{"use strict";t.r(e),t.d(e,{default:()=>o});const o="#version 300 es\n\nprecision highp float;\n// START ../common/colors.glsl\nconst vec3 INDIAN_RED = vec3(0.804, 0.361, 0.361);\nconst vec3 LIGHT_CORAL = vec3(0.941, 0.502, 0.502);\nconst vec3 SALMON = vec3(0.98, 0.502, 0.447);\nconst vec3 DARK_SALMON = vec3(0.914, 0.588, 0.478);\nconst vec3 LIGHT_SALMON = vec3(1.0, 0.627, 0.478);\nconst vec3 CRIMSON = vec3(0.863, 0.078, 0.235);\nconst vec3 RED = vec3(1.0, 0.0, 0.0);\nconst vec3 FIRE_BRICK = vec3(0.698, 0.133, 0.133);\nconst vec3 DARK_RED = vec3(0.545, 0.0, 0.0);\nconst vec3 PINK = vec3(1.0, 0.753, 0.796);\nconst vec3 LIGHT_PINK = vec3(1.0, 0.714, 0.757);\nconst vec3 HOT_PINK = vec3(1.0, 0.412, 0.706);\nconst vec3 DEEP_PINK = vec3(1.0, 0.078, 0.576);\nconst vec3 MEDIUM_VIOLET_RED = vec3(0.78, 0.082, 0.522);\nconst vec3 PALE_VIOLET_RED = vec3(0.859, 0.439, 0.576);\nconst vec3 CORAL = vec3(1.0, 0.498, 0.314);\nconst vec3 TOMATO = vec3(1.0, 0.388, 0.278);\nconst vec3 ORANGE_RED = vec3(1.0, 0.271, 0.0);\nconst vec3 DARK_ORANGE = vec3(1.0, 0.549, 0.0);\nconst vec3 ORANGE = vec3(1.0, 0.647, 0.0);\nconst vec3 GOLD = vec3(1.0, 0.843, 0.0);\nconst vec3 YELLOW = vec3(1.0, 1.0, 0.0);\nconst vec3 LIGHT_YELLOW = vec3(1.0, 1.0, 0.878);\nconst vec3 LEMON_CHION = vec3(1.0, 0.98, 0.804);\nconst vec3 LIGHT_GOLDENROD_YELLOW = vec3(0.98, 0.98, 0.824);\nconst vec3 PAPAYA_WHIP = vec3(1.0, 0.937, 0.835);\nconst vec3 MOCCASIN = vec3(1.0, 0.894, 0.71);\nconst vec3 PEACH_PU = vec3(1.0, 0.855, 0.725);\nconst vec3 PALE_GOLDENROD = vec3(0.933, 0.91, 0.667);\nconst vec3 KHAKI = vec3(0.941, 0.902, 0.549);\nconst vec3 DARK_KHAKI = vec3(0.741, 0.718, 0.42);\nconst vec3 LAVENDER = vec3(0.902, 0.902, 0.98);\nconst vec3 THISTLE = vec3(0.847, 0.749, 0.847);\nconst vec3 PLUM = vec3(0.867, 0.627, 0.867);\nconst vec3 VIOLET = vec3(0.933, 0.51, 0.933);\nconst vec3 ORCHID = vec3(0.855, 0.439, 0.839);\nconst vec3 FUCHSIA = vec3(1.0, 0.0, 1.0);\nconst vec3 MAGENTA = vec3(1.0, 0.0, 1.0);\nconst vec3 MEDIUM_ORCHID = vec3(0.729, 0.333, 0.827);\nconst vec3 MEDIUM_PURPLE = vec3(0.576, 0.439, 0.859);\nconst vec3 BLUE_VIOLET = vec3(0.541, 0.169, 0.886);\nconst vec3 DARK_VIOLET = vec3(0.58, 0.0, 0.827);\nconst vec3 DARK_ORCHID = vec3(0.6, 0.196, 0.8);\nconst vec3 DARK_MAGENTA = vec3(0.545, 0.0, 0.545);\nconst vec3 PURPLE = vec3(0.502, 0.0, 0.502);\nconst vec3 INDIGO = vec3(0.294, 0.0, 0.51);\nconst vec3 SLATE_BLUE = vec3(0.416, 0.353, 0.804);\nconst vec3 DARK_SLATE_BLUE = vec3(0.282, 0.239, 0.545);\nconst vec3 GREEN_YELLOW = vec3(0.678, 1.0, 0.184);\nconst vec3 CHARTREUSE = vec3(0.498, 1.0, 0.0);\nconst vec3 LAWN_GREEN = vec3(0.486, 0.988, 0.0);\nconst vec3 LIME = vec3(0.0, 1.0, 0.0);\nconst vec3 LIME_GREEN = vec3(0.196, 0.804, 0.196);\nconst vec3 PALE_GREEN = vec3(0.596, 0.984, 0.596);\nconst vec3 LIGHT_GREEN = vec3(0.565, 0.933, 0.565);\nconst vec3 MEDIUM_SPRING_GREEN = vec3(0.0, 0.98, 0.604);\nconst vec3 SPRING_GREEN = vec3(0.0, 1.0, 0.498);\nconst vec3 MEDIUM_SEA_GREEN = vec3(0.235, 0.702, 0.443);\nconst vec3 SEA_GREEN = vec3(0.18, 0.545, 0.341);\nconst vec3 FOREST_GREEN = vec3(0.133, 0.545, 0.133);\nconst vec3 GREEN = vec3(0.0, 0.502, 0.0);\nconst vec3 DARK_GREEN = vec3(0.0, 0.392, 0.0);\nconst vec3 YELLOW_GREEN = vec3(0.604, 0.804, 0.196);\nconst vec3 OLIVE_DRAB = vec3(0.42, 0.557, 0.137);\nconst vec3 OLIVE = vec3(0.502, 0.502, 0.0);\nconst vec3 DARK_OLIVE_GREEN = vec3(0.333, 0.42, 0.184);\nconst vec3 MEDIUM_AQUAMARINE = vec3(0.4, 0.804, 0.667);\nconst vec3 DARK_SEA_GREEN = vec3(0.561, 0.737, 0.561);\nconst vec3 LIGHT_SEA_GREEN = vec3(0.125, 0.698, 0.667);\nconst vec3 DARK_CYAN = vec3(0.0, 0.545, 0.545);\nconst vec3 TEAL = vec3(0.0, 0.502, 0.502);\nconst vec3 AQUA = vec3(0.0, 1.0, 1.0);\nconst vec3 CYAN = vec3(0.0, 1.0, 1.0);\nconst vec3 LIGHT_CYAN = vec3(0.878, 1.0, 1.0);\nconst vec3 PALE_TURQUOISE = vec3(0.686, 0.933, 0.933);\nconst vec3 AQUAMARINE = vec3(0.498, 1.0, 0.831);\nconst vec3 TURQUOISE = vec3(0.251, 0.878, 0.816);\nconst vec3 MEDIUM_TURQUOISE = vec3(0.282, 0.82, 0.8);\nconst vec3 DARK_TURQUOISE = vec3(0.0, 0.808, 0.82);\nconst vec3 CADET_BLUE = vec3(0.373, 0.62, 0.627);\nconst vec3 STEEL_BLUE = vec3(0.275, 0.51, 0.706);\nconst vec3 LIGHT_STEEL_BLUE = vec3(0.69, 0.769, 0.871);\nconst vec3 POWDER_BLUE = vec3(0.69, 0.878, 0.902);\nconst vec3 LIGHT_BLUE = vec3(0.678, 0.847, 0.902);\nconst vec3 SKY_BLUE = vec3(0.529, 0.808, 0.922);\nconst vec3 LIGHT_SKY_BLUE = vec3(0.529, 0.808, 0.98);\nconst vec3 DEEP_SKY_BLUE = vec3(0.0, 0.749, 1.0);\nconst vec3 DODGER_BLUE = vec3(0.118, 0.565, 1.0);\nconst vec3 CORNLOWER_BLUE = vec3(0.392, 0.584, 0.929);\nconst vec3 MEDIUM_SLATE_BLUE = vec3(0.482, 0.408, 0.933);\nconst vec3 ROYAL_BLUE = vec3(0.255, 0.412, 0.882);\nconst vec3 BLUE = vec3(0.0, 0.0, 1.0);\nconst vec3 MEDIUM_BLUE = vec3(0.0, 0.0, 0.804);\nconst vec3 DARK_BLUE = vec3(0.0, 0.0, 0.545);\nconst vec3 NAVY = vec3(0.0, 0.0, 0.502);\nconst vec3 MIDNIGHT_BLUE = vec3(0.098, 0.098, 0.439);\nconst vec3 CORNSILK = vec3(1.0, 0.973, 0.863);\nconst vec3 BLANCHED_ALMOND = vec3(1.0, 0.922, 0.804);\nconst vec3 BISQUE = vec3(1.0, 0.894, 0.769);\nconst vec3 NAVAJO_WHITE = vec3(1.0, 0.871, 0.678);\nconst vec3 WHEAT = vec3(0.961, 0.871, 0.702);\nconst vec3 BURLY_WOOD = vec3(0.871, 0.722, 0.529);\nconst vec3 TAN = vec3(0.824, 0.706, 0.549);\nconst vec3 ROSY_BROWN = vec3(0.737, 0.561, 0.561);\nconst vec3 SANDY_BROWN = vec3(0.957, 0.643, 0.376);\nconst vec3 GOLDENROD = vec3(0.855, 0.647, 0.125);\nconst vec3 DARK_GOLDENROD = vec3(0.722, 0.525, 0.043);\nconst vec3 PERU = vec3(0.804, 0.522, 0.247);\nconst vec3 CHOCOLATE = vec3(0.824, 0.412, 0.118);\nconst vec3 SADDLE_BROWN = vec3(0.545, 0.271, 0.075);\nconst vec3 SIENNA = vec3(0.627, 0.322, 0.176);\nconst vec3 BROWN = vec3(0.647, 0.165, 0.165);\nconst vec3 MAROON = vec3(0.502, 0.0, 0.0);\nconst vec3 WHITE = vec3(1.0, 1.0, 1.0);\nconst vec3 SNOW = vec3(1.0, 0.98, 0.98);\nconst vec3 HONEYDEW = vec3(0.941, 1.0, 0.941);\nconst vec3 MINT_CREAM = vec3(0.961, 1.0, 0.98);\nconst vec3 AZURE = vec3(0.941, 1.0, 1.0);\nconst vec3 ALICE_BLUE = vec3(0.941, 0.973, 1.0);\nconst vec3 GHOST_WHITE = vec3(0.973, 0.973, 1.0);\nconst vec3 WHITE_SMOKE = vec3(0.961, 0.961, 0.961);\nconst vec3 SEASHELL = vec3(1.0, 0.961, 0.933);\nconst vec3 BEIGE = vec3(0.961, 0.961, 0.863);\nconst vec3 OLD_LACE = vec3(0.992, 0.961, 0.902);\nconst vec3 FLORAL_WHITE = vec3(1.0, 0.98, 0.941);\nconst vec3 IVORY = vec3(1.0, 1.0, 0.941);\nconst vec3 ANTIQUE_WHITE = vec3(0.98, 0.922, 0.843);\nconst vec3 LINEN = vec3(0.98, 0.941, 0.902);\nconst vec3 LAVENDER_BLUSH = vec3(1.0, 0.941, 0.961);\nconst vec3 MISTY_ROSE = vec3(1.0, 0.894, 0.882);\nconst vec3 GAINSBORO = vec3(0.863, 0.863, 0.863);\nconst vec3 LIGHT_GREY = vec3(0.827, 0.827, 0.827);\nconst vec3 SILVER = vec3(0.753, 0.753, 0.753);\nconst vec3 DARK_GRAY = vec3(0.663, 0.663, 0.663);\nconst vec3 GRAY = vec3(0.502, 0.502, 0.502);\nconst vec3 DIM_GRAY = vec3(0.412, 0.412, 0.412);\nconst vec3 LIGHT_SLATE_GRAY = vec3(0.467, 0.533, 0.6);\nconst vec3 SLATE_GRAY = vec3(0.439, 0.502, 0.565);\nconst vec3 DARK_SLATE_GRAY = vec3(0.184, 0.31, 0.31);\nconst vec3 BLACK = vec3(0.0, 0.0, 0.0);\n\n// START ../common/matrices.glsl\n// START ./constants.glsl\nconst float SQRT1_2 = 0.7071067811865476;\nconst float SQRT1_3 = 0.57735026919;\nconst float SQRT2 = 1.4142135623730951;\nconst float SQRT3 = 1.732050807568877;\n// sqrt(3)/2 = sin(60*)\nconst float SQRT3_2 = 0.86602540378;\nconst float GOLDEN_RATIO = 1.61803398875;\nconst float PI = 3.141592653589793;\nconst float TAU = 6.28318530718;\n/**\n * One degree in radians. Use like `sin(30 * DEG)`.\n */\nconst float DEGREE = 0.017453292519943295;\n\n\nmat2 rot2(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat2(c, -s, s, c);\n}\nmat3 rotX(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\n}\nmat3 rotY(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\n}\nmat3 rotZ(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\n}\n/**\n * Returns a matrix that puts the camera at the eye point `ex, ey, ez` looking\n * toward the center point `cx, cy, cz` with an up direction of `ux, uy, uz`.\n * This emulates the OpenGL function `gluLookAt()`.\n */\nmat4 lookAt(vec3 eye, vec3 focus, vec3 up) {\n  vec3 f = normalize(eye - focus);\n  vec3 s = normalize(cross(up, f));\n  vec3 t = normalize(cross(f, s));\n\n  return mat4(\n    vec4(s.x, t.x, f.x, 0.0),\n    vec4(s.y, t.y, f.y, 0.0),\n    vec4(s.z, t.z, f.z, 0.0),\n    vec4(-dot(s, eye), -dot(t, eye), -dot(f, eye), 1)\n  );\n}\n\n// the OpenGL function `glFrustum()`.\nmat4 frustum(\n  float left,\n  float right,\n  float bottom,\n  float top,\n  float near,\n  float far\n) {\n  return mat4(\n    vec4(2.0 * near / (right - left), 0.0, 0.0, 0.0),\n    vec4(0, 2.0 * near / (top - bottom), 0.0, 0.0),\n    vec4(\n      (right + left) / (right - left),\n      (top + bottom) / (top - bottom),\n      -(far + near) / (far - near),\n      -1\n    ),\n    vec4(0.0, 0.0, -2.0 * far * near / (far - near), 0.0)\n  );\n}\n\nmat4 perspective(float fovDegrees, float aspect, float near, float far) {\n  float y = tan(fovDegrees * DEGREE / 2.0) * near;\n  float x = y * aspect;\n  return frustum(-x, x, -y, y, near, far);\n}\n\n// START ../common/max3.glsl\nfloat max3(float a, float b, float c) {\n  return max(a, max(b, c));\n}\nfloat max3(vec3 v) {\n  return max(v.x, max(v.y, v.z));\n}\n\n// #pragma glslify: export(max3)\n\n\n// START ../common/polar.glsl\n// START ../common/fromPolar.glsl\n// START ./unmix.glsl\nfloat unmix(float a, float b, float value) {\n  return (value - a) / (b - a);\n}\n\n// #pragma glslify: export(unmix)\n\n\n\nvec3 fromPolar(float radius, float phi, float z) {\n  return vec3(radius * cos(phi), radius * sin(phi), z);\n}\n\nvec2 fromPolar(float radius, float phi) {\n  return vec2(radius * cos(phi), radius * sin(phi));\n}\n\nvec2 fromPolar(vec2 polar) {\n  return fromPolar(polar.x, polar.y);\n}\n\n// #pragma glslify: export(fromPolar)\n\n\n// START ../common/toPolar.glsl\n\n\nvec2 toPolar(vec2 xy) {\n  return vec2(length(xy), atan(xy.y, xy.x));\n}\n\nmat2 toPolarDerivate(vec2 xy) {\n  return mat2(xy.x * xy.x, xy.y * xy.y, -xy.y, xy.x) / dot(xy, xy);\n}\n\n// #pragma glslify: export(toPolar)\n\n\n\n// START ../common/sdf3d/sdArrow.glsl\n// START ./sdCylinder.glsl\nfloat sdCylinder(float radius, float z, vec3 p) {\n  vec2 d = vec2(length(p.xy), abs(p.z)) - vec2(radius, z);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// #pragma glslify: export(sdCylinder)\n\n\n\n// START ./sdCone.glsl\n\n\n/**\n * Signed distance function (SDF) of a cone. The tip of the cone is at the\n * origin and points towards +Z. q is a point on the rim of the cone.\n */\nfloat sdCone(vec2 c, float h, vec3 p) {\n  vec2 q = h * vec2(c.x / c.y, -1.0);\n  vec2 w = vec2(length(p.xz), p.y);\n  vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);\n  vec2 b = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0);\n  float k = sign(q.y);\n  float d = min(dot(a, a), dot(b, b));\n  float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));\n  return sqrt(d) * sign(s);\n}\n// #pragma glslify: export(sdBox)\n\nfloat sdConeB(vec2 c, float h, vec3 p) {\n  float q = length(p.xz);\n  return max(dot(c.xy, vec2(q, p.y)), -h - p.y);\n}\n\nvec3 perpendicularVector(vec3 a) {\n  return cross(a, abs(a.z) > abs(a.x) ? vec3(0, 0, 1) : vec3(0, 1, 0));\n}\n/**\n * Signed distance function (SDF) of an arrow. The arrow goes along the X axis.\n * The shaft of the arrow has thickness TODO. The tip of the arrow has 30°\n * angle, length of TODO, with the widest point being.\n */\nfloat sdArrow(float length, vec3 p) {\n  float r = 0.01;\n  return min(\n    sdCylinder(\n      0.02 - r,\n      0.5 * (length - 0.1) - r,\n      p.yzx - vec3(0, 0, 0.5 * (length - 0.1))\n    ) -\n      r,\n    sdCone(\n      vec2(sin(15.0 * DEGREE), cos(15.0 * DEGREE)),\n      0.15 - r,\n      p.zxy - vec3(0, length - r, 0)\n    ) -\n      r\n  );\n}\nfloat sdArrow(vec3 a, vec3 b, vec3 p) {\n  vec3 x = normalize(b - a);\n  vec3 y = normalize(perpendicularVector(x));\n  vec3 z = cross(x, y);\n  return sdArrow(length(b - a), inverse(mat3(x, y, z)) * (p - a));\n}\n\n// START ../common/sdf3d/sdBox.glsl\n\n\nfloat sdBox(vec3 r, vec3 p) {\n  vec3 q = abs(p) - r;\n  return length(max(q, 0.0)) + min(max3(q), 0.0);\n}\n\nfloat sdBox(vec3 r, float r2, vec3 p) {\n  return sdBox(r - r2, p) - r2;\n}\n\n// #pragma glslify: export(sdBox)\n\n\n// START ../common/sdf3d/sdIcosahedron.glsl\n\n\n// signed distance function for icosahedron\n// cf. https://en.wikipedia.org/wiki/Regular_icosahedron\n// s: edge length\n// p: point to evaluate function for\nfloat sdIcosahedron(float s, vec3 p) {\n  // NN = 1/GOLDEN_RATIO = GOLDEN_RATIO - 1\n  const float K = GOLDEN_RATIO * 0.5;\n  // the three vertices of the icosahedron triangle which\n  // is fully inside the +++ octant. (edge length = 1)\n  const vec3 a = vec3(0.5, K, 0.0);\n  const vec3 b = vec3(0.0, 0.5, K);\n  const vec3 c = vec3(K, 0.0, 0.5);\n  const vec3 ab1 = b - a; // values chosen so edge length is 1\n  const vec3 n1 = normalize(cross(a, b));\n  const vec3 n2 = normalize(cross(b, c));\n  const vec3 n3 = normalize(cross(c, a));\n  const vec3 xyz1 = normalize(vec3(1.0));\n  // for edge-length 1\n  const float INSCRIBED_SPHERE_RADIUS = 0.7557613141;\n\n  // we use a rotation where the icosahedron is symmetric\n  // in all three coordinate planes, and reduce the problem\n  // to the +++ octant\n  p = abs(p);\n\n  // there is one complete triangle in the +++ octant\n  // mirror on planes which go through origin and the\n  // complete triangles sides.\n  if (dot(p, n1) < 0.0) {\n    p += -2.0 * dot(p, n1) * n1;\n  }\n  if (dot(p, n2) < 0.0) {\n    p += -2.0 * dot(p, n2) * n2;\n  }\n  if (dot(p, n3) < 0.0) {\n    p += -2.0 * dot(p, n3) * n3;\n  }\n\n  // rotate space around (1,1,1) vector so that all sides of the triangle\n  // end up mapped on the ab side.\n  vec3 dirs = vec3(-dot(n1, p), -dot(n2, p), -dot(n3, p));\n  if (dirs.y > dirs.x && dirs.y > dirs.z) {\n    p = p.yzx;\n  } else if (dirs.z > dirs.x && dirs.z > dirs.y) {\n    p = p.zxy;\n  }\n\n  // check if the point is directly (perpendicular) above the triangle.\n  // as we have rotated the space, we only need to check if it is\n  // inside one edge.\n  vec3 midAB = (a + b) / 2.0;\n  vec3 pn = normalize(c - midAB);\n  float w = dot(midAB, pn);\n  if (dot(p, pn) > w * s) {\n    // if not, return the distance to the plane the triangle is in\n    return dot(xyz1, p) - INSCRIBED_SPHERE_RADIUS * s;\n  }\n\n  // project the point onto segment ab, and return the distance to it\n  float d3 = dot(ab1, p);\n  d3 = clamp(d3, -0.5 * s, 0.5 * s);\n  vec3 closestp = midAB * s + d3 * ab1;\n  return distance(closestp, p);\n}\n// #pragma glslify: export(sdIcosahedron)\n\n// START ../common/sdf3d/sdOctahedron.glsl\nfloat sdOctahedron(float s, vec3 p) {\n  p = abs(p);\n  float m = p.x + p.y + p.z - s;\n  vec3 q;\n  if (3.0 * p.x < m) q = p.xyz;\n  else if (3.0 * p.y < m) q = p.yzx;\n  else if (3.0 * p.z < m) q = p.zxy;\n  else return m * 0.57735027;\n\n  float k = clamp(0.5 * (q.z - q.y + s), 0.0, s);\n  return length(vec3(q.x, q.y - s + k, q.z - k));\n}\n// #pragma glslify: export(sdOctahedron)\n\nfloat sdOctahedron(vec3 p, float s) {\n  p = abs(p);\n\n  float m = p.x + p.y + p.z - s;\n  //find point on octohedron surf nearest to p\n  vec3 projPoint = p - vec3(0.333333 * m); //project onto surface plane\n  //now push projected point, if outside triangle edge, perpendicular to edge, to edge\n  vec3 toMove = min(projPoint, 0.0); //if projpoint.x<0 move along (1.0,-0.5,-0.5) , etc\n  float toMoveSum = dot(toMove, vec3(1.0)); //which is basically along (1.5,0,0) then vec3(-0.5)\n\n  vec3 movedPoint = projPoint + toMove * vec3(-1.5) + toMoveSum * vec3(0.5); //better to multiply toMove by a matrix (1s diagonal, 0.5 other)?\n\n  movedPoint = max(movedPoint, 0.0); //cap x,y,z to 0 then\n  movedPoint *= s / dot(movedPoint, vec3(1.0)); //scale about 0,0,0\n\n  return length(p - movedPoint);\n}\n\n// START ../common/sdf3d/sdDodecahedron.glsl\n\n\nfloat sdDodecahedron(float s, vec3 p, out vec3 color) {\n  const float PHI = GOLDEN_RATIO;\n  color = vec3(0.2);\n  if (p != abs(p)) {\n    p = abs(p);\n    if (color == vec3(0.2)) color = RED;\n  }\n  p = abs(p);\n  const vec3 fv =\n    vec3(1.0 / PHI, 0, PHI) + 2.0 * vec3(1, 0, 1) + 2.0 * vec3(PHI, 0, 0);\n  const vec3 fv2 =\n    vec3(PHI, 1.0 / PHI, 0) + 2.0 * vec3(1, 1, 0) + 2.0 * vec3(0, PHI, 0);\n  const vec3 fv3 =\n    vec3(0, PHI, 1.0 / PHI) + 2.0 * vec3(0, 1, 1) + 2.0 * vec3(0, 0, PHI);\n  return max3(\n    dot(normalize(fv), p),\n    dot(normalize(fv2), p),\n    dot(normalize(fv3), p)\n  ) -\n  s;\n  //  float m = p.x + p.y + p.z - s;\n  //  vec3 q;\n  //  if (3.0 * p.x < m) q = p.xyz;\n  //  else if (3.0 * p.y < m) q = p.yzx;\n  //  else if (3.0 * p.z < m) q = p.zxy;\n  //  else return m * 0.57735027;\n  //\n  //  float k = clamp(0.5 * (q.z - q.y + s), 0.0, s);\n  //  return length(vec3(q.x, q.y - s + k, q.z - k));\n}\nfloat sdDodecahedron(float s, vec3 p) {\n  vec3 c;\n  return sdDodecahedron(s, p, c);\n}\n\n// START ../common/sdf3d/sdTetrahedron.glsl\n\n\n// START ./sdCapsule.glsl\nfloat sdCapsule(vec3 a, vec3 b, float r, vec3 p) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h) - r;\n}\n// #pragma glslify: export(sdCapsule)\n\n\n\n/**\n * Signed distance function (SDF) of a tetrahedron centered at the origin with\n * side length `2s`.\n *\n * The corners are at `a/b = (+-1,0,sqrt(1/2))` and `c/d = (0,+-1,-sqrt(1/2))`.\n *\n * The side length is `||`\n *\n * The outscribed sphere has a radius of `sqrt(3/2)`.\n *\n * The inscribed sphere has a radius of `sqrt(1/6)`. This is calculated using\n * the fact that the triangle defined by `mid(a,b) = (0,0,sqrt(1/2))`, `c` and\n * `mid(c,d) = (0,0,-sqrt(1/2))` is similar to the triangle `mid(a,b)`, `q`, and\n * `O`.\n *\n * For rounded edges, use TODO.\n *\n * ```\n *           ^ Z\n *           |(+-1, sqrt(1/2))\n *          /\\_\n *        /    \\.q = closest point to center on face\n *      /    .   \\__> Y\n *    /            \\_\n *  /________________\\_(0,-1,sqrt(1/2))\n * (0,-1,-sqrt(1/2))\n * ```\n */\nfloat sdTetrahedron(float s, vec3 p) {\n  const vec3 a = vec3(1, 0, SQRT1_2);\n  const vec3 b = vec3(-1, 0, SQRT1_2);\n  const vec3 c = vec3(0, 1, -SQRT1_2);\n  const vec3 d = vec3(0, -1, -SQRT1_2);\n  const vec3 midBC = 0.5 * (b + c);\n  const vec3 mirror = normalize(cross(midBC - d, midBC - a));\n\n  // Tetra is symmetric in X and Y axes. RED surface in image.\n  p.xy = abs(p.xy);\n  // The part z < 0 is symmetric if we rotate it by 90°. BLUE surface in image.\n  if (p.z < 0.0) {\n    p = vec3(p.y, p.x, -p.z);\n  }\n  // Points below the plane through a, d and mid(b,c) are mirrored through it.\n  // GREEN surface in image.\n  p -= 2.0 * mirror * min(dot(p, mirror), 0.0);\n  // After mirror some points are negative, abs again:\n  p.xy = abs(p.xy);\n\n  // Points are now either above the white surface, or above the positive ab segment.\n  // We shift the coordinate system so that a is now at the origin.\n  p -= vec3(1, 0, SQRT1_2) * s;\n  // Finally, we move points which are directely above the face parallel along\n  // it to a/origin. We can then calculate the sdf as length(p).\n  p.x = max(p.x, 0.0);\n  vec3 midABToC1 = normalize(vec3(0, 1, -SQRT2));\n\n  p -= max(dot(midABToC1, p), 0.0) * midABToC1;\n  return sign(p.z) * length(p);\n}\n\n// Same function but also outputs color for explanation image:\n//float sdTetrahedron(float s, vec3 p, out vec3 color) {\n//  //  return distance(vec3(1), p) - 0.2;\n//  const vec3 a = vec3(0, -1, -SQRT1_2);\n//  const vec3 b = vec3(0, 1, -SQRT1_2);\n//  const vec3 c = vec3(1, 0, SQRT1_2);\n//  const vec3 d = vec3(-1, 0, SQRT1_2);\n//  const vec3 x = 0.5 * (b + d);\n//  const vec3 mirror = normalize(cross(x - a, x - c));\n//\n//  color = WHITE;\n//  if (p.xy != abs(p.xy)) {\n//    p.xy = abs(p.xy);\n//    if (color == WHITE) color = RED;\n//  }\n//  if (p.z < 0.0) {\n//    p = vec3(p.y, p.x, -p.z);\n//    if (color == WHITE) color = BLUE;\n//  }\n//  if (dot(p, mirror) < 0.0) {\n//    if (color == WHITE) color = GREEN;\n//    p -= 2.0 * mirror * min(dot(p, mirror), 0.0);\n//  }\n//  p.xy = abs(p.xy);\n//  p -= vec3(1, 0, SQRT1_2);\n//  p.x = max(p.x, 0.0);\n//  vec3 fgh = normalize(vec3(0, 1, -SQRT2));\n//\n//  p -= max(dot(fgh, p), 0.0) * fgh;\n//  return sign(p.z) * length(p);\n//}\n\n\n// START ../common/ungamma.glsl\nvec3 ungamma(vec4 col) {\n  return pow(col.rgb, vec3(2.2));\n}\nvec3 ungamma(vec3 col) {\n  return pow(col, vec3(2.2));\n}\n\n\nuniform sampler2D texture;\nuniform float iTime;\nuniform vec4 colorPrimary;\nuniform vec4 colorSecondary;\nuniform vec4 colorBackground;\nuniform float a;\nuniform float b;\nuniform float c;\nuniform float d;\nuniform int bandCount;\nuniform vec3 extra;\nuniform vec2 iResolution;\nuniform vec2 iMouse;\nin float n;\nin vec2 coord;\nout vec4 fragColor;\n\n\nstruct Hit {\n  float distance;\n  vec4 color;\n};\nHit mixa(Hit a, Hit b, float t) {\n  return Hit(mix(a.distance, b.distance, t), mix(a.color, b.color, t));\n}\nfloat skybox(vec3 p) {\n  return 32.0 - max3(abs(p));\n}\n\nHit add(Hit a, Hit b) {\n  //    return a.distance < b.distance\n  //        ? Hit(a.distance, a.color)\n  //        : Hit(b.distance, b.color);\n  return mixa(a, b, float(b.distance < a.distance));\n}\n\nHit addTillet(float r, Hit a, Hit b) {\n  if (a.distance < r && b.distance < r) {\n    return Hit(\n      r - distance(vec2(a.distance, b.distance), vec2(r)),\n      mix(a.color, b.color, (a.distance - b.distance) / r * 0.5 + 0.5)\n    );\n  } else {\n    return add(a, b);\n  }\n}\n\nHit addTillet(float r, Hit a, Hit b, vec4 tilletColor) {\n  if (a.distance < r && b.distance < r) {\n    return Hit(\n      r - distance(vec2(a.distance, b.distance), vec2(r)),\n      tilletColor\n    );\n  } else {\n    return add(a, b);\n  }\n}\nHit addTillet2(float r, Hit a, Hit b) {\n  float h = smoothstep(-r, r, a.distance - b.distance);\n  return Hit(\n    mix(a.distance, b.distance, h) - r * h * (1.0 - h),\n    mix(a.color, b.color, h)\n  );\n}\n\nHit neg(Hit a) {\n  return Hit(-a.distance, a.color);\n}\nHit sub(Hit from, Hit what) {\n  Hit whatNeg = neg(what);\n  return mixa(from, whatNeg, float(whatNeg.distance > from.distance));\n}\n\nvec3 modv(vec3 v, vec3 dir1, float y) {\n  float t = dot(v, dir1);\n  return v - floor(t / y) * y * dir1;\n}\nvec3 modRotZ(vec3 p, float count) {\n  vec2 polarXY = toPolar(p.xy);\n  return fromPolar(polarXY.x, mod(polarXY.y, TAU / count), p.z);\n}\n\nfloat sin01(float x) {\n  return 0.5 + 0.5 * sin(x);\n}\nfloat cos01(float x) {\n  return 0.5 + 0.5 * cos(x);\n}\n\nfloat smoothmin(float r, float a, float b) {\n  float h = smoothstep(-r, r, a - b);\n  return mix(a, b, h) - r * h * (1.0 - h);\n}\n\nvec2 project(vec2 a, vec2 onto1) {\n  return onto1 * (dot(a, onto1) / dot(onto1, onto1));\n}\n\nconst float r = 0.0;\nvec3 reject(vec3 a, vec3 b1) {\n  return a - b1 * dot(a, b1);\n}\nfloat demoIcosahedron(vec3 p) {\n  float d1 = sdIcosahedron(1.0 - r, p - vec3(0, 0, 1)) - r;\n  float d2 = p.z;\n  return min(d1, d2);\n}\nfloat demoOctahedron(vec3 p) {\n  float d1 = sdOctahedron(1.0 - r, p - vec3(0, 0, 1)) - r;\n  float d2 = p.z;\n  return min(d1, d2);\n}\nfloat demoCube(vec3 p) {\n  float d1 = sdBox(vec3(1.0 - r), p - vec3(0, 0, 1)) - r;\n  float d2 = p.z;\n  return min(d1, d2);\n}\nHit gizmo(vec3 p) {\n  vec3 absp = abs(p);\n\n  Hit res = Hit(sdArrow(1.0, p), vec4(RED, 1));\n  res = add(res, Hit(sdArrow(1.0, p.yzx), vec4(GREEN, 1)));\n  res = add(res, Hit(sdArrow(1.0, p.zxy), vec4(BLUE, 1)));\n  res = add(res, Hit(length(p) - 0.05, vec4(BLACK, 1)));\n  return res;\n}\n// START ../common/squareWave.glsl\nfloat squareWave(float x) {\n  return floor(2.0 * fract(0.5 * x));\n}\n\n\nHit sdtetra(vec3 p) {\n  float r = d * 0.1;\n  vec3 cc;\n  return Hit(sdDodecahedron(b - r / sqrt(1.0 / 6.0), p, cc) - r, vec4(cc, 1));\n}\nfloat demoTetrahedron(vec3 p, out vec3 color) {\n  const vec3 ta = vec3(0, -1, -SQRT1_2);\n  const vec3 tb = vec3(0, 1, -SQRT1_2);\n  const vec3 tc = vec3(1, 0, SQRT1_2);\n  const vec3 td = vec3(-1, 0, SQRT1_2);\n  const vec3 x = 0.5 * (ta + td);\n  const vec3 x2 = 0.5 * (tb + td);\n  const vec3 mirror = normalize(-cross(x - tb, x - tc));\n  const vec3 mirror2 = normalize(cross(x2 - ta, x2 - tc));\n  float dbox = sdBox(vec3(3.0), p);\n  if (dbox > 0.0) {\n    color = SALMON;\n    return dbox + 1.0;\n  }\n  Hit d1 = gizmo(p - vec3(0, 0, 1));\n  vec3 fgh = normalize(vec3(0, 1, -SQRT2));\n  vec3 cc;\n  float d2 = p.z;\n  p = p - vec3(0, 0, 1);\n  vec3 pa = abs(p);\n  const float PHI = GOLDEN_RATIO;\n  d1 = add(d1, Hit(distance(vec3(1), pa) - 0.05, vec4(ORANGE, 1)));\n  d1 = add(\n    d1,\n    Hit(distance(vec3(0, PHI, 1.0 / PHI), pa) - 0.05, vec4(GREEN, 1))\n  );\n  d1 = add(\n    d1,\n    Hit(distance(vec3(1.0 / PHI, 0, PHI), pa) - 0.05, vec4(BLUE, 1))\n  );\n  d1 = add(\n    d1,\n    Hit(distance(vec3(PHI, 1.0 / PHI, 0), pa) - 0.05, vec4(PINK, 1))\n  );\n  const vec3 fv =\n    0.2 *\n    (vec3(1.0 / PHI, 0, PHI) + 2.0 * vec3(1, 0, 1) + 2.0 * vec3(PHI, 0, 0));\n  const vec3 fv2 =\n    0.2 *\n    (2.0 * vec3(0, PHI, 0) + 2.0 * vec3(1, 1, 0) + vec3(PHI, 1.0 / PHI, 0));\n  d1 = add(d1, Hit(distance(fv, p) - 0.05, vec4(RED, 1)));\n  d1 = add(d1, Hit(distance(fv2, p) - 0.05, vec4(RED, 1)));\n  d1 = add(d1, sdtetra(p));\n  //  d1 = add(d1, Hit(distance(ta, p) - 0.1, vec4(OLIVE_DRAB, 1)));\n  //  d1 = add(d1, Hit(distance(tb, p) - 0.1, vec4(OLIVE_DRAB, 1)));\n  //  d1 = add(d1, Hit(distance(tc, p) - 0.1, vec4(OLIVE_DRAB, 1)));\n  //  d1 = add(d1, Hit(distance(td, p) - 0.1, vec4(OLIVE_DRAB, 1)));\n  //  d1 = add(d1, Hit(sdArrow(vec3(0), mirror2, p), vec4(OLIVE_DRAB, 1)));\n  //  d1 = add(d1, Hit(length(p) - sqrt(1.0 / 6.0) - 0.002, vec4(CHARTREUSE, 1)));\n  //  d1 = add(\n  //    d1,\n  //    Hit(sdArrow(0.5 * (tc + td), 0.5 * (tc + td) + fgh, p), vec4(OLIVE_DRAB, 1))\n  //  );\n  //  float cd = sdBox(vec3(2.0, 2.0, 0.005), p - vec3(0, 0, a));\n  //  d1 = add(\n  //    d1,\n  //    Hit(cd, vec4(mix(BLUE, CYAN, squareWave(sdtetra(p) * 10.0)), 1))\n  //  );\n  //  d1 = sub(d1, Hit(sdBox(vec3(10), p - vec3(0, 0, c)), vec4(HOT_PINK, 1)));\n  //  float d1 = sdTetrahedron(1.0 - r, p - vec3(0, 0, 1), color) - r;\n  if (d2 < d1.distance) {\n    color = WHITE;\n    return d2;\n  } else {\n    color = d1.color.xyz;\n    return d1.distance;\n  }\n}\n// START ../common/sdf3d/sdLego.glsl\n\n// START ./sdTube.glsl\nfloat sdTube(float radius, float r2, float z, vec3 p) {\n  vec2 d = vec2(length(p.xy), abs(p.z)) - vec2(radius, z);\n  d.x = abs(d.x) - r2;\n  vec2 closest = vec2(abs(d.x - radius) - r2, clamp(d.y, 0.0, z));\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n\n\nfloat sdLego(vec3 p) {\n  const float IWALLT = 0.04;\n  p.xy = abs(p.xy);\n  vec2 c = vec2(4.0, 2.0);\n  //    p.xy = mod(p.xy + c * 0.5, c) - c * 0.5;\n  p -= vec3(0.0, 0.0, 0.6);\n  float d;\n  const float cr = 0.02;\n  d = sdBox(vec3(2.0, 1.0, 0.6), cr, p);\n  if (d > 0.5) {\n    return d;\n  }\n  //    top studs\n  vec3 p8 = vec3(abs(p.xy - vec2(1.0, 0.0)), p.z) - vec3(0.5, 0.5, 0.6);\n  float dStuds = sdCylinder(0.35 - 0.04, 0.2, p8) - 0.04;\n  d = min(d, dStuds);\n  // little holes in bottom of studs\n  float dStudHoles = sdCylinder(0.2 - 0.04, 0.3, p8 - vec3(0, 0, -0.4)) - 0.04;\n  d = max(d, -dStudHoles);\n  // TODO use sdf texture to add LEGO or custom logo to studs\n\n  // hole in the bottom\n  const float WALLT = 4.0 * IWALLT;\n  float dBottom = sdBox(\n    vec3(2.0 - WALLT, 1.0 - WALLT, 0.6),\n    p - vec3(0, 0, -WALLT)\n  );\n  d = max(d, -dBottom);\n\n  // 12 indentations on inside.\n  vec3 pa = p;\n  // 3. move by 1 in X dir\n  pa.x -= 1.0;\n  // 2. mirror across XY axis\n  if (pa.x > pa.y) pa.xy = pa.yx;\n  // 1. mirror across Y axis\n  pa.x = abs(pa.x);\n  float k = sdBox(vec3(0.5 * IWALLT, 0.05, 0.6), pa - vec3(0.5, 0.8, 0));\n  d = min(d, k);\n\n  // center bar\n  p = vec3(abs(p.xy), p.z);\n  d = min(d, sdBox(vec3(0.5 * IWALLT, 0.3, 0.5), p - vec3(0, 0.65, 0.1)));\n\n  // 3 tubes\n  vec3 pTube = p;\n  if (pTube.x > 0.5) pTube.x -= 1.0;\n  pTube.x = abs(pTube.x);\n  d = min(d, sdTube(0.35 + 0.5 * IWALLT, 0.5 * IWALLT, 0.6, pTube));\n  return d;\n}\n\nconst mat4[] positions = mat4[](\n  inverse(\n    transpose(\n      mat4(\n        vec4(0.9146, 0.4043, -0.0, -4.4334),\n        vec4(-0.4043, 0.9146, -0.0, 5.642),\n        vec4(0.0, 0.0, 1.0, 1.0401),\n        vec4(0.0, 0.0, 0.0, 1.0)\n      )\n    )\n  ),\n  inverse(\n    transpose(\n      mat4(\n        vec4(0.9993, 0.0378, -0.0, -0.406),\n        vec4(-0.0378, 0.9993, 0.0, 2.944),\n        vec4(0.0, -0.0, 1.0, 1.0401),\n        vec4(0.0, 0.0, 0.0, 1.0)\n      )\n    )\n  ),\n  inverse(\n    transpose(\n      mat4(\n        vec4(0.9795, 0.2015, 0.0, -0.3315),\n        vec4(-0.2015, 0.9795, 0.0, 3.0562),\n        vec4(0.0, -0.0, 1.0, 2.2402),\n        vec4(0.0, 0.0, 0.0, 1.0)\n      )\n    )\n  ),\n  inverse(\n    transpose(\n      mat4(\n        vec4(-0.9376, -0.3477, -0.0, -4.5541),\n        vec4(0.3477, -0.9376, 0.0, 1.1356),\n        vec4(-0.0, 0.0, 1.0, 1.0401),\n        vec4(0.0, 0.0, 0.0, 1.0)\n      )\n    )\n  ),\n  inverse(\n    transpose(\n      mat4(\n        vec4(-0.9709, 0.2393, 0.0001, 3.8652),\n        vec4(0.2393, 0.9709, -0.0001, 3.4039),\n        vec4(-0.0001, -0.0, -1.0, 7.0405),\n        vec4(0.0, 0.0, 0.0, 1.0)\n      )\n    )\n  ),\n  inverse(\n    transpose(\n      mat4(\n        vec4(0.999, 0.0456, -0.0, -0.1656),\n        vec4(-0.0456, 0.999, -0.0, 0.6654),\n        vec4(0.0, 0.0, 1.0, 1.0401),\n        vec4(0.0, 0.0, 0.0, 1.0)\n      )\n    )\n  ),\n  inverse(\n    transpose(\n      mat4(\n        vec4(0.9995, 0.0303, 0.0, -0.3213),\n        vec4(-0.0303, 0.9995, 0.0, 3.4494),\n        vec4(-0.0, -0.0, 1.0, 3.4403),\n        vec4(0.0, 0.0, 0.0, 1.0)\n      )\n    )\n  ),\n  inverse(\n    transpose(\n      mat4(\n        vec4(0.5829, -0.8126, -0.0, -8.6931),\n        vec4(0.8126, 0.5829, 0.0, 0.5259),\n        vec4(-0.0, -0.0, 1.0, 1.0401),\n        vec4(0.0, 0.0, 0.0, 1.0)\n      )\n    )\n  ),\n  inverse(\n    transpose(\n      mat4(\n        vec4(0.7582, 0.652, 0.0, 5.89),\n        vec4(-0.652, 0.7582, -0.0, 2.8033),\n        vec4(-0.0, 0.0, 1.0, 3.4401),\n        vec4(0.0, 0.0, 0.0, 1.0)\n      )\n    )\n  ),\n  inverse(\n    transpose(\n      mat4(\n        vec4(0.294, 0.9558, -0.0, 9.1408),\n        vec4(-0.9558, 0.294, -0.0, -0.129),\n        vec4(-0.0, 0.0, 1.0, 1.0401),\n        vec4(0.0, 0.0, 0.0, 1.0)\n      )\n    )\n  ),\n  inverse(\n    transpose(\n      mat4(\n        vec4(-0.7059, 0.7083, -0.0, 0.899),\n        vec4(-0.7083, -0.7059, 0.0, -3.7542),\n        vec4(0.0, 0.0, 1.0, 1.0401),\n        vec4(0.0, 0.0, 0.0, 1.0)\n      )\n    )\n  ),\n  inverse(\n    transpose(\n      mat4(\n        vec4(0.6319, 0.775, 0.0, 4.8559),\n        vec4(-0.775, 0.6319, -0.0001, 2.6001),\n        vec4(-0.0, 0.0, 1.0, 4.6402),\n        vec4(0.0, 0.0, 0.0, 1.0)\n      )\n    )\n  ),\n  inverse(\n    transpose(\n      mat4(\n        vec4(0.9808, 0.1952, 0.0, 4.0276),\n        vec4(-0.1952, 0.9808, -0.0, 3.1987),\n        vec4(-0.0, 0.0, 1.0, 2.2401),\n        vec4(0.0, 0.0, 0.0, 1.0)\n      )\n    )\n  ),\n  inverse(\n    transpose(\n      mat4(\n        vec4(0.4857, -0.2902, -0.8246, 9.5624),\n        vec4(0.1916, 0.9557, -0.2235, 2.9451),\n        vec4(0.8529, -0.0494, 0.5198, 5.9481),\n        vec4(0.0, 0.0, 0.0, 1.0)\n      )\n    )\n  ),\n  inverse(\n    transpose(\n      mat4(\n        vec4(0.0341, -0.3016, -0.9528, 10.418),\n        vec4(0.0108, 0.9534, -0.3014, 3.3781),\n        vec4(0.9994, 0.0, 0.0358, 3.0374),\n        vec4(0.0, 0.0, 0.0, 1.0)\n      )\n    )\n  ),\n  inverse(\n    transpose(\n      mat4(\n        vec4(0.9781, -0.2081, -0.0, 5.9647),\n        vec4(0.2081, 0.9781, 0.0, 2.9215),\n        vec4(0.0, -0.0, 1.0, 1.0401),\n        vec4(0.0, 0.0, 0.0, 1.0)\n      )\n    )\n  ),\n  inverse(\n    transpose(\n      mat4(\n        vec4(-0.0242, 0.9997, 0.0, -6.5609),\n        vec4(-0.9997, -0.0242, -0.0, -1.5591),\n        vec4(-0.0, -0.0, 1.0, 1.0401),\n        vec4(0.0, 0.0, 0.0, 1.0)\n      )\n    )\n  )\n);\n// START ../common/transform.glsl\nvec3 transform(mat4 pm, vec3 p) {\n  vec4 pStar = pm * vec4(p, 1);\n  return pStar.xyz / pStar.w;\n}\n\nvec2 transform(mat4 pm, vec2 p) {\n  vec4 pStar = pm * vec4(p, 0, 1);\n  return pStar.xy / pStar.w;\n}\n\n// START ../common/checkerboardGrad.glsl\n//https://iquilezles.org/articles/checkerfiltering/\nfloat tri(float x) {\n  float h = fract(x * 0.5) - 0.5;\n  return 1.0 - 2.0 * abs(h);\n}\nvec2 tri(vec2 x) {\n  vec2 h = fract(x * 0.5) - 0.5;\n  return 1.0 - 2.0 * abs(h);\n}\n\nfloat checkerboardGrad(vec2 uv) {\n  vec2 w = max(abs(dFdx(uv)), abs(dFdy(uv))) + 0.005; // filter kernel\n  vec2 i = (tri(uv + 0.5 * w) - tri(uv - 0.5 * w)) / w; // analytical integral (box filter)\n  return 0.5 - 0.5 * i.x * i.y; // xor pattern\n}\n\n\n#define NON_CONST_ZERO (min(int(iTime), 0))\n\nHit demoLego(float r, vec3 p) {\n  float scale = 1.0;\n  float d1 = sdLego(p * scale - vec3(0, 1, 0)) / scale;\n  for (int i = 0; i < 5; i++) {\n    vec3 pp = transform(positions[i], p);\n    d1 = min(d1, sdLego(pp * scale) / scale);\n  }\n  d1 = min(\n    d1,\n    sdLego(rotX(200.0 * DEGREE) * (p * scale - vec3(0, -2, 2))) / scale\n  );\n  d1 = min(\n    d1,\n    sdLego(rotY(240.0 * DEGREE) * (p * scale - vec3(6, 4, 5))) / scale\n  );\n  float d2 = p.z;\n  if (d2 < d1) {\n    return Hit(\n      d2,\n      vec4(mix(WHITE, ungamma(colorSecondary), checkerboardGrad(p.xy)), 1)\n    );\n  } else {\n    return Hit(d1, vec4(ungamma(colorPrimary), 1));\n  }\n}\n\nfloat sdf(vec3 p, out vec3 color) {\n  Hit h = demoLego(1.0, p);\n  color = h.color.xyz;\n  return h.distance;\n}\nfloat sdf(vec3 p) {\n  vec3 v;\n  return sdf(p, v);\n}\nfloat ambientOcclusion(vec3 pWC, vec3 n1WC) {\n  float k = 1.0;\n  float distance = sdf(pWC + n1WC * k);\n  return clamp(distance / k, 0.0, 1.0);\n}\n\nstruct RMResult {\n  float distance;\n  vec3 pos;\n  vec4 color;\n};\nRMResult raymarching2(vec3 start, vec3 dir1) {\n  vec3 pos = start;\n  float hit;\n  vec3 color;\n  for (int i = 0; i < 100; i++) {\n    vec3 newColor;\n    hit = sdf(pos, newColor);\n    if (hit < 0.0001 * hit) break;\n    pos = pos + dir1 * hit;\n    color = newColor;\n  }\n  if (color == WHITE) {\n    vec2 ff = round(fract(pos.xy * 0.5));\n\n    color = mix(\n      ungamma(colorBackground),\n      ungamma(colorSecondary),\n      mod(ff.x + ff.y, 2.0)\n    );\n  }\n  return RMResult(hit, pos, vec4(color, 1.0));\n}\nvec3 transform(mat4 pm, vec3 p) {\n  vec4 pStar = pm * vec4(p, 1.0);\n  return pStar.xyz / pStar.w;\n}\n\nfloat softshadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {\n  float res = 1.0;\n  float t = 0.1;\n  for (int i = 0; i < 1000 && t < maxt; i++) {\n    float h = sdf(ro + rd * t);\n    if (h < 0.001) return 0.0;\n    res = min(res, k * h / t);\n    t += h;\n  }\n  return res;\n}\n\nconst float eps = 1e-4;\nvec3 sdfNormal1(vec3 p, float d) {\n  return normalize(\n    vec3(\n      sdf(p + vec3(eps, 0.0, 0.0)),\n      sdf(p + vec3(0.0, eps, 0.0)),\n      sdf(p + vec3(0.0, 0.0, eps))\n    ) -\n      vec3(sdf(p))\n  );\n}\n\n//layout (depth_greater) out float gl_FragDepth;\nvoid main() {\n  vec3 camPos =\n    vec3(20, 0, 10) +\n    (-1.0 == iMouse.x\n      ? vec3(0)\n      : vec3(0, (iMouse / iResolution * 2.0 - 1.0) * 10.0));\n  mat4 modelView =\n    perspective(40.0, iResolution.x / iResolution.y, 0.1, 20.0) *\n    lookAt(camPos, vec3(0, 0, 1), vec3(0, 0, 1));\n  mat4 modelViewInverse = inverse(modelView);\n\n  vec3 light = normalize(vec3(-1.0, -2.0, -2));\n\n  vec3 a = vec3(coord * 2.0 - 1.0, -1.0);\n  vec3 b = vec3(coord * 2.0 - 1.0, 1.0);\n  vec3 aWC = transform(modelViewInverse, a);\n  vec3 bWC = transform(modelViewInverse, b);\n  vec3 lookDir1 = normalize(bWC - aWC);\n\n  RMResult hitWC = raymarching2(aWC, lookDir1);\n  vec3 hitn1 = sdfNormal1(hitWC.pos, hitWC.distance);\n  float dWC = distance(aWC, hitWC.pos);\n  vec3 hitNDC = transform(modelView, hitWC.pos);\n  vec3 p = hitWC.pos;\n  float inSun = softshadow(\n    hitWC.pos + hitn1 * 0.05,\n    -light,\n    0.0001,\n    300.0,\n    8.0\n  );\n  //    float inSun=1.;\n\n  vec3 material = hitWC.color.xyz;\n  if (dWC > 100.0) {\n    material = vec3(0.0, 0.0, 0.0);\n    //    } else if (p.z >= 0.001) {\n    //        material = vec3(0.2, 0.0, 0.0);\n    //    } else {\n    //        vec2 c = vec2(4.0, 2.0);\n    //        vec2 id = floor(((p.xy - c * 0.5) / c) );\n    //        material += .15 * cos(vec3(id.x, id.y + 2., id.x + id.y + 4.));\n  }\n\n  const vec3 sunlightColor = vec3(3.0);\n\n  float aOcc = ambientOcclusion(hitWC.pos, hitn1);\n\n  vec3 reflectionDirection = reflect(light, hitn1);\n\n  vec3 color = vec3(0.0);\n  color += material * aOcc;\n  color += inSun * sunlightColor * material * max(0.0, dot(-light, hitn1));\n  //    color = (hitn1);\n\n  vec3 eyeDirection = -lookDir1;\n  float uMaterialShininess = 256.0;\n  float specularLightWeighting = pow(\n    max(dot(reflectionDirection, eyeDirection), 0.0),\n    uMaterialShininess\n  );\n  color += specularLightWeighting;\n  //    float lightIntensity = 0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.);\n  //    float lightIntensity =\n  //        0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.) + 0.3*specularLightWeighting;\n  //    fragColor = visualize(blue, red, mix(0.5, 1.0, inSun) * lightIntensity);\n  //    fragColor = mix(hitWC.color, colorBackground, mix(0.5, 1.0, inSun) * clamp(lightIntensity, 0., 1.));\n  color = pow(color, vec3(1.0 / 2.2)); // gamma correction\n  fragColor = vec4(color, 1.0);\n}\n"},5592:(n,e,t)=>{"use strict";t.r(e),t.d(e,{default:()=>o});const o='#version 300 es\n\nprecision highp float;\n// START ../common/banded.glsl\nfloat banded(float bandCount, float t) {\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\n}\nfloat banded(int bandCount, float t) {\n  return banded(float(bandCount), t);\n}\n\n// #pragma glslify: export(banded)\n\n\n// START ../common/between.glsl\nbool between(float min, float max, float value) {\n  return min <= value && value <= max;\n}\n\n// #pragma glslify: export(between)\n\n\n// START ../common/hex2Ra.glsl\nvec2 hex2Ra(vec3 hex) {\n  float y = hex.t * 0.866;\n  float x = hex.s + hex.t / 2.0;\n  return vec2(x, y);\n}\n\n// #pragma glslify: export(hex2Ra)\n\n\n// START ../common/hexRound.glsl\nvec3 hexRound(vec3 hex) {\n  vec3 r = floor(hex + 0.5);\n  vec3 diff = abs(r - hex);\n\n  if (diff.x > diff.y && diff.x > diff.z) {\n    r.x = -(r.y + r.z);\n  } else if (diff.y > diff.z) {\n    r.y = -(r.x + r.z);\n  } else {\n    r.z = -(r.x + r.y);\n  }\n\n  return r;\n}\n\n// #pragma glslify: export(hexRound)\n\n\n// START ../common/hexSdf.glsl\n// START ./max3.glsl\nfloat max3(float a, float b, float c) {\n  return max(a, max(b, c));\n}\nfloat max3(vec3 v) {\n  return max(v.x, max(v.y, v.z));\n}\n\n// #pragma glslify: export(max3)\n\n\n\nfloat hexSdf(vec3 hex) {\n  return max3(abs(hex.yzx + hex.zxy / 2.0));\n}\n\n// #pragma glslify: export(hexSdf)\n\n\n// START ../common/transform.glsl\nvec3 transform(mat4 pm, vec3 p) {\n  vec4 pStar = pm * vec4(p, 1);\n  return pStar.xyz / pStar.w;\n}\n\nvec2 transform(mat4 pm, vec2 p) {\n  vec4 pStar = pm * vec4(p, 0, 1);\n  return pStar.xy / pStar.w;\n}\n\n\n// START ../common/perlin2DTexture.glsl\nuniform sampler2D gradients;\n\nfloat dotGridGradient(vec2 cell, vec2 pos) {\n  vec2 d = cell - pos;\n\n  vec2 gradient = texelFetch(gradients, ivec2(cell), 0).xy;\n  return dot(gradient, d);\n}\n\nfloat mixx(float a, float b, float t) {\n  return mix(a, b, smoothstep(0.0, 1.0, t));\n  //    return mix(a, b, t);\n}\n\n// resulting range is [-0.68, 0.68]. Use unmix to normalize if necessary.\nfloat perlin2D(vec2 xy) {\n  float x0 = floor(xy.x);\n  float x1 = x0 + 1.0;\n  float y0 = floor(xy.y);\n  float y1 = y0 + 1.0;\n\n  // Interpolate between grid point gradients\n  float n00 = dotGridGradient(vec2(x0, y0), xy);\n  float n10 = dotGridGradient(vec2(x1, y0), xy);\n  float ny0 = mixx(n00, n10, xy.x - x0);\n\n  float n01 = dotGridGradient(vec2(x0, y1), xy);\n  float n11 = dotGridGradient(vec2(x1, y1), xy);\n  float ny1 = mixx(n01, n11, xy.x - x0);\n\n  return mixx(ny0, ny1, xy.y - y0);\n}\n\n// #pragma glslify: export(perlin2D)\n\n\n// START ../common/hsl2rgb.glsl\n/**\n * The MIT License (MIT) Copyright (c) 2015 Jam3\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the "Software"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\nfloat hue2rgb(float f1, float f2, float hue) {\n  if (hue < 0.0) hue += 1.0;\n  else if (hue > 1.0) hue -= 1.0;\n  float res;\n  if (6.0 * hue < 1.0) res = f1 + (f2 - f1) * 6.0 * hue;\n  else if (2.0 * hue < 1.0) res = f2;\n  else if (3.0 * hue < 2.0) res = f1 + (f2 - f1) * (2.0 / 3.0 - hue) * 6.0;\n  else res = f1;\n  return res;\n}\n\nvec3 hsl2rgb(vec3 hsl) {\n  vec3 rgb;\n\n  if (hsl.y == 0.0) {\n    rgb = vec3(hsl.z); // Luminance\n  } else {\n    float f2;\n\n    if (hsl.z < 0.5) f2 = hsl.z * (1.0 + hsl.y);\n    else f2 = hsl.z + hsl.y - hsl.y * hsl.z;\n\n    float f1 = 2.0 * hsl.z - f2;\n\n    rgb.r = hue2rgb(f1, f2, hsl.x + 1.0 / 3.0);\n    rgb.g = hue2rgb(f1, f2, hsl.x);\n    rgb.b = hue2rgb(f1, f2, hsl.x - 1.0 / 3.0);\n  }\n  return rgb;\n}\n\nvec3 hsl2rgb(float h, float s, float l) {\n  return hsl2rgb(vec3(h, s, l));\n}\n\n// START ../common/polar.glsl\n// START ../common/fromPolar.glsl\n// START ./unmix.glsl\nfloat unmix(float a, float b, float value) {\n  return (value - a) / (b - a);\n}\n\n// #pragma glslify: export(unmix)\n\n\n\nvec3 fromPolar(float radius, float phi, float z) {\n  return vec3(radius * cos(phi), radius * sin(phi), z);\n}\n\nvec2 fromPolar(float radius, float phi) {\n  return vec2(radius * cos(phi), radius * sin(phi));\n}\n\nvec2 fromPolar(vec2 polar) {\n  return fromPolar(polar.x, polar.y);\n}\n\n// #pragma glslify: export(fromPolar)\n\n\n// START ../common/toPolar.glsl\n\n\nvec2 toPolar(vec2 xy) {\n  return vec2(length(xy), atan(xy.y, xy.x));\n}\n\nmat2 toPolarDerivate(vec2 xy) {\n  return mat2(xy.x * xy.x, xy.y * xy.y, -xy.y, xy.x) / dot(xy, xy);\n}\n\n// #pragma glslify: export(toPolar)\n\n\n\n// START ../common/ra2Hex.glsl\nvec3 raToHex(vec2 xy) {\n  float hex_t = xy.y / 0.866;\n  float hex_s = xy.x - hex_t / 2.0;\n  return vec3(hex_s, hex_t, -(hex_s + hex_t));\n}\n\n// #pragma glslify: export(raToHex)\n\n\n// START ../common/remix.glsl\n\n\nfloat remix(float fromA, float fromB, float toA, float toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\nvec4 remix(float fromA, float fromB, vec4 toA, vec4 toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\n// #pragma glslify: export(remix)\n\n\n\n// START ../common/visualize.glsl\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\n  float isLow = float(t < 0.0);\n  float isHigh = float(t > 1.0);\n  float isMid = 1.0 - isLow - isHigh;\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\n}\n\nvec4 visualize(float t) {\n  const vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\n  const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\n  return visualize(BLUE, RED, t);\n}\n\n// #pragma glslify: export(visualize)\n\n\n// START ../common/waves.glsl\nfloat waves(vec4 color, vec2 position, vec2 direction, float highResTimeStamp) {\n  return sin(\n    dot(position, direction / pow(length(direction), 2.0)) +\n      float(highResTimeStamp) / 200.0\n  );\n}\n\n// #pragma glslify: export(waves)\n\n\n// START ../common/matrices.glsl\n// START ./constants.glsl\nconst float SQRT1_2 = 0.7071067811865476;\nconst float SQRT1_3 = 0.57735026919;\nconst float SQRT2 = 1.4142135623730951;\nconst float SQRT3 = 1.732050807568877;\n// sqrt(3)/2 = sin(60*)\nconst float SQRT3_2 = 0.86602540378;\nconst float GOLDEN_RATIO = 1.61803398875;\nconst float PI = 3.141592653589793;\nconst float TAU = 6.28318530718;\n/**\n * One degree in radians. Use like `sin(30 * DEG)`.\n */\nconst float DEGREE = 0.017453292519943295;\n\n\nmat2 rot2(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat2(c, -s, s, c);\n}\nmat3 rotX(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\n}\nmat3 rotY(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\n}\nmat3 rotZ(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\n}\n/**\n * Returns a matrix that puts the camera at the eye point `ex, ey, ez` looking\n * toward the center point `cx, cy, cz` with an up direction of `ux, uy, uz`.\n * This emulates the OpenGL function `gluLookAt()`.\n */\nmat4 lookAt(vec3 eye, vec3 focus, vec3 up) {\n  vec3 f = normalize(eye - focus);\n  vec3 s = normalize(cross(up, f));\n  vec3 t = normalize(cross(f, s));\n\n  return mat4(\n    vec4(s.x, t.x, f.x, 0.0),\n    vec4(s.y, t.y, f.y, 0.0),\n    vec4(s.z, t.z, f.z, 0.0),\n    vec4(-dot(s, eye), -dot(t, eye), -dot(f, eye), 1)\n  );\n}\n\n// the OpenGL function `glFrustum()`.\nmat4 frustum(\n  float left,\n  float right,\n  float bottom,\n  float top,\n  float near,\n  float far\n) {\n  return mat4(\n    vec4(2.0 * near / (right - left), 0.0, 0.0, 0.0),\n    vec4(0, 2.0 * near / (top - bottom), 0.0, 0.0),\n    vec4(\n      (right + left) / (right - left),\n      (top + bottom) / (top - bottom),\n      -(far + near) / (far - near),\n      -1\n    ),\n    vec4(0.0, 0.0, -2.0 * far * near / (far - near), 0.0)\n  );\n}\n\nmat4 perspective(float fovDegrees, float aspect, float near, float far) {\n  float y = tan(fovDegrees * DEGREE / 2.0) * near;\n  float x = y * aspect;\n  return frustum(-x, x, -y, y, near, far);\n}\n\n// START ../common/sdf3d/sdDonut.glsl\nfloat sdDonut(float r0, float r1, vec3 p) {\n  vec3 closestCenter = vec3(normalize(p.xy) * r0, 0.0);\n  return distance(closestCenter, p) - r1;\n}\n\n// #pragma glslify: export(sdDonut)\n\n\n// START ../common/sdf3d/sdSphere.glsl\nfloat sdSphere(float radius, vec3 p) {\n  return length(p) - radius;\n}\n\n// #pragma glslify: export(sdSphere)\n\n\n// START ../common/sdf3d/sdCylinder.glsl\nfloat sdCylinder(float radius, float z, vec3 p) {\n  vec2 d = vec2(length(p.xy), abs(p.z)) - vec2(radius, z);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// #pragma glslify: export(sdCylinder)\n\n\n// START ../common/sdf3d/addChamfer.glsl\n\n\nfloat addChamfer(float d, float a, float b) {\n  float tillet = (a + b - d) * SQRT1_2;\n  return min(tillet, min(a, b));\n}\n\n// #pragma glslify: export(addChamfer)\n\n\n// START ../common/sdf3d/addTillet.glsl\nfloat addTillet(float r, float a, float b) {\n  if (a < r && b < r) {\n    return r - distance(vec2(a, b), vec2(r));\n  } else {\n    return min(a, b);\n  }\n}\n\n// #pragma glslify: export(addTillet)\n\n\n// START ../common/sdf3d/sdBox.glsl\n\n\nfloat sdBox(vec3 r, vec3 p) {\n  vec3 q = abs(p) - r;\n  return length(max(q, 0.0)) + min(max3(q), 0.0);\n}\n\nfloat sdBox(vec3 r, float r2, vec3 p) {\n  return sdBox(r - r2, p) - r2;\n}\n\n// #pragma glslify: export(sdBox)\n\n\n// START ../common/sdf3d/add.glsl\nfloat add(float a, float b) {\n  return min(a, b);\n}\n\n// #pragma glslify: export(add)\n\n\n// START ../common/sdf3d/sub.glsl\nfloat sub(float from, float what) {\n  return max(from, -what);\n}\n\n// #pragma glslify: export(sub)\n\n\n\nuniform sampler2D texture;\nuniform float iTime;\nuniform vec2 iMouse;\nuniform vec2 iResolution;\nuniform vec4 colorPrimary;\nuniform vec4 colorSecondary;\nuniform vec4 colorBackground;\nuniform float a;\nuniform float b;\nuniform float c;\nuniform float d;\nuniform int bandCount;\nuniform vec3 extra;\nuniform vec3 campos;\nin float n;\nin vec2 coord;\nout vec4 fragColor;\n\n\nconst vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\nconst vec4 yellow = vec4(1.0, 1.0, 0.0, 1.0);\nconst vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\nconst vec4 blue = vec4(0.0, 0.0, 1.0, 1.0);\nconst vec4 purple = vec4(0.5, 0.0, 0.5, 1.0);\nconst vec4 red = vec4(1.0, 0.0, 0.0, 1.0);\n\nstruct RMHit {\n  float distance;\n  vec4 color;\n};\nRMHit mixa(RMHit a, RMHit b, float t) {\n  return RMHit(mix(a.distance, b.distance, t), mix(a.color, b.color, t));\n}\nfloat skybox(vec3 p) {\n  return 32.0 - max3(abs(p));\n}\n\nfloat perlinSphere(float radius, vec3 p) {\n  vec3 cp = normalize(p);\n  float alpha = atan(cp.y, cp.x);\n  float beta = asin(cp.z);\n  return length(p) -\n  radius +\n  0.1 *\n    perlin2D(vec2(0.0 / 100.0, 0.0) + (vec2(5.0) + vec2(alpha, beta)) * 8.0);\n}\n\nfloat cylCircle(vec3 p) {\n  float d = 10e9;\n  for (int i = 0; i < 10; i++) {\n    d = min(\n      d,\n      sdCylinder(0.2, 2.0, p + fromPolar(3.0, TAU * float(i) / 10.0, 1.0))\n    );\n  }\n\n  return d;\n}\n\nfloat rblock(float r, vec3 p) {\n  return sdBox(vec3(r), p);\n}\n\nRMHit add(RMHit a, RMHit b) {\n  //    return a.distance < b.distance\n  //        ? RMHit(a.distance, a.color)\n  //        : RMHit(b.distance, b.color);\n  return mixa(a, b, float(b.distance < a.distance));\n}\n\nfloat wtf(vec3 p) {\n  vec3 center = p - mod(p, 3.0) + vec3(1.5);\n  return rblock(0.4 + 0.3 * sin(iTime + center.x), p - center);\n}\n\nRMHit addTillet(float r, RMHit a, RMHit b) {\n  if (a.distance < r && b.distance < r) {\n    return RMHit(\n      r - distance(vec2(a.distance, b.distance), vec2(r)),\n      mix(a.color, b.color, (a.distance - b.distance) / r * 0.5 + 0.5)\n    );\n  } else {\n    return add(a, b);\n  }\n}\n\nRMHit addTillet(float r, RMHit a, RMHit b, vec4 tilletColor) {\n  if (a.distance < r && b.distance < r) {\n    return RMHit(\n      r - distance(vec2(a.distance, b.distance), vec2(r)),\n      tilletColor\n    );\n  } else {\n    return add(a, b);\n  }\n}\nRMHit addTillet2(float r, RMHit a, RMHit b) {\n  float h = smoothstep(-r, r, a.distance - b.distance);\n  return RMHit(\n    mix(a.distance, b.distance, h) - r * h * (1.0 - h),\n    mix(a.color, b.color, h)\n  );\n}\n\nRMHit neg(RMHit a) {\n  return RMHit(-a.distance, a.color);\n}\nRMHit sub(RMHit from, RMHit what) {\n  RMHit whatNeg = neg(what);\n  return mixa(from, whatNeg, float(whatNeg.distance > from.distance));\n}\n\nvec3 modv(vec3 v, vec3 dir1, float y) {\n  float t = dot(v, dir1);\n  return v - floor(t / y) * y * dir1;\n}\nvec3 modRotZ(vec3 p, float count) {\n  vec2 polarXY = toPolar(p.xy);\n  return fromPolar(polarXY.x, mod(polarXY.y, TAU / count), p.z);\n}\n\nRMHit sdf(vec3 p) {\n  RMHit r = RMHit(skybox(p), colorBackground);\n  r = add(r, RMHit(sdBox(vec3(6.0, 6.0, 1.0), p), colorSecondary));\n  vec3 rotp = rotZ(0.1) * p;\n  vec3 floorTiles = vec3(mod(rotp.xy, 0.1), rotp.z);\n  float ftd = sdBox(\n    vec3(0.045),\n    rotY(d) * floorTiles - vec3(0.05, 0.05, -0.04)\n  );\n  float ftdl = max(ftd, sdBox(vec3(6), p));\n  //    r = addTillet2(.01, r, RMHit(ftdl, colorSecondary));\n  float dSphere = sdSphere(7.0, p);\n  if (dSphere < 0.0) {\n    RMHit m = RMHit(100000.0, black);\n    for (int i = 0; i < 50; i++) {\n      //            m = (addTillet(a, (m),\n      m = addTillet2(\n        a,\n        m,\n        //            m = (add((m),\n        RMHit(\n          sdDonut(\n            0.5 + float(i) * 0.1,\n            0.05,\n            rotX(2.0 + sin(iTime * 0.01) * 0.2) * rotZ(float(i) * 0.2) * p\n          ),\n          vec4(hsl2rgb(float(i) / 50.0, 0.99, 0.25), 1.0)\n        )\n      );\n    }\n    //        float b = sdBox(vec3(-5.,-5.,0.),vec3(5., 5., .2), p);\n    //        m = neg(add(neg(m),neg(RMHit(b, black))));\n    //    r = sub(r, RMHit(m.distance - 0.2, colorSecondary));\n    r = addTillet(0.3, r, m);\n  } else {\n    r = add(r, RMHit(dSphere + 1.0, black));\n  }\n  r = neg(addTillet(0.3, neg(r), RMHit(sdSphere(c, p - extra), black)));\n  //    vec3 rotSyma = modRotZ(p, 7.);\n  //    vec3 rotSym = rotZ(b) *rotY(c) * (vec3(1., sin(rotSyma.x)*d, 1.) + rotSyma);\n  //    vec3 tiled = vec3(mod(rotSym.x, 10. *a), rotSym.yz);\n  //    float q = sdSphere(1., tiled - vec3(5.*a, 0., 0.));\n  //    r = add(r, RMHit(q, blue));\n  //    for (int i = 0; i < 300; i++) {\n  //        float f = unmix(0., 300., float(i));\n  //        vec3 spherepos = fromPolar(mix(-6., 6., f), abs(mix(-10., 10., f)) + PI / 2., 0.);\n  r = add(r, RMHit(sdSphere(0.1, p - campos), black));\n  //    }\n  //    r = (addTillet(0.1, (r), RMHit(sdDonut(1.5, 0.5, rotX(iTime*6.) * p), colorSecondary)));\n  //    r = (addTillet(0.1, (r), RMHit(sdDonut(3.9, 0.5, rotY(iTime*3.) * p), blue)));\n  //    r = neg(addTillet(.2, neg(r), RMHit(sdBox(vec3(-1., -1., -2.), vec3(1., 1., 2.), p), red)));\n  //    r = add(r, wtf(p));\n  //    r = add(r, RMHit(perlinSphere(1., p - vec3(-2.0, 0.0, 3.0)), purple));\n  //    r = add(r, cylCircle(p));\n\n  //    r = add(r, sdSphere(p - vec3(3., 3., 0.)));\n  //    r = sub(r, RMHit(\n  //        cylinder(1.3, 4.5, rotX(iTime/30. * TAU) * p- vec3(2.0, 0.0, 0.0) - vec3(0., 0., -2.25)),\n  //        blue));\n  //    r = add(r, cylinder(0.8, 4., rotX(iTime/30. * TAU) * p- vec3(2.0, 0.0, 0.0) - vec3(0., 0., -2.)));\n  //    r = sub(r, cylCircle(p));\n  return r;\n}\nfloat sdff(vec3 p) {\n  return sdf(p).distance;\n}\n\nstruct RMResult {\n  float distance;\n  vec3 pos;\n  vec4 color;\n};\nRMResult raymarching2(vec3 start, vec3 dir1) {\n  vec3 pos = start;\n  RMHit hit;\n  for (int i = 0; i < 200; i++) {\n    hit = sdf(pos);\n    if (hit.distance < 0.0) break;\n    pos = pos + dir1 * hit.distance;\n  }\n  return RMResult(hit.distance, pos, hit.color);\n}\n\nfloat softshadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {\n  float res = 1.0;\n  float t = 0.1;\n  for (int i = 0; i < 1000 && t < maxt; i++) {\n    float h = sdff(ro + rd * t);\n    if (h < 0.001) return 0.0;\n    res = min(res, k * h / t);\n    t += h;\n  }\n  return res;\n}\n\nconst float eps = 1e-5;\nvec3 sdfNormal1(vec3 p, float d) {\n  return normalize(\n    vec3(\n      sdff(p + vec3(eps, 0.0, 0.0)),\n      sdff(p + vec3(0.0, eps, 0.0)),\n      sdff(p + vec3(0.0, 0.0, eps))\n    ) -\n      vec3(d)\n  );\n}\n//layout (depth_greater) out float gl_FragDepth;\nvoid main() {\n  vec3 camPos =\n    vec3(20, 0, 10) +\n    (-1.0 == iMouse.x\n      ? vec3(0)\n      : vec3(0, (iMouse / iResolution * 2.0 - 1.0) * 10.0));\n  mat4 modelView =\n    perspective(40.0, iResolution.x / iResolution.y, 0.1, 20.0) *\n    lookAt(camPos, vec3(0, 0, 1), vec3(0, 0, 1));\n  mat4 modelViewInverse = inverse(modelView);\n\n  vec3 light = normalize(vec3(-1.0, -2.0, -2));\n\n  vec3 a = vec3(coord * 2.0 - 1.0, -1.0);\n  vec3 b = vec3(coord * 2.0 - 1.0, 1.0);\n  vec3 aWC = transform(modelViewInverse, a);\n  vec3 bWC = transform(modelViewInverse, b);\n  vec3 lookDir1 = normalize(bWC - aWC);\n  //  vec3 light = normalize(vec3(-1.0, -2.0, -2));\n  //\n  //  vec3 a = vec3(coord, -1.0);\n  //  vec3 b = vec3(coord, 1.0);\n  //  vec3 aWC = transform(llli, a);\n  //  vec3 bWC = transform(llli, b);\n  //  vec3 lookDir1 = normalize(bWC - aWC);\n\n  RMResult hitWC = raymarching2(aWC, lookDir1);\n  vec3 hitn1 = sdfNormal1(hitWC.pos, hitWC.distance);\n  float dWC = distance(aWC, hitWC.pos);\n  //  vec3 hitNDC = transform(lll, hitWC.pos);\n\n  //    vec3 sunPoint = raymarching2(hitWC.pos +hitn1 *.1, -light).pos;\n  //    float inSun = float(distance(hitWC.pos, sunPoint) > 30.);\n  float inSun = softshadow(hitWC.pos + hitn1 * 0.1, -light, 0.1, 30.0, 64.0);\n  //    float inSun=1.;\n\n  vec3 reflectionDirection = reflect(light, hitn1);\n  vec3 eyeDirection = -lookDir1;\n  float uMaterialShininess = 256.0;\n  float specularLightWeighting = pow(\n    max(dot(reflectionDirection, eyeDirection), 0.0),\n    uMaterialShininess\n  );\n  //    float lightIntensity = 0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.);\n  float lightIntensity =\n    0.2 +\n    0.5 * clamp(-dot(light, hitn1), 0.0, 1.0) +\n    0.3 * specularLightWeighting;\n  //    fragColor = visualize(blue, red, mix(0.5, 1.0, inSun) * lightIntensity);\n  fragColor = mix(\n    hitWC.color,\n    colorBackground,\n    mix(0.5, 1.0, inSun) * clamp(lightIntensity, 0.0, 1.0)\n  );\n  fragColor /= 4.0;\n  fragColor.a = 1.0;\n  //    fragColor = visualize(hitWC.pos.x/10.);\n  //    fragColor = hitWC.color;\n  //    fragColor = visualize(blue, red, distance(hitWC, sunPoint)/20.);\n  //    fragColor = vec4(coord,0.,1.);\n  //    fragColor = vec4(aWC, 1.0);\n  // remap [-1, 1] to [0, 1]\n  // gl_FragDepth = hitNDC.z * 0.5 + 0.5;\n  //    gl_FragDepth = .9999999;\n}\n'},3801:(n,e,t)=>{"use strict";t.r(e),t.d(e,{default:()=>o});const o="#version 300 es\n\nprecision highp float;\n// START ../common/sdf2d/sdSegment.glsl\nfloat sdSegment(vec2 a, vec2 b, vec2 p) {\n  vec2 ab = b - a;\n  float t = dot(ab, p - a) / dot(ab, ab);\n  t = clamp(t, 0.0, 1.0);\n  vec2 closest = a + ab * t;\n\n  return distance(closest, p);\n}\n\n// #pragma glslify: export(sdSegment)\n\n\n// START ../common/unmix.glsl\nfloat unmix(float a, float b, float value) {\n  return (value - a) / (b - a);\n}\n\n// #pragma glslify: export(unmix)\n\n\n// START ../common/banded.glsl\nfloat banded(float bandCount, float t) {\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\n}\nfloat banded(int bandCount, float t) {\n  return banded(float(bandCount), t);\n}\n\n// #pragma glslify: export(banded)\n\n\n// START ../common/between.glsl\nbool between(float min, float max, float value) {\n  return min <= value && value <= max;\n}\n\n// #pragma glslify: export(between)\n\n\n// START ../common/hex2Ra.glsl\nvec2 hex2Ra(vec3 hex) {\n  float y = hex.t * 0.866;\n  float x = hex.s + hex.t / 2.0;\n  return vec2(x, y);\n}\n\n// #pragma glslify: export(hex2Ra)\n\n\n// START ../common/hexRound.glsl\nvec3 hexRound(vec3 hex) {\n  vec3 r = floor(hex + 0.5);\n  vec3 diff = abs(r - hex);\n\n  if (diff.x > diff.y && diff.x > diff.z) {\n    r.x = -(r.y + r.z);\n  } else if (diff.y > diff.z) {\n    r.y = -(r.x + r.z);\n  } else {\n    r.z = -(r.x + r.y);\n  }\n\n  return r;\n}\n\n// #pragma glslify: export(hexRound)\n\n\n// START ../common/hexSdf.glsl\n// START ./max3.glsl\nfloat max3(float a, float b, float c) {\n  return max(a, max(b, c));\n}\nfloat max3(vec3 v) {\n  return max(v.x, max(v.y, v.z));\n}\n\n// #pragma glslify: export(max3)\n\n\n\nfloat hexSdf(vec3 hex) {\n  return max3(abs(hex.yzx + hex.zxy / 2.0));\n}\n\n// #pragma glslify: export(hexSdf)\n\n\n\n// START ../common/perlin2DTexture.glsl\nuniform sampler2D gradients;\n\nfloat dotGridGradient(vec2 cell, vec2 pos) {\n  vec2 d = cell - pos;\n\n  vec2 gradient = texelFetch(gradients, ivec2(cell), 0).xy;\n  return dot(gradient, d);\n}\n\nfloat mixx(float a, float b, float t) {\n  return mix(a, b, smoothstep(0.0, 1.0, t));\n  //    return mix(a, b, t);\n}\n\n// resulting range is [-0.68, 0.68]. Use unmix to normalize if necessary.\nfloat perlin2D(vec2 xy) {\n  float x0 = floor(xy.x);\n  float x1 = x0 + 1.0;\n  float y0 = floor(xy.y);\n  float y1 = y0 + 1.0;\n\n  // Interpolate between grid point gradients\n  float n00 = dotGridGradient(vec2(x0, y0), xy);\n  float n10 = dotGridGradient(vec2(x1, y0), xy);\n  float ny0 = mixx(n00, n10, xy.x - x0);\n\n  float n01 = dotGridGradient(vec2(x0, y1), xy);\n  float n11 = dotGridGradient(vec2(x1, y1), xy);\n  float ny1 = mixx(n01, n11, xy.x - x0);\n\n  return mixx(ny0, ny1, xy.y - y0);\n}\n\n// #pragma glslify: export(perlin2D)\n\n\n// START ../common/polar.glsl\n// START ../common/fromPolar.glsl\n\n\nvec3 fromPolar(float radius, float phi, float z) {\n  return vec3(radius * cos(phi), radius * sin(phi), z);\n}\n\nvec2 fromPolar(float radius, float phi) {\n  return vec2(radius * cos(phi), radius * sin(phi));\n}\n\nvec2 fromPolar(vec2 polar) {\n  return fromPolar(polar.x, polar.y);\n}\n\n// #pragma glslify: export(fromPolar)\n\n\n// START ../common/toPolar.glsl\n\n\nvec2 toPolar(vec2 xy) {\n  return vec2(length(xy), atan(xy.y, xy.x));\n}\n\nmat2 toPolarDerivate(vec2 xy) {\n  return mat2(xy.x * xy.x, xy.y * xy.y, -xy.y, xy.x) / dot(xy, xy);\n}\n\n// #pragma glslify: export(toPolar)\n\n\n\n// START ../common/ra2Hex.glsl\nvec3 raToHex(vec2 xy) {\n  float hex_t = xy.y / 0.866;\n  float hex_s = xy.x - hex_t / 2.0;\n  return vec3(hex_s, hex_t, -(hex_s + hex_t));\n}\n\n// #pragma glslify: export(raToHex)\n\n\n// START ../common/remix.glsl\n\n\nfloat remix(float fromA, float fromB, float toA, float toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\nvec4 remix(float fromA, float fromB, vec4 toA, vec4 toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\n// #pragma glslify: export(remix)\n\n\n\n// START ../common/visualize.glsl\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\n  float isLow = float(t < 0.0);\n  float isHigh = float(t > 1.0);\n  float isMid = 1.0 - isLow - isHigh;\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\n}\n\nvec4 visualize(float t) {\n  const vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\n  const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\n  return visualize(BLUE, RED, t);\n}\n\n// #pragma glslify: export(visualize)\n\n\n// START ../common/waves.glsl\nfloat waves(vec4 color, vec2 position, vec2 direction, float highResTimeStamp) {\n  return sin(\n    dot(position, direction / pow(length(direction), 2.0)) +\n      float(highResTimeStamp) / 200.0\n  );\n}\n\n// #pragma glslify: export(waves)\n\n\n// START ../common/matrices.glsl\n// START ./constants.glsl\nconst float SQRT1_2 = 0.7071067811865476;\nconst float SQRT1_3 = 0.57735026919;\nconst float SQRT2 = 1.4142135623730951;\nconst float SQRT3 = 1.732050807568877;\n// sqrt(3)/2 = sin(60*)\nconst float SQRT3_2 = 0.86602540378;\nconst float GOLDEN_RATIO = 1.61803398875;\nconst float PI = 3.141592653589793;\nconst float TAU = 6.28318530718;\n/**\n * One degree in radians. Use like `sin(30 * DEG)`.\n */\nconst float DEGREE = 0.017453292519943295;\n\n\nmat2 rot2(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat2(c, -s, s, c);\n}\nmat3 rotX(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\n}\nmat3 rotY(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\n}\nmat3 rotZ(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\n}\n/**\n * Returns a matrix that puts the camera at the eye point `ex, ey, ez` looking\n * toward the center point `cx, cy, cz` with an up direction of `ux, uy, uz`.\n * This emulates the OpenGL function `gluLookAt()`.\n */\nmat4 lookAt(vec3 eye, vec3 focus, vec3 up) {\n  vec3 f = normalize(eye - focus);\n  vec3 s = normalize(cross(up, f));\n  vec3 t = normalize(cross(f, s));\n\n  return mat4(\n    vec4(s.x, t.x, f.x, 0.0),\n    vec4(s.y, t.y, f.y, 0.0),\n    vec4(s.z, t.z, f.z, 0.0),\n    vec4(-dot(s, eye), -dot(t, eye), -dot(f, eye), 1)\n  );\n}\n\n// the OpenGL function `glFrustum()`.\nmat4 frustum(\n  float left,\n  float right,\n  float bottom,\n  float top,\n  float near,\n  float far\n) {\n  return mat4(\n    vec4(2.0 * near / (right - left), 0.0, 0.0, 0.0),\n    vec4(0, 2.0 * near / (top - bottom), 0.0, 0.0),\n    vec4(\n      (right + left) / (right - left),\n      (top + bottom) / (top - bottom),\n      -(far + near) / (far - near),\n      -1\n    ),\n    vec4(0.0, 0.0, -2.0 * far * near / (far - near), 0.0)\n  );\n}\n\nmat4 perspective(float fovDegrees, float aspect, float near, float far) {\n  float y = tan(fovDegrees * DEGREE / 2.0) * near;\n  float x = y * aspect;\n  return frustum(-x, x, -y, y, near, far);\n}\n\n// START ../common/sdf3d/sdDonut.glsl\nfloat sdDonut(float r0, float r1, vec3 p) {\n  vec3 closestCenter = vec3(normalize(p.xy) * r0, 0.0);\n  return distance(closestCenter, p) - r1;\n}\n\n// #pragma glslify: export(sdDonut)\n\n\n// START ../common/sdf3d/sdCapsule.glsl\nfloat sdCapsule(vec3 a, vec3 b, float r, vec3 p) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h) - r;\n}\n// #pragma glslify: export(sdCapsule)\n\n// START ../common/sdf3d/opElongate.glsl\nvec3 opElongate(vec3 h, vec3 p) {\n  return p - clamp(p, -h, h);\n}\n// #pragma glslify: export(opElongate)\n\n// START ../common/sdf3d/sdSphere.glsl\nfloat sdSphere(float radius, vec3 p) {\n  return length(p) - radius;\n}\n\n// #pragma glslify: export(sdSphere)\n\n\n// START ../common/sdf3d/sdCylinder.glsl\nfloat sdCylinder(float radius, float z, vec3 p) {\n  vec2 d = vec2(length(p.xy), abs(p.z)) - vec2(radius, z);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// #pragma glslify: export(sdCylinder)\n\n\n// START ../common/sdf3d/addChamfer.glsl\n\n\nfloat addChamfer(float d, float a, float b) {\n  float tillet = (a + b - d) * SQRT1_2;\n  return min(tillet, min(a, b));\n}\n\n// #pragma glslify: export(addChamfer)\n\n\n\n// START ../common/sdf3d/addTillet.glsl\nfloat addTillet(float r, float a, float b) {\n  if (a < r && b < r) {\n    return r - distance(vec2(a, b), vec2(r));\n  } else {\n    return min(a, b);\n  }\n}\n\n// #pragma glslify: export(addTillet)\n\n\n// START ../common/sdf3d/sdBox.glsl\n\n\nfloat sdBox(vec3 r, vec3 p) {\n  vec3 q = abs(p) - r;\n  return length(max(q, 0.0)) + min(max3(q), 0.0);\n}\n\nfloat sdBox(vec3 r, float r2, vec3 p) {\n  return sdBox(r - r2, p) - r2;\n}\n\n// #pragma glslify: export(sdBox)\n\n\n// START ../common/sdf3d/sdOctahedron.glsl\nfloat sdOctahedron(float s, vec3 p) {\n  p = abs(p);\n  float m = p.x + p.y + p.z - s;\n  vec3 q;\n  if (3.0 * p.x < m) q = p.xyz;\n  else if (3.0 * p.y < m) q = p.yzx;\n  else if (3.0 * p.z < m) q = p.zxy;\n  else return m * 0.57735027;\n\n  float k = clamp(0.5 * (q.z - q.y + s), 0.0, s);\n  return length(vec3(q.x, q.y - s + k, q.z - k));\n}\n// #pragma glslify: export(sdOctahedron)\n\nfloat sdOctahedron(vec3 p, float s) {\n  p = abs(p);\n\n  float m = p.x + p.y + p.z - s;\n  //find point on octohedron surf nearest to p\n  vec3 projPoint = p - vec3(0.333333 * m); //project onto surface plane\n  //now push projected point, if outside triangle edge, perpendicular to edge, to edge\n  vec3 toMove = min(projPoint, 0.0); //if projpoint.x<0 move along (1.0,-0.5,-0.5) , etc\n  float toMoveSum = dot(toMove, vec3(1.0)); //which is basically along (1.5,0,0) then vec3(-0.5)\n\n  vec3 movedPoint = projPoint + toMove * vec3(-1.5) + toMoveSum * vec3(0.5); //better to multiply toMove by a matrix (1s diagonal, 0.5 other)?\n\n  movedPoint = max(movedPoint, 0.0); //cap x,y,z to 0 then\n  movedPoint *= s / dot(movedPoint, vec3(1.0)); //scale about 0,0,0\n\n  return length(p - movedPoint);\n}\n\n// START ../common/sdf3d/add.glsl\nfloat add(float a, float b) {\n  return min(a, b);\n}\n\n// #pragma glslify: export(add)\n\n\n// START ../common/sdf3d/sub.glsl\nfloat sub(float from, float what) {\n  return max(from, -what);\n}\n\n// #pragma glslify: export(sub)\n\n\n// START ../common/complex.glsl\n\n\nvec2 complexConj(vec2 z) {\n  return vec2(z.x, -z.y);\n}\n\nvec2 complexMul(vec2 a, vec2 b) {\n  return vec2(a.x * b.x - a.y * b.y, a.y * b.x + a.x * b.y);\n}\n\nvec2 complexDiv(vec2 a, vec2 b) {\n  vec2 bConj = vec2(b.x, -b.y);\n  float divisor = complexMul(b, bConj).x;\n  return complexMul(a, bConj) / divisor;\n}\n\n// return e^z\nvec2 complexPow(vec2 z) {\n  // e^(re + i * im)\n  // = e^re * e^(i * im)\n  return fromPolar(exp(z.x), z.y);\n}\n\n// return w^z\nvec2 complexPow(vec2 w, float z) {\n  // w = r * e ^ (i * phi)\n  // ln(w) = ln(r) + i * phi\n  // w^z = e^(z * log(w)) = e^(z * (ln(r) + i * (phi))\n  vec2 wPolar = toPolar(w);\n  vec2 eExp = z * vec2(log(wPolar.x), wPolar.y);\n  return complexPow(eExp);\n}\n\n// START ../common/quaternion.glsl\nvec4 quatMult(vec4 a, vec4 b) {\n  return vec4(\n    a[0] * b[0] - a[1] * b[1] - a[2] * b[2] - a[3] * b[3],\n    a[0] * b[1] + a[1] * b[0] + a[2] * b[3] - a[3] * b[2],\n    a[0] * b[2] - a[1] * b[3] + a[2] * b[0] + a[3] * b[1],\n    a[0] * b[3] + a[1] * b[2] - a[2] * b[1] + a[3] * b[0]\n  );\n}\n\nvec4 quatMult2(vec4 a, vec4 b) {\n  return vec4(\n    a.x * b.x - dot(a.yzw, b.yzw),\n    a.x * b.yzw + b.x * a.yzw + cross(a.yzw, b.yzw)\n  );\n}\n\nvec4 quatMult(vec4 a, vec4 b, vec4 c) {\n  return quatMult(quatMult(a, b), c);\n}\n\nvec4 quatConjugate(vec4 a) {\n  return vec4(a[0], -a[1], -a[2], -a[3]);\n}\nvec4 quatConjugate2(vec4 a) {\n  return vec4(a.x, -a.yzw);\n}\n\nfloat quatNorm(vec4 a) {\n  return length(a);\n}\n\nvec4 quatInverse(vec4 a) {\n  return quatConjugate(a) / dot(a, a);\n}\n\nvec4 quatRotation(vec3 axis1, float angleRad) {\n  return vec4(cos(0.5 * angleRad), axis1 * sin(0.5 * angleRad));\n}\n\nvec4 quatPower(vec4 q, float x) {\n  float a = q.x;\n  vec3 vv = q.yzw;\n  vec3 n1 = normalize(vv);\n  float phi = atan(length(vv), a);\n  return pow(quatNorm(q), x) * vec4(cos(x * phi), n1 * sin(x * phi));\n}\nvec4 quatExp(vec4 q) {\n  float a = q.x;\n  vec3 vv = q.yzw;\n  return exp(a) * vec4(cos(length(vv)), normalize(vv) * sin(length(vv)));\n}\n\nvec4 rotatePoint(vec4 quat, vec3 p) {\n  return quatMult(quat, vec4(0, p), quatInverse(quat));\n}\n\n\n\nuniform sampler2D texture;\nuniform float secs;\nuniform mat4 lll;\nuniform mat4 llli;\nuniform vec4 colorPrimary;\nuniform vec4 colorSecondary;\nuniform vec4 colorBackground;\nuniform float a;\nuniform float b;\nuniform float c;\nuniform float d;\nuniform float highResTimeStamp;\nuniform int bandCount;\nuniform vec3 extra;\nuniform vec3 campos;\nin float n;\nin vec2 coord;\nout vec4 fragColor;\n\nstruct FxDFx {\n  float fx;\n  vec2 dfx;\n};\n\n// f(r,a) = r - 1 + sin(3a+2r2)/2\n//float f(vec2 polar) {\n//  float r = length()polar.x;\n//  float a = polar.y;\n//  return r - 1.0 + sin(25.0 * a + 20.0 * r * r) / 2.0;\n//}\n//vec2 df(vec2 x) {\n//  float r = length(x);\n//  float a = atan(x.y, x.x);\n//  vec2 da = vec2(x.y, -x.x) / (r * r);\n//  return x / r + (1.5 * da + 2.0 * x) * cos(3.0 * a + 2.0 * r * r);\n//}\n\nFxDFx ff(vec2 p) {\n  float r = length(p);\n  float a = atan(p.x, p.y);\n  float fx = r - 1.0 + 0.5 * sin(3.0 * a + 2.0 * r * r);\n  vec2 da = vec2(p.y, -p.x) / (r * r);\n  vec2 dfx = p / r + (1.5 * da + 2.0 * p) * cos(3.0 * a + 2.0 * r * r);\n  return FxDFx(fx, dfx);\n}\n\n#define CHAIN(NAME, F, G)                                                      \\\n  FxDFx NAME(vec2 p) {                                                         \\\n    FxDFx gResult = G(x);                                                      \\\n    return FxDFx();                                                            \\\n  }\n\nfloat f(vec2 x) {\n  float r = length(x);\n  float a = atan(x.y, x.x);\n  return r - 1.0 + 0.5 * sin(5.0 * a + 2.0 * r * r);\n}\nvec2 grad(vec2 x) {\n  vec2 h = vec2(0.01, 0.0);\n  return vec2(f(x + h.xy) - f(x - h.xy), f(x + h.yx) - f(x - h.yx)) /\n  (2.0 * h.x);\n}\nuniform vec2 iMouse;\nuniform vec2 iResolution;\n\nfloat pointGrid(float scale, vec2 p) {\n  p -= 0.5;\n  p /= scale;\n  vec2 pCenter = round(p);\n  return smoothstep(-0.5, -0.4, -distance(pCenter, p) * scale);\n}\n\nfloat lineGrid(float scale, vec2 p) {\n  p -= 0.5;\n  p /= scale;\n  vec2 pCenter = round(p);\n  vec2 d = abs(p - pCenter);\n  return smoothstep(-0.5, -0.4, -min(d.x, d.y) * scale);\n}\nfloat lineGrid(float scale, vec2 p, vec2 dp) {\n  p -= 0.5;\n  p /= scale;\n  vec2 pCenter = round(p);\n  vec2 d = abs((p - pCenter) / dp);\n  return smoothstep(-0.5, -0.4, -min(d.x, d.y) * scale);\n}\n/**\n * Renders a transform of a coordinate system as a line grid.\n *\n * E.g.\n *\n * `p` should be p(fragCoord)\n *\n * and\n *\n * `scale` should be dp/dx(fragCoord)\n *\n * For a linear transformation (mat2 mi), you pass\n * `lineGrid(mi * fragCoord, mi)`\n */\nfloat lineGrid(vec2 p, mat2 scale) {\n  //  p -= 0.5;\n  vec2 pCenter = round(p);\n  vec2 gradX = vec2(1, 0) * scale;\n  vec2 gradY = vec2(0, 1) * scale;\n  vec2 d = abs(p - pCenter);\n  float m = min(d.x / length(gradX), d.y / length(gradY));\n  //  return float(m < 3.0);\n  return smoothstep(-1.5, -0.0, -m);\n}\nfloat lineCross(float scale, vec2 p, mat2 dp) {\n  p -= 0.5;\n  p /= scale;\n  dp /= scale;\n  //  vec2 d = abs(p * inverse(dp));\n  //  vec2 d = abs(inverse(dp) * p);\n  //  vec2 d = abs(dp * p);\n  vec2 d = abs(p);\n  //  vec2 d = abs(p * dp);\n  return smoothstep(-0.5, -0.4, -min(d.x, d.y));\n}\nconst vec3 white = vec3(1);\nconst vec3 red = vec3(1, 0, 0);\n\nvec2 fff2(vec2 x) {\n  vec2 p = toPolar(x);\n  return fromPolar(p.x, p.x);\n}\nvec2 fff(vec2 x) {\n  vec2 p = toPolar(x);\n  vec2 pp = vec2(p.x, p.y + 0.01 * p.x);\n  return fromPolar(pp);\n}\n\nvec2 ff3(vec2 x) {\n  return 1.0 + cos(x / 50.0) * 30.0 / 50.0;\n  return 1.0 + cos(x / 50.0) * 30.0 * a / 50.0;\n}\nvec2 cPow(vec2 fragCoord, float it) {\n  vec2 w = fragCoord / a / 50.0;\n  float z = 1.0 / c;\n  // w = r * e ^ (i * phi)\n  // ln(w) = ln(r) + i * phi\n  // w^z = e^(z * log(w)) = e^(z * (ln(r) + i * (phi))\n  vec2 wPolar = toPolar(w);\n  wPolar.y += it * TAU;\n  vec2 eExp = z * vec2(log(wPolar.x), wPolar.y);\n  if (!between(-PI, PI, eExp.y)) {\n    return vec2(0);\n  }\n  return complexPow(eExp);\n}\n\n#define DERIVATIVE_2_2(NAME, F, EPS)                                           \\\n  mat2 NAME(vec2 x) {                                                          \\\n    vec2 fx = F(x);                                                            \\\n    vec2 fx1 = F(x + vec2(EPS, 0));                                            \\\n    vec2 fx2 = F(x + vec2(0, EPS));                                            \\\n    return mat2(fx1 - fx, fx2 - fx) / (EPS);                                   \\\n  }\n\nDERIVATIVE_2_2(dfff, fff, 1e-4)\nDERIVATIVE_2_2(dff3, ff3, 1e-4)\nmat2 dCPow(vec2 x, float it) {\n  const float EPS = 1e-3;\n  vec2 fx = cPow(x, it);\n  vec2 fx1 = cPow(x + vec2(EPS, 0), it);\n  vec2 fx2 = cPow(x + vec2(0, EPS), it);\n  return mat2(fx1 - fx, fx2 - fx) / EPS;\n}\n\n#define MIX_MAT(genMType)                                                      \\\n  genMType mixMat(genMType a, genMType b, float t) {                           \\\n    return (1.0 - t) * a + t * b;                                              \\\n  }\n\nMIX_MAT(mat2)\n\n#define MIN3(G)                                                                \\\n  G min3(G a, G b, G c) {                                                      \\\n    return min(min(a, b), c);                                                  \\\n  }\n\nMIN3(vec2)\n\nuniform float iTime;\nvec3 ungamma(vec4 col) {\n  return pow(col.rgb, vec3(2.2));\n}\n\nvoid main() {\n  vec2 fragCoord = coord * iResolution;\n  //  //  vec2 p = toPolar(coord * 2.0);\n  vec2 crd = coord;\n  crd *= 2.0;\n  //  FxDFx r = ff(crd);\n  //  float fx = r.fx;\n  //  vec2 dfx = r.dfx;\n  //  float de = abs(fx) / length(dfx);\n  //  //  fx = abs(fx);\n  //  //  de = smoothstep(0.01, 0.02, de);\n  //  //  vec3 color = vec3(fx);\n  //  fragColor = visualize(de);\n  //  //  fragColor = vec4(color, 1.0);\n\n  vec4 z = vec4(coord, 0.0, 0.0);\n  const vec4 c = vec4(-0.4, 0.6, 0.0, 0.0);\n  int i = 0;\n  for (; i < 30; i++) {\n    z = quatMult(z, z) + c;\n    const vec4 c2 = vec4(-0.4, 0.6, 0.0, 0.0);\n    int i = 0;\n    for (; i < 30; i++) {\n      z = quatMult(z, z) + c2;\n      if (length(z) > 1.2) {\n        break;\n      }\n    }\n\n    //  vec3 color=mix(bl)\n\n    vec2 x = crd;\n    float v = f(x);\n    vec2 g = grad(x);\n    float de = abs(v) / length(g);\n    vec3 color;\n    //  fragColor = visualize(pow(de, 0.5));\n    color = mix(vec3(1.0), vec3(0.0, 0.0, 1.0), float(i) / 30.0);\n\n    {\n      int i = 0;\n      vec4 z = vec4(iMouse, 0, 0);\n      for (; i < 30; i++) {\n        vec4 prevZ = z;\n        z = quatMult(z, z) + c;\n        if (sdSegment(prevZ.xy, z.xy, coord) < 0.002) {\n          color = mix(vec3(0, 0, 0), vec3(0.1, 1.0, 0), float(i) / 30.0);\n          break;\n        }\n        if (length(z) > 1.2) {\n          break;\n        }\n      }\n    }\n    if (distance(vec2(0), coord) < 0.05) {\n      color = vec3(1, 0, 0);\n    }\n    if (distance(c.xy, coord) < 0.05) {\n      color = vec3(0, 1, 0);\n    }\n    //  fragColor = visualize(sdSegment(vec2(0), iMouse, coord));\n    //  color = mix(white, vec3(1, 0, 1), pointGrid(20.0, fragCoord));\n    //  fragCoord += sin(fragCoord / 50.0) * 30.0;\n    //    fragCoord -= 800.0;\n    //  fragCoord *= 2.0;\n    //  fragCoord = ff3(fragCoord);\n    //  vec2 dFragCoord = 1.0 + cos(fragCoord / 50.0) * 30.0 / 50.0;\n    mat2 dFragCoord = dfff(fragCoord);\n    color = mix(white, vec3(1, 0, 1), lineGrid(20.0, fragCoord, vec2(1.0)));\n    fragColor = vec4(color, 1.0);\n    fragColor = visualize(determinant(dFragCoord));\n    if (distance(c2.xy, coord) < 0.05) {\n      color = vec3(0, 1, 0);\n    }\n\n    color = pow(color, vec3(1.0 / 2.2)); // gamma correction\n    //  color = mix(white, vec3(1, 0, 1), pointGrid(20.0, fragCoord));\n    //  fragCoord += sin(fragCoord / 50.0) * 30.0;\n    vec2 p = fragCoord;\n    p -= 0.5 * iResolution;\n    //  p.y *= -1.0;\n    //  p *= 2.0;\n    //  p = ff3(p);\n    //  vec2 dFragCoord = 1.0 + cos(p / 50.0) * 30.0 / 50.0;\n    mat2 mi = inverse(mat2(1.0, 0.0, 0.0, 1.0) * a * 20.0);\n    mat2 id = mat2(1.0, 0.0, 0.0, 1.0);\n    float t = 0.0;\n    color = white;\n    //  color = mix(\n    //    color,\n    //    vec3(cPow(p) / 4.0, 0),\n    //    lineGrid(cPow(p), dCPow(p))\n    //  );\n\n    //  for (int i = -100; i < 100; i++) {\n    //    vec2 p = vec2(i, 2.0);\n    //    p = cPow(p, 0.0);\n    //    p *= 10.0;\n    //    float xxx = float(distance(p, p) < 5.0);\n    //    color = mix(color, vec3(float(i + 100) / 100.0, 0, 0), xxx);\n    //  }\n    // TODO: save this line grid/complex mult demo\n    //    for (float it = -2.0; it <= 2.0; it++) {\n    //      //    p += it * vec2(1.0) * d;\n    //      color = mix(\n    //        color,\n    //        vec3(0.5),\n    //        //      vec3(cPow(p, it) / 4.0, 0),\n    //        lineGrid(cPow(p, it), dCPow(p, it))\n    //      );\n    //    }\n    vec3 color0 = colorBackground.rgb;\n    vec3 color1 = colorPrimary.rgb;\n    vec3 color2 = colorSecondary.rgb;\n    float val = 1000.0;\n    //    const vec3 orange = vec3(1.0, 0.843, 0);\n    //    color = mix(color, color1, float(distance(a, fragCoord) < 10.0));\n    //    color = mix(color, color1, float(distance(b, fragCoord) < 10.0));\n    //    color = mix(color, color1, float(distance(c, fragCoord) < 10.0));\n    //    color = mix(color, color2, float(sdSegment(a, b, fragCoord) < 3.0));\n    //    color = vec3(fragCoord, 0.0);\n    color = pow(color, vec3(1.0 / 2.2)); // gamma correction\n    fragColor = vec4(color, 1.0);\n    //  fragColor = visualize(determinant(dFragCoord));\n  }\n}\n\n"},3717:(n,e,t)=>{"use strict";t.r(e),t.d(e,{default:()=>o});const o="#version 300 es\nprecision highp float;\n// START ../common/banded.glsl\nfloat banded(float bandCount, float t) {\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\n}\nfloat banded(int bandCount, float t) {\n  return banded(float(bandCount), t);\n}\n\n// #pragma glslify: export(banded)\n\n\n// START ../common/between.glsl\nbool between(float min, float max, float value) {\n  return min <= value && value <= max;\n}\n\n// #pragma glslify: export(between)\n\n\n// START ../common/perlin2DTexture.glsl\nuniform sampler2D gradients;\n\nfloat dotGridGradient(vec2 cell, vec2 pos) {\n  vec2 d = cell - pos;\n\n  vec2 gradient = texelFetch(gradients, ivec2(cell), 0).xy;\n  return dot(gradient, d);\n}\n\nfloat mixx(float a, float b, float t) {\n  return mix(a, b, smoothstep(0.0, 1.0, t));\n  //    return mix(a, b, t);\n}\n\n// resulting range is [-0.68, 0.68]. Use unmix to normalize if necessary.\nfloat perlin2D(vec2 xy) {\n  float x0 = floor(xy.x);\n  float x1 = x0 + 1.0;\n  float y0 = floor(xy.y);\n  float y1 = y0 + 1.0;\n\n  // Interpolate between grid point gradients\n  float n00 = dotGridGradient(vec2(x0, y0), xy);\n  float n10 = dotGridGradient(vec2(x1, y0), xy);\n  float ny0 = mixx(n00, n10, xy.x - x0);\n\n  float n01 = dotGridGradient(vec2(x0, y1), xy);\n  float n11 = dotGridGradient(vec2(x1, y1), xy);\n  float ny1 = mixx(n01, n11, xy.x - x0);\n\n  return mixx(ny0, ny1, xy.y - y0);\n}\n\n// #pragma glslify: export(perlin2D)\n\n\n// START ../common/remix.glsl\n// START ./unmix.glsl\nfloat unmix(float a, float b, float value) {\n  return (value - a) / (b - a);\n}\n\n// #pragma glslify: export(unmix)\n\n\n\nfloat remix(float fromA, float fromB, float toA, float toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\nvec4 remix(float fromA, float fromB, vec4 toA, vec4 toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\n// #pragma glslify: export(remix)\n\n\n\n// START ../common/waves.glsl\nfloat waves(vec4 color, vec2 position, vec2 direction, float highResTimeStamp) {\n  return sin(\n    dot(position, direction / pow(length(direction), 2.0)) +\n      float(highResTimeStamp) / 200.0\n  );\n}\n\n// #pragma glslify: export(waves)\n\n\n// START ../common/visualize.glsl\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\n  float isLow = float(t < 0.0);\n  float isHigh = float(t > 1.0);\n  float isMid = 1.0 - isLow - isHigh;\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\n}\n\nvec4 visualize(float t) {\n  const vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\n  const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\n  return visualize(BLUE, RED, t);\n}\n\n// #pragma glslify: export(visualize)\n\n\n// START ../common/ra2Hex.glsl\nvec3 raToHex(vec2 xy) {\n  float hex_t = xy.y / 0.866;\n  float hex_s = xy.x - hex_t / 2.0;\n  return vec3(hex_s, hex_t, -(hex_s + hex_t));\n}\n\n// #pragma glslify: export(raToHex)\n\n\n// START ../common/hex2Ra.glsl\nvec2 hex2Ra(vec3 hex) {\n  float y = hex.t * 0.866;\n  float x = hex.s + hex.t / 2.0;\n  return vec2(x, y);\n}\n\n// #pragma glslify: export(hex2Ra)\n\n\n// START ../common/hexRound.glsl\nvec3 hexRound(vec3 hex) {\n  vec3 r = floor(hex + 0.5);\n  vec3 diff = abs(r - hex);\n\n  if (diff.x > diff.y && diff.x > diff.z) {\n    r.x = -(r.y + r.z);\n  } else if (diff.y > diff.z) {\n    r.y = -(r.x + r.z);\n  } else {\n    r.z = -(r.x + r.y);\n  }\n\n  return r;\n}\n\n// #pragma glslify: export(hexRound)\n\n\n// START ../common/hexSdf.glsl\n// START ./max3.glsl\nfloat max3(float a, float b, float c) {\n  return max(a, max(b, c));\n}\nfloat max3(vec3 v) {\n  return max(v.x, max(v.y, v.z));\n}\n\n// #pragma glslify: export(max3)\n\n\n\nfloat hexSdf(vec3 hex) {\n  return max3(abs(hex.yzx + hex.zxy / 2.0));\n}\n\n// #pragma glslify: export(hexSdf)\n\n\n\n\nuniform sampler2D texture;\nuniform vec4 colorPrimary;\nuniform float highResTimeStamp;\nuniform vec4 colorSecondary;\nuniform vec4 colorBackground;\nuniform float a;\nuniform int bandCount;\nin float n;\nin vec2 coord;\nout vec4 fragColor;\n\nconst float SQRT1_2 = 0.7071067811865476;\nconst float SQRT2 = 1.4142135623730951;\nconst float PI = 3.141592653589793;\n\nconst vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\nconst vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\nconst vec4 blue = vec4(0.0, 0.0, 1.0, 1.0);\nconst vec4 red = vec4(1.0, 0.0, 0.0, 1.0);\n\n// (x, y) -> (u, v, R)\n// where u is horizontal, v is south-west to north-east\n// and R is wether the it is in the right triangle\nvec3 xy2tri(vec2 xy) {\n  float v = xy.y / 0.866;\n  float u = xy.x - v / 2.0;\n  float R = float(\n    mod(u + v, 2.0) > 1.0 != (mod(floor(u) + floor(v), 2.0) == 1.0)\n  );\n  return vec3(u, v, R);\n}\nvec3 triCenter(vec3 uvR) {\n  vec3 base = floor(uvR);\n  vec2 centerOffset = mix(vec2(1.0 / 3.0), vec2(2.0 / 3.0), uvR.z);\n  return base + vec3(centerOffset, 0.0);\n}\nvec2 tri2xy(vec3 uvR) {\n  float y = uvR.t * 0.866;\n  float x = uvR.s + uvR.t / 2.0;\n  return vec2(x, y);\n}\n\nmat2 rot2(float angle) {\n  float c = cos(angle),\n    s = sin(angle);\n  return mat2(c, -s, s, c);\n}\n\nfloat perlin01(vec2 pos) {\n  return unmix(-0.68, 0.68, perlin2D(pos));\n}\n\nfloat triSdf(vec2 uv) {\n  vec3 hex = vec3(uv.x, uv.y, -uv.x - uv.y);\n  return max3(hex);\n}\n\nvec2 fc(vec2 z, vec2 c) {\n  return complexMul(z, z) + c;\n}\n\nfloat mandelbrot(vec2 c) {\n  vec2 z = vec2(0);\n  for (int i = 0; i < bandCount * 2; i++) {\n    z = fc(z, c);\n  }\n  return length(z);\n}\nvec2 mandelbrotz(vec2 c) {\n  vec2 z = vec2(0);\n  for (int i = 0; i < bandCount * 2; i++) {\n    z = fc(z, c);\n  }\n  return z;\n}\n\nint mandelbrotcount(vec2 c) {\n  vec2 z = vec2(0);\n  int i;\n  for (i = 0; i < bandCount * 2; i++) {\n    z = fc(z, c);\n    if (length(z) > 1024.0) {\n      break;\n    }\n  }\n  return i;\n}\n\nvoid main() {\n  vec2 cc = coord / pow(10.0, a * 10.0) - vec2(0.5301, 0.5);\n  vec2 f = mandelbrotz(cc);\n  float inside = float(length(f) < 1024.0);\n  int c = mandelbrotcount(cc);\n\n  //    fragColor =\n  //        visualize(blue, red, f / 1000.0);\n\n  //    fragColor = vec4(f.xy, 0.0, 1.0);\n  float val = pow(float(c) / float(bandCount), 1.0 / 2.0);\n  fragColor = mix(colorBackground, colorPrimary, val);\n  //    fragColor = visualize(blue, red, val);\n}\n"},8261:(n,e,t)=>{var o={"./demoLego.frag":2699,"./demoTemple.frag":5592,"./fractals.frag":3801,"./mandelbrot.frag":3717};function r(n){var e=a(n);return t(e)}function a(n){if(!t.o(o,n)){var e=new Error("Cannot find module '"+n+"'");throw e.code="MODULE_NOT_FOUND",e}return o[n]}r.keys=function(){return Object.keys(o)},r.resolve=a,n.exports=r,r.id=8261},492:(n,e,t)=>{"use strict";function o(n,e){for(var t=0;t<e.length;t++){var o=e[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(n,o.key,o)}}function r(n,e){return function(n){if(Array.isArray(n))return n}(n)||function(n,e){if("undefined"!=typeof Symbol&&Symbol.iterator in Object(n)){var t=[],o=!0,r=!1,a=void 0;try{for(var c,i=n[Symbol.iterator]();!(o=(c=i.next()).done)&&(t.push(c.value),!e||t.length!==e);o=!0);}catch(n){r=!0,a=n}finally{try{o||null==i.return||i.return()}finally{if(r)throw a}}return t}}(n,e)||c(n,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function a(n){return function(n){if(Array.isArray(n))return i(n)}(n)||function(n){if("undefined"!=typeof Symbol&&Symbol.iterator in Object(n))return Array.from(n)}(n)||c(n)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function c(n,e){if(n){if("string"==typeof n)return i(n,e);var t=Object.prototype.toString.call(n).slice(8,-1);return"Object"===t&&n.constructor&&(t=n.constructor.name),"Map"===t||"Set"===t?Array.from(t):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?i(n,e):void 0}}function i(n,e){(null==e||e>n.length)&&(e=n.length);for(var t=0,o=new Array(e);t<e;t++)o[t]=n[t];return o}function s(n){if("undefined"==typeof Symbol||null==n[Symbol.iterator]){if(Array.isArray(n)||(n=c(n))){var e=0,t=function(){};return{s:t,n:function(){return e>=n.length?{done:!0}:{done:!1,value:n[e++]}},e:function(n){throw n},f:t}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var o,r,a=!0,i=!1;return{s:function(){o=n[Symbol.iterator]()},n:function(){var n=o.next();return a=n.done,n},e:function(n){i=!0,r=n},f:function(){try{a||null==o.return||o.return()}finally{if(i)throw r}}}}t.d(e,{Z:()=>h});var l=0;function v(n){return"__private_"+l+++"_"+n}function f(n,e){if(!Object.prototype.hasOwnProperty.call(n,e))throw new TypeError("attempted to use private field on non-instance");return n}var d=function(){function n(){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n)}return e=n,t=[{key:"format",value:function(e,t){return t in f(n,m)[m]||(f(n,m)[m][t]=n._generateMap(n.styles[t])),function(n,e){var t,o="",r=s(n);try{for(r.s();!(t=r.n()).done;){var a=t.value;o+=e.get(a)||a}}catch(n){r.e(n)}finally{r.f()}return o}(e,f(n,m)[m][t])}},{key:"_generateMap",value:function(e){var t,o=new Map,r=e.hasOwnProperty("exceptions");if(r)for(var c in t=[],Object.keys(e.exceptions).forEach((function(n){t=[].concat(a(t),a(n))})),e.exceptions){var i,l=e.exceptions[c],v=0,d=s(c);try{for(d.s();!(i=d.n()).done;){var m=i.value,u=String.fromCodePoint(v+l);o.set(m,u),v++}}catch(n){d.e(n)}finally{d.f()}}for(var h in!e.hasOwnProperty("upper")&&e.hasOwnProperty("lower")?e.upper=e.lower:!e.hasOwnProperty("lower")&&e.hasOwnProperty("upper")&&(e.lower=e.upper),f(n,p)[p])if("number"==typeof e[h]){var x,g=s(f(n,p)[p][h].chars);try{for(g.s();!(x=g.n()).done;){var y=x.value;if(!r||!t.includes(y)){var b=y.codePointAt(0),R=String.fromCodePoint(b+e[h]-f(n,p)[p][h]["lower-bound"]);o.set(y,R)}}}catch(n){g.e(n)}finally{g.f()}}return o}},{key:"unformat",value:function(e){void 0===f(n,u)[u]&&n._generateReverseMap();var t,o="",r=s(e);try{for(r.s();!(t=r.n()).done;){var a=t.value;o+=f(n,u)[u].get(a)||a}}catch(n){r.e(n)}finally{r.f()}return o}},{key:"_generateReverseMap",value:function(){for(var e={},t=arguments.length,o=new Array(t),a=0;a<t;a++)o[a]=arguments[a];if(0===o.length)for(var c in e=n.styles,f(n,p)[p]){var i=f(n,p)[p][c]["lower-bound"];e.normal=i}else o.forEach((function(t){e.push(n.styles[t])}));for(var l in f(n,u)[u]=new Map,e){var v,d=s(l in f(n,m)[m]?f(n,m)[m][l]:n._generateMap(e[l]));try{for(d.s();!(v=d.n()).done;){var h=r(v.value,2),x=h[0],g=h[1];f(n,u)[u].set(g,x)}}catch(n){d.e(n)}finally{d.f()}}}}],null&&o(e.prototype,null),t&&o(e,t),n;var e,t}(),p=v("charaters"),m=v("styleDict"),u=v("styleReverseMap");d.styles={"serf-bold":{upper:119808,lower:119834,digits:120783,zero:120782},"serf-italic":{upper:119860,lower:119886,exceptions:{h:8462}},"serf-bold-italic":{upper:119912,lower:119938},"sans-serf":{upper:120224,lower:120250,digits:120803,zero:120802},"sans-serf-bold":{upper:120276,lower:120302,digits:120813,zero:120812},"sans-serf-italic":{upper:120328,lower:120354},"sans-serf-bold-italic":{upper:120380,lower:120406},script:{upper:119964,lower:119990,exceptions:{B:8492,EF:8496,H:8459,I:8464,L:8466,M:8499,R:8475,e:8495,g:8458,o:8500}},"script-bold":{upper:120016,lower:120042},fraktur:{upper:120068,lower:120094,exceptions:{C:8493,H:8460,I:8465,R:8476,Z:8488}},"fraktur-bold":{upper:120172,lower:120198},monospace:{upper:120432,lower:120458,digits:120823,zero:120822},"double-struck":{upper:120120,lower:120146,digits:120793,zero:120792,exceptions:{C:8450,H:8461,N:8469,P:8473,Q:8474,R:8477,Z:8484}},circled:{upper:9398,lower:9424,digits:9312,zero:127243},"negative-circled":{upper:127312,zero:9471},"parenthesized-small":{lower:9372,digits:9332},"parenthesized-large":{upper:127248},squared:{upper:127280},"negative-squared":{upper:127344}},Object.defineProperty(d,p,{writable:!0,value:{lower:{chars:"abcdefghijklmnopqrstuvwxyz","lower-bound":97},upper:{chars:"ABCDEFGHIJKLMNOPQRSTUVWXYZ","lower-bound":65},digits:{chars:"123456789","lower-bound":49},zero:{chars:"0","lower-bound":48}}}),Object.defineProperty(d,m,{writable:!0,value:{}}),Object.defineProperty(d,u,{writable:!0,value:void 0});const h=d}}]);