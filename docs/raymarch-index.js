"use strict";(self.webpackChunkworkshop=self.webpackChunkworkshop||[]).push([[628],{3671:(e,n,t)=>{t.d(n,{PM:()=>i,X$:()=>l,XJ:()=>s,Qn:()=>c,q3:()=>f,oe:()=>d,_x:()=>u,hv:()=>p,kC:()=>h,li:()=>m,t1:()=>v,nl:()=>g,YQ:()=>y});var o=t(9526),r=t(2182);const a="C:\\Users\\aval\\tsdev\\workshop\\src\\paperBox1\\common.tsx",i=25.4,l=e=>(0,r.At)(e/r.Co,-1)+"°",s=(e,n)=>n/2/Math.sin(r.gc/e/2),c=(e,n)=>2*n*Math.sin(r.gc/e/2),f=(e,n)=>n/2/Math.tan(r.gc/e/2),d=(e,n)=>n/Math.cos(r.gc/e/2),u=(e,n)=>2*n*Math.tan(r.gc/e/2);function p({sides:e,radius:n,startAngle:t=0,sideLength:i,...l}){if(void 0!==i==(void 0!==n))throw new Error("must set either sideLength or radius");void 0===n&&(n=s(e,i));const{x:c,y:f}=r.V3.polar(n,t);return o.createElement("path",{d:g`
        M${c},${f}
        ${(0,r.hS)(0,e).map((o=>g`L${r.V3.polar(n,t+o*(r.gc/e))}`))}Z`,...l,__self:this,__source:{fileName:a,lineNumber:48}})}function h({id:e,children:n,count:t,stepDeg:i}){return o.createElement(o.Fragment,null,o.createElement("g",{id:e,__self:this,__source:{fileName:a,lineNumber:72}},n),(0,r.hS)(0,t-1).map((n=>o.createElement("use",{key:n,href:"#"+e,transform:`rotate(${(n+1)*i} 0 0)`,__self:this,__source:{fileName:a,lineNumber:74}}))))}const m=[[841,1189,"A0"],[594,841,"A1"],[420,594,"A2"],[297,420,"A3"],[210,297,"A4"],[148,210,"A5"],[105,148,"A6"],[74,105,"A7"],[52,74,"A8"],[37,52,"A9"],[26,37,"A10"],[150,150,"Origami 15cm"],[100,100,"Origami 10cm"],[75,75,"Origami 7.5cm"],[215.9,279.4,"Letter"],[215.9,355.6,"Legal"]],v=m.find((([,,e])=>e.includes("A4")));function g(e,...n){const t=e=>"number"==typeof e?""+e:"string"==typeof e?e:Array.isArray(e)?e.map(t).join(" "):e.x+","+e.y;let o=e[0];for(let r=0;r<n.length;r++)o+=t(n[r]),o+=e[r+1];return o}const y=e=>{const n=window.open(e,"_blank","noopener,noreferrer");n&&(n.opener=null)}},1641:(e,n,t)=>{t.d(n,{q:()=>d});var o=t(6897),r=t.n(o),a=t(508),i=t.n(a),l=t(9526);const s=e=>"#"+Object.entries(e).map((([e,n])=>encodeURIComponent(e)+"="+encodeURIComponent(n))).join("&"),c=e=>i()(e,(e=>"true"===e||"false"!==e&&("NaN"===e?NaN:"undefined"===e?void 0:"null"===e?null:""===e?"":isNaN(+e)?e:+e))),f=e=>i()(e,(e=>""+e));function d(e,{deserialize:n=c,serialize:t=f,wait:o=1e3}={}){const a=(0,l.useCallback)((()=>{const o="function"==typeof e?e():e,r=n(Object.assign(t(o),(a=document.location.hash)?a.substr(1).split("&").map((e=>{const[n,t]=e.split("=");return[decodeURIComponent(n),decodeURIComponent(t)]})).reduce(((e,[n,t])=>(e[n]=t,e)),{}):{}));var a;return history.pushState(void 0,document.title,s(t(r))),r}),[n,e,t]),[i,d]=(0,l.useState)(a),u=(0,l.useRef)();return u.current||(u.current=r()((function(e){history.pushState(void 0,document.title,s(t(e)))}),o)),(0,l.useEffect)((()=>u.current(i)),[i]),(0,l.useEffect)((()=>{const e=()=>{d(a())};return window.addEventListener("hashchange",e),()=>{window.removeEventListener("hashchange",e)}}),[a]),[i,d]}},1941:(e,n,t)=>{t.r(n),t.d(n,{default:()=>be});var o=t(5898),r=t(6800),a=t(260),i=t(1459),l=t(5477),s=t(1605),c=t(1492),f=t(2772),d=t(5282),u=t(5270);function p(e,n){for(var t=0;t<n.length;t++){var o=n[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}function h(e,n){return function(e){if(Array.isArray(e))return e}(e)||function(e,n){if("undefined"!=typeof Symbol&&Symbol.iterator in Object(e)){var t=[],o=!0,r=!1,a=void 0;try{for(var i,l=e[Symbol.iterator]();!(o=(i=l.next()).done)&&(t.push(i.value),!n||t.length!==n);o=!0);}catch(e){r=!0,a=e}finally{try{o||null==l.return||l.return()}finally{if(r)throw a}}return t}}(e,n)||v(e,n)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function m(e){return function(e){if(Array.isArray(e))return g(e)}(e)||function(e){if("undefined"!=typeof Symbol&&Symbol.iterator in Object(e))return Array.from(e)}(e)||v(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function v(e,n){if(e){if("string"==typeof e)return g(e,n);var t=Object.prototype.toString.call(e).slice(8,-1);return"Object"===t&&e.constructor&&(t=e.constructor.name),"Map"===t||"Set"===t?Array.from(t):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?g(e,n):void 0}}function g(e,n){(null==n||n>e.length)&&(n=e.length);for(var t=0,o=new Array(n);t<n;t++)o[t]=e[t];return o}function y(e){if("undefined"==typeof Symbol||null==e[Symbol.iterator]){if(Array.isArray(e)||(e=v(e))){var n=0,t=function(){};return{s:t,n:function(){return n>=e.length?{done:!0}:{done:!1,value:e[n++]}},e:function(e){throw e},f:t}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var o,r,a=!0,i=!1;return{s:function(){o=e[Symbol.iterator]()},n:function(){var e=o.next();return a=e.done,e},e:function(e){i=!0,r=e},f:function(){try{a||null==o.return||o.return()}finally{if(i)throw r}}}}var x=0;function b(e){return"__private_"+x+++"_"+e}function _(e,n){if(!Object.prototype.hasOwnProperty.call(e,n))throw new TypeError("attempted to use private field on non-instance");return e}var C=function(){function e(){!function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,e)}return n=e,t=[{key:"format",value:function(n,t){return t in _(e,M)[M]||(_(e,M)[M][t]=e._generateMap(e.styles[t])),function(e,n){var t,o="",r=y(e);try{for(r.s();!(t=r.n()).done;){var a=t.value;o+=n.get(a)||a}}catch(e){r.e(e)}finally{r.f()}return o}(n,_(e,M)[M][t])}},{key:"_generateMap",value:function(n){var t,o=new Map,r=n.hasOwnProperty("exceptions");if(r)for(var a in t=[],Object.keys(n.exceptions).forEach((function(e){t=[].concat(m(t),m(e))})),n.exceptions){var i,l=n.exceptions[a],s=0,c=y(a);try{for(c.s();!(i=c.n()).done;){var f=i.value,d=String.fromCodePoint(s+l);o.set(f,d),s++}}catch(e){c.e(e)}finally{c.f()}}for(var u in!n.hasOwnProperty("upper")&&n.hasOwnProperty("lower")?n.upper=n.lower:!n.hasOwnProperty("lower")&&n.hasOwnProperty("upper")&&(n.lower=n.upper),_(e,w)[w])if("number"==typeof n[u]){var p,h=y(_(e,w)[w][u].chars);try{for(h.s();!(p=h.n()).done;){var v=p.value;if(!r||!t.includes(v)){var g=v.codePointAt(0),x=String.fromCodePoint(g+n[u]-_(e,w)[w][u]["lower-bound"]);o.set(v,x)}}}catch(e){h.e(e)}finally{h.f()}}return o}},{key:"unformat",value:function(n){void 0===_(e,R)[R]&&e._generateReverseMap();var t,o="",r=y(n);try{for(r.s();!(t=r.n()).done;){var a=t.value;o+=_(e,R)[R].get(a)||a}}catch(e){r.e(e)}finally{r.f()}return o}},{key:"_generateReverseMap",value:function(){for(var n={},t=arguments.length,o=new Array(t),r=0;r<t;r++)o[r]=arguments[r];if(0===o.length)for(var a in n=e.styles,_(e,w)[w]){var i=_(e,w)[w][a]["lower-bound"];n.normal=i}else o.forEach((function(t){n.push(e.styles[t])}));for(var l in _(e,R)[R]=new Map,n){var s,c=y(l in _(e,M)[M]?_(e,M)[M][l]:e._generateMap(n[l]));try{for(c.s();!(s=c.n()).done;){var f=h(s.value,2),d=f[0],u=f[1];_(e,R)[R].set(u,d)}}catch(e){c.e(e)}finally{c.f()}}}}],null&&p(n.prototype,null),t&&p(n,t),e;var n,t}(),w=b("charaters"),M=b("styleDict"),R=b("styleReverseMap");C.styles={"serf-bold":{upper:119808,lower:119834,digits:120783,zero:120782},"serf-italic":{upper:119860,lower:119886,exceptions:{h:8462}},"serf-bold-italic":{upper:119912,lower:119938},"sans-serf":{upper:120224,lower:120250,digits:120803,zero:120802},"sans-serf-bold":{upper:120276,lower:120302,digits:120813,zero:120812},"sans-serf-italic":{upper:120328,lower:120354},"sans-serf-bold-italic":{upper:120380,lower:120406},script:{upper:119964,lower:119990,exceptions:{B:8492,EF:8496,H:8459,I:8464,L:8466,M:8499,R:8475,e:8495,g:8458,o:8500}},"script-bold":{upper:120016,lower:120042},fraktur:{upper:120068,lower:120094,exceptions:{C:8493,H:8460,I:8465,R:8476,Z:8488}},"fraktur-bold":{upper:120172,lower:120198},monospace:{upper:120432,lower:120458,digits:120823,zero:120822},"double-struck":{upper:120120,lower:120146,digits:120793,zero:120792,exceptions:{C:8450,H:8461,N:8469,P:8473,Q:8474,R:8477,Z:8484}},circled:{upper:9398,lower:9424,digits:9312,zero:127243},"negative-circled":{upper:127312,zero:9471},"parenthesized-small":{lower:9372,digits:9332},"parenthesized-large":{upper:127248},squared:{upper:127280},"negative-squared":{upper:127344}},Object.defineProperty(C,w,{writable:!0,value:{lower:{chars:"abcdefghijklmnopqrstuvwxyz","lower-bound":97},upper:{chars:"ABCDEFGHIJKLMNOPQRSTUVWXYZ","lower-bound":65},digits:{chars:"123456789","lower-bound":49},zero:{chars:"0","lower-bound":48}}}),Object.defineProperty(C,M,{writable:!0,value:{}}),Object.defineProperty(C,R,{writable:!0,value:void 0});const z=C;var k=t(7392),N=t(3059),S=t(9526),E=t(2182),H=t(9392),P=t(3671),L=t(1641);function A({state:e,prop:n,setStatePartial:t,...o}){return S.createElement(u.Z,{variant:"outlined",size:"small",type:"number",value:e[n],onChange:e=>t({[n]:+e.target.value}),label:n,...o,__self:this,__source:{fileName:"C:\\Users\\aval\\tsdev\\workshop\\src\\raymarch\\boundNumberField.tsx",lineNumber:16}})}var O=t(2035);function T(e){let n,t=e[0],o=1;for(;o<e.length;){const r=e[o],a=e[o+1];if(o+=2,("optionalAccess"===r||"optionalCall"===r)&&null==t)return;"access"===r||"optionalAccess"===r?(n=t,t=a(t)):"call"!==r&&"optionalCall"!==r||(t=a(((...e)=>t.call(n,...e))),n=void 0)}return t}const q=k.$_("red").gl(),V=k.$_("green").gl(),B=k.$_("blue").gl(),I=H.$R,Z={anchor:E.V3.O,dir1:E.V3.X},D={anchor:E.V3.O,dir1:E.V3.Y},W={anchor:E.V3.O,dir1:E.V3.Z};class j{__init(){this.meshes={}}__init2(){this.highlight=0}__init3(){this.offsetGC=void 0}__init4(){this.dragging=0}constructor(e,n,t,o,r,a){this.gl=e,this.pos=n,this.onHover=t,this.onStartDragging=o,this.onStopDragging=r,this.onChange=a,j.prototype.__init.call(this),j.prototype.__init2.call(this),j.prototype.__init3.call(this),j.prototype.__init4.call(this),j.prototype.__init5.call(this),j.prototype.__init6.call(this),j.prototype.__init7.call(this),this.meshes.vector=H.Kj.rotation([(0,E.V)(0,.04),(0,E.V)(.8,.04),(0,E.V)(.85,.06),(0,E.V)(1,0)],Z,E.gc,8,!0),this.meshes.vector.computeNormalsFromFlatTriangles(),this.meshes.vector.compile();const i=E.M4.rotateX(-90*E.Co).translate(E.V3.X);this.meshes.rotater=H.Kj.rotation((0,E.hS)(0,9).map((e=>i.transformPoint(E.V3.polar(.04,-E.gc*e/8)))),{anchor:E.V3.O,dir1:E.V3.Z},101.25*E.Co,8,!1),this.meshes.rotater.computeNormalsFromFlatTriangles(),this.meshes.rotater.compile()}drawVector(e,n,t,o=1){if(e.likeO())return;this.gl.pushMatrix();const r=e.getPerpendicular().unit();this.gl.multMatrix(E.M4.forSys(e.unit(),r,e.cross(r).unit(),n)),t.draw(this.meshes.vector),this.gl.popMatrix()}render(e){const n=this.gl;n.enable(n.CULL_FACE),n.cullFace(n.BACK),n.pushMatrix(),n.multMatrix(this.pos),n.cullFace(n.FRONT),e.uniforms({color:I,normalOffset:.01}),1!==this.highlight&&1!==this.dragging||this.drawVector(E.V3.X,E.V3.O,e,.1),2!==this.highlight&&2!==this.dragging||this.drawVector(E.V3.Y,E.V3.O,e,.1),3!==this.highlight&&3!==this.dragging||this.drawVector(E.V3.Z,E.V3.O,e,.1),n.cullFace(n.BACK),e.uniforms({normalOffset:0}),this.drawVector(E.V3.X,E.V3.O,e.uniforms({color:q}),.1),this.drawVector(E.V3.Y,E.V3.O,e.uniforms({color:V}),.1),this.drawVector(E.V3.Z,E.V3.O,e.uniforms({color:B}),.1),e.uniforms({color:B}).draw(this.meshes.rotater),n.rotate(-90,0,1,0),e.uniforms({color:q}).draw(this.meshes.rotater),n.rotate(-90,1,0,0),e.uniforms({color:V}).draw(this.meshes.rotater),n.popMatrix()}registerListeners(e,n){return this.getCameraMatrix=n,T([this,"access",e=>e.unregister,"optionalCall",e=>e()]),e.addEventListener("mousemove",this.mousemove),e.addEventListener("mousedown",this.mousedown),e.addEventListener("mouseup",this.mouseup),this.unregister=()=>{e.removeEventListener("mousemove",this.mousemove),e.removeEventListener("mousedown",this.mousedown),e.removeEventListener("mouseup",this.mouseup)}}unregisterListeners(){T([this,"access",e=>e.unregister,"optionalCall",e=>e()])}__init5(){this.mousemove=e=>{const n=(0,E.V)(e.offsetX,e.offsetY),t=e.target.getBoundingClientRect();t.width;const o=function(e,n,t){const o=(0,E.V)(2*e.x/n.width-1,2*-e.y/n.height+1,-1),r=(0,E.V)(2*e.x/n.width-1,2*-e.y/n.height+1,1),a=t.inversed(),i=a.transformPoint(o);return{anchor:i,dir1:a.transformPoint(r).minus(i).unit()}}(n,t,this.getCameraMatrix());if(this.dragging){const e=[E.V3.O,E.V3.X,E.V3.Y,E.V3.Z][this.dragging],n=$(o,{anchor:this.pos.getTranslation(),dir1:this.pos.transformVector(e).unit()}),t=this.pos.transformVector(this.offsetGC),r=n.lineClosest.minus(t);this.pos=this.pos.translate(this.pos.getTranslation().to(r)),this.onChange(this.pos)}else{const e=this.pos.inversed(),n={anchor:e.transformPoint(o.anchor),dir1:e.transformVector(o.dir1).unit()};let t;function r(e){const o=$(n,e);return t=G(e,(0,E.uZ)(o.lineT,0,1)),t.distanceTo(o.thClosest)}const a=this.highlight;r(Z)<.1?(this.highlight=1,this.offsetGC=t):r(D)<.1?(this.highlight=2,this.offsetGC=t):r(W)<.1?(this.highlight=3,this.offsetGC=t):(this.highlight=0,this.offsetGC=void 0),this.highlight!==a&&T([this,"access",e=>e.onHover,"optionalCall",e=>e(this.highlight)])}}}__init6(){this.mousedown=e=>{this.highlight&&(this.dragging=this.highlight,this.onStartDragging())}}__init7(){this.mouseup=e=>{this.dragging&&(this.dragging=0,this.onStopDragging())}}}function G(e,n){return e.anchor.plus(e.dir1.times(n))}function $(e,n){if(function(e,n){return(0,E.eq)(1,Math.abs(e.dir1.dot(n.dir1)))}(e,n))return{t:NaN,s:NaN,distance:e.distanceToLine(n)};const t=n.anchor,o=n.dir1,r=e.anchor,a=e.dir1,i=o.dot(a),l=o.squared(),s=a.squared(),c=t.minus(r),f=i*i-s*l,d=(c.dot(o)*i-c.dot(a)*l)/f,u=(c.dot(o)*s-c.dot(a)*i)/f;return{thT:d,lineT:u,thClosest:G(e,d),lineClosest:G(n,u),distance:G(e,d).distanceTo(G(n,u))}}function F(e){let n,t=e[0],o=1;for(;o<e.length;){const r=e[o],a=e[o+1];if(o+=2,("optionalAccess"===r||"optionalCall"===r)&&null==t)return;"access"===r||"optionalAccess"===r?(n=t,t=a(t)):"call"!==r&&"optionalCall"!==r||(t=a(((...e)=>t.call(n,...e))),n=void 0)}return t}class Y{__init(){this.lastPos=E.V3.O}__init2(){this.pressedKeys={}}__init3(){this.pauseCam=!1}constructor(e,n,t){this.state=e,this.onChange=n,this.lockUp=t,Y.prototype.__init.call(this),Y.prototype.__init2.call(this),Y.prototype.__init3.call(this),Y.prototype.__init4.call(this),Y.prototype.__init5.call(this),Y.prototype.__init6.call(this),Y.prototype.__init7.call(this)}__init4(){this.setState=e=>{e!==this.state&&E.M4.copy(e,this.state)}}registerListeners(e,n=e){return F([this,"access",e=>e.unregister,"optionalCall",e=>e()]),e.addEventListener("mousemove",this.mousemove),n.addEventListener("keydown",this.keydown),n.addEventListener("keyup",this.keyup),this.unregister=()=>{e.removeEventListener("mousemove",this.mousemove),n.removeEventListener("keydown",this.keydown),n.removeEventListener("keyup",this.keyup)}}unregisterListeners(){F([this,"access",e=>e.unregister,"optionalCall",e=>e()])}tick(){const e=new E.V3(+!!this.pressedKeys.a-+!!this.pressedKeys.d,+!!this.pressedKeys.q+ +!!this.pressedKeys.Control-+!!this.pressedKeys.e-+!!this.pressedKeys[" "],+!!this.pressedKeys.w-+!!this.pressedKeys.s);e.likeO()||(this.state=this.state.translate(e.toLength(.05)),F([this,"access",e=>e.onChange,"optionalCall",e=>e(this.state)]))}__init5(){this.mousemove=e=>{const n=(0,E.V)(e.pageX,e.pageY),t=this.lastPos.to(n);if(1&e.buttons&&!this.pauseCam){const e=E.M4.rotateY(.25*t.x*E.Co).rotateX(.25*t.y*E.Co);this.state=e.times(this.state),F([this,"access",e=>e.onChange,"optionalCall",e=>e(this.state)])}this.lastPos=n}}__init6(){this.keydown=e=>{this.pressedKeys[e.key]=!0,e.preventDefault()}}__init7(){this.keyup=e=>{this.pressedKeys[e.key]=void 0,e.preventDefault()}}getLookAt(){return this.state}static invertLookAt(e){const n=e.transposed().scale(-1);return{eye:n.transformVector(e.getTranslation(),!1),dir:n.transformVector(E.V3.Z,!1),up:n.transformVector(E.V3.Y.negated(),!1)}}static toShortString(e,n=100){const t=(e,n)=>[e.x,e.y,e.z].map((e=>Math.floor(e*n))).join("."),{eye:o,dir:r,up:a}=Y.invertLookAt(e);return t(o,n)+"~"+t(r.unit(),100)+"~"+t(a,100)}static fromShortString(e,n=100){const t=(e,n)=>(0,E.V)(e.split(".").map((e=>+e/n))),[o,r,a]=e.split("~"),i=t(o,n);return E.M4.lookAt(i,i.plus(t(r,100)),t(a,100))}}class K{__init(){this.count=0}__init2(){this.lastTime=performance.now()}constructor(e){this.notify=e,K.prototype.__init.call(this),K.prototype.__init2.call(this)}tick(e=performance.now()){if(this.count=(this.count+1)%10,0===this.count){const n=Math.floor(1e4/(e-this.lastTime));this.notify(n),this.lastTime=e}}}function X(e){let n,t=e[0],o=1;for(;o<e.length;){const r=e[o],a=e[o+1];if(o+=2,("optionalAccess"===r||"optionalCall"===r)&&null==t)return;"access"===r||"optionalAccess"===r?(n=t,t=a(t)):"call"!==r&&"optionalCall"!==r||(t=a(((...e)=>t.call(n,...e))),n=void 0)}return t}const U=["zoomIn","zoomOut","left","right","up","down"];class Q{__init(){this.lastPos=E.V3.O}__init2(){this.pressedKeys={zoomIn:!1,zoomOut:!1,left:!1,right:!1,up:!1,down:!1}}__init3(){this.pauseCam=!1}__init4(){this.udRot=.1}__init5(){this.rot=0}__init6(){this.dist=10}constructor(e,n={zoomIn:"w",zoomOut:"s",left:"a",right:"d",up:" ",down:"Control"}){this.onChange=e,this.keys=n,Q.prototype.__init.call(this),Q.prototype.__init2.call(this),Q.prototype.__init3.call(this),Q.prototype.__init4.call(this),Q.prototype.__init5.call(this),Q.prototype.__init6.call(this),Q.prototype.__init7.call(this),Q.prototype.__init8.call(this),Q.prototype.__init9.call(this),Q.prototype.__init10.call(this),Q.prototype.__init11.call(this),Q.prototype.__init12.call(this)}__init7(){this.setState=e=>{console.log("setStaet"),[this.udRot,this.rot,this.dist]=Q.toOrbitCameraState(e)}}static toOrbitCameraState(e){if(e instanceof E.M4){const n=e.transposed().scale(-1).transformVector(e.getTranslation(),!1);return[Math.atan(n.z/n.lengthXY()),n.angleXY(),n.length()]}return e}registerListeners(e,n=e){return X([this,"access",e=>e.unregister,"optionalCall",e=>e()]),e.addEventListener("mousemove",this.mousemove),e.addEventListener("wheel",this.wheel),n.addEventListener("keydown",this.keydown),n.addEventListener("keyup",this.keyup),n.addEventListener("blur",this.keyup),this.unregister=()=>{e.removeEventListener("mousemove",this.mousemove),e.removeEventListener("wheel",this.wheel),n.removeEventListener("keydown",this.keydown),n.removeEventListener("keyup",this.keyup),n.removeEventListener("keyup",this.keyup)}}__init8(){this.blur=()=>{}}unregisterListeners(){X([this,"access",e=>e.unregister,"optionalCall",e=>e()])}tick(){const e=.1*(+this.pressedKeys.zoomOut-+this.pressedKeys.zoomIn),n=.1*(-+this.pressedKeys.left+ +this.pressedKeys.right),t=(0,E.uZ)(this.udRot+.1*(+this.pressedKeys.up-+this.pressedKeys.down),.5*-Math.PI,.5*Math.PI);0===e&&0===n&&t===this.udRot||(this.dist+=e,this.rot+=n,this.udRot=t,X([this,"access",e=>e.onChange,"optionalCall",e=>e(this.ss)]))}__init9(){this.mousemove=e=>{const n=(0,E.V)(e.pageX,e.pageY),t=this.lastPos.to(n);if(1&e.buttons&&!this.pauseCam){const n=t.x/100,o=(0,E.uZ)(this.udRot+t.y/100,.5*-Math.PI,.5*Math.PI);o===this.udRot&&0===n||(this.udRot=o,this.rot+=n,X([this,"access",e=>e.onChange,"optionalCall",e=>e(this.ss)]),e.stopImmediatePropagation(),e.preventDefault())}this.lastPos=n}}__init10(){this.wheel=e=>{const n=(0,E.uZ)(this.dist+e.deltaY,.1,1e3);n!==this.dist&&(this.dist=n,e.stopImmediatePropagation(),e.preventDefault(),X([this,"access",e=>e.onChange,"optionalCall",e=>e(this.ss)]))}}get ss(){return[this.udRot,this.rot,this.dist]}__init11(){this.keydown=e=>{for(const n of U)if(this.keys[n]===e.key)return this.pressedKeys[n]=!0,e.stopImmediatePropagation(),void e.preventDefault()}}__init12(){this.keyup=e=>{for(const n of U)if(this.keys[n]===e.key)return this.pressedKeys[n]=!1,e.stopImmediatePropagation(),void e.preventDefault()}}getLookAt(){return Q.getLookAt(this.ss)}static getLookAt([e,n,t]){return E.M4.rotateZ(n).rotateY(e).transform(E.M4.lookAt((0,E.V)(t,0,0),E.V3.O,E.V3.Z))}static invertLookAt(e){const n=e.transposed().scale(-1);return{eye:n.transformVector(e.getTranslation(),!1),dir:n.transformVector(E.V3.Z,!1),up:n.transformVector(E.V3.Y.negated(),!1)}}static toShortString(e,n=100){const[t,o,r]=this.toOrbitCameraState(e),a=(e,n)=>Math.floor(e*n);return a(t,100)+"~"+a(o,100)+"~"+a(r,100)}static fromShortString(e,n=100){const t=(e,n)=>+e/n,[o,r,a]=e.split("~");return[t(o,100),t(r,100),t(a,100)]}}var J=t(5583);function ee(e){let n,t=e[0],o=1;for(;o<e.length;){const r=e[o],a=e[o+1];if(o+=2,("optionalAccess"===r||"optionalCall"===r)&&null==t)return;"access"===r||"optionalAccess"===r?(n=t,t=a(t)):"call"!==r&&"optionalCall"!==r||(t=a(((...e)=>t.call(n,...e))),n=void 0)}return t}function ne(e){return{sdf:H.ex.create(t(3363),t(9794),e),singleColor:H.ex.create(t(1507),t(7080),e)}}const te="C:\\Users\\aval\\tsdev\\workshop\\src\\raymarch\\index.tsx";function oe(e){let n,t=e[0],o=1;for(;o<e.length;){const r=e[o],a=e[o+1];if(o+=2,("optionalAccess"===r||"optionalCall"===r)&&null==t)return;"access"===r||"optionalAccess"===r?(n=t,t=a(t)):"call"!==r&&"optionalCall"!==r||(t=a(((...e)=>t.call(n,...e))),n=void 0)}return t}const re={a:.2,b:.2,c:.2,d:.2,cam:"999.999.999~-56.-58.-61~-44.-44.79"};function ae(e){e.makeCurrent();const n=H.Kj.plane({startX:-1,startY:-1,width:2,height:2});return n.coords=[[-1,-1],[1,-1],[-1,1],[1,1]],n.compile(),{planeMesh:n,shaders:ne(e)}}function ie(e,{shaders:n,planeMesh:t},o,r,a,i,l){e.makeCurrent();const s=o.inversed();n.sdf.uniforms({colorPrimary:r.primary,colorSecondary:r.secondary,colorBg:r.background,highResTimeStamp:i,secs:i/1e3,gradients:1,extra:l,...a,lll:o,llli:s}).draw(t)}const le=(0,f.Z)((e=>({sidebar:{display:"flex",flexDirection:"column",width:256,padding:e.spacing(1),alignItems:"stretch","& > *":{margin:e.spacing(1)}},media:{height:0,paddingTop:"100%"}}))),se=(0,f.Z)((e=>({root:{"&:focused":{border:"2px solid "+e.palette.primary.main}}})));function ce({children:e,label:n,onFocus:t,onBlur:o}){return se(),S.createElement(s.Z,{onFocus:t,onBlur:o,label:n,inputComponent:"textarea",value:e.toString(),__self:this,__source:{fileName:te,lineNumber:257}})}function fe(e){let n=0;function t(e){const n=""+e;return n.includes(".")?n:n+".0"}function o([e,n,o]){return"vec3("+t(e)+", "+t(n)+", "+t(o)+")"}const[r,a,i]=function e(r){let a,i,l;function s(e){a="p"+n++,i="d"+n++,l=`float ${i} = ${e(a)};\n`}for(const c of r)if("sphere"===c.type)s((e=>`sdSphere(${t(c.radius)}, ${e})`));else if("box"===c.type)s((e=>`betterBox(${o(c.radius)}, ${e})`));else if("octahedron"===c.type)s((e=>`sdOctahedron(${t(c.radius)}, ${e})`));else if("donut"===c.type)s((e=>`sdDonut(${t(c.r0)}, ${t(c.r1)}, ${e})`));else if("translate"===c.type){const e=a;a="p"+n++,l=`vec3 ${e} = ${a} + ${o(c.by)};\n`+l}else if("expand"===c.type){const e=i;i="d"+n++,l+=`float ${i} = ${e} - ${t(c.by)};\n`}else if("add"===c.type||"sub"===c.type){const[n,t,o]=e(c.what);l=l+`vec3 ${t} = ${a};\n`+n+`${i} = `+("add"===c.type?`min(${i}, ${o})`:`max(${i}, -${o})`)+";\n"}return[l,a,i]}(e);let l=`RMHit sdf(vec3 ${a}) {\n`;return l+=r,l+=`return RMHit(${i}, black);\n`,l+="}\n",l}function de({value:e,onChange:n}){const t=(0,S.useCallback)((t=>n({...e,radius:+t.target.value},e)),[n]);return S.createElement("div",{__self:this,__source:{fileName:te,lineNumber:387}},"Sphere"," ",S.createElement(u.Z,{value:e.radius,onChange:t,inputProps:{type:"number"},__self:this,__source:{fileName:te,lineNumber:389}}))}function ue({value:e,onChange:n}){const t=(0,S.useCallback)((t=>n({...e,radius:t},e)),[e,n]);return S.createElement("div",{style:{display:"flex"},__self:this,__source:{fileName:te,lineNumber:410}},"Box ",S.createElement(he,{value:e.radius,onChange:t,__self:this,__source:{fileName:te,lineNumber:411}}))}function pe({value:e,onChange:n}){const t=(0,S.useCallback)((t=>n({...e,by:+t.target.value},e)),[e,n]);return S.createElement("div",{style:{display:"flex"},__self:this,__source:{fileName:te,lineNumber:428}},"Expand"," ",S.createElement(u.Z,{value:e.by,onChange:t,type:"number",inputProps:{},__self:this,__source:{fileName:te,lineNumber:430}}))}function he({value:e,onChange:n,gizmoControl:t}){const r=(0,S.useCallback)((t=>{const o=e.slice();o[t.target.name]=+t.target.value,n(o,e)}),[e,n]),a=(0,S.useCallback)((()=>t.take(e,n)),[t,n,e]);return S.createElement(S.Fragment,null,S.createElement(o.Z,{onClick:a,__self:this,__source:{fileName:te,lineNumber:467}},"X"),[0,1,2].map((n=>S.createElement(u.Z,{key:n,name:""+n,value:e[n],onChange:r,inputProps:{type:"number"},__self:this,__source:{fileName:te,lineNumber:469}}))))}function me({value:e,onChange:n,gizmoControl:t}){const o=(0,S.useCallback)((t=>n({...e,by:t},e)),[e,n]);return S.createElement("div",{style:{display:"flex"},__self:this,__source:{fileName:te,lineNumber:495}},"Translate"," ",S.createElement(he,{value:e.by,onChange:o,gizmoControl:t,__self:this,__source:{fileName:te,lineNumber:497}}))}function ve({value:e,onChange:n,gizmoControl:t}){const o=(0,S.useCallback)((t=>n({...e,[t.target.name]:+t.target.value},e)),[e,n]);return S.createElement("div",{style:{display:"flex"},__self:this,__source:{fileName:te,lineNumber:527}},"Donut"," ",["r0","r1"].map((n=>S.createElement(u.Z,{key:n,name:n,value:e[n],onChange:o,inputProps:{type:"number"},__self:this,__source:{fileName:te,lineNumber:530}}))))}function ge({value:e,onChange:n,gizmoControl:t}){const o=(0,S.useCallback)((t=>n({...e,[t.target.name]:+t.target.value},e)),[e,n]);return S.createElement("div",{style:{display:"flex"},__self:this,__source:{fileName:te,lineNumber:562}},"Octahedron"," ",["radius"].map((n=>S.createElement(u.Z,{key:n,name:n,value:e[n],onChange:o,inputProps:{type:"number"},__self:this,__source:{fileName:te,lineNumber:565}}))))}function ye({value:e,onChange:n,gizmoControl:t}){const o=(0,S.useCallback)((t=>n({...e,type:t.target.value},e)),[e,n]),r=(0,S.useCallback)((t=>n({...e,what:t},e)),[e,n]);return S.createElement("div",{style:{display:"flex"},__self:this,__source:{fileName:te,lineNumber:595}},S.createElement(c.Z,{value:e.type,name:"type",onChange:o,__self:this,__source:{fileName:te,lineNumber:596}},S.createElement(l.Z,{value:"add",__self:this,__source:{fileName:te,lineNumber:597}},"Add"),S.createElement(l.Z,{value:"sub",__self:this,__source:{fileName:te,lineNumber:598}},"Sub"))," ",S.createElement(xe,{value:e.what,onChange:r,gizmoControl:t,__self:this,__source:{fileName:te,lineNumber:600}}))}function xe({value:e,onChange:n,gizmoControl:t}){const o=(0,S.useCallback)(((t,o)=>n(e.map((e=>e===o?t:e)))),[n,e]);return S.createElement("div",{__self:this,__source:{fileName:te,lineNumber:624}},e.map(((e,n)=>{const r={sphere:de,expand:pe,add:ye,sub:ye,box:ue,donut:ve,translate:me,octahedron:ge}[e.type];return r&&S.createElement(r,{key:n,value:e,onChange:o,gizmoControl:t,__self:this,__source:{fileName:te,lineNumber:638}})})))}const be=()=>{const e=(0,S.useRef)(null),[n,s]=(0,S.useState)(void 0),[f,u]=(0,S.useState)(E.M4.IDENTITY),[p,h]=(0,S.useState)(512),[m,v]=(0,S.useState)(!1),[g,y]=(0,L.q)(re),x=(0,S.useCallback)((e=>y((n=>({...n,...e})))),[y]),[b,_]=(0,S.useState)(0),[C,w]=(0,S.useState)(0),M=(0,S.useRef)(Object.assign({},g)),R=(0,S.useRef)(),[T,q]=(0,S.useState)([{type:"sphere",radius:1},{type:"translate",by:[1,2,3]},{type:"add",what:[{type:"box",radius:[1,2,3]},{type:"translate",by:[.1,.1,.1]},{type:"expand",by:.3}]},{type:"add",what:[{type:"octahedron",radius:2},{type:"translate",by:[.1,.1,.1]}]},{type:"add",what:[{type:"donut",r0:2,r1:.2},{type:"translate",by:[.1,.1,.1]}]}]),V=le(),B=(0,d.Z)(),I=(0,S.useMemo)((()=>({background:k.iv(B.palette.background.default).gl(),primary:k.iv(B.palette.primary.main).gl(),secondary:k.iv(B.palette.secondary.main).gl()})),[B.palette]),Z=(0,S.useCallback)((async([e,n])=>{const t=URL.createObjectURL(await async function([e,n],t,o,r){ee([r,"optionalCall",e=>e(0)]),await(0,J.Z)(10);const a=document.createElement("canvas");a.width=e,a.height=n;const i=200,l=H.ZG.create({canvas:a});l.enable(l.SCISSOR_TEST);const s=t(l);let c=0;for(let t=0;t<e;t+=i)for(let a=0;a<n;a+=i){const f=Math.min(i,e-t),d=Math.min(i,n-a);l.scissor(t,a,f,d),o(l,s),await(0,J.Z)(0),c+=f*d,ee([r,"optionalCall",t=>t(c/(e*n))])}return new Promise(((e,n)=>a.toBlob((t=>t?e(t):n("error")),"png")))}([e,n],ae,((t,o)=>{ie(t,o,E.M4.product(E.M4.perspective(70,e/n,.1,50),Q.getLookAt(Q.fromShortString(g.cam))),I,g,2e3,f.getTranslation())}),s));s(void 0),(0,P.YQ)(t)}),[f,I,g]);(0,S.useEffect)((()=>{console.log("creating context");const n=H.ZG.create({canvas:e.current,alpha:!0,premultipliedAlpha:!0,throwOnError:!0});return console.log(n.getParameter(n.MAX_SAMPLES)),R.current=function(e,n,o,r,a,i,l,s,c){e.canvas.addEventListener("keydown",(e=>"r"===e.key&&Z([1920,1080])));const f=new Q(i);let d=E.M4.IDENTITY;const u=new j(e,E.M4.rotateZ(20*E.Co).translate(5,5,1),l,(()=>f.pauseCam=!0),(()=>f.pauseCam=!1),s);u.registerListeners(e.canvas,(()=>d)),e.clearColor(...n.background),e.clearColor(0,0,0,1),e.clear(e.COLOR_BUFFER_BIT),e.cullFace(e.BACK),e.pointSize(10),e.disable(e.CULL_FACE),e.disable(e.DEPTH_TEST),e.disable(e.BLEND),e.blendFunc(e.ONE,e.ONE),e.blendEquation(e.FUNC_ADD),e.canvas.contentEditable="true",e.canvas.focus(),f.registerListeners(e.canvas);const p=new K(r),h=ae(e);return{updateShader(e){h.shaders.ed=H.ex.create(t(3363),e)},teardown:e.animate((function(t,r){e.clear(e.COLOR_BUFFER_BIT),e.makeCurrent(),f.tick(),p.tick(t),d=E.M4.product(E.M4.perspective(70,e.canvas.offsetWidth/e.canvas.offsetHeight,.1,50),f.getLookAt()),ie(e,h,d,n,o,t,u.pos.getTranslation()),e.matrixMode(e.PROJECTION),e.loadMatrix(d),e.matrixMode(e.MODELVIEW),e.loadIdentity(),u.render(h.shaders.singleColor)})),setCam:f.setState}}(n,I,M.current,w,0,(0,N.debounce)((e=>{x({cam:Q.toShortString(e)})})),_,u),()=>{oe([R,"access",e=>e.current,"optionalAccess",e=>e.teardown,"call",e=>e()])}}),[]),(0,S.useEffect)((()=>{}),[g.cam]),(0,S.useEffect)((()=>{oe([R,"access",e=>e.current,"optionalAccess",e=>e.updateShader,"call",e=>e(O.replace(/RMHit sdf\(vec3 p\) {.*/,fe(T)))])}),[T]),(0,S.useEffect)((()=>{Object.assign(M.current,g)}),[g]);const D=(0,S.useCallback)((({dim:e,children:t})=>{return S.createElement(o.Z,{variant:"contained",onClick:()=>Z(e),disabled:void 0!==n,__self:void 0,__source:{fileName:te,lineNumber:786}},void 0===n?t:"Rendering... "+(r=""+Math.floor(100*n),z.format(r,"monospace")).padStart(3," ")+"%");var r}),[Z,n]);function W({cam:e}){const n=Y.fromShortString(e);x({cam:Q.toShortString(n)})}return S.createElement(i.Z,{container:!0,style:{height:"99%"},__self:void 0,__source:{fileName:te,lineNumber:810}},S.createElement(i.Z,{item:!0,xs:12,md:9,__self:void 0,__source:{fileName:te,lineNumber:811}},S.createElement("div",{style:{height:"100%"},__self:void 0,__source:{fileName:te,lineNumber:812}},S.createElement("canvas",{ref:e,style:{width:"100%",height:"100%",cursor:0===b?"move":"grab"},width:p,height:p,tabIndex:0,__self:void 0,__source:{fileName:te,lineNumber:813}}))),S.createElement(i.Z,{item:!0,xs:12,md:3,className:V.sidebar,__self:void 0,__source:{fileName:te,lineNumber:826}},S.createElement(r.Z,{__self:void 0,__source:{fileName:te,lineNumber:827}},S.createElement(a.Z,{__self:void 0,__source:{fileName:te,lineNumber:828}},"Raymarching demo.")),S.createElement(c.Z,{onChange:e=>h(+e.target.value),value:p,__self:void 0,__source:{fileName:te,lineNumber:830}},S.createElement(l.Z,{value:256,__self:void 0,__source:{fileName:te,lineNumber:834}},"256x256"),S.createElement(l.Z,{value:512,__self:void 0,__source:{fileName:te,lineNumber:835}},"512x512")),S.createElement(A,{state:g,setStatePartial:x,prop:"a",inputProps:{step:.05},__self:void 0,__source:{fileName:te,lineNumber:837}})," ",S.createElement(A,{state:g,setStatePartial:x,prop:"b",inputProps:{step:.05},__self:void 0,__source:{fileName:te,lineNumber:842}}),S.createElement(A,{state:g,setStatePartial:x,prop:"c",inputProps:{step:.05},__self:void 0,__source:{fileName:te,lineNumber:847}})," ",S.createElement(A,{state:g,setStatePartial:x,prop:"d",inputProps:{step:.05},__self:void 0,__source:{fileName:te,lineNumber:852}}),S.createElement(D,{dim:[1920,1080],__self:void 0,__source:{fileName:te,lineNumber:857}},"render hd"),S.createElement(D,{dim:[3840,2160],__self:void 0,__source:{fileName:te,lineNumber:858}},"render 4k"),S.createElement(o.Z,{color:"secondary",variant:"outlined",onClick:()=>W({cam:"999.999.999~-56.-58.-61~-44.-44.79"}),__self:void 0,__source:{fileName:te,lineNumber:859}},"Cam 0"),S.createElement(o.Z,{color:"secondary",variant:"outlined",onClick:()=>W({cam:"57.427.96~1.-100.-8~7.-7.99"}),__self:void 0,__source:{fileName:te,lineNumber:866}},"Cam 1"),S.createElement(o.Z,{color:"secondary",variant:"outlined",onClick:()=>W({cam:"53.80.892~-9.-8.-100~-18.-99.8"}),__self:void 0,__source:{fileName:te,lineNumber:873}},"Cam 2"),S.createElement("div",{__self:void 0,__source:{fileName:te,lineNumber:880}},"cam: ",g.cam),S.createElement("div",{__self:void 0,__source:{fileName:te,lineNumber:881}},"fps: ",C),S.createElement(ce,{label:"gp",onFocus:()=>setEditing(!0),onBlur:()=>setEditing(!1),__self:void 0,__source:{fileName:te,lineNumber:882}},f),S.createElement("div",{__self:void 0,__source:{fileName:te,lineNumber:889}},S.createElement(xe,{value:T,onChange:q,__self:void 0,__source:{fileName:te,lineNumber:890}})),S.createElement("div",{__self:void 0,__source:{fileName:te,lineNumber:892}},S.createElement("pre",{__self:void 0,__source:{fileName:te,lineNumber:893}},S.createElement("code",{__self:void 0,__source:{fileName:te,lineNumber:894}},fe(T))))))}},260:(e,n,t)=>{t.d(n,{Z:()=>c});var o=t(7692),r=t(9382),a=t(9526),i=(t(2652),t(3060)),l=t(562),s=a.forwardRef((function(e,n){var t=e.classes,l=e.className,s=e.component,c=void 0===s?"div":s,f=(0,r.Z)(e,["classes","className","component"]);return a.createElement(c,(0,o.Z)({className:(0,i.Z)(t.root,l),ref:n},f))}));const c=(0,l.Z)({root:{padding:16,"&:last-child":{paddingBottom:24}}},{name:"MuiCardContent"})(s)},6800:(e,n,t)=>{t.d(n,{Z:()=>f});var o=t(7692),r=t(9382),a=t(9526),i=(t(2652),t(3060)),l=t(1845),s=t(562),c=a.forwardRef((function(e,n){var t=e.classes,s=e.className,c=e.raised,f=void 0!==c&&c,d=(0,r.Z)(e,["classes","className","raised"]);return a.createElement(l.Z,(0,o.Z)({className:(0,i.Z)(t.root,s),elevation:f?8:1,ref:n},d))}));const f=(0,s.Z)({root:{overflow:"hidden"}},{name:"MuiCard"})(c)},2035:e=>{e.exports="#version 300 es\n\nprecision highp float;\n#define GLSLIFY 1\n\nfloat hue2rgb(float f1, float f2, float hue) {\n    if (hue < 0.0)\n        hue += 1.0;\n    else if (hue > 1.0)\n        hue -= 1.0;\n    float res;\n    if ((6.0 * hue) < 1.0)\n        res = f1 + (f2 - f1) * 6.0 * hue;\n    else if ((2.0 * hue) < 1.0)\n        res = f2;\n    else if ((3.0 * hue) < 2.0)\n        res = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;\n    else\n        res = f1;\n    return res;\n}\n\nvec3 hsl2rgb(vec3 hsl) {\n    vec3 rgb;\n    \n    if (hsl.y == 0.0) {\n        rgb = vec3(hsl.z); // Luminance\n    } else {\n        float f2;\n        \n        if (hsl.z < 0.5)\n            f2 = hsl.z * (1.0 + hsl.y);\n        else\n            f2 = hsl.z + hsl.y - hsl.y * hsl.z;\n            \n        float f1 = 2.0 * hsl.z - f2;\n        \n        rgb.r = hue2rgb(f1, f2, hsl.x + (1.0/3.0));\n        rgb.g = hue2rgb(f1, f2, hsl.x);\n        rgb.b = hue2rgb(f1, f2, hsl.x - (1.0/3.0));\n    }   \n    return rgb;\n}\n\nvec3 hsl2rgb(float h, float s, float l) {\n    return hsl2rgb(vec3(h, s, l));\n}\n\nfloat banded(float bandCount, float t) {\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\n}\nfloat banded(int bandCount, float t) {\n  return banded(float(bandCount), t);\n}\n\nbool between(float min, float max, float value) {\n    return min <= value && value <= max;\n}\n\nvec2 hex2Ra(vec3 hex) {\n    float y = hex.t * 0.866;\n    float x = hex.s + hex.t / 2.0;\n    return vec2(x, y);\n}\n\nvec3 hexRound(vec3 hex) {\n    vec3 r = floor(hex + 0.5);\n    vec3 diff = abs(r - hex);\n\n    if (diff.x > diff.y && diff.x > diff.z) {\n        r.x = -(r.y + r.z);\n    } else if (diff.y > diff.z) {\n        r.y = -(r.x + r.z);\n    } else {\n        r.z = -(r.x + r.y);\n    }\n\n    return r;\n}\n\nfloat max3(float a, float b, float c) {\n  return max(a, max(b, c));\n}\nfloat max3(vec3 v) {\n  return max(v.x, max(v.y, v.z));\n}\n\nfloat hexSdf(vec3 hex) {\n    return max3(abs(hex.yzx + hex.zxy / 2.0));\n}\n\nuniform sampler2D gradients;\n\nfloat dotGridGradient(vec2 cell, vec2 pos) {\n    vec2 d = cell - pos;\n\n    vec2 gradient = texelFetch(gradients, ivec2(cell), 0).xy;\n    return dot(gradient, d);\n}\n\nfloat mixx(float a, float b, float t) {\n     return mix(a, b, smoothstep(0.0, 1.0, t));\n//    return mix(a, b, t);\n}\n\n// resulting range is [-0.68, 0.68]. Use unmix to normalize if necessary.\nfloat perlin2D(vec2 xy) {\n    float x0 = floor(xy.x);\n    float x1 = x0 + 1.0;\n    float y0 = floor(xy.y);\n    float y1 = y0 + 1.0;\n\n    // Interpolate between grid point gradients\n    float n00 = dotGridGradient(vec2(x0, y0), xy);\n    float n10 = dotGridGradient(vec2(x1, y0), xy);\n    float ny0 = mixx(n00, n10, xy.x - x0);\n\n    float n01 = dotGridGradient(vec2(x0, y1), xy);\n    float n11 = dotGridGradient(vec2(x1, y1), xy);\n    float ny1 = mixx(n01, n11, xy.x - x0);\n\n    return mixx(ny0, ny1, xy.y - y0);\n}\n\nfloat unmix(float a, float b, float value) {\n  return (value - a) / (b - a);\n}\n\nvec3 fromPolar(float radius, float phi, float z) {\n  return vec3(radius * cos(phi), radius * sin(phi), z);\n}\n\nvec2 fromPolar(float radius, float phi) {\n  return vec2(radius * cos(phi), radius * sin(phi));\n}\n\nvec2 fromPolar(vec2 polar) {\n  return fromPolar(polar.x, polar.y);\n}\n\nvec2 toPolar(vec2 xy) {\n    return vec2(length(xy), atan(xy.y, xy.x));\n}\n\nvec3 raToHex(vec2 xy) {\n    float hex_t = xy.y / 0.866;\n    float hex_s = xy.x - hex_t / 2.0;\n    return vec3(hex_s, hex_t, -(hex_s + hex_t));\n}\n\nfloat remix(float fromA, float fromB, float toA, float toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\nvec4 remix(float fromA, float fromB, vec4 toA, vec4 toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\nconst vec4 blue_0 = vec4(0.0, 0.0, 1.0, 1.0);\nconst vec4 red_0 = vec4(1.0, 0.0, 0.0, 1.0);\n\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\n  float isLow = float(t < 0.0);\n  float isHigh = float(t > 1.0);\n  float isMid = 1.0 - isLow - isHigh;\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\n}\n\nvec4 visualize(float t) {\n  return visualize(blue_0, red_0, t);\n}\n\nuniform float highResTimeStamp_0;\n\nfloat waves(vec4 color, vec2 position, vec2 direction) {\n    return sin(dot(position, direction / pow(length(direction), 2.0)) + float(highResTimeStamp_0) / 200.0);\n}\n\nmat3 rotX(float angle) {\n    float c = cos(angle), s = sin(angle);\n    return mat3(\n    1., 0., 0.,\n    0., c, -s,\n    0., s, c);\n}\n\nmat3 rotY(float angle) {\n    float c = cos(angle), s = sin(angle);\n    return mat3(\n    c,  0., s,\n    0., 1., 0.,\n    -s,  0.,  c);\n}\n\nmat3 rotZ(float angle) {\n    float c = cos(angle), s = sin(angle);\n    return mat3(\n    c,  -s, 0.,\n    s, c, 0.,\n    0.,  0.,  1.);\n}\n\nfloat sdDonut(float r0, float r1, vec3 p) {\n    vec3 closestCenter = vec3(normalize(p.xy) * r0, 0.0);\n    return distance(closestCenter, p) - r1;\n}\n\nfloat sdCapsule(vec3 a, vec3 b, float r, vec3 p) {\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\nvec3 opElongate(vec3 h, vec3 p) {\n    return p - clamp(p, -h, h);\n}\n\nfloat sdSphere(float radius, vec3 p) {\n    return length(p) - radius;\n}\n\nfloat sdCylinder(float radius, float height, vec3 p ) {\n    vec2 d = vec2(length(p.xy), abs(p.z)) - vec2(radius, height);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nconst float SQRT1_2_1921068617 = 0.7071067811865476;\n\nfloat addChamfer(float d, float a, float b) {\n    float tillet = ((a + b) - d) * SQRT1_2_1921068617;\n    return min(tillet, min(a, b));\n}\n\nfloat addTillet(float r, float a, float b) {\n    if (a < r && b < r) {\n        return r - distance(vec2(a, b), vec2(r));\n    } else {\n        return min(a ,b);\n    }\n}\n\nfloat sdBox(vec3 r, vec3 p) {\n    vec3 q = abs(p) - r;\n    return length(max(q, 0.0)) + min(max3(q), 0.0);\n}\n\nfloat sdBox(vec3 r, float r2, vec3 p) {\n    return sdBox(r - r2, p) - r2;\n}\n\nfloat sdOctahedron(float s, vec3 p) {\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n    vec3 q;\n    if (3.0 * p.x < m) q = p.xyz;\n    else if (3.0 * p.y < m) q = p.yzx;\n    else if (3.0 * p.z < m) q = p.zxy;\n    else return m * 0.57735027;\n\n    float k = clamp(0.5 * (q.z - q.y + s), 0.0, s);\n    return length(vec3(q.x, q.y - s + k, q.z - k));\n}\n\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n\n    float m = p.x + p.y + p.z - s;\n    //find point on octohedron surf nearest to p\n    vec3 projPoint = p - vec3(0.333333*m);\t\t//project onto surface plane\n    //now push projected point, if outside triangle edge, perpendicular to edge, to edge\n    vec3 toMove = min(projPoint,0.0);\t\t\t//if projpoint.x<0 move along (1.0,-0.5,-0.5) , etc\n    float toMoveSum = dot(toMove, vec3(1.0));\t//which is basically along (1.5,0,0) then vec3(-0.5)\n\n    vec3 movedPoint = projPoint + toMove*vec3(-1.5) + toMoveSum*vec3(0.5);\t//better to multiply toMove by a matrix (1s diagonal, 0.5 other)?\n\n    movedPoint = max(movedPoint, 0.0);\t\t\t//cap x,y,z to 0 then\n    movedPoint*= s/dot(movedPoint,vec3(1.0));\t//scale about 0,0,0\n\n    return length(p-movedPoint);\n}\nfloat add(float a, float b) {\n    return min(a, b);\n}\n\nfloat sub(float from, float what) {\n    return max(from, -what);\n}\n\nuniform sampler2D texture;\nuniform float secs;\nuniform mat4 lll;\nuniform mat4 llli;\nuniform vec4 colorPrimary;\nuniform vec4 colorSecondary;\nuniform vec4 colorBg;\nuniform float a;\nuniform float b;\nuniform float c;\nuniform float d;\nuniform float highResTimeStamp;\nuniform int bandCount;\nuniform vec3 extra;\nuniform vec3 campos;\nin float n;\nin vec2 coord;\nout vec4 fragColor;\n\nconst float TAU = 6.283185307179586;\nconst float SQRT1_2 = 0.7071067811865476;\nconst float SQRT2 = 1.4142135623730951;\nconst float PI = 3.141592653589793;\n\nconst vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\nconst vec4 yellow = vec4(1.0, 1.0, 0.0, 1.0);\nconst vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\nconst vec4 blue = vec4(0.0, 0.0, 1.0, 1.0);\nconst vec4 purple = vec4(0.5, 0.0, 0.5, 1.0);\nconst vec4 red = vec4(1.0, 0.0, 0.0, 1.0);\n\nstruct RMHit {\n    float distance;\n    vec4 color;\n};\nRMHit mixa(RMHit a, RMHit b, float t) {\n    return RMHit(mix(a.distance, b.distance, t), mix(a.color, b.color, t));\n}\nfloat skybox(vec3 p) {\n    return 32. - max3(abs(p));\n}\n\nfloat perlinSphere(float radius, vec3 p) {\n    vec3 cp = normalize(p);\n    float alpha = atan(cp.y, cp.x);\n    float beta = asin(cp.z);\n    return length(p) - radius + 0.1 * perlin2D(vec2(0. / 100., 0.) + (vec2(5.)+vec2(alpha, beta))*8.0);\n}\n\nfloat cylCircle(vec3 p) {\n    float d = 10e9;\n    for (int i = 0; i < 10; i++) {\n        d = min(d, sdCylinder(0.2, 2., p + fromPolar(3., TAU * float(i) / 10., 1.)));\n    }\n\n    return d;\n}\n\nfloat rblock(float r, out vec3 p) {\n    return sdBox(vec3(r), p);\n}\n\nRMHit add(RMHit a, RMHit b) {\n//    return a.distance < b.distance\n//        ? RMHit(a.distance, a.color)\n//        : RMHit(b.distance, b.color);\n    return mixa(a, b, float(b.distance < a.distance));\n}\n\nfloat wtf(vec3 p) {\n    vec3 center = p - mod(p, 3.0) + vec3(1.5);\n    return rblock(.4 + .3 * sin(secs+ center.x), center);\n}\n\nRMHit addTillet(float r, RMHit a, RMHit b) {\n    if (a.distance < r && b.distance < r) {\n        return RMHit(\n            r - distance(vec2(a.distance, b.distance), vec2(r)),\n            mix(a.color, b.color, (a.distance - b.distance) / r * 0.5 + 0.5));\n    } else {\n        return add(a, b);\n    }\n}\n\nRMHit addTillet(float r, RMHit a, RMHit b, vec4 tilletColor) {\n    if (a.distance < r && b.distance < r) {\n        return RMHit(\n        r - distance(vec2(a.distance, b.distance), vec2(r)),\n        tilletColor);\n    } else {\n        return add(a, b);\n    }\n}\nRMHit addTillet2(float r, RMHit a, RMHit b) {\n    float h = smoothstep(-r, r, a.distance - b.distance);\n    return RMHit(\n        mix(a.distance, b.distance, h) - r * h * (1. - h),\n        mix(a.color, b.color, h));\n}\n\nRMHit neg(RMHit a) {\n    return RMHit(-a.distance, a.color);\n}\nRMHit sub(RMHit from, RMHit what) {\n    RMHit whatNeg = neg(what);\n    return mixa(from, whatNeg, float(whatNeg.distance > from.distance));\n}\n\nvec3 modv(vec3 v, vec3 dir1, float y) {\n    float t = dot(v, dir1);\n    return v - floor(t/y)*y * dir1;\n}\nvec3 modRotZ(vec3 p, float count) {\n    vec2 polarXY = toPolar(p.xy);\n    return fromPolar(polarXY.x, mod(polarXY.y, TAU / count), p.z);\n}\n\nfloat sin01(float x) {\n    return 0.5 + 0.50 * sin(x);\n}\nfloat cos01(float x) {\n    return 0.5 + 0.50 * cos(x);\n}\n\nfloat betterBox(vec3 r, vec3 p) {\n    vec3 q = abs(p) - r;\n    return length(max(q, 0.0)) + min(max3(q), 0.0);\n    p = abs(p);\n    return max3(p - r);\n}\n\nfloat sdConeB(vec2 c, float h, vec3 p) {\n    float q = length(p.xz);\n    return max(dot(c.xy, vec2(q, p.y)), -h-p.y);\n}\n\nfloat sdCone(vec2 c, float h, vec3 p) {\n    vec2 q = h * vec2(c.x / c.y, -1.0);\n    vec2 w = vec2(length(p.xz), p.y);\n    vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);\n    vec2 b = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0);\n    float k = sign(q.y);\n    float d = min(dot(a, a), dot(b, b));\n    float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));\n    return sqrt(d) * sign(s);\n}\n\nfloat sdEllipsoidB(vec3 r, vec3 p) {\n    float k0 = length(p / r);\n    float k1 = length(p / (r * r));\n    return k0 * (k0 - 1.0) / k1;\n}\nfloat sdOctahedronB(float s, vec3 p) {\n    p = abs(p);\n    return (p.x + p.y + p.z - s) * 0.57735027;\n}\nfloat donutc(float r0, float r1, vec3 p) {\n    vec3 closestCenter = vec3(normalize(p.xy) * r0, 0.0);\n    return distance(closestCenter, p) - r1;\n}\n\nfloat smoothmin(float r, float a, in float b) {\n    float h = smoothstep(-r, r, a - b);\n    return mix(a, b, h) - r * h * (1. - h);\n}\n\nRMHit sdf(vec3 p) { return RMHit(0.0, black); }\n\nfloat sdff(vec3 p) {\n    return sdf(p).distance;\n}\n\nstruct RMResult {\n    float distance;\n    vec3 pos;\n    vec4 color;\n};\nRMResult raymarching2(vec3 start, vec3 dir1) {\n    vec3 pos = start;\n    RMHit hit;\n    for (int i = 0; i < 200; i++) {\n        hit = sdf(pos);\n        if (hit.distance < 0.0001) break;\n        pos = pos + dir1 * hit.distance;\n    }\n    return RMResult(hit.distance, pos, hit.color);\n}\nvec3 pt(mat4 pm, vec3 p) {\n    vec4 pStar = pm * vec4(p, 1.0);\n    return pStar.xyz / pStar.w;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float t = 0.1;\n    for (int i = 0; i < 1000 && t < maxt; i++) {\n        float h = sdff(ro + rd*t);\n        if( h<0.001 )\n        return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\nconst float eps = 1e-4;\nvec3 sdfNormal1(vec3 p, float d) {\n    return normalize(vec3(\n        sdff(p + vec3(eps, 0., 0.)),\n        sdff(p + vec3(0., eps, 0.)),\n        sdff(p + vec3(0., 0., eps))\n    ) - sdff(p));\n}\n\nfloat ambientOcclusion(vec3 pWC, vec3 n1WC) {\n    float k = 1.0;\n    float distance = sdff(pWC + n1WC * k);\n    return clamp(distance / k, 0.0, 1.0);\n}\n\n//layout (depth_greater) out float gl_FragDepth;\nvoid main() {\n    vec3 light = normalize(vec3(-1., -2., -2));\n\n    vec3 a = vec3(coord, -1.);\n    vec3 b = vec3(coord, 1.);\n    vec3 aWC = pt(llli, a);\n    vec3 bWC = pt(llli, b);\n    vec3 lookDir1 = normalize(bWC - aWC);\n\n    RMResult hitWC = raymarching2(aWC, lookDir1);\n    vec3 hitn1 = sdfNormal1(hitWC.pos, hitWC.distance);\n    float dWC = distance(aWC, hitWC.pos);\n    vec3 hitNDC = pt(lll, hitWC.pos);\n\n    vec3 sunPoint = raymarching2(hitWC.pos +hitn1 *.1, -light).pos;\n//    float inSun = float(distance(hitWC.pos, sunPoint) > 30.);\n    float inSun = softshadow(hitWC.pos+hitn1 *0.05, -light, 0.0001, 300.0, 8.);\n//    float inSun=1.;\n\n    vec3 material = vec3(0.0, 0.2, 0.0);\n    if (dWC > 100.) {\n        material = vec3(0.0, 0.0, 0.0);\n    }\n\n    const vec3 sunlightColor = vec3(8., 6., 1.);\n\n    float aOcc = ambientOcclusion(hitWC.pos, hitn1);\n\n    vec3 reflectionDirection = reflect(light, hitn1);\n\n    vec3 color = vec3(0.0);\n    color += material * aOcc;\n    color += inSun * sunlightColor * material * max(0.0, dot(-light, hitn1));\n//    color = (hitn1);\n\n    vec3 camPos = aWC;\n\n    vec3 eyeDirection = -lookDir1;\n    float uMaterialShininess = 256.0;\n    float specularLightWeighting =\n        pow(max(dot(reflectionDirection, eyeDirection), 0.0), uMaterialShininess);\n    color += specularLightWeighting;\n//    float lightIntensity = 0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.);\n//    float lightIntensity =\n//        0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.) + 0.3*specularLightWeighting;\n//    fragColor = visualize(blue, red, mix(0.5, 1.0, inSun) * lightIntensity);\n//    fragColor = mix(hitWC.color, colorBg, mix(0.5, 1.0, inSun) * clamp(lightIntensity, 0., 1.));\n    color = pow( color, vec3(1.0/2.2) ); // gamma correction\n    fragColor = vec4(color, 1.0);\n//    fragColor = visualize(hitWC.pos.x/10.);\n//    fragColor = hitWC.color;\n//    fragColor = visualize(blue, red, distance(hitWC, sunPoint)/20.);\n//    fragColor = vec4(coord,0.,1.);\n//    fragColor = vec4(aWC, 1.0);\n    // remap [-1, 1] to [0, 1]\n   // gl_FragDepth = hitNDC.z * 0.5 + 0.5;\n//    gl_FragDepth = .9999999;\n}"},3363:e=>{e.exports="#version 300 es\nprecision highp float;\n#define GLSLIFY 1\n\nin vec4 ts_Vertex;\nin vec2 ts_TexCoord;\nout vec2 coord;\nvoid main() {\n    gl_Position = ts_Vertex;\n    coord = ts_TexCoord;\n}"},9794:e=>{e.exports="#version 300 es\n\nprecision highp float;\n#define GLSLIFY 1\n\nfloat hue2rgb(float f1, float f2, float hue) {\n    if (hue < 0.0)\n        hue += 1.0;\n    else if (hue > 1.0)\n        hue -= 1.0;\n    float res;\n    if ((6.0 * hue) < 1.0)\n        res = f1 + (f2 - f1) * 6.0 * hue;\n    else if ((2.0 * hue) < 1.0)\n        res = f2;\n    else if ((3.0 * hue) < 2.0)\n        res = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;\n    else\n        res = f1;\n    return res;\n}\n\nvec3 hsl2rgb(vec3 hsl) {\n    vec3 rgb;\n    \n    if (hsl.y == 0.0) {\n        rgb = vec3(hsl.z); // Luminance\n    } else {\n        float f2;\n        \n        if (hsl.z < 0.5)\n            f2 = hsl.z * (1.0 + hsl.y);\n        else\n            f2 = hsl.z + hsl.y - hsl.y * hsl.z;\n            \n        float f1 = 2.0 * hsl.z - f2;\n        \n        rgb.r = hue2rgb(f1, f2, hsl.x + (1.0/3.0));\n        rgb.g = hue2rgb(f1, f2, hsl.x);\n        rgb.b = hue2rgb(f1, f2, hsl.x - (1.0/3.0));\n    }   \n    return rgb;\n}\n\nvec3 hsl2rgb(float h, float s, float l) {\n    return hsl2rgb(vec3(h, s, l));\n}\n\nfloat banded(float bandCount, float t) {\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\n}\nfloat banded(int bandCount, float t) {\n  return banded(float(bandCount), t);\n}\n\nbool between(float min, float max, float value) {\n    return min <= value && value <= max;\n}\n\nfloat unmix(float a, float b, float value) {\n  return (value - a) / (b - a);\n}\n\nvec3 fromPolar(float radius, float phi, float z) {\n  return vec3(radius * cos(phi), radius * sin(phi), z);\n}\n\nvec2 fromPolar(float radius, float phi) {\n  return vec2(radius * cos(phi), radius * sin(phi));\n}\n\nvec2 fromPolar(vec2 polar) {\n  return fromPolar(polar.x, polar.y);\n}\n\nvec2 hex2Ra(vec3 hex) {\n    float y = hex.t * 0.866;\n    float x = hex.s + hex.t / 2.0;\n    return vec2(x, y);\n}\n\nvec3 hexRound(vec3 hex) {\n    vec3 r = floor(hex + 0.5);\n    vec3 diff = abs(r - hex);\n\n    if (diff.x > diff.y && diff.x > diff.z) {\n        r.x = -(r.y + r.z);\n    } else if (diff.y > diff.z) {\n        r.y = -(r.x + r.z);\n    } else {\n        r.z = -(r.x + r.y);\n    }\n\n    return r;\n}\n\nfloat max3(float a, float b, float c) {\n  return max(a, max(b, c));\n}\nfloat max3(vec3 v) {\n  return max(v.x, max(v.y, v.z));\n}\n\nfloat hexSdf(vec3 hex) {\n    return max3(abs(hex.yzx + hex.zxy / 2.0));\n}\n\nuniform sampler2D gradients;\n\nfloat dotGridGradient(vec2 cell, vec2 pos) {\n    vec2 d = cell - pos;\n\n    vec2 gradient = texelFetch(gradients, ivec2(cell), 0).xy;\n    return dot(gradient, d);\n}\n\nfloat mixx(float a, float b, float t) {\n     return mix(a, b, smoothstep(0.0, 1.0, t));\n//    return mix(a, b, t);\n}\n\n// resulting range is [-0.68, 0.68]. Use unmix to normalize if necessary.\nfloat perlin2D(vec2 xy) {\n    float x0 = floor(xy.x);\n    float x1 = x0 + 1.0;\n    float y0 = floor(xy.y);\n    float y1 = y0 + 1.0;\n\n    // Interpolate between grid point gradients\n    float n00 = dotGridGradient(vec2(x0, y0), xy);\n    float n10 = dotGridGradient(vec2(x1, y0), xy);\n    float ny0 = mixx(n00, n10, xy.x - x0);\n\n    float n01 = dotGridGradient(vec2(x0, y1), xy);\n    float n11 = dotGridGradient(vec2(x1, y1), xy);\n    float ny1 = mixx(n01, n11, xy.x - x0);\n\n    return mixx(ny0, ny1, xy.y - y0);\n}\n\nvec3 raToHex(vec2 xy) {\n    float hex_t = xy.y / 0.866;\n    float hex_s = xy.x - hex_t / 2.0;\n    return vec3(hex_s, hex_t, -(hex_s + hex_t));\n}\n\nfloat remix(float fromA, float fromB, float toA, float toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\nvec4 remix(float fromA, float fromB, vec4 toA, vec4 toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\nmat3 rotX(float angle) {\n    float c = cos(angle), s = sin(angle);\n    return mat3(\n    1., 0., 0.,\n    0., c, -s,\n    0., s, c);\n}\n\nmat3 rotY(float angle) {\n    float c = cos(angle), s = sin(angle);\n    return mat3(\n    c,  0., s,\n    0., 1., 0.,\n    -s,  0.,  c);\n}\n\nmat3 rotZ(float angle) {\n    float c = cos(angle), s = sin(angle);\n    return mat3(\n    c,  -s, 0.,\n    s, c, 0.,\n    0.,  0.,  1.);\n}\n\nvec2 toPolar(vec2 xy) {\n    return vec2(length(xy), atan(xy.y, xy.x));\n}\n\nconst vec4 blue_0 = vec4(0.0, 0.0, 1.0, 1.0);\nconst vec4 red_0 = vec4(1.0, 0.0, 0.0, 1.0);\n\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\n  float isLow = float(t < 0.0);\n  float isHigh = float(t > 1.0);\n  float isMid = 1.0 - isLow - isHigh;\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\n}\n\nvec4 visualize(float t) {\n  return visualize(blue_0, red_0, t);\n}\n\nuniform float highResTimeStamp_0;\n\nfloat waves(vec4 color, vec2 position, vec2 direction) {\n    return sin(dot(position, direction / pow(length(direction), 2.0)) + float(highResTimeStamp_0) / 200.0);\n}\n\nfloat add(float a, float b) {\n    return min(a, b);\n}\n\nconst float SQRT1_2_2197045468 = 0.7071067811865476;\n\nfloat addChamfer(float d, float a, float b) {\n    float tillet = ((a + b) - d) * SQRT1_2_2197045468;\n    return min(tillet, min(a, b));\n}\n\nfloat addTillet(float r, float a, float b) {\n    if (a < r && b < r) {\n        return r - distance(vec2(a, b), vec2(r));\n    } else {\n        return min(a ,b);\n    }\n}\n\nvec3 opElongate(vec3 h, vec3 p) {\n    return p - clamp(p, -h, h);\n}\n\nvec3 opRepLim(vec3 p, vec3 cellSize, vec3 limit) {\n    return p - cellSize * clamp(round(p / cellSize), vec3(0.0), limit);\n}\nvec2 opRepLim(vec2 p, vec2 cellSize, vec2 limit) {\n    return p - cellSize * clamp(round(p / cellSize), vec2(0.0), limit);\n}\nfloat opRepLim(float p, float cellSize, float limit) {\n    return p - cellSize * clamp(round(p / cellSize), 0.0, limit);\n}\n\nfloat sdBox(vec3 r, vec3 p) {\n    vec3 q = abs(p) - r;\n    return length(max(q, 0.0)) + min(max3(q), 0.0);\n}\n\nfloat sdBox(vec3 r, float r2, vec3 p) {\n    return sdBox(r - r2, p) - r2;\n}\n\nfloat sdCylinder(float radius, float height, vec3 p ) {\n    vec2 d = vec2(length(p.xy), abs(p.z)) - vec2(radius, height);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdDonut(float r0, float r1, vec3 p) {\n    vec3 closestCenter = vec3(normalize(p.xy) * r0, 0.0);\n    return distance(closestCenter, p) - r1;\n}\n\nconst float GOLDEN_RATIO_2645608689 = 1.61803398875;\n// NN = 1/GOLDEN_RATIO = GOLDEN_RATIO - 1\nconst float K = GOLDEN_RATIO_2645608689 * 0.5;\n// the three vertices of the icosahedron triangle which\n// is fully inside the +++ octant. (edge length = 1)\nconst vec3 a_0 = vec3(0.5, K, 0.0);\nconst vec3 b_0 = vec3(0.0, 0.5, K);\nconst vec3 c_0 = vec3(K, 0.0, 0.5);\nconst vec3 ab1 = b_0 - a_0; // values chosen so edge length is 1\nconst vec3 n1 = normalize(cross(a_0, b_0));\nconst vec3 n2 = normalize(cross(b_0, c_0));\nconst vec3 n3 = normalize(cross(c_0, a_0));\nconst vec3 xyz1 = normalize(vec3(1.0));\n// for edge-length 1\nconst float INSCRIBED_SPHERE_RADIUS_2645608689 = 0.7557613141;\n\n// signed distance function for icosahedron\n// cf. https://en.wikipedia.org/wiki/Regular_icosahedron\n// s: edge length\n// p: point to evaluate function for\nfloat sdIcosahedron(float s, vec3 p) {\n    // we use a rotation where the icosahedron is symmetric\n    // in all three coordinate planes, and reduce the problem\n    // to the +++ octant\n    p = abs(p);\n\n    // there is one complete triangle in the +++ octant\n    // mirror on planes which go through origin and the\n    // complete triangles sides.\n    if (dot(p, n1) < 0.0) {\n        p += -2.0 * dot(p, n1) * n1;\n    }\n    if (dot(p, n2) < 0.0) {\n        p += -2.0 * dot(p, n2) * n2;\n    }\n    if (dot(p, n3) < 0.0) {\n        p += -2.0 * dot(p, n3) * n3;\n    }\n\n    // rotate space around (1,1,1) vector so that all sides of the triangle\n    // end up mapped on the ab side.\n    vec3 dirs = vec3(-dot(n1, p), -dot(n2, p), -dot(n3, p));\n    if (dirs.y > dirs.x && dirs.y > dirs.z) {\n        p = p.yzx;\n    } else if (dirs.z > dirs.x && dirs.z > dirs.y) {\n        p = p.zxy;\n    }\n\n    // check if the point is directly (perpendicular) above the triangle.\n    // as we have rotated the space, we only need to check if it is\n    // inside one edge.\n    vec3 midAB = (a_0 + b_0) / 2.0;\n    vec3 pn = normalize(c_0 - midAB);\n    float w = dot(midAB, pn);\n    if (dot(p, pn) > w * s) {\n        // if not, return the distance to the plane the triangle is in\n        return dot(xyz1, p) - INSCRIBED_SPHERE_RADIUS_2645608689 * s;\n    }\n\n    // project the point onto segment ab, and return the distance to it\n    float d3 = dot(ab1, p);\n    d3 = clamp(d3, -0.5 * s, 0.5 * s);\n    vec3 closestp = midAB * s + d3 * ab1;\n    return distance(closestp, p);\n}\n\nfloat sdOctahedron(float s, vec3 p) {\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n    vec3 q;\n    if (3.0 * p.x < m) q = p.xyz;\n    else if (3.0 * p.y < m) q = p.yzx;\n    else if (3.0 * p.z < m) q = p.zxy;\n    else return m * 0.57735027;\n\n    float k = clamp(0.5 * (q.z - q.y + s), 0.0, s);\n    return length(vec3(q.x, q.y - s + k, q.z - k));\n}\n\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n\n    float m = p.x + p.y + p.z - s;\n    //find point on octohedron surf nearest to p\n    vec3 projPoint = p - vec3(0.333333*m);\t\t//project onto surface plane\n    //now push projected point, if outside triangle edge, perpendicular to edge, to edge\n    vec3 toMove = min(projPoint,0.0);\t\t\t//if projpoint.x<0 move along (1.0,-0.5,-0.5) , etc\n    float toMoveSum = dot(toMove, vec3(1.0));\t//which is basically along (1.5,0,0) then vec3(-0.5)\n\n    vec3 movedPoint = projPoint + toMove*vec3(-1.5) + toMoveSum*vec3(0.5);\t//better to multiply toMove by a matrix (1s diagonal, 0.5 other)?\n\n    movedPoint = max(movedPoint, 0.0);\t\t\t//cap x,y,z to 0 then\n    movedPoint*= s/dot(movedPoint,vec3(1.0));\t//scale about 0,0,0\n\n    return length(p-movedPoint);\n}\n// Pyramid with tip at (0,0,0), up = z\n// c is the bottom corner. c.xy should be positive, c.z negative.\nvec2 sdPyramid(vec3 c, vec3 p) {\n    // pyramid is symmetric in XZ and YZ planes\n    p.xy = abs(p.xy);\n    bool flip = p.y*c.x > p.x*c.y; // p.y/p.x > c.y/c.x\n    c.xy = flip ? c.yx : c.xy;\n    p.xy = flip ? p.yx : p.xy;\n    vec3 cc = c / dot(c, c);\n    vec3 qx1 = normalize(vec3(-c.z, 0.0, c.x));\n    vec3 pOnQx  = p - qx1 * dot(p, qx1);\n    float dx = dot(p, qx1);\n    float maxY = c.y * (pOnQx.x / c.x);\n    if (p.z <= c.z || pOnQx.z <= c.z) {\n        if (p.x <= c.x) {\n            // vertically underneath pyramid\n            return vec2(-p.z + c.z, 2.0);\n        } else {\n            float aa = distance(p, vec3(c.x, min(c.y, p.y), c.z));\n            return vec2(aa, 3.0);\n        }\n    } else\n    if (pOnQx.y > maxY || pOnQx.z > 0.0) {\n        float xx = dot(cc, p);\n        float aa= length(p - clamp(xx, 0.0, 1.0) * c);\n\n        return vec2(aa, 1.0);\n    } else {\n        // need max for negativ values above base\n        return vec2(max(dx,-p.z + c.z), 0.0);\n    }\n}\n\nfloat sdSphere(float radius, vec3 p) {\n    return length(p) - radius;\n}\n\nfloat sub(float from, float what) {\n    return max(from, -what);\n}\n\nuniform sampler2D texture;\nuniform float secs;\nuniform mat4 lll;\nuniform mat4 llli;\nuniform vec4 colorPrimary;\nuniform vec4 colorSecondary;\nuniform vec4 colorBg;\nuniform float a;\nuniform float b;\nuniform float c;\nuniform float d;\nuniform float highResTimeStamp;\nuniform int bandCount;\nuniform vec3 extra;\nuniform vec3 campos;\nin float n;\nin vec2 coord;\nout vec4 fragColor;\n\nconst float TAU = 6.283185307179586;\nconst float SQRT1_2 = 0.7071067811865476;\nconst float SQRT2 = 1.4142135623730951;\nconst float PI = 3.141592653589793;\n\nconst vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\nconst vec4 yellow = vec4(1.0, 1.0, 0.0, 1.0);\nconst vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\nconst vec4 blue = vec4(0.0, 0.0, 1.0, 1.0);\nconst vec4 purple = vec4(0.5, 0.0, 0.5, 1.0);\nconst vec4 red = vec4(1.0, 0.0, 0.0, 1.0);\n\nstruct RMHit {\n    float distance;\n    vec4 color;\n};\nRMHit mixa(RMHit a, RMHit b, float t) {\n    return RMHit(mix(a.distance, b.distance, t), mix(a.color, b.color, t));\n}\nfloat skybox(vec3 p) {\n    return 32. - max3(abs(p));\n}\n\nfloat perlinSphere(float radius, vec3 p) {\n    vec3 cp = normalize(p);\n    float alpha = atan(cp.y, cp.x);\n    float beta = asin(cp.z);\n    return length(p) - radius + 0.1 * perlin2D(vec2(0. / 100., 0.) + (vec2(5.)+vec2(alpha, beta))*8.0);\n}\n\nfloat cylCircle(vec3 p) {\n    float d = 10e9;\n    for (int i = 0; i < 10; i++) {\n        d = min(d, sdCylinder(0.2, 2., p + fromPolar(3., TAU * float(i) / 10., 1.)));\n    }\n\n    return d;\n}\n\nfloat rblock(float r, vec3 p) {\n    return sdBox(vec3(r), p);\n}\n\nRMHit add(RMHit a, RMHit b) {\n    //    return a.distance < b.distance\n    //        ? RMHit(a.distance, a.color)\n    //        : RMHit(b.distance, b.color);\n    return mixa(a, b, float(b.distance < a.distance));\n}\n\nfloat wtf(vec3 p) {\n    vec3 center = p - mod(p, 3.0) + vec3(1.5);\n    return rblock(.4 + .3 * sin(secs+ center.x), p - center);\n}\n\nRMHit addTillet(float r, RMHit a, RMHit b) {\n    if (a.distance < r && b.distance < r) {\n        return RMHit(\n            r - distance(vec2(a.distance, b.distance), vec2(r)),\n            mix(a.color, b.color, (a.distance - b.distance) / r * 0.5 + 0.5));\n    } else {\n        return add(a, b);\n    }\n}\n\nRMHit addTillet(float r, RMHit a, RMHit b, vec4 tilletColor) {\n    if (a.distance < r && b.distance < r) {\n        return RMHit(\n        r - distance(vec2(a.distance, b.distance), vec2(r)),\n        tilletColor);\n    } else {\n        return add(a, b);\n    }\n}\nRMHit addTillet2(float r, RMHit a, RMHit b) {\n    float h = smoothstep(-r, r, a.distance - b.distance);\n    return RMHit(\n    mix(a.distance, b.distance, h) - r * h * (1. - h),\n    mix(a.color, b.color, h));\n}\n\nRMHit neg(RMHit a) {\n    return RMHit(-a.distance, a.color);\n}\nRMHit sub(RMHit from, RMHit what) {\n    RMHit whatNeg = neg(what);\n    return mixa(from, whatNeg, float(whatNeg.distance > from.distance));\n}\n\nvec3 modv(vec3 v, vec3 dir1, float y) {\n    float t = dot(v, dir1);\n    return v - floor(t/y)*y * dir1;\n}\nvec3 modRotZ(vec3 p, float count) {\n    vec2 polarXY = toPolar(p.xy);\n    return fromPolar(polarXY.x, mod(polarXY.y, TAU / count), p.z);\n}\n\nfloat sin01(float x) {\n    return 0.5 + 0.50 * sin(x);\n}\nfloat cos01(float x) {\n    return 0.5 + 0.50 * cos(x);\n}\n\nfloat betterBox(vec3 r, vec3 p) {\n    vec3 q = abs(p) - r;\n    return length(max(q, 0.0)) + min(max3(q), 0.0);\n    p = abs(p);\n    return max3(p - r);\n}\n\nfloat roundedBlock(vec3 r, float cr, vec3 p) {\n    return betterBox(r - vec3(cr), p) - cr;\n}\n\nfloat sdConeB(vec2 c, float h, vec3 p) {\n    float q = length(p.xz);\n    return max(dot(c.xy, vec2(q, p.y)), -h-p.y);\n}\n\nfloat sdCone(vec2 c, float h, vec3 p) {\n    vec2 q = h * vec2(c.x / c.y, -1.0);\n    vec2 w = vec2(length(p.xz), p.y);\n    vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);\n    vec2 b = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0);\n    float k = sign(q.y);\n    float d = min(dot(a, a), dot(b, b));\n    float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));\n    return sqrt(d) * sign(s);\n}\n\nfloat sdCapsule(vec3 a, vec3 b, float r, vec3 p) {\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\nfloat sdEllipsoidB(vec3 r, vec3 p) {\n    float k0 = length(p / r);\n    float k1 = length(p / (r * r));\n    return k0 * (k0 - 1.0) / k1;\n}\nfloat sdOctahedronB(float s, vec3 p) {\n    p = abs(p);\n    return (p.x + p.y + p.z - s) * 0.57735027;\n}\nfloat donutc(float r0, float r1, vec3 p) {\n    vec3 closestCenter = vec3(normalize(p.xy) * r0, 0.0);\n    return distance(closestCenter, p) - r1;\n}\n\nfloat sdCappedCylinder(float h, float r, vec3 p) {\n    vec2 d = vec2(length(p.xy), abs(p.z)) - vec2(r, h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\nfloat smoothmin(float r, float a, in float b) {\n    float h = smoothstep(-r, r, a - b);\n    return mix(a, b, h) - r * h * (1. - h);\n}\nfloat queen(vec3 p) {\n    float lxy = length(p.xy);\n    float d;\n    d = lxy - 1.1;\n    d += .16*p.z;\n    d -= -c*(1.-pow(sin01(b+p.z * 2.5), 1.5));\n    d +=.1* normalize(p.xy).x*smoothstep(2., .5, p.z);\n    d += .02*sin(15.*atan(p.y, p.x) -p.z*5.)*smoothstep(2., .5, p.z);\n    //    float d = sdCappedCylinder(a, b, p);\n    d = max(d, -p.z);\n    d = max(d, p.z - 4.);\n\n    float head = sdSphere(.55, p - vec3(0., 0., 4.4));\n    d = smoothmin(0.15, d, head);\n    float crown = sdCone(fromPolar(vec2(1., 1.15)), 1., -(p - vec3(0., 0., 4.5)).yzx);\n    d = min(d, crown);\n    d *= .5;\n    return d;\n}\nfloat lego(vec3 p) {\n    vec2 c = vec2(4.0, 2.0);\n    //    p.xy = mod(p.xy + c * 0.5, c) - c * 0.5;\n    float lxy = length(p.xy);\n    p -= vec3(0., 0., 0.6);\n    float d;\n    const float cr = 0.02;\n    d = sdBox(vec3(2., 1., 0.6), cr, p);\n    //    vec3 p8 = vec3(fract(p.xy + 0.5) - 0.5, p.z);\n    vec3 p8 = vec3(abs(abs(p.xy) - vec2(1.0, 0.)), p.z) - vec3(0.5, 0.5, .6);\n    float dCyl = sdCylinder(0.35 - 0.04, .2, p8) - 0.04;\n    d = min(d, dCyl);\n    return d;\n}\n\nvec2 project(vec2 a, vec2 onto1) {\n    return onto1 * (dot(a, onto1) / dot(onto1, onto1));\n}\n\nvec3 reject(vec3 a, vec3 b1) {\n    return a - b1 * dot(a, b1);\n}\n\nRMHit sdf(vec3 p) {\n    const vec4 red = vec4(0.2, 0.0, 0.0, 1.0);\n    //    RMHit d = RMHit(block(vec3(-1., -1., -1.), vec3(1., 1., 1.), p), black);\n    //    RMHit d = RMHit(sphere(2., p), black);\n    //    RMHit d = RMHit(betterBox(vec3(1.), p), black);\n    //    RMHit d = RMHit(roundedBlock(vec3(1.), 0.1, p), black);\n    //    RMHit d = RMHit(donut(2., 0.5, p), black);\n    //    RMHit d = RMHit(sdCapsule(vec3(-a,-a,0.), vec3(a,a,0.), b, p), black);\n    //    RMHit d = RMHit(sdEllipsoidB(vec3(-a,-b,1.), p), black);\n    //    RMHit d = RMHit(sdOctahedron(1., p)-a, red) ;\n    //    RMHit d = RMHit(queen(p), black) ;\n    //    RMHit d = RMHit(lego(p), black) ;\n    //- vec3(0.0, 0.0, 1.0)\n    vec3 h = vec3(.5, 0.0, 0.0);\n    vec3 q = abs(p)-h;\n//    vec2 pyr = sdPyramid(\n//        vec3(2.0, 2.0, -2.0),\n//        opElongate(h,\n//            rotZ(highResTimeStamp/1000.) *\n//                rotX(c) *\n//                opRepLim(p - vec3(-8., -8., 2.), vec3(8.), vec3(2., 2., 0.))));\n    vec3 p2 = rotX(highResTimeStamp *.00) * p;\n    vec2 xx = vec2(sdIcosahedron(d, p2) - c, 1.);\n    vec4 cc = red;\n    cc.xyz = cc.xyz * xx.y*.1;\n    RMHit d = RMHit(xx.x, cc);\n    //    RMHit d = RMHit(sdCone(fromPolar(vec2(1., a)), b, p.yzx - vec3(0.,2., 0.)), black);\n    //    d.distance = abs(d.distance) - 0.4;\n    //    d.distance = abs(d.distance) - 0.1;\n    //    d.distance = abs(d.distance) - 0.02;\n    float s = length(p - vec3(1., 1., 0.)) - 1.0;\n    //    d.distance = s;\n    //    d.distance = max(d.distance, -s);\n\n    vec3 color = .1*sin(abs(vec3(0.0, PI, 0.0) + vec3(d.distance*PI*2.)));\n//    color.z = .1*xx.y;\n    RMHit base = RMHit(sdBox(vec3(10., 10., 0.), p), vec4(color, 1.0));\n\n//    d = base;\n    d = add(base, d);\n    if (b > 1.0) {\n        d = base;\n    }\n    //    d.distance *=0.5;\n    return d;\n}\nfloat sdff(vec3 p) {\n    return sdf(p).distance;\n}\nfloat ambientOcclusion(vec3 pWC, vec3 n1WC) {\n    float k = 1.0;\n    float distance = sdff(pWC + n1WC * k);\n    return clamp(distance / k, 0.0, 1.0);\n}\n\nstruct RMResult {\n    float distance;\n    vec3 pos;\n    vec4 color;\n};\nRMResult raymarching2(vec3 start, vec3 dir1) {\n    vec3 pos = start;\n    RMHit hit;\n    for (int i = 0; i < 200; i++) {\n        hit = sdf(pos);\n        if (hit.distance < 0.0001 * hit.distance) break;\n        pos = pos + dir1 * hit.distance;\n    }\n    return RMResult(hit.distance, pos, hit.color);\n}\nvec3 pt(mat4 pm, vec3 p) {\n    vec4 pStar = pm * vec4(p, 1.0);\n    return pStar.xyz / pStar.w;\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd, float mint, float maxt, float k)\n{\n    float res = 1.0;\n    float t = 0.1;\n    for (int i = 0; i < 1000 && t < maxt; i++) {\n        float h = sdff(ro + rd*t);\n        if (h<0.001)\n        return 0.0;\n        res = min(res, k*h/t);\n        t += h;\n    }\n    return res;\n}\n\nconst float eps = 1e-4;\nvec3 sdfNormal1(vec3 p, float d) {\n    return normalize(vec3(\n    sdff(p + vec3(eps, 0., 0.)),\n    sdff(p + vec3(0., eps, 0.)),\n    sdff(p + vec3(0., 0., eps))\n    ) - vec3(sdff(p)));\n}\n\n//layout (depth_greater) out float gl_FragDepth;\nvoid main() {\n    vec3 light = normalize(vec3(-1., -2., -2));\n\n    vec3 a = vec3(coord, -1.);\n    vec3 b = vec3(coord, 1.);\n    vec3 aWC = pt(llli, a);\n    vec3 bWC = pt(llli, b);\n    vec3 lookDir1 = normalize(bWC - aWC);\n\n    RMResult hitWC = raymarching2(aWC, lookDir1);\n    vec3 hitn1 = sdfNormal1(hitWC.pos, hitWC.distance);\n    float dWC = distance(aWC, hitWC.pos);\n    vec3 hitNDC = pt(lll, hitWC.pos);\n    vec3 p = hitWC.pos;\n    float inSun = softshadow(hitWC.pos+hitn1 *0.05, -light, 0.0001, 300.0, 8.);\n    //    float inSun=1.;\n\n    vec3 material = hitWC.color.xyz;\n    if (dWC > 100.) {\n        material = vec3(0.0, 0.0, 0.0);\n        //    } else if (p.z >= 0.001) {\n        //        material = vec3(0.2, 0.0, 0.0);\n        //    } else {\n        //        vec2 c = vec2(4.0, 2.0);\n        //        vec2 id = floor(((p.xy - c * 0.5) / c) );\n        //        material += .15 * cos(vec3(id.x, id.y + 2., id.x + id.y + 4.));\n    }\n\n    const vec3 sunlightColor = vec3(8., 6., 1.);\n\n    float aOcc = ambientOcclusion(hitWC.pos, hitn1);\n\n    vec3 reflectionDirection = reflect(light, hitn1);\n\n    vec3 color = vec3(0.0);\n    color += material * aOcc;\n    color += inSun * sunlightColor * material * max(0.0, dot(-light, hitn1));\n    //    color = (hitn1);\n\n    vec3 camPos = aWC;\n\n    vec3 eyeDirection = -lookDir1;\n    float uMaterialShininess = 256.0;\n    float specularLightWeighting =\n    pow(max(dot(reflectionDirection, eyeDirection), 0.0), uMaterialShininess);\n    color += specularLightWeighting;\n    //    float lightIntensity = 0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.);\n    //    float lightIntensity =\n    //        0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.) + 0.3*specularLightWeighting;\n    //    fragColor = visualize(blue, red, mix(0.5, 1.0, inSun) * lightIntensity);\n    //    fragColor = mix(hitWC.color, colorBg, mix(0.5, 1.0, inSun) * clamp(lightIntensity, 0., 1.));\n    color = pow(color, vec3(1.0/2.2));// gamma correction\n    fragColor = vec4(color, 1.0);\n}"},7080:e=>{e.exports="#version 300 es\n\nprecision highp float;\n#define GLSLIFY 1\n\nconst vec4 blue = vec4(0.0, 0.0, 1.0, 1.0);\nconst vec4 red = vec4(1.0, 0.0, 0.0, 1.0);\n\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\n  float isLow = float(t < 0.0);\n  float isHigh = float(t > 1.0);\n  float isMid = 1.0 - isLow - isHigh;\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\n}\n\nvec4 visualize(float t) {\n  return visualize(blue, red, t);\n}\n\nfloat banded(float bandCount, float t) {\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\n}\nfloat banded(int bandCount, float t) {\n  return banded(float(bandCount), t);\n}\n\nuniform vec4 color;\n\nout vec4 fragColor;\n\nvoid main() {\n\n    fragColor = color;\n}"},1507:e=>{e.exports="#version 300 es\nprecision highp float;\n#define GLSLIFY 1\n\nuniform mat4 ts_ModelViewProjectionMatrix;\nuniform float normalOffset;\nin vec3 ts_Normal;\nin vec4 ts_Vertex;\n\nvoid main() {\n    gl_Position = ts_ModelViewProjectionMatrix * (ts_Vertex + normalOffset * vec4(ts_Normal, 0.));\n}"},5583:(e,n,t)=>{t.d(n,{Z:()=>a});var o=setTimeout;function r(e,n){var t=n.useCachedSetTimeout?o:setTimeout;return new Promise((function(n){t(n,e)}))}const a=function(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},t=n.useCachedSetTimeout,o=r(e,{useCachedSetTimeout:t});function a(e){return o.then((function(){return e}))}return a.then=function(){return o.then.apply(o,arguments)},a.catch=Promise.resolve().catch,a}}}]);