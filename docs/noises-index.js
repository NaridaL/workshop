(self.webpackChunkworkshop=self.webpackChunkworkshop||[]).push([[388],{6941:(n,e,t)=>{"use strict";t.r(e),t.d(e,{band:()=>b,default:()=>C});var o=t(6800),r=t(260),a=t(1459),i=t(9975),l=t(2772),c=t(5282),s=t(5270),f=t(7392),d=t(9526),v=t(2182),u=t(9392),m=t(1641);n=t.hmd(n);const x="C:\\Users\\aval\\tsdev\\workshop\\src\\noises\\index.tsx",p=(0,v.Nv)(512,(()=>v.V3.polar(1,2*(Math.random()-.5)*Math.PI))),h={xOffset:0,yOffset:0,xScale:64,yScale:64,bandCount:2,a:.5,b:.5},y=(n,e,t)=>{const o=0|n,r=o+1,a=0|e,i=a+1,l=n=>n*n*(3-2*n),c=(n,e,t,o)=>{const r=t-n,a=o-e;return(0,v.en)(p,59*n+e).dot(new v.V3(r,a,0))},s=c(o,a,n,e),f=c(r,a,n,e),d=(0,v.t7)(s,f,t?l(n-o):n-o),u=c(o,i,n,e),m=c(r,i,n,e),x=(0,v.t7)(u,m,t?l(n-o):n-o);return(0,v.t7)(d,x,t?l(e-a):e-a)},b=(n,e,t,o)=>(0,v.t7)(n,e,Math.floor(4*(0,v.kL)(n,e,o))/3);const g=(0,l.Z)((n=>({sidebar:{display:"flex",flexDirection:"column",width:256,padding:n.spacing(1),alignItems:"stretch","& > *":{margin:n.spacing(1)}},media:{height:0,paddingTop:"100%"}})));function _({state:n,prop:e,setStatePartial:t,...o}){return d.createElement(s.Z,{variant:"outlined",size:"small",type:"number",value:n[e],onChange:n=>t({[e]:+n.target.value}),label:e,...o,__self:this,__source:{fileName:x,lineNumber:619}})}const C=()=>{const e=(0,d.useRef)(null),[l,s]=(0,m.q)(h),p=(0,d.useCallback)((n=>s((e=>({...e,...n})))),[s]),b=((0,d.useRef)(),(0,d.useRef)(Object.assign({},l))),C=g(),M=(0,c.Z)();return(0,d.useEffect)((()=>{!function(e,o,r){let a=!0;const i=512,l=new Uint8Array(512*i),c=new u.xE(i,512,{format:e.RED,type:e.UNSIGNED_BYTE,internalFormat:e.R8}),s=new u.xE(256,256,{format:e.RG,type:e.FLOAT,internalFormat:e.RG32F,data:v.V3.packXY((0,v.Nv)(65536,(()=>v.V3.polar(1,2*(Math.random()-.5)*Math.PI))))}),f=()=>{let n=1/0,e=-1/0;for(let t=0;t<512;t++)for(let o=0;o<i;o++){const c=(0,v.uZ)(.8*(y(r.xOffset+o/r.xScale,r.yOffset+t/r.yScale,a)+.5),0,1),s=Math.random();l[t*i+o]=Math.floor(4*c)/3*255,e=Math.max(e,s),n=Math.min(n,s)}l[0]=0,c.setData(l)},d=u.Kj.plane({detail:128}),m=u.Kj.sphere(0).computeWireframeFromFlatTrianglesClosedMesh().compile();!function(n){const e=[],t=Math.sqrt(3)/2,o=Math.cos(Math.PI/3),r=2*Math.asin(1/Math.sqrt(3));for(let a=-0;a<2;a++)for(let i=-0;i<2;i++)for(let l=-0;l<1;l++){const c=a+(i%2==0?0:o);e.push(n.transform(v.M4.scale(1,.01,.01).translate(c,i*t,l*t)),n.transform(v.M4.scale(1,.01,.01).rotateZ(Math.PI/3).translate(c,i*t,l*t)),n.transform(v.M4.scale(1,.01,.01).rotateZ(Math.PI/3*2).translate(c,i*t,l*t)),n.transform(v.M4.scale(1,.01,.01).rotateZ(Math.PI/2).rotateX((Math.PI-r)/2).translate(c,i*t,l*t)),n.transform(v.M4.scale(1,.01,.01).rotateY(-Math.PI/3*2).rotateX(Math.PI/2-r).translate(c,i*t,l*t)),n.transform(v.M4.scale(1,.01,.01).rotateY(-Math.PI/3).rotateX(Math.PI/2-r).translate(c,i*t,l*t)))}const[a,...i]=e;a.concat(...i)}(u.Kj.rotation([v.V3.Y,v.V3.XY],{anchor:v.V3.O,dir1:v.V3.X},2*Math.PI,3,!0)),console.log(m);const x=u.ex.create("\n      uniform mat4 ts_ModelViewProjectionMatrix;\n      attribute vec4 ts_Vertex;\n      uniform float pointSize;\n      varying vec4 foo;\n      void main() {\n        foo = vec4(1.0, 1.0, 1.0, 1.0);\n        gl_Position = ts_ModelViewProjectionMatrix * ts_Vertex;\n        gl_PointSize = pointSize;\n      }\n    ","\n      precision highp float;\n      uniform vec4 color;\n      varying vec4 bar;\n      void main() {\n        gl_FragColor = color;\n        if (length(gl_PointCoord - vec2(0.5, 0.5)) > 0.5) {\n          discard;\n        }\n      }\n    ");u.ex.create("#version 300 es\n      precision highp float;\n      \n      uniform mat4 ts_ModelViewProjectionMatrix;\n      in vec4 ts_Vertex;\n      uniform float pointSize;\n      uniform vec2 scale;\n      uniform vec2 offset;\n      in vec3 ts_TexCoordUVQ;\n      in vec2 ts_TexCoord;\n      out vec3 coordUVQ;\n      out float n;\n      out vec2 coord;\n      void main() {\n        vec2 texCoordAdjusted = offset + ts_TexCoord * scale;\n        n = 0.0;  \n        gl_Position = ts_ModelViewProjectionMatrix * \n          (ts_Vertex + vec4(0.0, 0.0, n, 0.0));\n        gl_PointSize = pointSize;\n        coordUVQ = ts_TexCoordUVQ;\n        coord = texCoordAdjusted;\n      }\n  ","#version 300 es\n      precision highp float;\n      \n      uniform sampler2D texture;\n      uniform vec4 colorPrimary;\n      uniform vec4 colorBg;\n      uniform int bandCount;\n      in float n;\n      in vec2 coord;\n      out vec4 fragColor;\n      void main() {\n        float fraction = (n + 0.5) * 0.5;\n        fragColor = mix(colorBg, colorPrimary, fraction);\n        \n        if (length(gl_PointCoord - vec2(0.5, 0.5)) > 0.5) {\n          discard;\n        }\n      }\n    ");let p={raymarch:u.ex.create(t(1493),t(3016)),simplex:u.ex.create(t(1493),t(1502)),julia:u.ex.create(t(1493),t(4046))};n.hot,u.ex.create("\n      uniform mat4 ts_ModelViewProjectionMatrix;\n      attribute vec4 ts_Vertex;\n      uniform float pointSize;\n      attribute vec3 ts_TexCoordUVQ;\n      attribute vec2 ts_TexCoord;\n      varying vec4 foo;\n      varying vec3 coordUVQ;\n      varying vec2 coord;\n      void main() {\n        foo = vec4(1.0, 1.0, 1.0, 1.0);\n        gl_Position = ts_ModelViewProjectionMatrix * ts_Vertex;\n        gl_PointSize = pointSize;\n        coordUVQ = ts_TexCoordUVQ;\n        coord = ts_TexCoord;\n      }\n    ","\n      precision highp float;\n      uniform sampler2D texture;\n      uniform vec4 colorPrimary;\n      uniform vec4 colorBg;\n      varying vec4 bar;\n      varying vec3 coordUVQ;\n      varying vec2 coord;\n      void main() {\n        float fraction = texture2D(texture, coord).r;\n        gl_FragColor = mix(colorBg, colorPrimary, fraction);\n        \n        if (length(gl_PointCoord - vec2(0.5, 0.5)) > 0.5) {\n          discard;\n        }\n      }\n    ");const h={pos:(0,v.V)(.75,0,1),lookDir:(0,v.V)(0,0,-1)};(()=>{if(null!=localStorage.getItem("viewState")){const n=JSON.parse(localStorage.getItem("viewState"));h.pos=v.V3.fromArray(n.pos),h.lookDir=v.V3.fromArray(n.lookDir)}})(),e.clearColor(...o.background),e.cullFace(e.BACK);const b=()=>{e.matrixMode(e.PROJECTION),e.loadIdentity(),e.perspective(70,e.canvas.width/e.canvas.height,.1,1e3),e.lookAt((0,v.V)(.75,0,1),(0,v.V)(.75,0,0),v.V3.Y),e.matrixMode(e.MODELVIEW)};b(),e.pointSize(10),e.disable(e.CULL_FACE),e.enable(e.DEPTH_TEST),e.enable(e.BLEND),e.blendFunc(e.SRC_ALPHA,e.ONE_MINUS_SRC_ALPHA);const g={};console.log(e.canvas),e.canvas.contentEditable="true",e.canvas.focus(),e.canvas.onkeydown=function(n){g[n.key]=!0,"o"===n.key&&(a=!a,f()),"2"===n.key&&b(),"1"===n.key&&(e.matrixMode(e.PROJECTION),e.loadIdentity(),e.perspective(70,e.canvas.width/e.canvas.height,.1,1e3),e.lookAt((0,v.V)(0,.5,2.2),v.V3.O,v.V3.Y),e.matrixMode(e.MODELVIEW))},e.canvas.onkeypress=function(n){new v.V3(0,0,0)},e.canvas.onkeyup=function(n){g[n.key]=!1};let _=v.V3.O,C=v.M4.IDENTITY;e.canvas.onmousemove2=function(n){const e=(0,v.V)(n.pageX,n.pageY),t=_.to(e);1&n.buttons&&(C=C.rotateZ(.25*t.x*v.Co),C=C.rotateX(.25*t.y*v.Co)),_=e},e.canvas.onmousemove=function(n){const e=(0,v.V)(n.pageX,n.pageY),t=_.to(e);if(1&n.buttons){const n=v.M4.rotateY(.25*-t.x*v.Co).rotateX(.25*-t.y*v.Co);h.lookDir=n.transformVector(h.lookDir).unit()}_=e};let M=!1;Object.assign(e.animate((function(n,t){const a=new v.V3(+!!g.w-+!!g.s,+!!g.a-+!!g.d,+!!g.e-+!!g.q+ +!!g[" "]).times(.05);if(!a.likeO()){const n=h.lookDir;h.pos=h.pos.plus(v.M4.forSys(n,v.V3.Y.cross(n).unit()).transformVector(a)),localStorage.setItem("viewState",JSON.stringify({pos:h.pos.toArray(),lookDir:h.lookDir.toArray()}))}e.matrixMode(e.PROJECTION),e.loadIdentity(),e.perspective(70,e.canvas.width/e.canvas.height,.1,1e3),e.lookAt(h.pos,h.pos.plus(h.lookDir),v.V3.Y),e.matrixMode(e.MODELVIEW),e.clear(e.COLOR_BUFFER_BIT|e.DEPTH_BUFFER_BIT),e.loadIdentity(),e.pushMatrix(),e.translate(.25,-.5,0),c.bind(0),s.bind(1);const i=n/1e3/40%1,l=n=>v.V3.polar((0,v.t7)(-6,6,n),Math.abs((0,v.t7)(-10,10,n))+v.PI/2,.5),f=v.M4.product(v.M4.perspective(70,1,.1,50),v.M4.lookAt(l(i),l(i+.005).unit().plus((0,v.V)(0,0,.2)),v.V3.Z)),u=f.inversed();M||(console.log(""+f),console.log(f.transformPoint(v.V3.XYZ.negated())),console.log(f.transformPoint(v.V3.XYZ)),M=!0),p.raymarch.uniforms({a:r.a,b:r.b,colorPrimary:o.primary,colorSecondary:o.secondary,colorBg:o.background,scale:[r.xScale,r.yScale],offset:[r.xOffset,r.yOffset],bandCount:r.bandCount,highResTimeStamp:n,secs:n/1e3,gradients:1,lll:f,llli:u}).draw(d),e.popMatrix(),e.pushMatrix(),e.translate(-.75,0,0),e.scale(.5),e.rotate(-90,1,0,0),p.raymarch.uniforms({colorPrimary:o.primary,colorBg:o.background,pointSize:12,texture:0}).draw(m),x.uniforms({color:o.primary,pointSize:12}).draw(m,e.LINES),e.popMatrix()})),{redoTex:f})}(u.ZG.create({canvas:e.current}),{background:f.iv(M.palette.background.default).gl(),primary:f.iv(M.palette.primary.main).gl(),secondary:f.iv(M.palette.secondary.main).gl()},b.current)}),[M.palette.background.default,M.palette.primary.main,M.palette.secondary.main]),(0,d.useEffect)((()=>{Object.assign(b.current,l)}),[l]),d.createElement(a.Z,{container:!0,style:{height:"99%"},__self:void 0,__source:{fileName:x,lineNumber:670}},d.createElement(a.Z,{item:!0,xs:12,md:9,__self:void 0,__source:{fileName:x,lineNumber:671}},d.createElement("div",{style:{height:"100%"},__self:void 0,__source:{fileName:x,lineNumber:672}},d.createElement("canvas",{ref:e,style:{width:"100%",height:"100%"},width:128,height:128,tabIndex:0,__self:void 0,__source:{fileName:x,lineNumber:673}}))),d.createElement(a.Z,{item:!0,xs:12,md:3,className:C.sidebar,__self:void 0,__source:{fileName:x,lineNumber:682}},d.createElement(o.Z,{__self:void 0,__source:{fileName:x,lineNumber:683}},d.createElement(r.Z,{__self:void 0,__source:{fileName:x,lineNumber:684}},"Test with various noise generation functions.")),d.createElement(_,{state:l,setStatePartial:p,prop:"xOffset",__self:void 0,__source:{fileName:x,lineNumber:688}}),d.createElement(_,{state:l,setStatePartial:p,prop:"yOffset",__self:void 0,__source:{fileName:x,lineNumber:689}}),d.createElement(_,{state:l,setStatePartial:p,prop:"xScale",__self:void 0,__source:{fileName:x,lineNumber:690}}),d.createElement(_,{state:l,setStatePartial:p,prop:"yScale",__self:void 0,__source:{fileName:x,lineNumber:691}}),d.createElement(_,{state:l,setStatePartial:p,prop:"bandCount",__self:void 0,__source:{fileName:x,lineNumber:692}}),d.createElement("div",{__self:void 0,__source:{fileName:x,lineNumber:693}},d.createElement(i.Z,{value:l.a,onChange:(n,e)=>p({a:e}),min:0,max:1,step:.01,__self:void 0,__source:{fileName:x,lineNumber:694}})),d.createElement("div",{__self:void 0,__source:{fileName:x,lineNumber:702}},d.createElement(i.Z,{value:l.b,onChange:(n,e)=>p({b:e}),min:0,max:1,step:.01,__self:void 0,__source:{fileName:x,lineNumber:703}})),l.a))}},1641:(n,e,t)=>{"use strict";t.d(e,{q:()=>d});var o=t(6897),r=t.n(o),a=t(508),i=t.n(a),l=t(9526);const c=n=>"#"+Object.entries(n).map((([n,e])=>encodeURIComponent(n)+"="+encodeURIComponent(e))).join("&"),s=n=>i()(n,(n=>"true"===n||"false"!==n&&("NaN"===n?NaN:"undefined"===n?void 0:"null"===n?null:isNaN(+n)?n:+n))),f=n=>i()(n,(n=>""+n));function d(n,{deserialize:e=s,serialize:t=f,wait:o=1e3}={}){const a=(0,l.useCallback)((()=>{const o="function"==typeof n?n():n,r=e(Object.assign(t(o),(a=document.location.hash)?a.substr(1).split("&").map((n=>{const[e,t]=n.split("=");return[decodeURIComponent(e),decodeURIComponent(t)]})).reduce(((n,[e,t])=>(n[e]=t,n)),{}):{}));var a;return history.pushState(void 0,document.title,c(t(r))),r}),[e,n,t]),[i,d]=(0,l.useState)(a),v=(0,l.useRef)();return v.current||(v.current=r()((function(n){history.pushState(void 0,document.title,c(t(n)))}),o)),v.current(i),(0,l.useEffect)((()=>{const n=()=>{d(a())};return window.addEventListener("hashchange",n),()=>{window.removeEventListener("hashchange",n)}}),[a]),[i,d]}},4046:n=>{"use strict";n.exports="#version 300 es\nprecision highp float;\n#define GLSLIFY 1\n\nfloat banded(float bandCount, float t) {\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\n}\nfloat banded(int bandCount, float t) {\n  return banded(float(bandCount), t);\n}\n\nbool between(float min, float max, float value) {\n    return min <= value && value <= max;\n}\n\nuniform sampler2D gradients;\nuniform int bandCount_0;\n\nvec3 xy2tri(vec2 xy) {\n    float v = xy.y / 0.866;\n    float u = xy.x - v / 2.0;\n    float R = float(mod(u, 1.0) + mod(v, 1.0) > 1.0);\n    return vec3(u, v, R);\n}\nvec3 triCenter(vec3 uvR) {\n    vec3 base = floor(uvR);\n    vec2 centerOffset = mix(vec2(1./3.), vec2(2./3.), uvR.z);\n    return base + vec3(centerOffset, 0.0);\n}\nvec2 tri2xy(vec3 uvR) {\n    float y = uvR.t * 0.866;\n    float x = uvR.s + uvR.t / 2.0;\n    return vec2(x, y);\n}\nvec2 tri2xy(vec2 uv) {\n    float y = uv.t * 0.866;\n    float x = uv.s + uv.t / 2.0;\n    return vec2(x, y);\n}\nconst float SQRT2 = 1.4142135623730951;\nconst float GOLDEN_RATIO_1117569599 = 1.61803398875;\nconst float SQRT3 = 1.732050807568877;\n/* Create random direction vector\n */\nvec2 randomGradient(vec2 i) {\n    // Random float. No precomputed gradients mean this works for any number of grid coordinates\n    float random = 2920.0 *\n        sin(float(i.x) * 2.19420 + float(i.y) * 1.713240 + 8.9120) *\n        cos(float(i.x) * 2.31570 * float(i.y) * 2.178320 + 9.7580);\n//    random = (i.x + 1667.) * (i.x + 2083.) * (i.y + 2659.) * (i.y * 50.77 + .3769);\n//    random = sin(SQRT2 * i.x) + cos(GOLDEN_RATIO * i.y) + tan((i.x + i.y) * SQRT3);\n    return vec2(cos(random), sin(random)) ;\n}\n\nfloat dotGridGradient2(vec2 cell, vec2 pos) {\n    vec2 xy_d = cell - pos;\n    if (length(xy_d) > 0.4) return 0.;\n    float r = 1.;\n    float part = pow(max(0., .999 - dot(xy_d, xy_d)), 4.);\n//    vec2 gradient = texelFetch(gradients, ivec2(cell), 0).xy;\n    vec2 gradient = randomGradient(cell);\n    return part * dot(gradient, xy_d);\n}\n\n// resulting range is [-0.68, 0.68]. Use unmix to normalize if necessary.\nfloat simplex2D(vec2 xy) {\n    vec3 uvR = xy2tri(xy);\n    ivec2 baseUV = ivec2(uvR.xy);\n\n    float a = dotGridGradient2(tri2xy(vec2(baseUV)), xy);\n    float b = dotGridGradient2(tri2xy(vec2(baseUV + ivec2(1, 0))), xy);\n    float c = dotGridGradient2(tri2xy(vec2(baseUV + ivec2(0, 1))), xy);\n    float d = dotGridGradient2(tri2xy(vec2(baseUV + ivec2(1, 1))), xy);\n\n    return b + c + mix(a, d, uvR.z);\n}\n\nfloat unmix(float a, float b, float value) {\n  return (value - a) / (b - a);\n}\n\nfloat remix(float fromA, float fromB, float toA, float toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\nvec4 remix(float fromA, float fromB, vec4 toA, vec4 toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\nvec2 complexMul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.y * b.x + a.x * b.y);\n}\n\nvec2 complexDiv(vec2 a, vec2 b) {\n    vec2 bConj = vec2(b.x, -b.y);\n    float divisor = complexMul(b, bConj).x;\n    return complexMul(a, bConj) / divisor;\n}\n\nvec2 toPolar(vec2 xy) {\n    return vec2(length(xy), atan(xy.y, xy.x));\n}\n\nvec3 fromPolar(float radius, float phi, float z) {\n  return vec3(radius * cos(phi), radius * sin(phi), z);\n}\n\nvec2 fromPolar(float radius, float phi) {\n  return vec2(radius * cos(phi), radius * sin(phi));\n}\n\nvec2 fromPolar(vec2 polar) {\n  return fromPolar(polar.x, polar.y);\n}\n\n// return e^z\nvec2 complexPow(vec2 z) {\n    // e^(re + i * im)\n    // = e^re * e^(i * im)\n    return fromPolar(exp(z.x), z.y);\n}\n\n// return w^z\nvec2 complexPow(vec2 w, float z) {\n    // w = r * e ^ (i * phi)\n    // ln(w) = ln(r) + i * phi\n    // w^z = e^(z * log(w)) = e^(z * (ln(r) + i * (phi))\n    vec2 wPolar = toPolar(w);\n    vec2 eExp = z * vec2(log(wPolar.x), wPolar.y);\n    return complexPow(eExp);\n}\n\nuniform float highResTimeStamp;\n\nfloat waves(vec4 color, vec2 position, vec2 direction) {\n    return sin(dot(position, direction / pow(length(direction), 2.0)) + float(highResTimeStamp) / 200.0);\n}\n\nconst vec4 blue_0 = vec4(0.0, 0.0, 1.0, 1.0);\nconst vec4 red_0 = vec4(1.0, 0.0, 0.0, 1.0);\n\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\n  float isLow = float(t < 0.0);\n  float isHigh = float(t > 1.0);\n  float isMid = 1.0 - isLow - isHigh;\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\n}\n\nvec4 visualize(float t) {\n  return visualize(blue_0, red_0, t);\n}\n\nvec3 raToHex(vec2 xy) {\n    float hex_t = xy.y / 0.866;\n    float hex_s = xy.x - hex_t / 2.0;\n    return vec3(hex_s, hex_t, -(hex_s + hex_t));\n}\n\nvec2 hex2Ra(vec3 hex) {\n    float y = hex.t * 0.866;\n    float x = hex.s + hex.t / 2.0;\n    return vec2(x, y);\n}\n\nvec3 hexRound(vec3 hex) {\n    vec3 r = floor(hex + 0.5);\n    vec3 diff = abs(r - hex);\n\n    if (diff.x > diff.y && diff.x > diff.z) {\n        r.x = -(r.y + r.z);\n    } else if (diff.y > diff.z) {\n        r.y = -(r.x + r.z);\n    } else {\n        r.z = -(r.x + r.y);\n    }\n\n    return r;\n}\n\nfloat max3(float a, float b, float c) {\n  return max(a, max(b, c));\n}\nfloat max3(vec3 v) {\n  return max(v.x, max(v.y, v.z));\n}\n\nfloat hexSdf(vec3 hex) {\n    return max3(abs(hex.yzx + hex.zxy / 2.0));\n}\n\nmat3 rotY(float angle) {\n    float c = cos(angle), s = sin(angle);\n    return mat3(\n    c,  0., -s,\n    0., 1., 0.,\n    s,  0.,  c);\n}\n\nuniform sampler2D texture;\nuniform vec4 colorPrimary;\nuniform vec4 colorSecondary;\nuniform vec4 colorBg;\nuniform float a;\nuniform float b;\nuniform int bandCount;\nuniform float secs;\nin vec2 coord;\nout vec4 fragColor;\n\nconst vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\nconst vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\nconst vec4 blue = vec4(0.0, 0.0, 1.0, 1.0);\nconst vec4 red = vec4(1.0, 0.0, 0.0, 1.0);\nconst float GOLDEN_RATIO = 1.61803398875;\n\nconst vec2 c = vec2(-0.4, 0.6);\nvec2 f(vec2 z) {\n\n//    return complexMul(z, z) + fromPolar(0.7885,(a + b/50.)*6.);\n    return complexMul(z, z) + fromPolar(0.7885,secs/2.);\n//    return complexMul(z, z)  + fromPolar(0.7885,4.);\n}\n\nvec2 complexSqr(vec2 z) {\n    return complexMul(z, z);\n}\nvec2 f2(vec2 z) {\n    const float n = 8.;\n    return complexDiv(1. + (n - 1.) * complexPow(z, n), n * complexPow(z, n - 1.));\n}\n\nvec2 f3(vec2 z) {\n    vec2 z2 = complexMul(z, z);\n    vec2 z3 = complexMul(z2, z);\n    return complexDiv(vec2(1., 0.) + 2. * z3, 3. * z2);\n}\nvec2 flf(vec2 z) {\n    vec2 z2 = complexMul(z, z);\n    vec2 z3 = complexMul(z2, z);\n    return complexDiv(vec2(1., 0.) - z3 / 6., complexSqr(z - z2 / 2.)) + vec2(-a, b);\n}\n\nconst float rSqr = 2. * 2.;\n\nvec3 juliaIteration(vec2 start) {\n    vec2 p = start;\n    for (uint i = uint(0); i < 20u; i++) {\n        p = f(p);\n        if (dot(p, p) > rSqr) {\n            return vec3(p, float(i));\n        }\n    }\n    return vec3(p, float(20u));\n}\n\nvoid main() {\n    vec3 res = juliaIteration(coord);\n    float f = res.z / 20.;\n\n//    fragColor = mix(colorBg, colorPrimary, banded(bandCount, unmix(-.35, .35, f2)));\n    fragColor = mix(colorBg, colorPrimary, min(banded(bandCount, f), 1.));\n    fragColor = vec4(res, 1.0);\n//    fragColor = visualize(f);\n//    fragColor = visualize(float(i == 1000u));\n\n}"},3016:n=>{"use strict";n.exports="#version 300 es\n\nprecision highp float;\n#define GLSLIFY 1\n\nfloat hue2rgb(float f1, float f2, float hue) {\n    if (hue < 0.0)\n        hue += 1.0;\n    else if (hue > 1.0)\n        hue -= 1.0;\n    float res;\n    if ((6.0 * hue) < 1.0)\n        res = f1 + (f2 - f1) * 6.0 * hue;\n    else if ((2.0 * hue) < 1.0)\n        res = f2;\n    else if ((3.0 * hue) < 2.0)\n        res = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;\n    else\n        res = f1;\n    return res;\n}\n\nvec3 hsl2rgb(vec3 hsl) {\n    vec3 rgb;\n    \n    if (hsl.y == 0.0) {\n        rgb = vec3(hsl.z); // Luminance\n    } else {\n        float f2;\n        \n        if (hsl.z < 0.5)\n            f2 = hsl.z * (1.0 + hsl.y);\n        else\n            f2 = hsl.z + hsl.y - hsl.y * hsl.z;\n            \n        float f1 = 2.0 * hsl.z - f2;\n        \n        rgb.r = hue2rgb(f1, f2, hsl.x + (1.0/3.0));\n        rgb.g = hue2rgb(f1, f2, hsl.x);\n        rgb.b = hue2rgb(f1, f2, hsl.x - (1.0/3.0));\n    }   \n    return rgb;\n}\n\nvec3 hsl2rgb(float h, float s, float l) {\n    return hsl2rgb(vec3(h, s, l));\n}\n\nfloat banded(float bandCount, float t) {\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\n}\nfloat banded(int bandCount, float t) {\n  return banded(float(bandCount), t);\n}\n\nbool between(float min, float max, float value) {\n    return min <= value && value <= max;\n}\n\nvec2 hex2Ra(vec3 hex) {\n    float y = hex.t * 0.866;\n    float x = hex.s + hex.t / 2.0;\n    return vec2(x, y);\n}\n\nvec3 hexRound(vec3 hex) {\n    vec3 r = floor(hex + 0.5);\n    vec3 diff = abs(r - hex);\n\n    if (diff.x > diff.y && diff.x > diff.z) {\n        r.x = -(r.y + r.z);\n    } else if (diff.y > diff.z) {\n        r.y = -(r.x + r.z);\n    } else {\n        r.z = -(r.x + r.y);\n    }\n\n    return r;\n}\n\nfloat max3(float a, float b, float c) {\n  return max(a, max(b, c));\n}\nfloat max3(vec3 v) {\n  return max(v.x, max(v.y, v.z));\n}\n\nfloat hexSdf(vec3 hex) {\n    return max3(abs(hex.yzx + hex.zxy / 2.0));\n}\n\nuniform sampler2D gradients;\n\nfloat dotGridGradient(vec2 cell, vec2 pos) {\n    vec2 d = cell - pos;\n\n    vec2 gradient = texelFetch(gradients, ivec2(cell), 0).xy;\n    return dot(gradient, d);\n}\n\nfloat mixx(float a, float b, float t) {\n     return mix(a, b, smoothstep(0.0, 1.0, t));\n//    return mix(a, b, t);\n}\n\n// resulting range is [-0.68, 0.68]. Use unmix to normalize if necessary.\nfloat perlin2D(vec2 xy) {\n    float x0 = floor(xy.x);\n    float x1 = x0 + 1.0;\n    float y0 = floor(xy.y);\n    float y1 = y0 + 1.0;\n\n    // Interpolate between grid point gradients\n    float n00 = dotGridGradient(vec2(x0, y0), xy);\n    float n10 = dotGridGradient(vec2(x1, y0), xy);\n    float ny0 = mixx(n00, n10, xy.x - x0);\n\n    float n01 = dotGridGradient(vec2(x0, y1), xy);\n    float n11 = dotGridGradient(vec2(x1, y1), xy);\n    float ny1 = mixx(n01, n11, xy.x - x0);\n\n    return mixx(ny0, ny1, xy.y - y0);\n}\n\nfloat unmix(float a, float b, float value) {\n  return (value - a) / (b - a);\n}\n\nvec3 fromPolar(float radius, float phi, float z) {\n  return vec3(radius * cos(phi), radius * sin(phi), z);\n}\n\nvec2 fromPolar(float radius, float phi) {\n  return vec2(radius * cos(phi), radius * sin(phi));\n}\n\nvec2 fromPolar(vec2 polar) {\n  return fromPolar(polar.x, polar.y);\n}\n\nvec3 raToHex(vec2 xy) {\n    float hex_t = xy.y / 0.866;\n    float hex_s = xy.x - hex_t / 2.0;\n    return vec3(hex_s, hex_t, -(hex_s + hex_t));\n}\n\nfloat remix(float fromA, float fromB, float toA, float toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\nvec4 remix(float fromA, float fromB, vec4 toA, vec4 toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\nconst vec4 blue_0 = vec4(0.0, 0.0, 1.0, 1.0);\nconst vec4 red_0 = vec4(1.0, 0.0, 0.0, 1.0);\n\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\n  float isLow = float(t < 0.0);\n  float isHigh = float(t > 1.0);\n  float isMid = 1.0 - isLow - isHigh;\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\n}\n\nvec4 visualize(float t) {\n  return visualize(blue_0, red_0, t);\n}\n\nuniform float highResTimeStamp_0;\n\nfloat waves(vec4 color, vec2 position, vec2 direction) {\n    return sin(dot(position, direction / pow(length(direction), 2.0)) + float(highResTimeStamp_0) / 200.0);\n}\n\nmat3 rotX(float angle) {\n    float c = cos(angle), s = sin(angle);\n    return mat3(\n    1., 0., 0.,\n    0., c, -s,\n    0., s, c);\n}\n\nmat3 rotY(float angle) {\n    float c = cos(angle), s = sin(angle);\n    return mat3(\n    c,  0., -s,\n    0., 1., 0.,\n    s,  0.,  c);\n}\n\nmat3 rotZ(float angle) {\n    float c = cos(angle), s = sin(angle);\n    return mat3(\n    c,  -s, 0.,\n    s, c, 0.,\n    0.,  0.,  1.);\n}\n\nfloat donut(float r0, float r1, vec3 p) {\n    vec3 closestCenter = vec3(normalize(p.xy) * r0, 0.0);\n    return distance(closestCenter, p) - r1;\n}\n\nfloat sphere(float radius, vec3 p) {\n    return length(p) - radius;\n}\n\nfloat cylinder(float r, float height, vec3 p) {\n    float a = length(p.xy) - r;\n    float b = p.z - height;\n    float c = -p.z;\n    return max(a, max(b, c));\n}\n\nconst float SQRT1_2_4181093413 = 0.7071067811865476;\n\nfloat addChamfer(float d, float a, float b) {\n    float tillet = ((a + b) - d) * SQRT1_2_4181093413;\n    return min(tillet, min(a, b));\n}\n\nfloat addTillet(float r, float a, float b) {\n    if (a < r && b < r) {\n        return r - distance(vec2(a, b), vec2(r));\n    } else {\n        return min(a ,b);\n    }\n}\n\nfloat block(vec3 minCorner, vec3 maxCorner, vec3 p) {\n    return max(max3(p - maxCorner), max3(-p + minCorner));\n}\n\nfloat add(float a, float b) {\n    return min(a, b);\n}\n\nfloat sub(float from, float what) {\n    return max(from, -what);\n}\n\nuniform sampler2D texture;\nuniform float secs;\nuniform mat4 lll;\nuniform mat4 llli;\nuniform vec4 colorPrimary;\nuniform vec4 colorSecondary;\nuniform vec4 colorBg;\nuniform float a;\nuniform float highResTimeStamp;\nuniform int bandCount;\nuniform vec3 campos;\nin float n;\nin vec2 coord;\nout vec4 fragColor;\n\nconst float TAU = 6.283185307179586;\nconst float SQRT1_2 = 0.7071067811865476;\nconst float SQRT2 = 1.4142135623730951;\nconst float PI = 3.141592653589793;\n\nconst vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\nconst vec4 yellow = vec4(1.0, 1.0, 0.0, 1.0);\nconst vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\nconst vec4 blue = vec4(0.0, 0.0, 1.0, 1.0);\nconst vec4 purple = vec4(0.5, 0.0, 0.5, 1.0);\nconst vec4 red = vec4(1.0, 0.0, 0.0, 1.0);\n\nstruct RMHit {\n    float distance;\n    vec4 color;\n};\nRMHit mixa(RMHit a, RMHit b, float t) {\n    return RMHit(mix(a.distance, b.distance, t), mix(a.color, b.color, t));\n}\nfloat skybox(vec3 p) {\n    return 32. - max3(abs(p));\n}\n\nfloat perlinSphere(float radius, vec3 p) {\n    vec3 cp = normalize(p);\n    float alpha = atan(cp.y, cp.x);\n    float beta = asin(cp.z);\n    return length(p) - radius + 0.1 * perlin2D(vec2(0. / 100., 0.) + (vec2(5.)+vec2(alpha, beta))*8.0);\n}\n\nfloat cylCircle(vec3 p) {\n    float d = 10e9;\n    for (int i = 0; i < 10; i++) {\n        d = min(d, cylinder(0.2, 2., p + fromPolar(3., TAU * float(i) / 10., 1.)));\n    }\n\n    return d;\n}\n\nfloat rblock(float r, vec3 p) {\n    return block(-vec3(r), vec3(r), p);\n}\n\nRMHit add(RMHit a, RMHit b) {\n//    return a.distance < b.distance\n//        ? RMHit(a.distance, a.color)\n//        : RMHit(b.distance, b.color);\n    return mixa(a, b, float(b.distance < a.distance));\n}\n\nfloat wtf(vec3 p) {\n    vec3 center = p - mod(p, 3.0) + vec3(1.5);\n    return rblock(.4 + .3 * sin(secs+ center.x), p - center);\n}\n\nRMHit addTillet(float r, RMHit a, RMHit b) {\n    if (a.distance < r && b.distance < r) {\n        return RMHit(\n            r - distance(vec2(a.distance, b.distance), vec2(r)),\n            mix(a.color, b.color, (a.distance - b.distance) / r * 0.5 + 0.5));\n    } else {\n        return add(a, b);\n    }\n}\n\nRMHit addTillet(float r, RMHit a, RMHit b, vec4 tilletColor) {\n    if (a.distance < r && b.distance < r) {\n        return RMHit(\n            r - distance(vec2(a.distance, b.distance), vec2(r)),\n            tilletColor);\n    } else {\n        return add(a, b);\n    }\n}\n\nRMHit neg(RMHit a) {\n    return RMHit(-a.distance, a.color);\n}\nRMHit sub(RMHit from, RMHit what) {\n    RMHit whatNeg = neg(what);\n    return mixa(from, whatNeg, float(whatNeg.distance > from.distance));\n}\n\nRMHit sdf(vec3 p) {\n    RMHit d = RMHit(skybox(p), colorBg);\n    d = add(d, RMHit(block(vec3(-6., -6., -1.), vec3(6., 6., 0.), p), colorSecondary));\n    float dSphere = sphere(7., p);\n    if (dSphere < 0.) {\n        RMHit m = RMHit(100000., black);\n        for (int i = 0; i < 50; i++) {\n            m = (addTillet(0.4, (m),\n            RMHit(\n            donut(0.5 + float(i) * 0.1, 0.05, rotX(2.+sin(secs*0.01)*0.2) *rotZ(float(i)*0.2)* p),\n            vec4(hsl2rgb(float(i) / 50., 0.99, 0.25), 1.0))));\n        }\n//        float b = block(vec3(-5.,-5.,0.),vec3(5., 5., .2), p);\n//        m = neg(add(neg(m),neg(RMHit(b, black))));\n        //    d = sub(d, RMHit(m.distance - 0.2, colorSecondary));\n        d = addTillet(0.3, d, m);\n    } else {\n        d = add(d, RMHit(dSphere + 1., black));\n    }\n//    for (int i = 0; i < 300; i++) {\n//        float f = unmix(0., 300., float(i));\n//        vec3 spherepos = fromPolar(mix(-6., 6., f), abs(mix(-10., 10., f)) + PI / 2., 0.);\n        d = add(d, RMHit(sphere(0.1, p - campos), black));\n//    }\n//    d = (addTillet(0.1, (d), RMHit(donut(1.5, 0.5, rotX(secs*6.) * p), colorSecondary)));\n//    d = (addTillet(0.1, (d), RMHit(donut(3.9, 0.5, rotY(secs*3.) * p), blue)));\n//    d = neg(addTillet(.2, neg(d), RMHit(block(vec3(-1., -1., -2.), vec3(1., 1., 2.), p), red)));\n//    d = add(d, wtf(p));\n//    d = add(d, RMHit(perlinSphere(1., p - vec3(-2.0, 0.0, 3.0)), purple));\n//    d = add(d, cylCircle(p));\n\n//    d = add(d, sphere(p - vec3(3., 3., 0.)));\n//    d = sub(d, RMHit(\n//        cylinder(1.3, 4.5, rotX(secs/30. * TAU) * p- vec3(2.0, 0.0, 0.0) - vec3(0., 0., -2.25)),\n//        blue));\n//    d = add(d, cylinder(0.8, 4., rotX(secs/30. * TAU) * p- vec3(2.0, 0.0, 0.0) - vec3(0., 0., -2.)));\n//    d = sub(d, cylCircle(p));\n    return d;\n}\nfloat sdff(vec3 p) {\n    return sdf(p).distance;\n}\n\nstruct RMResult {\n    float distance;\n    vec3 pos;\n    vec4 color;\n};\nRMResult raymarching2(vec3 start, vec3 dir1) {\n    vec3 pos = start;\n    RMHit hit;\n    for (int i = 0; i < 200; i++) {\n        hit = sdf(pos);\n        if (hit.distance < 0.) break;\n        pos = pos + dir1 * hit.distance;\n    }\n    return RMResult(hit.distance, pos, hit.color);\n}\nvec3 pt(mat4 pm, vec3 p) {\n    vec4 pStar = pm * vec4(p, 1.0);\n    return pStar.xyz / pStar.w;\n}\n\nconst float eps = 1e-5;\nvec3 sdfNormal(vec3 p, float d) {\n    return (vec3(\n        sdff(p + vec3(eps, 0., 0.)),\n        sdff(p + vec3(0., eps, 0.)),\n        sdff(p + vec3(0., 0., eps))\n    ) - vec3(d)) / eps;\n}\n\nvoid main() {\n    vec3 light = normalize(vec3(-1., -2., -2));\n\n    vec3 a = vec3(coord, -1.);\n    vec3 b = vec3(coord, 1.);\n    vec3 aWC = pt(llli, a);\n    vec3 bWC = pt(llli, b);\n    vec3 lookDir1 = normalize(bWC - aWC);\n\n    RMResult hitWC = raymarching2(aWC, lookDir1);\n    vec3 hitn1 = normalize(sdfNormal(hitWC.pos, hitWC.distance));\n    float dWC = distance(aWC, hitWC.pos);\n\n    vec3 sunPoint = raymarching2(hitWC.pos +hitn1 *.1, -light).pos;\n    float inSun = float(distance(hitWC.pos, sunPoint) > 30.);\n//    float inSun=1.;\n\n    vec3 camPos = aWC;\n\n    vec3 reflectionDirection = reflect(light, hitn1);\n    vec3 eyeDirection = -lookDir1;\n    float uMaterialShininess = 256.0;\n    float specularLightWeighting = pow(max(dot(reflectionDirection, eyeDirection), 0.0), uMaterialShininess);\n    float lightIntensity = 0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.);\n//    float lightIntensity = 0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.) + 0.3*specularLightWeighting;\n//    fragColor = visualize(blue, red, mix(0.5, 1.0, inSun) * lightIntensity);\n    fragColor = mix(hitWC.color, colorBg, mix(0.5, 1.0, inSun) * clamp(lightIntensity, 0., 1.));\n//    fragColor = visualize(dWC);\n//    fragColor = hitWC.color;\n//    fragColor = visualize(blue, red, distance(hitWC, sunPoint)/20.);\n//    fragColor = vec4(aWC, 1.0);\n//    fragColor = vec4(coord, 0.0, 1.);\n}"},1502:n=>{"use strict";n.exports="#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\n\nfloat banded(float bandCount, float t) {\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\n}\nfloat banded(int bandCount, float t) {\n  return banded(float(bandCount), t);\n}\n\nbool between(float min, float max, float value) {\n    return min <= value && value <= max;\n}\n\nuniform sampler2D gradients;\nuniform int bandCount_0;\n\nvec3 xy2tri(vec2 xy) {\n    float v = xy.y / 0.866;\n    float u = xy.x - v / 2.0;\n    float R = float(mod(u, 1.0) + mod(v, 1.0) > 1.0);\n    return vec3(u, v, R);\n}\nvec3 triCenter(vec3 uvR) {\n    vec3 base = floor(uvR);\n    vec2 centerOffset = mix(vec2(1./3.), vec2(2./3.), uvR.z);\n    return base + vec3(centerOffset, 0.0);\n}\nvec2 tri2xy(vec3 uvR) {\n    float y = uvR.t * 0.866;\n    float x = uvR.s + uvR.t / 2.0;\n    return vec2(x, y);\n}\nvec2 tri2xy(vec2 uv) {\n    float y = uv.t * 0.866;\n    float x = uv.s + uv.t / 2.0;\n    return vec2(x, y);\n}\nconst float SQRT2 = 1.4142135623730951;\nconst float GOLDEN_RATIO_1117569599 = 1.61803398875;\nconst float SQRT3 = 1.732050807568877;\n/* Create random direction vector\n */\nvec2 randomGradient(vec2 i) {\n    // Random float. No precomputed gradients mean this works for any number of grid coordinates\n    float random = 2920.0 *\n        sin(float(i.x) * 2.19420 + float(i.y) * 1.713240 + 8.9120) *\n        cos(float(i.x) * 2.31570 * float(i.y) * 2.178320 + 9.7580);\n//    random = (i.x + 1667.) * (i.x + 2083.) * (i.y + 2659.) * (i.y * 50.77 + .3769);\n//    random = sin(SQRT2 * i.x) + cos(GOLDEN_RATIO * i.y) + tan((i.x + i.y) * SQRT3);\n    return vec2(cos(random), sin(random)) ;\n}\n\nfloat dotGridGradient2(vec2 cell, vec2 pos) {\n    vec2 xy_d = cell - pos;\n    if (length(xy_d) > 0.4) return 0.;\n    float r = 1.;\n    float part = pow(max(0., .999 - dot(xy_d, xy_d)), 4.);\n//    vec2 gradient = texelFetch(gradients, ivec2(cell), 0).xy;\n    vec2 gradient = randomGradient(cell);\n    return part * dot(gradient, xy_d);\n}\n\n// resulting range is [-0.68, 0.68]. Use unmix to normalize if necessary.\nfloat simplex2D(vec2 xy) {\n    vec3 uvR = xy2tri(xy);\n    ivec2 baseUV = ivec2(uvR.xy);\n\n    float a = dotGridGradient2(tri2xy(vec2(baseUV)), xy);\n    float b = dotGridGradient2(tri2xy(vec2(baseUV + ivec2(1, 0))), xy);\n    float c = dotGridGradient2(tri2xy(vec2(baseUV + ivec2(0, 1))), xy);\n    float d = dotGridGradient2(tri2xy(vec2(baseUV + ivec2(1, 1))), xy);\n\n    return b + c + mix(a, d, uvR.z);\n}\n\nfloat unmix(float a, float b, float value) {\n  return (value - a) / (b - a);\n}\n\nfloat remix(float fromA, float fromB, float toA, float toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\nvec4 remix(float fromA, float fromB, vec4 toA, vec4 toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\nuniform float highResTimeStamp;\n\nfloat waves(vec4 color, vec2 position, vec2 direction) {\n    return sin(dot(position, direction / pow(length(direction), 2.0)) + float(highResTimeStamp) / 200.0);\n}\n\nconst vec4 blue_0 = vec4(0.0, 0.0, 1.0, 1.0);\nconst vec4 red_0 = vec4(1.0, 0.0, 0.0, 1.0);\n\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\n  float isLow = float(t < 0.0);\n  float isHigh = float(t > 1.0);\n  float isMid = 1.0 - isLow - isHigh;\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\n}\n\nvec4 visualize(float t) {\n  return visualize(blue_0, red_0, t);\n}\n\nvec3 raToHex(vec2 xy) {\n    float hex_t = xy.y / 0.866;\n    float hex_s = xy.x - hex_t / 2.0;\n    return vec3(hex_s, hex_t, -(hex_s + hex_t));\n}\n\nvec2 hex2Ra(vec3 hex) {\n    float y = hex.t * 0.866;\n    float x = hex.s + hex.t / 2.0;\n    return vec2(x, y);\n}\n\nvec3 hexRound(vec3 hex) {\n    vec3 r = floor(hex + 0.5);\n    vec3 diff = abs(r - hex);\n\n    if (diff.x > diff.y && diff.x > diff.z) {\n        r.x = -(r.y + r.z);\n    } else if (diff.y > diff.z) {\n        r.y = -(r.x + r.z);\n    } else {\n        r.z = -(r.x + r.y);\n    }\n\n    return r;\n}\n\nfloat max3(float a, float b, float c) {\n  return max(a, max(b, c));\n}\nfloat max3(vec3 v) {\n  return max(v.x, max(v.y, v.z));\n}\n\nfloat hexSdf(vec3 hex) {\n    return max3(abs(hex.yzx + hex.zxy / 2.0));\n}\n\nuniform sampler2D texture;\nuniform vec4 colorPrimary;\nuniform vec4 colorSecondary;\nuniform vec4 colorBg;\nuniform float a;\nuniform int bandCount;\nin float n;\nin vec2 coord;\nout vec4 fragColor;\n\nconst vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\nconst vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\nconst vec4 blue = vec4(0.0, 0.0, 1.0, 1.0);\nconst vec4 red = vec4(1.0, 0.0, 0.0, 1.0);\n\nfloat simplex01(vec2 pos) {\n    return unmix(-.68, .68, simplex2D(pos));\n}\n\nvoid main() {\n    float f = mix (simplex2D(coord), simplex2D(coord * 4.), a);\n    float f2 = simplex2D(coord);\n\n    fragColor = mix(colorBg, colorPrimary, banded(bandCount, unmix(-.35, .35, f2)));\n//    fragColor = mix(fragColor, colorSecondary, float(between(0.0, 1., f)));\n}"},1493:n=>{"use strict";n.exports="#version 300 es\nprecision highp float;\n#define GLSLIFY 1\n\nuniform mat4 ts_ModelViewProjectionMatrix;\nin vec4 ts_Vertex;\nuniform vec2 scale;\nuniform vec2 offset;\nin vec3 ts_TexCoordUVQ;\nin vec2 ts_TexCoord;\nout vec3 coordUVQ;\nout float n;\nout vec2 coord;\nvoid main() {\n    vec2 texCoordAdjusted = offset + ts_TexCoord * scale;\n    gl_Position = ts_ModelViewProjectionMatrix * ts_Vertex;\n    coordUVQ = ts_TexCoordUVQ;\n    coord = mix(vec2(-1., -1.), vec2(1., 1.), texCoordAdjusted);\n}"}}]);