(self.webpackChunkworkshop=self.webpackChunkworkshop||[]).push([[388],{6941:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "band": () => (/* binding */ band),\n  "default": () => (/* binding */ src_noises)\n});\n\n// EXTERNAL MODULE: ./node_modules/@material-ui/core/esm/Card/Card.js\nvar Card = __webpack_require__(6800);\n// EXTERNAL MODULE: ./node_modules/@material-ui/core/esm/CardContent/CardContent.js\nvar CardContent = __webpack_require__(260);\n// EXTERNAL MODULE: ./node_modules/@material-ui/core/esm/Grid/Grid.js\nvar Grid = __webpack_require__(1459);\n// EXTERNAL MODULE: ./node_modules/@material-ui/core/esm/Slider/Slider.js + 1 modules\nvar Slider = __webpack_require__(9975);\n// EXTERNAL MODULE: ./node_modules/@material-ui/core/styles/makeStyles.js\nvar makeStyles = __webpack_require__(9905);\n// EXTERNAL MODULE: ./node_modules/@material-ui/core/styles/useTheme.js\nvar useTheme = __webpack_require__(4881);\n// EXTERNAL MODULE: ./node_modules/@material-ui/core/esm/TextField/TextField.js + 1 modules\nvar TextField = __webpack_require__(5270);\n// EXTERNAL MODULE: ./node_modules/chroma.ts/dist/index.es.js\nvar index_es = __webpack_require__(7392);\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__(9526);\n// EXTERNAL MODULE: ./node_modules/ts3dutils/lib/index.es.min.js + 1 modules\nvar index_es_min = __webpack_require__(2182);\n// EXTERNAL MODULE: ../nla/tsgl/lib/index.es.min.js\nvar lib_index_es_min = __webpack_require__(9392);\n// EXTERNAL MODULE: ./src/paperBox1/useHashState.ts\nvar useHashState = __webpack_require__(1641);\n;// CONCATENATED MODULE: ./src/noises/shaders.ts\n\n\nlet shader1\n\nfunction buildShaders() {\n  shader1 = lib_index_es_min/* Shader.create */.ex.create(__webpack_require__(5395), __webpack_require__(2683))\n}\n\n(0,lib_index_es_min/* currentGL */.Qu)() && buildShaders()\n\n;// CONCATENATED MODULE: ./src/noises/index.tsx\nconst _jsxFileName = "C:\\\\Users\\\\aval\\\\tsdev\\\\workshop\\\\src\\\\noises\\\\index.tsx";\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst gradients = (0,index_es_min/* arrayFromFunction */.Nv)(512, () =>\n  index_es_min.V3.polar(1, (Math.random() - 0.5) * 2 * Math.PI),\n)\n\nconst initialState = {\n  xOffset: 0,\n  yOffset: 0,\n  xScale: 64,\n  yScale: 64,\n  bandCount: 2,\n  a: 0.5,\n}\n\n\nconst perlin = (x, y, o1) => {\n  const x0 = x | 0\n  const x1 = x0 + 1\n  const y0 = y | 0\n  const y1 = y0 + 1\n\n  const smoothstep = (x) => x * x * (3 - 2 * x)\n\n  const dotGridGradient = (ix, iy, x, y) => {\n    // Compute the distance vector\n    const dx = x - ix\n    const dy = y - iy\n\n    const gradient = (0,index_es_min/* emod */.en)(gradients, ix * 59 + iy)\n    //console.log(dx, dy, gradient)\n    // Compute the dot-product\n    return gradient.dot(new index_es_min.V3(dx, dy, 0))\n  }\n  // Interpolate between grid point gradients\n\n  const n00 = dotGridGradient(x0, y0, x, y)\n  const n10 = dotGridGradient(x1, y0, x, y)\n  const ny0 = (0,index_es_min/* lerp */.t7)(n00, n10, o1 ? smoothstep(x - x0) : x - x0)\n\n  const n01 = dotGridGradient(x0, y1, x, y)\n  const n11 = dotGridGradient(x1, y1, x, y)\n  const ny1 = (0,index_es_min/* lerp */.t7)(n01, n11, o1 ? smoothstep(x - x0) : x - x0)\n\n  return (0,index_es_min/* lerp */.t7)(ny0, ny1, o1 ? smoothstep(y - y0) : y - y0)\n}\n\nfunction makeCubicGridMesh(cylinderMesh) {\n  const cylMeshes = []\n  for (let x = -5; x < 5; x++) {\n    for (let y = -5; y < 5; y++) {\n      for (let z = -5; z < 5; z++) {\n        cylMeshes.push(\n          cylinderMesh.transform(M4.scale(1, 0.01, 0.01).translate(x, y, z)),\n          cylinderMesh.transform(\n            M4.scale(1, 0.01, 0.01)\n              .rotateY(Math.PI / 2)\n              .translate(x, y, z),\n          ),\n          cylinderMesh.transform(\n            M4.scale(1, 0.01, 0.01)\n              .rotateZ(Math.PI / 2)\n              .translate(x, y, z),\n          ),\n        )\n      }\n    }\n  }\n  const [first, ...rest] = cylMeshes\n  return first.concat(...rest)\n}\n\nfunction makeTetrahedralGridMesh(cylinderMesh) {\n  const cylMeshes = []\n\n  const SIN60 = Math.sqrt(3) / 2\n  const COS60 = Math.cos(Math.PI / 3)\n  // when a regular tetrahedron is viewed projectively so that two faces are\n  // perpendicular to the viewer, they make an isosceles triangle with sides\n  // 1, sin 60°, sin 60°. gamma is the angle between the two short sides.\n  const gamma = 2 * Math.asin(1 / Math.sqrt(3))\n  for (let x = -0; x < 2; x++) {\n    for (let y = -0; y < 2; y++) {\n      for (let z = -0; z < 1; z++) {\n        const dx = x + (y % 2 == 0 ? 0 : COS60)\n        cylMeshes.push(\n          cylinderMesh.transform(\n            index_es_min.M4.scale(1, 0.01, 0.01).translate(dx, y * SIN60, z * SIN60),\n          ),\n          cylinderMesh.transform(\n            index_es_min.M4.scale(1, 0.01, 0.01)\n              .rotateZ(Math.PI / 3)\n              .translate(dx, y * SIN60, z * SIN60),\n          ),\n          cylinderMesh.transform(\n            index_es_min.M4.scale(1, 0.01, 0.01)\n              .rotateZ((Math.PI / 3) * 2)\n              .translate(dx, y * SIN60, z * SIN60),\n          ),\n          cylinderMesh.transform(\n            index_es_min.M4.scale(1, 0.01, 0.01)\n              .rotateZ(Math.PI / 2)\n              .rotateX((Math.PI - gamma) / 2)\n              .translate(dx, y * SIN60, z * SIN60),\n          ),\n          cylinderMesh.transform(\n            index_es_min.M4.scale(1, 0.01, 0.01)\n              .rotateY(-(Math.PI / 3) * 2)\n              .rotateX(Math.PI / 2 - gamma)\n              .translate(dx, y * SIN60, z * SIN60),\n          ),\n          cylinderMesh.transform(\n            index_es_min.M4.scale(1, 0.01, 0.01)\n              .rotateY(-(Math.PI / 3))\n              .rotateX(Math.PI / 2 - gamma)\n              .translate(dx, y * SIN60, z * SIN60),\n          ),\n        )\n      }\n    }\n  }\n  const [first, ...rest] = cylMeshes\n  return first.concat(...rest)\n}\n\nconst band = (\n  minValue,\n  maxValue,\n  bandCount,\n  value,\n) =>\n  (0,index_es_min/* lerp */.t7)(\n    minValue,\n    maxValue,\n    Math.floor((0,index_es_min/* lerpInv */.kL)(minValue, maxValue, value) * 4) / (4 - 1),\n  )\n\nfunction noises(\n  gl,\n  colors,\n  dynamicState,\n) {\n  let o1 = true\n  const w = 512,\n    h = 512\n  const data = new Uint8Array(w * h)\n  const tex = new lib_index_es_min/* Texture */.xE(w, h, {\n    format: gl.RED,\n    type: gl.UNSIGNED_BYTE,\n    internalFormat: gl.R8,\n    // filter: gl.NEAREST,\n  })\n  const gradientsTex = new lib_index_es_min/* Texture */.xE(256, 256, {\n    format: gl.RG,\n    type: gl.FLOAT,\n    internalFormat: gl.RG32F,\n    data: index_es_min.V3.packXY(\n      (0,index_es_min/* arrayFromFunction */.Nv)(256 * 256, () =>\n        index_es_min.V3.polar(1, (Math.random() - 0.5) * 2 * Math.PI),\n      ),\n    ),\n  })\n  const redoTex = () => {\n    let min = Infinity,\n      max = -Infinity\n    for (let y = 0; y < h; y++) {\n      for (let x = 0; x < w; x++) {\n        //data[y * w + x] = ((x + y) / (w + h - 2)) * 255\n        const perl = (0,index_es_min/* clamp */.uZ)(\n          (perlin(\n            dynamicState.xOffset + x / dynamicState.xScale,\n            dynamicState.yOffset + y / dynamicState.yScale,\n            o1,\n          ) +\n            0.5) *\n            0.8,\n          0,\n          1,\n        )\n        const v = Math.random()\n        data[y * w + x] = (Math.floor(perl * 4) / (4 - 1)) * 255\n        max = Math.max(max, v)\n        min = Math.min(min, v)\n      }\n    }\n    data[0] = 0\n    tex.setData(data)\n  }\n\n  // const lll = M4.lookAt(V(2, -10, 5), V3.O, V3.Z).times(\n  //     M4.perspective(70, 1, 0.1, 100)\n  // )\n  // console.log("" + llli)\n  // console.log(llli.transformPoint(V(-1, -1, 1)))\n  // redoTex()\n  const planeMesh = lib_index_es_min/* Mesh.plane */.Kj.plane({ detail: 128 })\n  const sphereMesh = lib_index_es_min/* Mesh.sphere */.Kj.sphere(0)\n    .computeWireframeFromFlatTrianglesClosedMesh()\n    .compile()\n  const cylinderMesh = lib_index_es_min/* Mesh.rotation */.Kj.rotation(\n    [index_es_min.V3.Y, index_es_min.V3.XY],\n    { anchor: index_es_min.V3.O, dir1: index_es_min.V3.X },\n    2 * Math.PI,\n    3,\n    true,\n  )\n  const cubicGridMesh = makeTetrahedralGridMesh(cylinderMesh)\n  console.log(sphereMesh)\n  // const cubeMesh = Mesh.cube()\n  const shader = lib_index_es_min/* Shader.create */.ex.create(\n    `\n      uniform mat4 ts_ModelViewProjectionMatrix;\n      attribute vec4 ts_Vertex;\n      uniform float pointSize;\n      varying vec4 foo;\n      void main() {\n        foo = vec4(1.0, 1.0, 1.0, 1.0);\n        gl_Position = ts_ModelViewProjectionMatrix * ts_Vertex;\n        gl_PointSize = pointSize;\n      }\n    `,\n    `\n      precision highp float;\n      uniform vec4 color;\n      varying vec4 bar;\n      void main() {\n        gl_FragColor = color;\n        if (length(gl_PointCoord - vec2(0.5, 0.5)) > 0.5) {\n          discard;\n        }\n      }\n    `,\n  )\n\n  const perlinShader2 = lib_index_es_min/* Shader.create */.ex.create\n\n\n\n\n\n\n\n(\n    `#version 300 es\n      precision highp float;\n      \n      uniform mat4 ts_ModelViewProjectionMatrix;\n      in vec4 ts_Vertex;\n      uniform float pointSize;\n      uniform vec2 scale;\n      uniform vec2 offset;\n      in vec3 ts_TexCoordUVQ;\n      in vec2 ts_TexCoord;\n      out vec3 coordUVQ;\n      out float n;\n      out vec2 coord;\n      void main() {\n        vec2 texCoordAdjusted = offset + ts_TexCoord * scale;\n        n = 0.0;  \n        gl_Position = ts_ModelViewProjectionMatrix * \n          (ts_Vertex + vec4(0.0, 0.0, n, 0.0));\n        gl_PointSize = pointSize;\n        coordUVQ = ts_TexCoordUVQ;\n        coord = texCoordAdjusted;\n      }\n  `,\n    `#version 300 es\n      precision highp float;\n      \n      uniform sampler2D texture;\n      uniform vec4 colorPrimary;\n      uniform vec4 colorBg;\n      uniform int bandCount;\n      in float n;\n      in vec2 coord;\n      out vec4 fragColor;\n      void main() {\n        float fraction = (n + 0.5) * 0.5;\n        fragColor = mix(colorBg, colorPrimary, fraction);\n        \n        if (length(gl_PointCoord - vec2(0.5, 0.5)) > 0.5) {\n          discard;\n        }\n      }\n    `,\n  )\n  buildShaders()\n  const texShader = lib_index_es_min/* Shader.create */.ex.create\n\n\n\n\n\n\n\n(\n    `\n      uniform mat4 ts_ModelViewProjectionMatrix;\n      attribute vec4 ts_Vertex;\n      uniform float pointSize;\n      attribute vec3 ts_TexCoordUVQ;\n      attribute vec2 ts_TexCoord;\n      varying vec4 foo;\n      varying vec3 coordUVQ;\n      varying vec2 coord;\n      void main() {\n        foo = vec4(1.0, 1.0, 1.0, 1.0);\n        gl_Position = ts_ModelViewProjectionMatrix * ts_Vertex;\n        gl_PointSize = pointSize;\n        coordUVQ = ts_TexCoordUVQ;\n        coord = ts_TexCoord;\n      }\n    `,\n    `\n      precision highp float;\n      uniform sampler2D texture;\n      uniform vec4 colorPrimary;\n      uniform vec4 colorBg;\n      varying vec4 bar;\n      varying vec3 coordUVQ;\n      varying vec2 coord;\n      void main() {\n        float fraction = texture2D(texture, coord).r;\n        gl_FragColor = mix(colorBg, colorPrimary, fraction);\n        \n        if (length(gl_PointCoord - vec2(0.5, 0.5)) > 0.5) {\n          discard;\n        }\n      }\n    `,\n  )\n\n  const viewState = {\n    pos: (0,index_es_min.V)(0.75, 0, 1),\n    lookDir: (0,index_es_min.V)(0, 0, -1),\n  }\n  const saveViewState = () => {\n    localStorage.setItem(\n      "viewState",\n      JSON.stringify({\n        pos: viewState.pos.toArray(),\n        lookDir: viewState.lookDir.toArray(),\n      }),\n    )\n  }\n  const loadViewState = () => {\n    if (null != localStorage.getItem("viewState")) {\n      const json = JSON.parse(localStorage.getItem("viewState"))\n      viewState.pos = index_es_min.V3.fromArray(json.pos)\n      viewState.lookDir = index_es_min.V3.fromArray(json.lookDir)\n    }\n  }\n  loadViewState()\n\n  gl.clearColor(...colors.background)\n  gl.cullFace(gl.BACK)\n\n  // setup camera\n  const cam1 = () => {\n    gl.matrixMode(gl.PROJECTION)\n    gl.loadIdentity()\n    gl.perspective(70, gl.canvas.width / gl.canvas.height, 0.1, 1000)\n    gl.lookAt((0,index_es_min.V)(0, 0.5, 2.2), index_es_min.V3.O, index_es_min.V3.Y)\n    gl.matrixMode(gl.MODELVIEW)\n  }\n  const cam2 = () => {\n    gl.matrixMode(gl.PROJECTION)\n    gl.loadIdentity()\n    gl.perspective(70, gl.canvas.width / gl.canvas.height, 0.1, 1000)\n    gl.lookAt((0,index_es_min.V)(0.75, 0, 1), (0,index_es_min.V)(0.75, 0, 0), index_es_min.V3.Y)\n    gl.matrixMode(gl.MODELVIEW)\n  }\n  cam2()\n  gl.pointSize(10)\n\n  //gl.enable(gl.CULL_FACE)\n  gl.disable(gl.CULL_FACE)\n  gl.enable(gl.DEPTH_TEST)\n  gl.enable(gl.BLEND)\n  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)\n  const pressedKeys = {}\n  console.log(gl.canvas)\n  gl.canvas.contentEditable = "true" // make canvas focusable\n  gl.canvas.focus()\n  gl.canvas.onkeydown = function (e) {\n    pressedKeys[e.key] = true\n\n    if ("o" === e.key) {\n      o1 = !o1\n      redoTex()\n    }\n    if ("2" === e.key) {\n      cam2()\n    }\n    if ("1" === e.key) {\n      cam1()\n    }\n  }\n  gl.canvas.onkeypress = function (e) {\n    const dir = new index_es_min.V3(0, 0, 0)\n  }\n  gl.canvas.onkeyup = function (e) {\n    pressedKeys[e.key] = false\n  }\n  let lastPos = index_es_min.V3.O\n  let rot = index_es_min.M4.IDENTITY\n  const zRot = 0\n  const yRot = 0\n  gl.canvas.onmousemove2 = function (e) {\n    const pagePos = (0,index_es_min.V)(e.pageX, e.pageY)\n    const delta = lastPos.to(pagePos)\n    if (e.buttons & 1) {\n      // zRot -= delta.x * 0.25 * DEG\n      rot = rot.rotateZ(delta.x * 0.25 * index_es_min/* DEG */.Co)\n      rot = rot.rotateX(delta.y * 0.25 * index_es_min/* DEG */.Co)\n      // rot = rot.rotate(V3.O, rot.X, delta.y * 0.25 * DEG)\n      // yRot = clamp(yRot - delta.y * 0.25 * DEG, -85 * DEG, 85 * DEG)\n    }\n    lastPos = pagePos\n  }\n  gl.canvas.onmousemove = function (e) {\n    const pagePos = (0,index_es_min.V)(e.pageX, e.pageY)\n    const delta = lastPos.to(pagePos)\n    if (e.buttons & 1) {\n      // zRot -= delta.x * 0.25 * DEG\n      const rot = index_es_min.M4.rotateY(-delta.x * 0.25 * index_es_min/* DEG */.Co).rotateX(\n        -delta.y * 0.25 * index_es_min/* DEG */.Co,\n      )\n      viewState.lookDir = rot.transformVector(viewState.lookDir).unit()\n      // rot = rot.rotate(V3.O, rot.X, delta.y * 0.25 * DEG)\n      // yRot = clamp(yRot - delta.y * 0.25 * DEG, -85 * DEG, 85 * DEG)\n    }\n    lastPos = pagePos\n  }\n  let outputllll = false\n  return Object.assign(\n    gl.animate(function (abs, _diff) {\n      const speed = new index_es_min.V3(\n        +!!pressedKeys.w - +!!pressedKeys.s,\n        +!!pressedKeys.a - +!!pressedKeys.d,\n        +!!pressedKeys.e - +!!pressedKeys.q + +!!pressedKeys[" "],\n      ).times(0.05)\n      if (!speed.likeO()) {\n        const lookDirZ = viewState.lookDir\n\n        viewState.pos = viewState.pos.plus(\n          index_es_min.M4.forSys(lookDirZ, index_es_min.V3.Y.cross(lookDirZ).unit()).transformVector(\n            speed,\n          ),\n        )\n        saveViewState()\n      }\n      gl.matrixMode(gl.PROJECTION)\n      gl.loadIdentity()\n      gl.perspective(70, gl.canvas.width / gl.canvas.height, 0.1, 1000)\n      gl.lookAt(viewState.pos, viewState.pos.plus(viewState.lookDir), index_es_min.V3.Y)\n      gl.matrixMode(gl.MODELVIEW)\n\n      // const angleDeg = (abs / 1000) * 10\n      // const angleDeg = 0\n      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)\n      gl.loadIdentity()\n      // gl.rotate(yRot / DEG, 0, 1, 0)\n      // gl.rotate(-zRot / DEG, 0, 0, 1)\n      //gl.multMatrix(rot)\n\n      gl.pushMatrix()\n\n      gl.translate(0.25, -0.5, 0)\n      // shader\n      //   .uniforms({ color: colors.primary, pointSize: 12 })\n      //   .draw(planeMesh, gl.LINES)\n      tex.bind(0)\n      gradientsTex.bind(1)\n\n      const lll = index_es_min.M4.product(\n        index_es_min.M4.perspective(70, 1, 1, 50),\n        index_es_min.M4.lookAt((0,index_es_min.V)(10, 0, 10), index_es_min.V3.O, index_es_min.V3.Z),\n        index_es_min.M4.rotateZ(abs / 10000),\n      )\n      const llli = lll.inversed()\n      if (!outputllll) {\n        console.log("" + lll)\n        console.log(lll.transformPoint(index_es_min.V3.XYZ.negated()))\n        console.log(lll.transformPoint(index_es_min.V3.XYZ))\n        outputllll = true\n      }\n      shader1.uniforms({\n          a: dynamicState.a,\n          colorPrimary: colors.primary,\n          colorSecondary: colors.secondary,\n          colorBg: colors.background,\n          scale: [dynamicState.xScale, dynamicState.yScale],\n          offset: [dynamicState.xOffset, dynamicState.yOffset],\n          bandCount: dynamicState.bandCount,\n          highResTimeStamp: abs,\n          secs: abs / 1000,\n          gradients: 1,\n          lll,\n          llli,\n        })\n        .draw(planeMesh)\n\n      gl.popMatrix()\n      gl.pushMatrix()\n\n      gl.translate(-0.75, 0, 0)\n      gl.scale(0.5)\n      gl.rotate(-90, 1, 0, 0)\n      shader1.uniforms({\n          colorPrimary: colors.primary,\n          colorBg: colors.background,\n          pointSize: 12,\n          texture: 0,\n        })\n        .draw(sphereMesh)\n      shader\n        .uniforms({ color: colors.primary, pointSize: 12 })\n        .draw(sphereMesh, gl.LINES)\n      gl.popMatrix()\n\n      // shader.uniforms({ color: colors.secondary }).draw(cubicGridMesh)\n\n      //shader\n      // .uniforms({\n      //  color: chroma.css("grey").gl(),\n      // pointSize: 10,\n      // })\n      //.drawBuffers(pointMesh.vertexBuffers, undefined, gl.POINTS)\n      //shader.uniforms({ color: [1, 1, 0, 1] }).draw(pointMesh, gl.LINES)\n      //shader.uniforms({ color: [0, 0, 0, 0.5] }).draw(pointMesh,\n      // gl.TRIANGLES) gl.pushMatrix() gl.translate(30, 0, 0)\n    }),\n    {\n      redoTex,\n    },\n  )\n}\n\nconst useStyles = (0,makeStyles/* default */.Z)((theme) => ({\n  sidebar: {\n    display: "flex",\n    flexDirection: "column",\n    width: 256,\n    padding: theme.spacing(1),\n    alignItems: "stretch",\n    "& > *": {\n      margin: theme.spacing(1),\n    },\n  },\n  media: {\n    height: 0,\n    paddingTop: "100%", // 1:1\n  },\n}))\n\nfunction BoundNumberField({\n  state,\n  prop,\n  setStatePartial,\n  ...props\n}\n\n\n\n) {\n  return (\n    react.createElement(TextField/* default */.Z, {\n      variant: "outlined",\n      size: "small",\n      type: "number",\n      value: state[prop],\n      onChange: (e) =>\n        setStatePartial({ [prop]: +e.target.value } )\n      ,\n      label: prop,\n      ...props, __self: this, __source: {fileName: _jsxFileName, lineNumber: 596}}\n    )\n  )\n}\n\n/* harmony default export */ const src_noises = (() => {\n  const canvasRef = (0,react.useRef)(null)\n\n  const [state, setState] = (0,useHashState/* useHashState */.q)(initialState)\n  const setStatePartial = (0,react.useCallback)(\n    (o) => setState((s) => ({ ...s, ...o })),\n    [setState],\n  )\n  const redoTex = (0,react.useRef)()\n  const fluid = (0,react.useRef)(Object.assign({}, state))\n\n  const classes = useStyles()\n  const theme = (0,useTheme/* default */.Z)()\n  ;(0,react.useEffect)(() => {\n    const tsgl = lib_index_es_min/* TSGLContext.create */.ZG.create({ canvas: canvasRef.current })\n    //tsgl.fixCanvasRes()\n    //tsgl.addResizeListener()\n    noises(\n      tsgl,\n      {\n        background: index_es/* css */.iv(theme.palette.background.default).gl(),\n        primary: index_es/* css */.iv(theme.palette.primary.main).gl(),\n        secondary: index_es/* css */.iv(theme.palette.secondary.main).gl(),\n      },\n      fluid.current,\n    )\n  }, [\n    theme.palette.background.default,\n    theme.palette.primary.main,\n    theme.palette.secondary.main,\n  ])\n\n  ;(0,react.useEffect)(() => {\n    Object.assign(fluid.current, state)\n  }, [state])\n\n  return (\n    react.createElement(Grid/* default */.Z, { container: true, style: { height: "99%" }, __self: undefined, __source: {fileName: _jsxFileName, lineNumber: 647}}\n      , react.createElement(Grid/* default */.Z, { item: true, xs: 12, md: 9, __self: undefined, __source: {fileName: _jsxFileName, lineNumber: 648}}\n        , react.createElement(\'div\', { style: { height: "100%" }, __self: undefined, __source: {fileName: _jsxFileName, lineNumber: 649}}\n          , react.createElement(\'canvas\', {\n            ref: canvasRef,\n            style: { width: "100%", height: "100%" },\n            width: 1024,\n            height: 1024,\n            tabIndex: 0, __self: undefined, __source: {fileName: _jsxFileName, lineNumber: 650}}\n          )\n        )\n      )\n      , react.createElement(Grid/* default */.Z, { item: true, xs: 12, md: 3, className: classes.sidebar, __self: undefined, __source: {fileName: _jsxFileName, lineNumber: 659}}\n        , react.createElement(Card/* default */.Z, {__self: undefined, __source: {fileName: _jsxFileName, lineNumber: 660}}\n          , react.createElement(CardContent/* default */.Z, {__self: undefined, __source: {fileName: _jsxFileName, lineNumber: 661}}, "Test with various noise generation functions."\n\n          )\n        )\n        , react.createElement(BoundNumberField, { ...{ state, setStatePartial }, prop: "xOffset", __self: undefined, __source: {fileName: _jsxFileName, lineNumber: 665}} )\n        , react.createElement(BoundNumberField, { ...{ state, setStatePartial }, prop: "yOffset", __self: undefined, __source: {fileName: _jsxFileName, lineNumber: 666}} )\n        , react.createElement(BoundNumberField, { ...{ state, setStatePartial }, prop: "xScale", __self: undefined, __source: {fileName: _jsxFileName, lineNumber: 667}} )\n        , react.createElement(BoundNumberField, { ...{ state, setStatePartial }, prop: "yScale", __self: undefined, __source: {fileName: _jsxFileName, lineNumber: 668}} )\n        , react.createElement(BoundNumberField, { ...{ state, setStatePartial }, prop: "bandCount", __self: undefined, __source: {fileName: _jsxFileName, lineNumber: 669}} )\n        , react.createElement(\'div\', {__self: undefined, __source: {fileName: _jsxFileName, lineNumber: 670}}\n          , react.createElement(Slider/* default */.Z, {\n            value: state.a,\n            onChange: (e, a) => setStatePartial({ a }),\n            min: 0,\n            max: 1,\n            step: 0.01, __self: undefined, __source: {fileName: _jsxFileName, lineNumber: 671}}\n          )\n        )\n      )\n    )\n  )\n});\n\nif (false) {}\n\n\n//# sourceURL=webpack://workshop/./src/noises/index.tsx_+_1_modules?')},1641:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "q": () => (/* binding */ useHashState)\n/* harmony export */ });\n/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6897);\n/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var lodash_mapValues__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(508);\n/* harmony import */ var lodash_mapValues__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_mapValues__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9526);\n\n\n\n\nconst parseHash = (hash) => {\n  return !hash\n    ? {}\n    : hash\n        .substr(1)\n        .split("&")\n        .map((part) => {\n          const [key, value] = part.split("=")\n          return [decodeURIComponent(key), decodeURIComponent(value)]\n        })\n        .reduce((obj, [key, value]) => {\n          obj[key] = value\n          return obj\n        }, {} )\n}\nconst objectToHash = (o) => {\n  return (\n    "#" +\n    Object.entries(o)\n      .map(\n        ([key, value]) =>\n          encodeURIComponent(key) + "=" + encodeURIComponent(value),\n      )\n      .join("&")\n  )\n}\n\nconst defaultDeserialize = (\n  x,\n) =>\n  lodash_mapValues__WEBPACK_IMPORTED_MODULE_1___default()(x, (v) => {\n    if ("true" === v) {\n      return true\n    } else if ("false" === v) {\n      return false\n    } else if ("NaN" === v) {\n      return NaN\n    } else if ("undefined" === v) {\n      return undefined\n    } else if ("null" === v) {\n      return null\n    } else if (!isNaN(+v)) {\n      return +v\n    } else {\n      return v\n    }\n  })\nconst defaultSerialize = (x) =>\n  lodash_mapValues__WEBPACK_IMPORTED_MODULE_1___default()(x, (v) => "" + v)\n\nfunction useHashState(\n  initialState,\n  {\n    deserialize = defaultDeserialize,\n    serialize = defaultSerialize,\n    wait = 1000,\n  } = {},\n) {\n  const createInitialState = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)(() => {\n    const state =\n      "function" === typeof initialState\n        ? (initialState )()\n        : initialState\n    // hash overrides parameter\n    const mergedState = deserialize(\n      Object.assign(serialize(state), parseHash(document.location.hash)),\n    ) \n    history.pushState(\n      undefined,\n      document.title,\n      objectToHash(serialize(mergedState)),\n    )\n\n    return mergedState\n  }, [deserialize, initialState, serialize])\n  const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(createInitialState)\n  const updateHashRef = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)()\n  if (!updateHashRef.current) {\n    updateHashRef.current = lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default()(function (newState) {\n      history.pushState(\n        undefined,\n        document.title,\n        objectToHash(serialize(newState)),\n      )\n    }, wait)\n  }\n  updateHashRef.current(state)\n  ;(0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(() => {\n    const onHashChange = () => {\n      setState(createInitialState())\n    }\n    window.addEventListener("hashchange", onHashChange)\n    return () => {\n      window.removeEventListener("hashchange", onHashChange)\n    }\n  }, [createInitialState])\n  return [state, setState]\n}\n\n\n//# sourceURL=webpack://workshop/./src/paperBox1/useHashState.ts?')},2683:module=>{"use strict";eval('module.exports = "#version 300 es\\nprecision highp float;\\n#define GLSLIFY 1\\n\\nfloat banded(float bandCount, float t) {\\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\\n}\\nfloat banded(int bandCount, float t) {\\n  return banded(float(bandCount), t);\\n}\\n\\nbool between(float min, float max, float value) {\\n    return min <= value && value <= max;\\n}\\n\\nvec2 hex2Ra(vec3 hex) {\\n    float y = hex.t * 0.866;\\n    float x = hex.s + hex.t / 2.0;\\n    return vec2(x, y);\\n}\\n\\nvec3 hexRound(vec3 hex) {\\n    vec3 r = floor(hex + 0.5);\\n    vec3 diff = abs(r - hex);\\n\\n    if (diff.x > diff.y && diff.x > diff.z) {\\n        r.x = -(r.y + r.z);\\n    } else if (diff.y > diff.z) {\\n        r.y = -(r.x + r.z);\\n    } else {\\n        r.z = -(r.x + r.y);\\n    }\\n\\n    return r;\\n}\\n\\nfloat max3(float a, float b, float c) {\\n  return max(a, max(b, c));\\n}\\nfloat max3(vec3 v) {\\n  return max(v.x, max(v.y, v.z));\\n}\\n\\nfloat hexSdf(vec3 hex) {\\n    return max3(abs(hex.yzx + hex.zxy / 2.0));\\n}\\n\\nuniform sampler2D gradients;\\n\\nfloat dotGridGradient(vec2 cell, vec2 pos) {\\n    vec2 d = cell - pos;\\n\\n    vec2 gradient = texelFetch(gradients, ivec2(cell), 0).xy;\\n    return dot(gradient, d);\\n}\\n\\nfloat mixx(float a, float b, float t) {\\n     return mix(a, b, smoothstep(0.0, 1.0, t));\\n//    return mix(a, b, t);\\n}\\n\\n// resulting range is [-0.68, 0.68]. Use unmix to normalize if necessary.\\nfloat perlin2D(vec2 xy) {\\n    float x0 = floor(xy.x);\\n    float x1 = x0 + 1.0;\\n    float y0 = floor(xy.y);\\n    float y1 = y0 + 1.0;\\n\\n    // Interpolate between grid point gradients\\n    float n00 = dotGridGradient(vec2(x0, y0), xy);\\n    float n10 = dotGridGradient(vec2(x1, y0), xy);\\n    float ny0 = mixx(n00, n10, xy.x - x0);\\n\\n    float n01 = dotGridGradient(vec2(x0, y1), xy);\\n    float n11 = dotGridGradient(vec2(x1, y1), xy);\\n    float ny1 = mixx(n01, n11, xy.x - x0);\\n\\n    return mixx(ny0, ny1, xy.y - y0);\\n}\\n\\nfloat unmix(float a, float b, float value) {\\n  return (value - a) / (b - a);\\n}\\n\\nvec3 polar(float radius, float phi, float z) {\\n  return vec3(radius * cos(phi), radius * sin(phi), z);\\n}\\n\\nvec3 raToHex(vec2 xy) {\\n    float hex_t = xy.y / 0.866;\\n    float hex_s = xy.x - hex_t / 2.0;\\n    return vec3(hex_s, hex_t, -(hex_s + hex_t));\\n}\\n\\nfloat remix(float fromA, float fromB, float toA, float toB, float value) {\\n  return mix(toA, toB, unmix(fromA, fromB, value));\\n}\\n\\nvec4 remix(float fromA, float fromB, vec4 toA, vec4 toB, float value) {\\n  return mix(toA, toB, unmix(fromA, fromB, value));\\n}\\n\\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\\n  float isLow = float(t < 0.0);\\n  float isHigh = float(t > 1.0);\\n  float isMid = 1.0 - isLow - isHigh;\\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\\n}\\n\\nuniform float highResTimeStamp_0;\\n\\nfloat waves(vec4 color, vec2 position, vec2 direction) {\\n    return sin(dot(position, direction / pow(length(direction), 2.0)) + float(highResTimeStamp_0) / 200.0);\\n}\\n\\nmat3 rotX(float angle) {\\n    float c = cos(angle), s = sin(angle);\\n    return mat3(\\n    1., 0., 0.,\\n    0., c, -s,\\n    0., s, c);\\n}\\n\\nuniform sampler2D texture;\\nuniform float secs;\\nuniform mat4 lll;\\nuniform mat4 llli;\\nuniform vec4 colorPrimary;\\nuniform vec4 colorSecondary;\\nuniform vec4 colorBg;\\nuniform float a;\\nuniform float highResTimeStamp;\\nuniform int bandCount;\\nin float n;\\nin vec2 coord;\\nout vec4 fragColor;\\n\\nconst float TAU = 6.283185307179586;\\n\\nconst vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\\nconst vec4 yellow = vec4(1.0, 1.0, 0.0, 1.0);\\nconst vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\\nconst vec4 blue = vec4(0.0, 0.0, 1.0, 1.0);\\nconst vec4 red = vec4(1.0, 0.0, 0.0, 1.0);\\n\\nfloat donut(float r0, float r1, vec3 p) {\\n    vec3 closestCenter = vec3(normalize(p.xy) * r0, 0.0);\\n    return distance(closestCenter, p) - r1;\\n}\\n\\nfloat sphere(float radius, vec3 p) {\\n    return length(p) - radius;\\n}\\n\\nfloat cylinder(float r, float height, vec3 p) {\\n    float a = length(p.xy) - r;\\n    float b = p.z - height;\\n    float c = -p.z;\\n    return max(a, max(b, c));\\n}\\n\\nfloat skybox(vec3 p) {\\n    return 64. - max3(abs(p));\\n}\\n\\nfloat perlinSphere(float radius, vec3 p) {\\n    vec3 cp = normalize(p);\\n    float alpha = atan(cp.y, cp.x);\\n    float beta = asin(cp.z);\\n    return length(p) - radius + 0.1 * perlin2D(vec2(0. / 100., 0.) + (vec2(5.)+vec2(alpha, beta))*8.0);\\n}\\n\\nfloat block(vec3 min, vec3 maxx, vec3 p) {\\n    return max(max3(p - maxx), max3(-p + min));\\n}\\nfloat sub(float from, float what) {\\n    return max(from, -what);\\n}\\nfloat add(float a, float b) {\\n    return min(a, b);\\n}\\nfloat cylCircle(vec3 p) {\\n    float d = 10e9;\\n    for (int i = 0; i < 10; i++) {\\n        d = min(d, cylinder(0.2, 2., p + polar(3., TAU * float(i) / 10., 1.)));\\n    }\\n\\n    return d;\\n}\\n\\nfloat addWithRadius(float r, float a, float b) {\\n    if (a < r && b < r) {\\n        return r - distance(vec2(a, b), vec2(r));\\n    } else {\\n        return min(a ,b);\\n    }\\n}\\n\\nfloat sdf(vec3 p) {\\n    float d = skybox(p);\\n    d = add(d, block(vec3(-5., -5., -1.), vec3(5., 5., 0.), p));\\n    d = -addWithRadius(0.1, -d, donut(2., 0.5, p));\\n    d = -addWithRadius(0.1, -d, donut(4., 0.5, p));\\n    d = add(d, sphere(0.5, p));\\n    d = add(d, perlinSphere(1., p - vec3(-2.0, 0.0, 3.0)));\\n//    d = add(d, cylCircle(p));\\n\\n//    d = add(d, sphere(p - vec3(3., 3., 0.)));\\n    d = sub(d, cylinder(1.3, 4.5, rotX(0./30. * TAU) * p- vec3(2.0, 0.0, 0.0) - vec3(0., 0., -2.25)));\\n    d = add(d, cylinder(0.8, 4., rotX(0./30. * TAU) * p- vec3(2.0, 0.0, 0.0) - vec3(0., 0., -2.)));\\n    d = sub(d, cylCircle(p));\\n    d -= 0.2;\\n    return d;\\n}\\n\\nvec3 raymarching(vec3 start, vec3 dir1) {\\n    vec3 pos = start;\\n    for (int i = 0; i < 60; i++) {\\n        float d = sdf(pos);\\n        if (d < 0.) break;\\n        pos = pos + dir1 * d;\\n    }\\n    return pos;\\n}\\n\\nvec3 pt(mat4 pm, vec3 p) {\\n    vec4 pStar = pm * vec4(p, 1.0);\\n    return pStar.xyz / pStar.w;\\n}\\n\\nconst float eps = 1e-5;\\nvec3 sdfNormal(vec3 p) {\\n    float d = sdf(p);\\n    return (vec3(\\n        sdf(p + vec3(eps, 0., 0.)),\\n        sdf(p + vec3(0., eps, 0.)),\\n        sdf(p + vec3(0., 0., eps))\\n    ) - vec3(d)) / eps;\\n}\\n\\nvoid main() {\\n    vec3 light = normalize(vec3(-1., -1., -1));\\n\\n    vec3 a = vec3(coord, -1.);\\n    vec3 b = vec3(coord, 1.);\\n    vec3 aWC = pt(llli, a);\\n    vec3 bWC = pt(llli, b);\\n    vec3 lookDir1 = normalize(bWC - aWC);\\n\\n    vec3 hitWC = raymarching(aWC, lookDir1);\\n    vec3 hitn1 = normalize(sdfNormal(hitWC));\\n    float dWC = distance(aWC, hitWC);\\n\\n    vec3 sunPoint = raymarching(hitWC -light *.1, -light);\\n    float inSun = float(distance(hitWC, sunPoint) > 50.);\\n\\n    vec3 camPos = aWC;\\n\\n    vec3 reflectionDirection = reflect(light, hitn1);\\n    vec3 eyeDirection = -lookDir1;\\n    float uMaterialShininess = 256.0;\\n    float specularLightWeighting = pow(max(dot(reflectionDirection, eyeDirection), 0.0), uMaterialShininess);\\n    float lightIntensity = 0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.) + 0.3*specularLightWeighting;\\n    fragColor = visualize(blue, red, mix(0.5, 1.0, inSun) * lightIntensity);\\n    fragColor = mix(colorPrimary, colorBg, mix(0.5, 1.0, inSun) * clamp(lightIntensity, 0., 1.));\\n//    fragColor = visualize(blue, red, dWC/20.);\\n//    fragColor = visualize(blue, red, distance(hitWC, sunPoint)/20.);\\n//    fragColor = vec4(aWC, 1.0);\\n//    fragColor = vec4(coord, 0.0, 1.);\\n}";\n\n//# sourceURL=webpack://workshop/./src/noises/rm.glsl?')},5395:module=>{"use strict";eval('module.exports = "#version 300 es\\nprecision highp float;\\n#define GLSLIFY 1\\n\\nuniform mat4 ts_ModelViewProjectionMatrix;\\nin vec4 ts_Vertex;\\nuniform vec2 scale;\\nuniform vec2 offset;\\nin vec3 ts_TexCoordUVQ;\\nin vec2 ts_TexCoord;\\nout vec3 coordUVQ;\\nout float n;\\nout vec2 coord;\\nvoid main() {\\n    vec2 texCoordAdjusted = offset + ts_TexCoord * scale;\\n    gl_Position = ts_ModelViewProjectionMatrix * ts_Vertex;\\n    coordUVQ = ts_TexCoordUVQ;\\n    coord = mix(vec2(-1., -1.), vec2(1., 1.), ts_TexCoord);\\n}";\n\n//# sourceURL=webpack://workshop/./src/noises/vs.glsl?')}}]);