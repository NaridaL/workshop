(self.webpackChunkworkshop=self.webpackChunkworkshop||[]).push([[392],{9392:(t,e,r)=>{"use strict";r.d(e,{lW:()=>a,Kj:()=>p,ex:()=>_,ZG:()=>P,xE:()=>T});var i=r(2182),s=r(8149),n=r(7769);const o=WebGLRenderingContext;class a{constructor(t,e){this.target=t,this.type=e,this.buffer=void 0,this.data=[],this.count=0,this.spacing=1,this.hasBeenCompiled=!1,(0,i.hu)(t==o.ARRAY_BUFFER||t==o.ELEMENT_ARRAY_BUFFER,"target == WGL.ARRAY_BUFFER || target == WGL.ELEMENT_ARRAY_BUFFER"),(0,i.hu)(e==Float32Array||e==Uint16Array||e==Uint32Array,"type == Float32Array || type == Uint16Array || type == Uint32Array"),Uint16Array==e?this.bindSize=o.UNSIGNED_SHORT:Uint32Array==e&&(this.bindSize=o.UNSIGNED_INT)}compile(t=o.STATIC_DRAW,e=F()){let r;if((0,i.hu)(o.STATIC_DRAW==t||o.DYNAMIC_DRAW==t,"WGL.STATIC_DRAW == type || WGL.DYNAMIC_DRAW == type"),this.buffer=this.buffer||e.createBuffer(),0==this.data.length&&console.warn("empty buffer "+this.name),0==this.data.length||this.data[0]instanceof i.V3)(0,i.hu)(!(this.data[0]instanceof i.V3)||this.type==Float32Array),i.V3.pack(this.data,r=new this.type(3*this.data.length)),this.spacing=3,this.count=this.data.length,this.maxValue=0;else{if(Array.isArray(this.data[0])){const t=this.data.length*this.data[0].length;r=new this.type(t);let e=this.data.length,s=t;for(;e--;){const t=this.data[e];let i=t.length;for(;i--;)r[--s]=t[i]}(0,i.hu)(0==s)}else r=new this.type(this.data);const t=this.data.length?r.length/this.data.length:0;(0,i.hu)(t%1==0,`buffer ${this.name} elements not of consistent size, average size is `+t),i.wU&&(1e4<=r.length?this.maxValue=0:this.maxValue=Math.max.apply(void 0,r)),(0,i.hu)([1,2,3,4].includes(t)),this.spacing=t,this.count=this.data.length}e.bindBuffer(this.target,this.buffer),e.bufferData(this.target,r,t),this.hasBeenCompiled=!0}}const{cos:h,sin:c,PI:f,min:u,max:l}=Math,d=WebGLRenderingContext,m=new i.M4,g=new i.M4;class p extends i.yu{constructor(){super(),this.hasBeenCompiled=!1,this.vertexBuffers={},this.indexBuffers={},this.addVertexBuffer("vertices","ts_Vertex")}calcVolume(){let t=0,e=i.V3.O,r=0;const s=this.TRIANGLES,n=this.vertices;for(let o=0;o<s.length;o+=3){const a=s[o+0],h=s[o+1],c=s[o+2],f=n[a],u=n[h],l=n[c],d=u.minus(f),m=l.minus(f),g=d.cross(m);t+=i.V3.add(f,u,l).div(3).z*g.z,r+=g.length();const p=i.V3.add(f.times(2*f.z+u.z+l.z),u.times(f.z+2*u.z+l.z),l.times(f.z+u.z+2*l.z)).times(g.z);e=e.plus(p)}const o=t/2;return{volume:o,centroid:(0,i.p3)(o)?i.V3.O:e.div(24*o).schur(new i.V3(1,1,.5)),area:r/2}}addVertexBuffer(t,e){return(0,i.hu)(!this.vertexBuffers[e],"Buffer "+e+" already exists."),this.hasBeenCompiled=!1,(0,i.hu)("string"==typeof t),(0,i.hu)("string"==typeof e),(this.vertexBuffers[e]=new a(d.ARRAY_BUFFER,Float32Array)).name=t,this[t]=[],this}addIndexBuffer(t,e=d.UNSIGNED_SHORT){this.hasBeenCompiled=!1;const r=d.UNSIGNED_SHORT==e?Uint16Array:Uint32Array;return(this.indexBuffers[t]=new a(d.ELEMENT_ARRAY_BUFFER,r)).name=t,this[t]=[],this}concat(...t){const e=new p,r=[this].concat(t);return Object.getOwnPropertyNames(this.vertexBuffers).forEach((s=>{(0,i.hu)(t.every((t=>!!t.vertexBuffers[s])));const n=this.vertexBuffers[s].name;"ts_Vertex"!==s&&e.addVertexBuffer(n,s),e[n]=[].concat(...r.map((t=>t[n])))})),Object.getOwnPropertyNames(this.indexBuffers).forEach((s=>{(0,i.hu)(t.every((t=>!!t.indexBuffers[s]))),e.addIndexBuffer(s,this.indexBuffers[s].bindSize);const n=Array(r.reduce(((t,e)=>t+e[s].length),0));let o=0,a=0;for(const t of r){for(const e of t[s])n[o++]=a+e;a+=t.vertices.length}e[s]=n})),e.compile(),e}compile(t=F()){let e=1/0;Object.getOwnPropertyNames(this.vertexBuffers).forEach((r=>{const i=this.vertexBuffers[r];i.data=this[i.name],i.compile(void 0,t),this[i.name].length<e&&(e=this[i.name].length)}));for(const e in this.indexBuffers){const r=this.indexBuffers[e];r.data=this[r.name],r.compile(void 0,t)}return this.hasBeenCompiled=!0,this}static fromBinarySTL(t){return(0,s.mG)(this,void 0,void 0,(function*(){return new Promise(((e,r)=>{const s=(new p).addVertexBuffer("normals","ts_Normal"),n=new FileReader;n.onerror=r,n.onload=function(t){const r=new DataView(this.result),n=r.getUint32(80,!0);s.normals.length=3*n,s.vertices.length=3*n;let o=3*n,a=84;function h(){const t=r.getFloat32(a,!0);a+=4;const e=r.getFloat32(a,!0);a+=4;const s=r.getFloat32(a,!0);return a+=4,new i.V3(t,e,s)}for(;o;){o-=3;const t=h();s.normals[o+0]=t,s.normals[o+1]=t,s.normals[o+2]=t,s.vertices[o+0]=h(),s.vertices[o+1]=h(),s.vertices[o+2]=h(),a+=2}e(s)},n.readAsArrayBuffer(t)}))}))}toBinarySTL(){if(!this.TRIANGLES)throw Error("TRIANGLES must be defined.");const t=this.TRIANGLES,e=t.length/3,r=new ArrayBuffer(84+50*e),s=new DataView(r);s.setUint32(80,e,!0);let n=84,o=t.length;for(;o;){o-=3;const e=this.vertices[t[o]],r=this.vertices[t[o+1]],a=this.vertices[t[o+2]];[i.V3.normalOnPoints(e,r,a),e,r,a].forEach((t=>{s.setFloat32(n,t.x,!0),n+=4,s.setFloat32(n,t.y,!0),n+=4,s.setFloat32(n,t.z,!0),n+=4})),n+=2}return(0,i.hu)(n==r.byteLength,n+" "+r.byteLength),new Blob([r],{type:"application/octet-stream"})}transform(t){const e=new p;if(e.vertices=t.transformedPoints(this.vertices),this.normals){e.addVertexBuffer("normals","ts_Normal");const r=t.as3x3(m).inversed(g).transposed(m);e.normals=this.normals.map((t=>r.transformVector(t).unit()))}for(const t in this.indexBuffers)e.addIndexBuffer(t),e[t]=this[t];for(const t in this.vertexBuffers)if("ts_Vertex"!==t&&"ts_Normal"!==t){const r=this.vertexBuffers[t].name;e.addVertexBuffer(r,t),e[r]=this[r]}return e}computeNormalsFromFlatTriangles(){this.normals||this.addVertexBuffer("normals","ts_Normal");const t=this.TRIANGLES,e=this.vertices,r=this.normals;r.length=e.length;for(let i=0;i<t.length;i+=3){const s=t[i],n=t[i+1],o=t[i+2],a=e[s],h=e[n],c=e[o],f=h.minus(a).cross(c.minus(a)).unit();r[s]=r[s]?r[s].plus(f):f,r[n]=r[n]?r[n].plus(f):f,r[o]=r[o]?r[o].plus(f):f}for(let t=0;t<e.length;t++)r[t]=r[t].unit();return this.hasBeenCompiled=!1,this}computeWireframeFromFlatTriangles(t="LINES"){if(!this.TRIANGLES)throw Error("TRIANGLES must be defined.");const e=new Set;function r(t,e){return u(t,e)<<16|l(t,e)}const i=this.TRIANGLES;for(let t=0;t<i.length;t+=3)e.add(r(i[t+0],i[t+1])),e.add(r(i[t+1],i[t+2])),e.add(r(i[t+2],i[t+0]));const s=t;return this[s]||this.addIndexBuffer(t),e.forEach((t=>this[s].push(t>>16,65535&t))),this.hasBeenCompiled=!1,this}computeWireframeFromFlatTrianglesClosedMesh(t="LINES"){if(!this.TRIANGLES)throw Error("TRIANGLES must be defined.");this.LINES||this.addIndexBuffer("LINES");const e=this.TRIANGLES;this[t]||this.addIndexBuffer(t);const r=this[t];for(let t=0;t<e.length;t+=3)e[t+0]<e[t+1]&&r.push(e[t+0],e[t+1]),e[t+1]<e[t+2]&&r.push(e[t+1],e[t+2]),e[t+2]<e[t+0]&&r.push(e[t+2],e[t+0]);return this.hasBeenCompiled=!1,this}computeNormalLines(t=1,e="LINES"){if(!this.normals)throw Error("normals must be defined.");const r=this.vertices,i=this.vertices.length;this[e]||this.addIndexBuffer(e);for(let s=0;s<this.normals.length;s++)r[i+s]=r[s].plus(this.normals[s].toLength(t)),this[e].push(i+s,s);return this.hasBeenCompiled=!1,this}getAABB(){return(new i.mN).addPoints(this.vertices)}getBoundingSphere(){const t={center:this.getAABB().getCenter(),radius:0};for(let e=0;e<this.vertices.length;e++)t.radius=Math.max(t.radius,this.vertices[e].minus(t.center).length());return t}static plane(t={}){const e=t.detailX||t.detail||1,r=t.detailY||t.detail||1,s=t.startX||0,n=t.startY||0,o=t.width||1,a=t.height||1,h=(new p).addIndexBuffer("LINES").addIndexBuffer("TRIANGLES").addVertexBuffer("normals","ts_Normal").addVertexBuffer("coords","ts_TexCoord");for(let t=0;t<=r;t++){const c=t/r;for(let f=0;f<=e;f++){const u=f/e;if(h.vertices.push(new i.V3(s+u*o,n+c*a,0)),h.coords.push([u,c]),h.normals.push(i.V3.Z),f<e&&t<r){const r=f+t*(e+1);h.TRIANGLES.push(r,r+1,r+e+1,r+e+1,r+1,r+e+2)}}}for(let t=0;t<e;t++)h.LINES.push(t,t+1),h.LINES.push((e+1)*r+t,(e+1)*r+t+1);for(let t=0;t<r;t++)h.LINES.push(e*t,e*(t+1)+1),h.LINES.push(e*(t+1),e*(t+2)+1);return h.compile(),h}static box(t=1,e=1,r=1){const s=(new p).addIndexBuffer("LINES").addIndexBuffer("TRIANGLES").addVertexBuffer("normals","ts_Normal");s.vertices.length=s.normals.length=2*((t+1)*(e+1)+(e+1)*(r+1)+(r+1)*(t+1)),s.TRIANGLES.length=4*(t*e+e*r+r*t);let n=0,o=0;function a(t,e,r,a=0,h=1,c=0,f=1){const u=r.transformVector(i.V3.Z);for(let l=0;l<=e;l++){const d=l/e;for(let m=0;m<=t;m++){const g=m/t;if(s.vertices[n]=r.transformPoint(new i.V3(a+g*h,c+d*f,0)),s.normals[n]=u,n++,m<t&&l<e){const e=m+l*(t+1);s.TRIANGLES[o++]=e,s.TRIANGLES[o++]=e+t+1,s.TRIANGLES[o++]=e+1,s.TRIANGLES[o++]=e+t+1,s.TRIANGLES[o++]=e+t+2,s.TRIANGLES[o++]=e+1}}}}return a(e,t,i.M4.forSys(i.V3.Y,i.V3.X,i.V3.Z.negated())),a(t,e,i.M4.translate(i.V3.Z)),a(r,e,i.M4.forSys(i.V3.Z,i.V3.Y,i.V3.X.negated())),a(e,r,i.M4.forSys(i.V3.Y,i.V3.Z,i.V3.X,i.V3.X)),a(t,r,i.M4.forSys(i.V3.X,i.V3.Z,i.V3.Y.negated())),a(r,t,i.M4.forSys(i.V3.Z,i.V3.X,i.V3.Y,i.V3.Y)),s}static cube(){const t=(new p).addVertexBuffer("normals","ts_Normal").addIndexBuffer("TRIANGLES").addIndexBuffer("LINES"),e=[[0,4,6,2],[1,3,7,5],[0,1,5,4],[2,6,7,3],[0,2,3,1],[4,5,7,6]],r=[i.V3.X.negated(),i.V3.X,i.V3.Y.negated(),i.V3.Y,i.V3.Z.negated(),i.V3.Z];for(let i=0;i<6;i++)O(t.TRIANGLES,!0,t.vertices.length,t.vertices.length+1,t.vertices.length+3,t.vertices.length+2),t.vertices.push(...e[i].map((t=>p.UNIT_CUBE_CORNERS[t]))),t.normals.push(r[i],r[i],r[i],r[i]);return t.LINES=[[0,1],[0,2],[1,3],[2,3],[0,4],[1,5],[2,6],[3,7],[4,5],[4,6],[5,7],[6,7]].flatMap((t=>t)).map((t=>{let r=0;return 4*e.findIndex((e=>-1!=(r=e.indexOf(t))))+r})),t.compile(),t}static isocahedron(){return p.sphere(0)}static sphere2(t,e){const r=(0,i.Nv)(t,(e=>{const r=e/(t-1)*f-f/2;return new i.V3(0,h(r),c(r))})),s=(0,i.Nv)(t,(e=>{const r=h(e/(t-1)*f-f/2);return[e/(t-1)*r,r]}));return p.rotation(r,{anchor:i.V3.O,dir1:i.V3.Z},2*f,e,!0,r,s)}static sphere(t=3){const e=new i.V3(1,1.618033988749895,0).unit(),r=e.x,s=e.y,n=[new i.V3(-r,s,0),new i.V3(r,s,0),new i.V3(-r,-s,0),new i.V3(r,-s,0),new i.V3(0,-r,s),new i.V3(0,r,s),new i.V3(0,-r,-s),new i.V3(0,r,-s),new i.V3(s,0,-r),new i.V3(s,0,r),new i.V3(-s,0,-r),new i.V3(-s,0,r)],o=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];function a(t,e,r,i,s,n,o,h,c,f){if(0==i)n.push(o,h,c),o<h&&f.push(o,h),h<c&&f.push(h,c),c<o&&f.push(c,o);else{const u=t.plus(e).toLength(1),l=e.plus(r).toLength(1),d=r.plus(t).toLength(1),m=s.length,g=m+1,p=m+2;s.push(u,l,d),a(u,l,d,i-1,s,n,m,g,p,f),a(t,u,d,i-1,s,n,o,m,p,f),a(e,l,u,i-1,s,n,h,g,m,f),a(r,d,l,i-1,s,n,c,p,g,f)}}const h=(new p).addVertexBuffer("normals","ts_Normal").addIndexBuffer("TRIANGLES").addIndexBuffer("LINES");h.vertices.push(...n),t=null==t?4:t;for(let e=0;e<20;e++){const[r,i,s]=o.slice(3*e,3*e+3);a(n[r],n[i],n[s],t,h.vertices,h.TRIANGLES,r,i,s,h.LINES)}return h.normals=h.vertices,h.compile(),h}static aabb(t){const e=i.M4.product(i.M4.translate(t.min),i.M4.scale(t.size().max(new i.V3(i.bE,i.bE,i.bE)))),r=p.cube().transform(e);return r.computeNormalLines(20),r.compile(),r}static offsetVertices(t,e,r,s){i.nY.apply(void 0,t),(0,i.nY)(e);const n=(new p).addIndexBuffer("TRIANGLES").addVertexBuffer("coords","ts_TexCoord");s&&n.addVertexBuffer("normals","ts_Normal"),n.vertices=t.concat(t.map((t=>t.plus(e))));const o=t.length;n.coords=(0,i.Nv)(2*o,(t=>[t%o/o,t/o|0]));const a=n.TRIANGLES;for(let e=0;e<t.length-1;e++)O(a,!1,e,e+1,t.length+e,t.length+e+1);return r&&O(a,!1,t.length-1,0,2*t.length-1,t.length),s&&(n.normals=s.concat(s)),n.compile(),n}static rotation(t,e,r,s,n=!0,o,a){const h=(new p).addIndexBuffer("TRIANGLES");o&&h.addVertexBuffer("normals","ts_Normal"),a&&h.addVertexBuffer("coordsUVQ","ts_TexCoordUVQ");const c=t.length,f=c*s,u=new i.M4,l=h.TRIANGLES;for(let d=0;d<s;d++){const m=r*(d/s);if(i.M4.rotateLine(e.anchor,e.dir1,m,u),h.vertices.push(...u.transformedPoints(t)),o&&h.normals.push(...u.transformedVectors(o)),a&&h.coordsUVQ.push(...a.map((([t,e])=>[d/s*e,t,e]))),n||d!==s-1)for(let t=0;t<c-1;t++)O(l,!1,d*c+t+1,d*c+t,((d+1)*c+t+1)%f,((d+1)*c+t)%f)}return h.compile(),h}static spiral(t,e,r,s,n,o,a){const h=(new p).addIndexBuffer("TRIANGLES");o&&h.addVertexBuffer("normals","ts_Normal"),a&&h.addVertexBuffer("coordsUVQ","ts_TexCoordUVQ");const c=t.length,f=c*s,u=new i.M4,l=h.TRIANGLES;for(let d=0;d<s;d++){const m=r*(d/s);if(i.M4.rotateLine(e.anchor,e.dir1,m,u),h.vertices.push(...u.translate(e.dir1.toLength(r/i.gc*(d/s)*n)).transformedPoints(t)),o&&h.normals.push(...u.transformedVectors(o)),a&&h.coordsUVQ.push(...a.map((([t,e])=>[d/s*e,t,e]))),d!==s-1)for(let t=0;t<c-1;t++)O(l,!1,d*c+t+1,d*c+t,((d+1)*c+t+1)%f,((d+1)*c+t)%f)}return h.compile(),h}static parametric(t,e,r,s,n,o,a,h){const c=(new p).addIndexBuffer("TRIANGLES").addVertexBuffer("normals","ts_Normal");for(let f=0;f<=a;f++){const u=(0,i.t7)(r,s,f/a);for(let r=0;r<=h;r++){const s=(0,i.t7)(n,o,r/h);if(c.vertices.push(t(u,s)),e&&c.normals.push(e(u,s)),r<h&&f<a){const t=r+f*(h+1);O(c.TRIANGLES,!1,t,t+h+1,t+1,t+h+2)}}}return c}static load(t){const e=new p;if(!Array.isArray(t.vertices[0]))throw Error();return e.vertices=t.vertices.map((t=>(0,i.V)(t))),t.triangles&&(e.addIndexBuffer("TRIANGLES"),e.TRIANGLES=t.triangles),t.normals&&(e.addVertexBuffer("normals","ts_Normal"),e.normals=t.normals),e.compile(),e}toJSON(){return{vertices:this.vertices.map((t=>t.toArray())),TRIANGLES:this.TRIANGLES}}}p.UNIT_CUBE_CORNERS=[i.V3.O,new i.V3(0,0,1),new i.V3(0,1,0),new i.V3(0,1,1),new i.V3(1,0,0),new i.V3(1,0,1),new i.V3(1,1,0),i.V3.XYZ];const x=WebGLRenderingContext,E={[x.POINTS]:"POINTS",[x.LINES]:"LINES",[x.LINE_STRIP]:"LINE_STRIP",[x.LINE_LOOP]:"LINE_LOOP",[x.TRIANGLES]:"TRIANGLES",[x.TRIANGLE_STRIP]:"TRIANGLE_STRIP",[x.TRIANGLE_FAN]:"TRIANGLE_FAN"},w={[x.POINTS]:t=>!0,[x.LINES]:t=>0==t%2,[x.LINE_STRIP]:t=>t>2,[x.LINE_LOOP]:t=>t>2,[x.TRIANGLES]:t=>0==t%3,[x.TRIANGLE_STRIP]:t=>t>3,[x.TRIANGLE_FAN]:t=>t>3};function M(t){return Float32Array==t.constructor||Float64Array==t.constructor||Array.isArray(t)&&t.every((t=>"number"==typeof t))}function A(t){return!![Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array].some((e=>t instanceof e))||(t instanceof Float32Array||t instanceof Float64Array||Array.isArray(t))&&t.every((t=>Number.isInteger(t)))}class _{constructor(t,e,r=F(),i){this.gl=r,this.name=i,this.projectionMatrixVersion=-1,this.modelViewMatrixVersion=-1,this.outputWarnings={};const s="\n\t\tuniform mat3 ts_NormalMatrix;\n\t\tuniform mat4 ts_ModelViewMatrix;\n\t\tuniform mat4 ts_ProjectionMatrix;\n\t\tuniform mat4 ts_ModelViewProjectionMatrix;\n\t\tuniform mat4 ts_ModelViewMatrixInverse;\n\t\tuniform mat4 ts_ProjectionMatrixInverse;\n\t\tuniform mat4 ts_ModelViewProjectionMatrixInverse;\n\t".match(/\bts_\w+/g);function n(t,e){const i=r.createShader(t);if(r.shaderSource(i,e),r.compileShader(i),!r.getShaderParameter(i,r.COMPILE_STATUS))throw Error("compile error: "+r.getShaderInfoLog(i));return i}if(this.program=r.createProgram(),r.attachShader(this.program,n(r.VERTEX_SHADER,t)),r.attachShader(this.program,n(r.FRAGMENT_SHADER,e)),r.linkProgram(this.program),!r.getProgramParameter(this.program,r.LINK_STATUS))throw Error("link error: "+r.getProgramInfoLog(this.program));this.attributeLocations={},this.uniformLocations={},this.constantAttributes={},this.activeMatrices={},s&&s.forEach((t=>{r.getUniformLocation(this.program,t)&&(this.activeMatrices[t]=!0)})),this.uniformInfos={};for(let t=r.getProgramParameter(this.program,r.ACTIVE_UNIFORMS);t-- >0;){const e=r.getActiveUniform(this.program,t);this.uniformInfos[e.name]=e}}static create(t,e,r,i){return new _(t,e,r,i)}uniforms(t){const e=this.gl;e.useProgram(this.program);for(const r in t){const s=this.uniformLocations[r]||e.getUniformLocation(this.program,r);if(!s)continue;this.uniformLocations[r]=s;let n=t[r];const o=this.uniformInfos[r];if(i.wU){if(!o)throw Error(`uniform ${r} is not defined (available = ${Object.keys(this.uniformInfos).join(",")})`);e.SAMPLER_2D!=o.type&&e.SAMPLER_CUBE!=o.type&&e.INT!=o.type||(1==o.size?(0,i.hu)(Number.isInteger(n)):(0,i.hu)(A(n)&&n.length==o.size,"value must be int array if info.size != 1")),(0,i.hu)(e.FLOAT!=o.type||1==o.size&&"number"==typeof n||M(n)),(0,i.hu)(e.FLOAT_VEC3!=o.type||1==o.size&&n instanceof i.V3||Array.isArray(n)&&o.size==n.length&&(0,i.nY)(...n)),(0,i.hu)(e.FLOAT_VEC4!=o.type||1!=o.size||M(n)&&4==n.length),(0,i.hu)(e.FLOAT_MAT4!=o.type||n instanceof i.M4,(()=>n.toSource())),(0,i.hu)(e.FLOAT_MAT3!=o.type||9==n.length||n instanceof i.M4)}if(n instanceof i.V3&&(n=n.toArray()),e.FLOAT_VEC4==o.type&&1!=o.size)n instanceof Float32Array||n instanceof Float64Array?e.uniform4fv(s,n instanceof Float32Array?n:Float32Array.from(n)):e.uniform4fv(s,n.flatMap((t=>t)));else if(e.FLOAT==o.type&&1!=o.size)e.uniform1fv(s,n);else if(e.FLOAT_VEC3==o.type&&1!=o.size)e.uniform3fv(s,i.V3.pack(n));else if(n.length)switch(n.length){case 1:e.uniform1fv(s,n);break;case 2:e.uniform2fv(s,n);break;case 3:e.uniform3fv(s,n);break;case 4:e.uniform4fv(s,n);break;case 9:e.uniformMatrix3fv(s,!1,new Float32Array([n[0],n[3],n[6],n[1],n[4],n[7],n[2],n[5],n[8]]));break;case 16:e.uniformMatrix4fv(s,!1,new Float32Array([n[0],n[4],n[8],n[12],n[1],n[5],n[9],n[13],n[2],n[6],n[10],n[14],n[3],n[7],n[11],n[15]]));break;default:throw Error("don't know how to load uniform \""+r+'" of length '+n.length)}else if("number"==typeof n)e.SAMPLER_2D==o.type||e.SAMPLER_CUBE==o.type||e.INT==o.type?e.uniform1i(s,n):e.uniform1f(s,n);else if("boolean"==typeof n)e.uniform1i(s,+n);else{if(!(n instanceof i.M4))throw Error('attempted to set uniform "'+r+'" to invalid value '+n);{const t=n.m;if(e.FLOAT_MAT4==o.type)e.uniformMatrix4fv(s,!1,[t[0],t[4],t[8],t[12],t[1],t[5],t[9],t[13],t[2],t[6],t[10],t[14],t[3],t[7],t[11],t[15]]);else if(e.FLOAT_MAT3==o.type)e.uniformMatrix3fv(s,!1,[t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]]);else{if(e.FLOAT_MAT2!=o.type)throw Error("Can't assign M4 to "+o.type);e.uniformMatrix2fv(s,!1,new Float32Array([t[0],t[4],t[1],t[5]]))}}}}return this}attributes(t){const e=this.gl;e.useProgram(this.program);for(const r in t){const s=this.attributeLocations[r]||e.getAttribLocation(this.program,r);if(-1==s){r.startsWith("ts_")||console.warn(`[shader ${this.name}] Vertex buffer ${r} was not bound because the attribute is not active.`);continue}this.attributeLocations[r]=s,e.disableVertexAttribArray(s);let n=t[r];n instanceof i.V3&&(n=n.toArray()),"number"==typeof n?e.vertexAttrib1f(s,n):e.vertexAttrib4fv(s,n),this.constantAttributes[r]=!0}return this}draw(t,e=x.TRIANGLES,r,s){(0,i.hu)(t.hasBeenCompiled,"mesh.hasBeenCompiled"),(0,i.hu)(null!=E[e]);const n=E[e];return this.drawBuffers(t.vertexBuffers,t.indexBuffers[n],e,r,s)}drawBuffers(t,e,r=x.TRIANGLES,s=0,n){const o=this.gl;(0,i.hu)(null!=E[r]),(0,i.OD)((()=>1<=Object.keys(t).length)),Object.keys(t).forEach((e=>(0,i.yP)(a,t[e])));const h=this.activeMatrices,c=(h.ts_ModelViewMatrixInverse||h.ts_NormalMatrix)&&o.modelViewMatrix.inversed(),f=h.ts_ProjectionMatrixInverse&&o.projectionMatrix.inversed(),u=(h.ts_ModelViewProjectionMatrix||h.ts_ModelViewProjectionMatrixInverse)&&o.projectionMatrix.times(o.modelViewMatrix),l={};h.ts_ModelViewMatrix&&this.modelViewMatrixVersion!=o.modelViewMatrixVersion&&(l.ts_ModelViewMatrix=o.modelViewMatrix),h.ts_ModelViewMatrixInverse&&(l.ts_ModelViewMatrixInverse=c),h.ts_ProjectionMatrix&&this.projectionMatrixVersion!=o.projectionMatrixVersion&&(l.ts_ProjectionMatrix=o.projectionMatrix),f&&(l.ts_ProjectionMatrixInverse=f),u&&(l.ts_ModelViewProjectionMatrix=u),u&&h.ts_ModelViewProjectionMatrixInverse&&(l.ts_ModelViewProjectionMatrixInverse=u.inversed()),h.ts_NormalMatrix&&this.modelViewMatrixVersion!=o.modelViewMatrixVersion&&(l.ts_NormalMatrix=c.transposed()),this.uniforms(l),this.projectionMatrixVersion=o.projectionMatrixVersion,this.modelViewMatrixVersion=o.modelViewMatrixVersion;let d=1/0;for(const e in t){const r=t[e];(0,i.hu)(r.hasBeenCompiled);const s=this.attributeLocations[e]||o.getAttribLocation(this.program,e);-1!=s&&r.buffer?(this.attributeLocations[e]=s,o.bindBuffer(x.ARRAY_BUFFER,r.buffer),o.enableVertexAttribArray(s),o.vertexAttribPointer(s,r.spacing,x.FLOAT,!1,0,0),d=Math.min(d,r.count)):e.startsWith("ts_")||console.warn(`[shader ${this.name}] Vertex buffer ${e} was not bound because the attribute is not active.`)}for(const e in this.attributeLocations)e in t||o.disableVertexAttribArray(this.attributeLocations[e]);if(i.wU){const t=o.getProgramParameter(this.program,o.ACTIVE_ATTRIBUTES);for(let e=0;e<t;++e)if(!o.getVertexAttrib(e,o.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING)){const t=o.getActiveAttrib(this.program,e);this.constantAttributes[t.name]||this.outputWarnings[t.name]||(this.outputWarnings[t.name]=!0,console.warn("No buffer is bound to attribute "+t.name+" and it was not set with .attributes()"))}}if(d){if(void 0===n&&(n=e?e.count:d),(0,i.hu)(w[r](n),"count "+n+"doesn't fulfill requirement +"+w[r].toString()+" for mode "+E[r]),e){if((0,i.hu)(e.hasBeenCompiled),(0,i.hu)(d>e.maxValue),(0,i.hu)(n%e.spacing==0),(0,i.hu)(s%e.spacing==0),s+n>e.count)throw Error("Buffer not long enough for passed parameters start/length/buffer length "+s+" "+n+" "+e.count);o.bindBuffer(x.ELEMENT_ARRAY_BUFFER,e.buffer),o.drawElements(r,n,e.bindSize,e.type.BYTES_PER_ELEMENT*s)}else{if(s+n>d)throw Error("invalid");o.drawArrays(r,s,n)}o.drawCallCount++}return this}}class T{constructor(t,e,r={},i=F()){this.gl=i,this.width=t,this.height=e,this.format=r.format||i.RGBA,this.internalFormat=r.internalFormat||i.RGBA,this.type=r.type||i.UNSIGNED_BYTE;const s=r.filter||r.magFilter||i.LINEAR,n=r.filter||r.minFilter||i.LINEAR;if(this.type===i.FLOAT){if(2!=i.version&&!i.getExtension("OES_texture_float"))throw Error("OES_texture_float is required but not supported");if((n!==i.NEAREST||s!==i.NEAREST)&&!i.getExtension("OES_texture_float_linear"))throw Error("OES_texture_float_linear is required but not supported")}else if(this.type===i.HALF_FLOAT_OES){if(!i.getExtension("OES_texture_half_float"))throw Error("OES_texture_half_float is required but not supported");if((n!==i.NEAREST||s!==i.NEAREST)&&!i.getExtension("OES_texture_half_float_linear"))throw Error("OES_texture_half_float_linear is required but not supported")}this.texture=i.createTexture(),i.bindTexture(i.TEXTURE_2D,this.texture),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MAG_FILTER,s),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MIN_FILTER,n),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_S,r.wrap||r.wrapS||i.CLAMP_TO_EDGE),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_T,r.wrap||r.wrapT||i.CLAMP_TO_EDGE),i.texImage2D(i.TEXTURE_2D,0,this.internalFormat,t,e,0,this.format,this.type,r.data)}setData(t){this.gl.bindTexture(this.gl.TEXTURE_2D,this.texture),this.gl.texImage2D(this.gl.TEXTURE_2D,0,this.internalFormat,this.width,this.height,0,this.format,this.type,t)}downloadData(t){if(!this.framebuffer)throw Error("No framebuffer. You need to draw to this texture before it makes sense to read from it.");const e=this.gl,r=e.getParameter(e.FRAMEBUFFER_BINDING);this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,this.framebuffer),this.gl.readPixels(0,0,this.width,this.height,this.format,this.type,t),r!==this.framebuffer&&e.bindFramebuffer(e.FRAMEBUFFER,r)}bind(t){this.gl.activeTexture(this.gl.TEXTURE0+t),this.gl.bindTexture(this.gl.TEXTURE_2D,this.texture)}unbind(t){this.gl.activeTexture(this.gl.TEXTURE0+t),this.gl.bindTexture(this.gl.TEXTURE_2D,null)}drawTo(t){const e=this.gl,r=e.getParameter(e.FRAMEBUFFER_BINDING);if(this.framebuffer)r!==this.framebuffer&&e.bindFramebuffer(e.FRAMEBUFFER,this.framebuffer);else{const t=e.getParameter(e.RENDERBUFFER_BINDING),r=e.createRenderbuffer();if(e.bindRenderbuffer(e.RENDERBUFFER,r),e.renderbufferStorage(e.RENDERBUFFER,e.DEPTH_COMPONENT16,this.width,this.height),e.bindRenderbuffer(e.RENDERBUFFER,t),this.framebuffer=e.createFramebuffer(),e.bindFramebuffer(e.FRAMEBUFFER,this.framebuffer),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,this.texture,0),e.framebufferRenderbuffer(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.RENDERBUFFER,r),e.checkFramebufferStatus(e.FRAMEBUFFER)!==e.FRAMEBUFFER_COMPLETE)throw Error("Rendering to this texture is not supported (incomplete this.framebuffer)")}const i=e.getParameter(e.VIEWPORT);e.viewport(0,0,this.width,this.height),t(e),r!==this.framebuffer&&e.bindFramebuffer(e.FRAMEBUFFER,r),e.viewport(i[0],i[1],i[2],i[3])}swapWith(t){let e;(0,i.hu)(this.gl==t.gl),e=t.texture,t.texture=this.texture,this.texture=e,e=t.width,t.width=this.width,this.width=e,e=t.height,t.height=this.height,this.height=e,e=t.framebuffer,t.framebuffer=this.framebuffer,this.framebuffer=e}static fromImage(t,e={},r=F()){const i=new T(t.width,t.height,e,r);try{r.texImage2D(r.TEXTURE_2D,0,i.format,i.format,i.type,t)}catch(t){throw"file:"==location.protocol?Error('imgElement not loaded for security reasons (serve this page over "http://" instead)'):Error("imgElement not loaded for security reasons (imgElement must originate from the same domain as this page or use Cross-Origin Resource Sharing)")}return e.minFilter&&e.minFilter!=r.NEAREST&&e.minFilter!=r.LINEAR&&r.generateMipmap(r.TEXTURE_2D),i}static fromURLSwitch(t,e,r=F()){T.checkerBoardCanvas=T.checkerBoardCanvas||function(){const t=document.createElement("canvas").getContext("2d");if(!t)throw Error("Could not create 2d canvas.");t.canvas.width=t.canvas.height=128;for(let e=0;e<t.canvas.height;e+=16)for(let r=0;r<t.canvas.width;r+=16)t.fillStyle=16&(r^e)?"#FFF":"#DDD",t.fillRect(r,e,16,16);return t.canvas}();const i=T.fromImage(T.checkerBoardCanvas,e),s=new Image;return s.onload=()=>T.fromImage(s,e,r).swapWith(i),s.onerror=()=>{throw Error("Could not load image "+s.src+". 404?")},s.src=t,i}static fromURL(t,e,r=F()){return new Promise(((i,s)=>{const n=new Image;n.onload=()=>i(T.fromImage(n,e,r)),n.onerror=t=>s("Could not load image "+n.src+". 404?"+t),n.src=t}))}}WebGLRenderingContext;const b={enable:{1:{0:!0}},disable:{1:{0:!0}},getParameter:{1:{0:!0}},drawArrays:{3:{0:!0}},drawElements:{4:{0:!0,2:!0}},createShader:{1:{0:!0}},getShaderParameter:{2:{1:!0}},getProgramParameter:{2:{1:!0}},getShaderPrecisionFormat:{2:{0:!0,1:!0}},getVertexAttrib:{2:{1:!0}},vertexAttribPointer:{6:{2:!0}},bindTexture:{2:{0:!0}},activeTexture:{1:{0:!0}},getTexParameter:{2:{0:!0,1:!0}},texParameterf:{3:{0:!0,1:!0}},texParameteri:{3:{0:!0,1:!0,2:!0}},copyTexImage2D:{8:{0:!0,2:!0}},copyTexSubImage2D:{8:{0:!0}},generateMipmap:{1:{0:!0}},bindBuffer:{2:{0:!0}},getBufferParameter:{2:{0:!0,1:!0}},pixelStorei:{2:{0:!0,1:!0}},bindRenderbuffer:{2:{0:!0}},bindFramebuffer:{2:{0:!0}},checkFramebufferStatus:{1:{0:!0}},framebufferRenderbuffer:{4:{0:!0,1:!0,2:!0}},framebufferTexture2D:{5:{0:!0,1:!0,2:!0}},getFramebufferAttachmentParameter:{3:{0:!0,1:!0,2:!0}},getRenderbufferParameter:{2:{0:!0,1:!0}},renderbufferStorage:{4:{0:!0,1:!0}},clear:{1:{0:{enumBitwiseOr:["COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","STENCIL_BUFFER_BIT"]}}},depthFunc:{1:{0:!0}},blendFunc:{2:{0:!0,1:!0}},blendFuncSeparate:{4:{0:!0,1:!0,2:!0,3:!0}},blendEquation:{1:{0:!0}},blendEquationSeparate:{2:{0:!0,1:!0}},stencilFunc:{3:{0:!0}},stencilFuncSeparate:{4:{0:!0,1:!0}},stencilMaskSeparate:{2:{0:!0}},stencilOp:{3:{0:!0,1:!0,2:!0}},stencilOpSeparate:{4:{0:!0,1:!0,2:!0,3:!0}},cullFace:{1:{0:!0}},frontFace:{1:{0:!0}},drawArraysInstancedANGLE:{4:{0:!0}},drawElementsInstancedANGLE:{5:{0:!0,2:!0}},blendEquationEXT:{1:{0:!0}},bufferData:{3:{0:!0,2:!0},4:{0:!0,2:!0},5:{0:!0,2:!0}},bufferSubData:{3:{0:!0},4:{0:!0},5:{0:!0}},copyBufferSubData:{5:{0:!0,1:!0}},getBufferSubData:{3:{0:!0},4:{0:!0},5:{0:!0}},blitFramebuffer:{10:{8:{enumBitwiseOr:["COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","STENCIL_BUFFER_BIT"]},9:!0}},framebufferTextureLayer:{5:{0:!0,1:!0}},invalidateFramebuffer:{2:{0:!0}},invalidateSubFramebuffer:{6:{0:!0}},readBuffer:{1:{0:!0}},getInternalformatParameter:{3:{0:!0,1:!0,2:!0}},renderbufferStorageMultisample:{5:{0:!0,2:!0}},texStorage2D:{5:{0:!0,2:!0}},texStorage3D:{6:{0:!0,2:!0}},texImage2D:{9:{0:!0,2:!0,6:!0,7:!0},6:{0:!0,2:!0,3:!0,4:!0},10:{0:!0,2:!0,6:!0,7:!0}},texImage3D:{10:{0:!0,2:!0,7:!0,8:!0},11:{0:!0,2:!0,7:!0,8:!0}},texSubImage2D:{9:{0:!0,6:!0,7:!0},7:{0:!0,4:!0,5:!0},10:{0:!0,6:!0,7:!0}},texSubImage3D:{11:{0:!0,8:!0,9:!0},12:{0:!0,8:!0,9:!0}},copyTexSubImage3D:{9:{0:!0}},compressedTexImage2D:{7:{0:!0,2:!0},8:{0:!0,2:!0},9:{0:!0,2:!0}},compressedTexImage3D:{8:{0:!0,2:!0},9:{0:!0,2:!0},10:{0:!0,2:!0}},compressedTexSubImage2D:{8:{0:!0,6:!0},9:{0:!0,6:!0},10:{0:!0,6:!0}},compressedTexSubImage3D:{10:{0:!0,8:!0},11:{0:!0,8:!0},12:{0:!0,8:!0}},vertexAttribIPointer:{5:{2:!0}},drawArraysInstanced:{4:{0:!0}},drawElementsInstanced:{5:{0:!0,2:!0}},drawRangeElements:{6:{0:!0,4:!0}},readPixels:{7:{4:!0,5:!0},8:{4:!0,5:!0}},clearBufferfv:{3:{0:!0},4:{0:!0}},clearBufferiv:{3:{0:!0},4:{0:!0}},clearBufferuiv:{3:{0:!0},4:{0:!0}},clearBufferfi:{4:{0:!0}},beginQuery:{2:{0:!0}},endQuery:{1:{0:!0}},getQuery:{2:{0:!0,1:!0}},getQueryParameter:{2:{1:!0}},samplerParameteri:{3:{1:!0,2:!0}},samplerParameterf:{3:{1:!0}},getSamplerParameter:{2:{1:!0}},fenceSync:{2:{0:!0,1:{enumBitwiseOr:[]}}},clientWaitSync:{3:{1:{enumBitwiseOr:["SYNC_FLUSH_COMMANDS_BIT"]}}},waitSync:{3:{1:{enumBitwiseOr:[]}}},getSyncParameter:{2:{1:!0}},bindTransformFeedback:{2:{0:!0}},beginTransformFeedback:{1:{0:!0}},transformFeedbackVaryings:{3:{2:!0}},bindBufferBase:{3:{0:!0}},bindBufferRange:{5:{0:!0}},getIndexedParameter:{2:{0:!0}},getActiveUniforms:{3:{2:!0}},getActiveUniformBlockParameter:{3:{2:!0}}};let R=null,v=null;function I(){if(null===R){R={},v={};const t=window.WebGL2RenderingContext||window.WebGLRenderingContext;if(!t)throw Error("Neither WebGL2RenderingContext nor WebGLRenderingContext exists on window.");for(const e in t){const r=t[e];"number"==typeof r&&(R[r]=e,v[e]=r)}}}function V(t){I();var e=R[t];return void 0!==e?"gl."+e:"/*UNKNOWN WebGL ENUM*/ 0x"+t.toString(16)}function S(t,e,r,i){const s=b[t];if(void 0!==s){const t=s[e];if(void 0!==t){const e=t[r];if(e){if("object"==typeof e){const t=e.enumBitwiseOr,r=[];let s=0;for(let e=0;e<t.length;++e){const n=v[t[e]];0!=(i&n)&&(s|=n,r.push(V(n)))}return s===i?r.join(" | "):V(i)}return V(i)}}}return null===i?"null":void 0===i?"undefined":i.toString()}function N(t,e,r){t.__defineGetter__(r,(function(){return e[r]})),t.__defineSetter__(r,(function(t){e[r]=t}))}function L(t,e,r,i=t){I(),e=e||function(t,e,r){var i,s="",n=r.length;for(let t=0;t<n;++t)s+=(0==t?"":", ")+S(e,n,t,r[t]);i="WebGL error "+V(t)+" in "+e+"("+s+")",window.console&&window.console.error?window.console.error(i):function(t){window.console&&window.console.log&&window.console.log(t)}(i)};const s={};function n(t,n){return function(...o){r&&r(n,o);const a=t[n].apply(t,o),h=i.getError();return 0!=h&&(s[h]=!0,e(h,n,o)),a}}const o={};for(let s in t)if("function"==typeof t[s])if("getExtension"!=s)o[s]=n(t,s);else{let a=n(t,s);o[s]=function(){const s=a.apply(t,arguments);return s?L(s,e,r,i):null}}else N(o,t,s);return o.getError=function(){for(const t in s)if(s.hasOwnProperty(t)&&s[t])return s[t]=!1,parseInt(t);return t.NO_ERROR},o}const y=[0,0,0,1];function F(){return B.gl}class B{constructor(t,e={mesh:(new p).addVertexBuffer("coords","ts_TexCoord").addVertexBuffer("colors","ts_Color"),mode:-1,coord:[0,0],color:[1,1,1,1],pointSize:1,shader:_.create("\n        attribute vec4 ts_Color;\n        attribute vec4 ts_Vertex;\n        uniform mat4 ts_ModelViewProjectionMatrix;\n        attribute vec2 ts_TexCoord;\n        uniform float pointSize;\n        varying vec4 color;\n        varying vec2 coord;\n        void main() {\n            color = ts_Color;\n            coord = ts_TexCoord;\n            gl_Position = ts_ModelViewProjectionMatrix * ts_Vertex;\n            gl_PointSize = pointSize;\n        }\n        ","\n        precision highp float;\n        uniform sampler2D texture;\n        uniform float pointSize;\n        // uniform bool useTexture;\n        varying vec4 color;\n        varying vec2 coord;\n        void main() {\n            gl_FragColor = color;\n            // if (useTexture) gl_FragColor *= texture2D(texture, coord.xy);\n        }\n        ",t)}){this.immediate=e,this.modelViewMatrix=i.M4.identity(),this.projectionMatrix=i.M4.identity(),this.tempMatrix=new i.M4,this.resultMatrix=new i.M4,this.modelViewStack=[],this.projectionStack=[],this.drawCallCount=0,this.projectionMatrixVersion=0,this.modelViewMatrixVersion=0,this.cachedSDFMeshes={},this.matrixMode(B.MODELVIEW)}matrixMode(t){switch(t){case this.MODELVIEW:this.currentMatrixName="modelViewMatrix",this.stack=this.modelViewStack;break;case this.PROJECTION:this.currentMatrixName="projectionMatrix",this.stack=this.projectionStack;break;default:throw Error("invalid matrix mode "+t)}}loadIdentity(){i.M4.identity(this[this.currentMatrixName]),"projectionMatrix"==this.currentMatrixName?this.projectionMatrixVersion++:this.modelViewMatrixVersion++}loadMatrix(t){i.M4.copy(t,this[this.currentMatrixName]),"projectionMatrix"==this.currentMatrixName?this.projectionMatrixVersion++:this.modelViewMatrixVersion++}multMatrix(t){i.M4.multiply(this[this.currentMatrixName],t,this.resultMatrix);const e=this.resultMatrix;this.resultMatrix=this[this.currentMatrixName],this[this.currentMatrixName]=e,"projectionMatrix"==this.currentMatrixName?this.projectionMatrixVersion++:this.modelViewMatrixVersion++}mirror(t){this.multMatrix(i.M4.mirror(t))}perspective(t,e,r,s){this.multMatrix(i.M4.perspectiveRad(t*i.Co,e,r,s,this.tempMatrix))}frustum(t,e,r,s,n,o){this.multMatrix(i.M4.frustum(t,e,r,s,n,o,this.tempMatrix))}ortho(t,e,r,s,n,o){this.multMatrix(i.M4.ortho(t,e,r,s,n,o,this.tempMatrix))}scale(...t){this.multMatrix(i.M4.scale(...t,this.tempMatrix))}mirroredX(){this.multMatrix(i.M4.mirror(i.Fw))}translate(t,e,r){void 0!==e?this.multMatrix(i.M4.translate(t,e,r,this.tempMatrix)):this.multMatrix(i.M4.translate(t,this.tempMatrix))}rotate(t,e,r,s){this.multMatrix(i.M4.rotate(t*i.Co,{x:e,y:r,z:s},this.tempMatrix))}lookAt(t,e,r){this.multMatrix(i.M4.lookAt(t,e,r,this.tempMatrix))}pushMatrix(){this.stack.push(i.M4.copy(this[this.currentMatrixName]))}popMatrix(){const t=this.stack.pop();(0,i.hu)(void 0!==t),this[this.currentMatrixName]=t,"projectionMatrix"==this.currentMatrixName?this.projectionMatrixVersion++:this.modelViewMatrixVersion++}wcToWindowMatrix(){const t=this.getParameter(this.VIEWPORT),[e,r,s,n]=t,o=new i.M4([s/2,0,0,e+s/2,n/2,0,0,r+n/2,0,0,1,0,0,0,0,1]);return i.M4.product(o,this.projectionMatrix,this.modelViewMatrix)}pointSize(t){this.immediate.shader.uniforms({pointSize:t})}begin(t){if(-1!=this.immediate.mode)throw Error("mismatched viewerGL.begin() and viewerGL.end() calls");this.immediate.mode=t,this.immediate.mesh.colors=[],this.immediate.mesh.coords=[],this.immediate.mesh.vertices=[]}color(...t){this.immediate.color=1==t.length&&Array.isArray(t[0])?t[0]:1==t.length&&"number"==typeof t[0]?function(t){return[(t>>16)/255,(t>>8&255)/255,(255&t)/255,1]}(t[0]):1==t.length&&"string"==typeof t[0]?(0,n.$_)(t[0]).gl():[t[0],t[1],t[2],t[3]||1]}texCoord(...t){this.immediate.coord=i.V.apply(void 0,t).toArray(2)}vertex(...t){this.immediate.mesh.colors.push(this.immediate.color),this.immediate.mesh.coords.push(this.immediate.coord),this.immediate.mesh.vertices.push(i.V.apply(void 0,t))}end(){if(-1==this.immediate.mode)throw Error("mismatched viewerGL.begin() and viewerGL.end() calls");this.immediate.mesh.compile(),this.immediate.shader.uniforms({useTexture:!!B.gl.getParameter(this.TEXTURE_BINDING_2D)}).drawBuffers(this.immediate.mesh.vertexBuffers,void 0,this.immediate.mode),this.immediate.mode=-1}makeCurrent(){B.gl=this}animate(t){const e=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||function(t){setTimeout((()=>t(performance.now())),1e3/60)};let r=performance.now(),i=!0;const s=n=>{i&&(t.call(this,n,n-r),r=n,e(s))};return e(s),()=>{i=!1}}fullscreen(t={}){const e=t.paddingTop||0,r=t.paddingLeft||0,i=t.paddingRight||0,s=t.paddingBottom||0;if(!document.body)throw Error("document.body doesn't exist yet (call viewerGL.fullscreen() from window.onload() or from inside the <body> tag)");return Object.assign(this.canvas.style,{position:"absolute",left:r+"px",top:e+"px",width:window.innerWidth-r-i+"px",height:window.innerHeight-e-s+"px"}),this.addResizeListener(),this}addResizeListener(t={}){const e=this;function r(){const r=e.canvas.getBoundingClientRect();e.canvas.width=r.width*window.devicePixelRatio,e.canvas.height=r.height*window.devicePixelRatio,e.viewport(0,0,e.canvas.width,e.canvas.height),t.camera&&(e.matrixMode(B.PROJECTION),e.loadIdentity(),e.perspective(t.fov||45,e.canvas.width/e.canvas.height,t.near||.1,t.far||1e3),e.matrixMode(B.MODELVIEW))}return window.addEventListener("resize",r),r(),this}getMouseLine(t,e){if(t instanceof MouseEvent)return this.getMouseLine(t.offsetX,t.offsetY);const r=(0,i.V)(2*t/this.canvas.offsetWidth-1,2*-e/this.canvas.offsetHeight+1,0),s=(0,i.V)(2*t/this.canvas.offsetWidth-1,2*-e/this.canvas.offsetHeight+1,1),n=this.projectionMatrix.inversed(),o=n.transformPoint(r);return{anchor:o,dir:n.transformPoint(s).minus(o)}}viewportFill(){this.viewport(0,0,this.canvas.width,this.canvas.height)}setupTextRendering(t,e){return(0,s.mG)(this,void 0,void 0,(function*(){this.textRenderShader=_.create("attribute vec2 ts_TexCoord;attribute vec4 ts_Vertex;uniform mat4 ts_ModelViewProjectionMatrix;varying vec2 coord;void main(){coord=ts_TexCoord.xy;gl_Position=ts_ModelViewProjectionMatrix*ts_Vertex;}","precision mediump float;uniform sampler2D u_texture;uniform vec4 u_color;uniform float u_buffer;uniform float u_gamma;uniform float u_debug;varying vec2 coord;void main(){float dist=texture2D(u_texture,coord).r;if(u_debug>0.0){gl_FragColor=vec4(dist,dist,dist,1);}else{float alpha=smoothstep(u_buffer-u_gamma,u_buffer+u_gamma,dist);gl_FragColor=vec4(u_color.rgb,alpha*u_color.a);if(gl_FragColor.a==0.0){discard;}}}"),[this.textAtlas,this.textMetrics]=yield Promise.all([T.fromURL(t,{format:this.LUMINANCE,internalFormat:this.LUMINANCE,type:this.UNSIGNED_BYTE}),fetch(e).then((t=>t.json()))])}))}getSDFMeshForString(t){return(0,i.hu)(this.textMetrics),this.cachedSDFMeshes[t]||(this.cachedSDFMeshes[t]=function(t,e,r,s=1){const n=(new p).addIndexBuffer("TRIANGLES").addVertexBuffer("coords","ts_TexCoord");let o=0,a=0;function h(r){const s=t.chars[r];if(!s)return;const[h,c,f,u,l,d,m]=s,{size:g,buffer:p}=t,x=n.vertices.length;if(h>0&&c>0){const t=(o+f-p)/g,r=(o+f+h+p)/g,s=(u-c-p)/g,l=(u+p)/g;n.vertices.push(new i.V3(t,s,a/g),new i.V3(r,s,a/g),new i.V3(t,l,a/g),new i.V3(r,l,a/g));const E=d/e.width,w=(d+h+2*p)/e.width,M=(m+c+2*p)/e.height,A=m/e.height;n.coords.push([E,M],[w,M],[E,A],[w,A]),O(n.TRIANGLES,!1,x,x+1,x+2,x+3)}o+=l}for(let e=0;e<r.length;e++){const i=r[e];"\n"==i?(o=0,a+=s*t.size):h(i)}return Object.assign(n.compile(),{width:o/t.size,lineCount:a+1})}(this.textMetrics,this.textAtlas,t))}renderText(t,e,r=1,s="left",n="bottom",o=.05,a=1.2){const h=this.getSDFMeshForString(t);this.pushMatrix(),this.scale(r);const c={top:-this.textMetrics.ascender/this.textMetrics.size,middle:(-this.textMetrics.ascender-this.textMetrics.descender)/2/this.textMetrics.size,alphabetic:0,bottom:-this.textMetrics.descender/this.textMetrics.size};this.translate({left:0,center:-.5,right:-1}[s]*h.width,c[n],0),this.multMatrix(i.M4.forSys(i.V3.X,i.V3.Y,new i.V3(0,-a,0))),this.textAtlas.bind(0),this.textRenderShader.uniforms({texture:0,u_color:e,u_debug:0,u_gamma:o,u_buffer:.75}).draw(h),this.popMatrix()}static create(t={}){const e=t.canvas||document.createElement("canvas");let r;t.canvas||(e.width=800,e.height=600),"alpha"in t||(t.alpha=!1);try{r=e.getContext("webgl2",t),r&&(r.version=2),r||(r=e.getContext("webgl",t)||e.getContext("experimental-webgl",t),r&&(r.version=1))}catch(t){console.log(t,"Failed to get context")}if(!r)throw Error("WebGL not supported");return t.throwOnError&&(r=L(r,((t,e)=>{throw Error(V(t)+" was caused by "+e)}))),B.gl=r,(0,i.zy)(r,B.prototype),(0,i.zy)(r,new B(r)),r}fixCanvasRes(t=1/0){this.canvas.width=this.canvas.clientWidth*Math.min(window.devicePixelRatio,t),this.canvas.height=this.canvas.clientHeight*Math.min(window.devicePixelRatio,t),this.viewport(0,0,this.canvas.width,this.canvas.height)}drawVector(t,e,r=y,s=1){if(t.likeO())return;this.pushMatrix();const n=4*s;if(n>t.length())return;const o=t.getPerpendicular().unit();this.multMatrix(i.M4.forSys(t.unit(),o,t.cross(o).unit(),e)),this.scale(t.length()-n,s/2,s/2),this.shaders.singleColor.uniforms({color:r}).draw(this.meshes.vectorShaft),this.scale(1/(t.length()-n),1,1),this.translate(t.length()-n,0,0),this.scale(n/2,1,1),this.shaders.singleColor.draw(this.meshes.vectorHead),this.popMatrix()}}var P;function O(t,e,r,i,s,n){e?t.push(r,s,i,i,s,n):t.push(r,i,s,i,n,s)}B.MODELVIEW=0,B.PROJECTION=1,B.HALF_FLOAT_OES=36193,(P||(P={})).create=B.create,B.prototype.MODELVIEW=B.MODELVIEW,B.prototype.PROJECTION=B.PROJECTION,B.prototype.HALF_FLOAT_OES=B.HALF_FLOAT_OES}}]);