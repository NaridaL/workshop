(self.webpackChunkworkshop=self.webpackChunkworkshop||[]).push([[383],{3888:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var padLeft = __webpack_require__(7841)\n\nmodule.exports = addLineNumbers\nfunction addLineNumbers (string, start, delim) {\n  start = typeof start === 'number' ? start : 1\n  delim = delim || ': '\n\n  var lines = string.split(/\\r?\\n/)\n  var totalDigits = String(lines.length + start - 1).length\n  return lines.map(function (line, i) {\n    var c = i + start\n    var digits = String(c).length\n    var prefix = padLeft(c, totalDigits - digits)\n    return prefix + delim + line\n  }).join('\\n')\n}\n\n\n//# sourceURL=webpack://workshop/../nla/tsgl/node_modules/add-line-numbers/index.js?")},2490:module=>{eval("module.exports = function _atob(str) {\n  return atob(str)\n}\n\n\n//# sourceURL=webpack://workshop/../nla/tsgl/node_modules/atob-lite/atob-browser.js?")},7769:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "$_": () => (/* binding */ color)\n/* harmony export */ });\n/* unused harmony exports Color, CubeHelix, Scale, analyze, average, bezier, black, blend, brewer, cmyk, contrast, css, cubehelix, deltaE, distance, gl, hcg, hsi, hsl, hsv, kelvin, lab, lch, limits, mix, num, random, rgb, scale, scales, w3cx11, white, xyz */\n/**\n * @license\n *\n * js - JavaScript library for color conversions\n *\n * Copyright (c) 2011-2017, Gregor Aisch\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * 3. The name Gregor Aisch may not be used to endorse or promote products\n *    derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n// tslint:disable:no-unnecessary-qualifier\nconst { abs, atan2, cos, floor, log, min, max, round, sign, sin, sqrt, cbrt, PI, hypot } = Math;\nfunction lerp(a, b, f) {\n    return a + (b - a) * f;\n}\nfunction lerpInv(a, b, f) {\n    return (f - a) / (b - a);\n}\nfunction clamp(x, min = 0, max = 1) {\n    return x < min ? min : x > max ? max : x;\n}\nfunction newtonIterate1d(f, xStart, max_steps, eps = 1e-8) {\n    let x = xStart, fx;\n    while (max_steps-- && abs((fx = f(x))) > eps) {\n        const dfdx = (f(x + eps) - fx) / eps;\n        console.log("fx / dfdx", fx / dfdx, "fx", fx, "x", x);\n        x = x - fx / dfdx;\n    }\n    return x;\n}\nfunction bisect(f, a, b, steps) {\n    //assert(a < b)\n    let fA = f(a);\n    // let fB = f(b)\n    //assert(fA * fB < 0)\n    while (steps--) {\n        const c = (a + b) / 2;\n        const fC = f(c);\n        // console.log("fC", fC, "c", c)\n        if (sign(fA) == sign(fC)) {\n            a = c;\n            fA = fC;\n        }\n        else {\n            b = c;\n            // fB = fC\n        }\n    }\n    //assert(a <= (b + a) / 2)\n    //assert(b >= (b + a) / 2)\n    return (a + b) / 2;\n}\nconst TWOPI = 2 * PI;\nconst DEG2RAD = PI / 180;\nconst RAD2DEG = 180 / PI;\nfunction color(...args) {\n    if (args[0] instanceof Color) {\n        return args[0];\n    }\n    if (args.length > 1 && "string" == typeof args[args.length - 1]) {\n        return guess(args.slice(0, args.length - 1), args[args.length - 1]);\n    }\n    else if (Array.isArray(args[0])) {\n        return guess(args[0]);\n    }\n    else {\n        return guess(args);\n    }\n}\nclass Color {\n    /** @internal */\n    constructor(r, g, b, a = 1) {\n        this.r = r;\n        this.g = g;\n        this.b = b;\n        this.a = a;\n    }\n    // public shade() {\n    // \tconst shades: [string, string, number][] = [\n    // \t\t["ff0000", "red"],\n    // \t\t["ffa500", "orange"],\n    // \t\t["ffff00", "yellow"],\n    // \t\t["008000", "green"],\n    // \t\t["0000ff", "blue"],\n    // \t\t["ee82ee", "violet"],\n    // \t\t["a52a2a", "brown"],\n    // \t\t["000000", "black"],\n    // \t\t["808080", "grey"],\n    // \t\t["ffffff", "white"],\n    // \t] as any\n    // \tfunction angleDiff(a: number, b: number) {\n    // \t\tconst d = (a - b) % 360\n    // \t\tif (d > 180) return d - 360\n    // \t\tif (d < -180) return d + 360\n    // \t\treturn d\n    // \t}\n    // \tshades.forEach(arr => arr.push(color(arr[0]).hsl()[0]))\n    // \tconst [h, s, l] = this.hsl()\n    // \tif (l > 0.9) return "white"\n    // \tif (l > 0.8 && s < 0.2) return "white"\n    // \tif (s < 0.1) return "grey"\n    // \tif (s < 0.4 && h > 0 && h < 48) return "brown"\n    // \tconst distanceInXYZ: { [hue: number]: number } = { 0: 0 }\n    // \tfor (let i = 60; i <= 360; i += 60) {\n    // \t\tdistanceInXYZ[i] =\n    // \t\t\tdistanceInXYZ[i - 60] + distance(hsl(i - 60, 1, 0.5), hsl(i, 1, 0.5), "xyz")\n    // \t}\n    // \t// console.log(distanceInXYZ)\n    // \tconst shadeEnds: { [hue: number]: number } = {\n    // \t\t0: 9,\n    // \t\t38: 48,\n    // \t\t60: 65,\n    // \t\t120: 165,\n    // \t\t240: 245,\n    // \t\t300: 338,\n    // \t\t360: 369,\n    // \t}\n    // \tconst getColorDistanceAlongXYZHue = (hueDegrees: number) => {\n    // \t\tconst base = hueDegrees - (hueDegrees % 60)\n    // \t\treturn (\n    // \t\t\tdistanceInXYZ[base] + distance(hsl(base, 1, 0.5), hsl(hueDegrees, 1, 0.5), "xyz")\n    // \t\t)\n    // \t}\n    // \tconst colorXYZD = getColorDistanceAlongXYZHue(this.hsl()[0])\n    // \tconst md = distanceInXYZ[360]\n    // \tconst shadeHue =\n    // \t\t(Object.keys(shadeEnds) as any[]).find(shadeHue => shadeEnds[shadeHue | 0] >= this.hsl()[0])! % 360\n    // \treturn shades.find(([_hex, _name, _hue]) => (_hue | 0) === shadeHue)![1]\n    // \t// process.exit()\n    // \treturn withMax(shades, ([_hex, _name, _hue]) => {\n    // \t\treturn -abs(angleDiff(this.hsl()[0], _hue))\n    // \t})[1]\n    // \treturn withMax(shades, ([_hex, _name, _hue]) => {\n    // \t\tconst [thisL, thisA, thisB] = this.lab()\n    // \t\tconst [L, A, B] = color(_hex).lab()\n    // \t\treturn -hypot(thisL - L, thisA - A, thisB - B)\n    // \t})[1]\n    // }\n    /**\n     * @see [[mix]]\n     */\n    mix(col2, f, m = "rgb") {\n        return mix(this, col2, f, m);\n    }\n    rgb(doRound = true, clamp_ = true) {\n        const f = (t) => {\n            if (doRound)\n                t = round(t);\n            if (clamp_)\n                t = clamp(t, 0, 255);\n            return t;\n        };\n        const { r, g, b } = this;\n        return [f(r), f(g), f(b)];\n    }\n    rgba(doRound = true, clamp_ = true) {\n        const f = (t) => {\n            if (doRound)\n                t = round(t);\n            if (clamp_)\n                t = clamp(t, 0, 255);\n            return t;\n        };\n        const { r, g, b, a } = this;\n        return [f(r), f(g), f(b), a];\n    }\n    /**\n     * Return a hex-string representation of this color.\n     *\n     * @param mode\n     * @see #num for a hex-number representation.\n     * @example chroma.color(\'yellow\').alpha(0.7).hex()\n     * @example chroma.color(\'yellow\').alpha(0.7).hex(\'rgba\')\n     * @example chroma.color(\'yellow\').alpha(0.7).hex(\'argb\')\n     */\n    hex(mode = "rgb") {\n        const { r, g, b, a } = this;\n        return rgb2hex(r, g, b, a, mode);\n    }\n    /**\n     * Returns the [HSL] representation of this color. hue will always be in [0;360). Values are never NaN.\n     *\n     * @example chroma.color(\'purple\').hsl()\n     */\n    hsl() {\n        const { r, g, b } = this;\n        return rgb2hsl(r, g, b);\n    }\n    /**\n     * Returns the [HSL] representation of this color. hue will always be in [0;360). Values are never NaN.\n     *\n     * @example chroma.color(\'purple\').hsv()\n     */\n    hsv() {\n        const { r, g, b } = this;\n        return rgb2hsv(r, g, b);\n    }\n    /**\n     * Returns the [HSL] representation of this color. hue will always be in [0;360). Values are never NaN.\n     *\n     * @example chroma.color(\'purple\').hcg()\n     */\n    hcg() {\n        const { r, g, b } = this;\n        return rgb2hcg(r, g, b);\n    }\n    /**\n     * Returns a CSS `rgb(...)` or `hsl(...)` string representation that can be used as CSS-color definition. The alpha\n     * value is not output if it 1.\n     * @example chroma.color(\'teal\').css() // == "rgb(0,128,128)"\n     * @example chroma.color(\'teal\').alpha(0.5).css() // == "rgba(0,128,128,0.5)"\n     * @example chroma.color(\'teal\').css(\'hsl\') // == "hsl(180,100%,25.1%)"\n     */\n    css(mode = "rgb") {\n        if ("rgb" == mode) {\n            const { r, g, b, a } = this;\n            return rgb2css(r, g, b, a);\n        }\n        else if ("hsl" == mode) {\n            return hsl2css(this.hsl(), this.alpha());\n        }\n        else {\n            throw new Error();\n        }\n    }\n    name(closest = false) {\n        const thisNum = this.num();\n        const name = Object.keys(w3cx11).find((name) => w3cx11[name] == thisNum);\n        if (!name && closest) {\n            const [thisLStar, thisAStar, thisBStar] = this.lab();\n            return withMax(Object.keys(w3cx11), (name) => {\n                const [lStar, aStar, bStar] = num(w3cx11[name]).lab();\n                return -hypot(thisLStar - lStar, thisAStar - aStar, thisBStar - bStar);\n            });\n        }\n        return name;\n    }\n    /**\n     * Get the [CMYK](#CMYK) representation of this color.\n     *\n     * @example chroma.color(\'red\').cmyk()\n     */\n    cmyk() {\n        const { r, g, b } = this;\n        return rgb2cmyk(r, g, b);\n    }\n    /**\n     * Returns the [GL] representation of this color.\n     * @example chroma.color(\'33cc00\').gl()\n     */\n    gl() {\n        const { r, g, b, a } = this;\n        return [r / 255, g / 255, b / 255, a];\n    }\n    luminance(lum1) {\n        const { r, g, b, a } = this;\n        const [, Y] = rgb2xyz(r, g, b);\n        if (undefined === lum1) {\n            return Y;\n        }\n        const inverseLerp = (a, b, val) => (val - a) / (b - a);\n        if (lum1 > Y) {\n            // lerp to white\n            return mix(this, white, inverseLerp(Y, 1, lum1), "xyz").alpha(a);\n        }\n        else {\n            // lerp to black\n            return mix(black, this, inverseLerp(0, Y, lum1), "xyz").alpha(a);\n        }\n    }\n    /**\n     * Get color temperature of this color in Kelvin. This only makes sense for colors close to those output by\n     * kelvin\n     *\n     * @example [c = chroma.color(\'#ff3300\'), c.temperature()]\n     * @example [c = chroma.color(\'#ffe3cd\'), c.temperature()]\n     * @example [c = chroma.color(\'#b3ccff\'), c.temperature()]\n     */\n    temperature() {\n        const { r, g, b } = this;\n        return rgb2kelvin(r, g, b);\n    }\n    /**\n     * Returns a new [Color] with a channel changed.\n     * @example chroma.color(\'skyblue\').set(\'hsl.h\', 0) // change hue to 0 deg (=red)\n     * @example chroma.color(\'hotpink\').set(\'lch.c\', 30) // set chromaticity to 30\n     * @example chroma.color(\'orangered\').set(\'lab.l\', x => x / 2) // half Lab lightness\n     * @example chroma.color(\'darkseagreen\').set(\'lch.c\', x => x * 2) // double Lch saturation\n     */\n    set(modeAndChannel, value) {\n        const [mode, channel] = modeAndChannel.split(".");\n        const src = this[mode]();\n        const i = mode.indexOf(channel);\n        if (-1 == i)\n            throw new Error("invalid channel");\n        src[i] = "number" == typeof value ? value : value(src[i]);\n        return color(src, mode).alpha(this.a);\n    }\n    /**\n     * Returns whether this color is outside the RGB color cube and will be clipped/clamped when calling .rgb()\n     *\n     * @example [c = chroma.lch( 20, 40, 50), c.clipped()]\n     * @example [c = chroma.lch( 40, 40, 50), c.clipped()]\n     * @example [c = chroma.lch( 60, 40, 50), c.clipped()]\n     * @example [c = chroma.lch( 80, 40, 50), c.clipped()]\n     * @example [c = chroma.lch(100, 40, 50), c.clipped()]\n     */\n    clipped() {\n        const { r, g, b } = this;\n        return !(0 <= r && r <= 255 && 0 <= g && g <= 255 && 0 <= b && b <= 255);\n    }\n    /**\n     * Returns black or white, whichever has the highest contrast to `this`.\n     * In the readme you should see the result of this.\n     *\n     * @example chroma.color(\'red\')\n     * @example chroma.color(\'yellow\')\n     */\n    textColor() {\n        return this.luminance() > 0.5 ? black : white;\n    }\n    alpha(alpha1) {\n        if (undefined === alpha1) {\n            return this.a;\n        }\n        const { r, g, b } = this;\n        return rgb(r, g, b, alpha1);\n    }\n    darker(amount = 1) {\n        const [l, a, b] = this.lab();\n        return lab(l - LAB_Kn * amount, a, b, this.alpha());\n    }\n    /**\n     *\n     * @param amount\n     * @example chroma.color(\'hotpink\')\n     * @example chroma.color(\'hotpink\').brighter()\n     * @example chroma.color(\'hotpink\').brighter(2)\n     * @example chroma.color(\'hotpink\').brighter(3)\n     */\n    brighter(amount = 1) {\n        return this.darker(-amount);\n    }\n    /**\n     * Returns a new [Color] with increased saturation.\n     * @param amount How much.\n     * @example chroma.color(\'slategray\')\n     * @example chroma.color(\'slategray\').saturate()\n     * @example chroma.color(\'slategray\').saturate(2)\n     * @example chroma.color(\'slategray\').saturate(3)\n     */\n    saturate(amount = 1) {\n        const [l, c, h] = this.lch();\n        return lch(l, max(0, c + amount * LAB_Kn), h, this.alpha());\n    }\n    /**\n     * Equivalent to `saturate(-amount)`.\n     * @see #saturate\n     */\n    desaturate(amount = 1) {\n        return this.saturate(-amount);\n    }\n    premultiplied() {\n        const { r, g, b, a } = this;\n        return rgb(r * a, g * a, b * a, a);\n    }\n    /**\n     * Returns the [HSI] representation of this color. hue will always be in [0; 360). Values are never NaN.\n     *\n     * @example chroma.color(\'purple\').hsi()\n     */\n    hsi() {\n        const { r, g, b } = this;\n        return rgb2hsi(r, g, b);\n    }\n    /**\n     * Returns the [LAB] representation of this color.\n     *\n     * @example chroma.color(\'purple\').lab()\n     */\n    lab() {\n        const { r, g, b } = this;\n        return rgb2lab(r, g, b);\n    }\n    /**\n     * Return a hex-num of this color.\n     *\n     * @param mode\n     * @see #num for a hex-number representation.\n     * @example chroma.color(\'yellow\').alpha(0.7).hex()\n     * @example chroma.color(\'yellow\').alpha(0.7).hex(\'rgba\')\n     * @example chroma.color(\'yellow\').alpha(0.7).hex(\'argb\')\n     */\n    num(mode = "rgb") {\n        const { r, g, b, a } = this;\n        return rgb2num(r, g, b, a, mode);\n    }\n    /**\n     * Returns the [LCH] representation of this color. hue will always be in [0; 360). Values are never NaN.\n     *\n     * @example chroma.color(\'purple\').lch()\n     */\n    lch() {\n        const { r, g, b } = this;\n        return rgb2lch(r, g, b);\n    }\n    /**\n     * Returns the [XYZ] representation of this color. hue will always be in [0; 360). Values are never NaN.\n     *\n     * @example chroma.color(\'purple\').xyz()\n     */\n    xyz() {\n        const { r, g, b } = this;\n        return rgb2xyz(r, g, b);\n    }\n    /**\n     * Whether this [Color](#Color) is identical (strict equality of r, g, b, a) to `color`.\n     */\n    equals(color) {\n        const { r, g, b, a } = this;\n        const { r: r2, g: g2, b: b2, a: a2 } = color;\n        return r == r2 && g == g2 && b == b2 && a == a2;\n    }\n    hashCode() {\n        return this.num("rgba");\n    }\n    /**\n     * @example chroma.color(\'red\').toSource() // == "rgb(255, 0, 0)"\n     * @example chroma.rgb(-2, 100.02, 200, 0.5).toSource() // == "rgb(-2, 100.02, 200, 0.5)"\n     */\n    toSource() {\n        const { r, g, b, a } = this;\n        return "chroma.rgb(" + r + ", " + g + ", " + b + (a === 1 ? ")" : ", " + a + ")");\n    }\n}\nColor.prototype.toString = Color.prototype.css;\nColor.prototype.kelvin = Color.prototype.temperature;\n/**\n * @example chroma.black\n */\nconst black = new Color(0, 0, 0, 1);\n/**\n * @example chroma.black\n */\nconst white = new Color(255, 255, 255, 1);\nconst brewer = {\n    OrRd: [0xfff7ec, 0xfee8c8, 0xfdd49e, 0xfdbb84, 0xfc8d59, 0xef6548, 0xd7301f, 0xb30000, 0x7f0000],\n    PuBu: [0xfff7fb, 0xece7f2, 0xd0d1e6, 0xa6bddb, 0x74a9cf, 0x3690c0, 0x0570b0, 0x045a8d, 0x023858],\n    BuPu: [0xf7fcfd, 0xe0ecf4, 0xbfd3e6, 0x9ebcda, 0x8c96c6, 0x8c6bb1, 0x88419d, 0x810f7c, 0x4d004b],\n    Oranges: [0xfff5eb, 0xfee6ce, 0xfdd0a2, 0xfdae6b, 0xfd8d3c, 0xf16913, 0xd94801, 0xa63603, 0x7f2704],\n    BuGn: [0xf7fcfd, 0xe5f5f9, 0xccece6, 0x99d8c9, 0x66c2a4, 0x41ae76, 0x238b45, 0x006d2c, 0x00441b],\n    YlOrBr: [0xffffe5, 0xfff7bc, 0xfee391, 0xfec44f, 0xfe9929, 0xec7014, 0xcc4c02, 0x993404, 0x662506],\n    YlGn: [0xffffe5, 0xf7fcb9, 0xd9f0a3, 0xaddd8e, 0x78c679, 0x41ab5d, 0x238443, 0x006837, 0x004529],\n    Reds: [0xfff5f0, 0xfee0d2, 0xfcbba1, 0xfc9272, 0xfb6a4a, 0xef3b2c, 0xcb181d, 0xa50f15, 0x67000d],\n    RdPu: [0xfff7f3, 0xfde0dd, 0xfcc5c0, 0xfa9fb5, 0xf768a1, 0xdd3497, 0xae017e, 0x7a0177, 0x49006a],\n    Greens: [0xf7fcf5, 0xe5f5e0, 0xc7e9c0, 0xa1d99b, 0x74c476, 0x41ab5d, 0x238b45, 0x006d2c, 0x00441b],\n    YlGnBu: [0xffffd9, 0xedf8b1, 0xc7e9b4, 0x7fcdbb, 0x41b6c4, 0x1d91c0, 0x225ea8, 0x253494, 0x081d58],\n    Purples: [0xfcfbfd, 0xefedf5, 0xdadaeb, 0xbcbddc, 0x9e9ac8, 0x807dba, 0x6a51a3, 0x54278f, 0x3f007d],\n    GnBu: [0xf7fcf0, 0xe0f3db, 0xccebc5, 0xa8ddb5, 0x7bccc4, 0x4eb3d3, 0x2b8cbe, 0x0868ac, 0x084081],\n    Greys: [0xffffff, 0xf0f0f0, 0xd9d9d9, 0xbdbdbd, 0x969696, 0x737373, 0x525252, 0x252525, 0x000000],\n    YlOrRd: [0xffffcc, 0xffeda0, 0xfed976, 0xfeb24c, 0xfd8d3c, 0xfc4e2a, 0xe31a1c, 0xbd0026, 0x800026],\n    PuRd: [0xf7f4f9, 0xe7e1ef, 0xd4b9da, 0xc994c7, 0xdf65b0, 0xe7298a, 0xce1256, 0x980043, 0x67001f],\n    Blues: [0xf7fbff, 0xdeebf7, 0xc6dbef, 0x9ecae1, 0x6baed6, 0x4292c6, 0x2171b5, 0x08519c, 0x08306b],\n    PuBuGn: [0xfff7fb, 0xece2f0, 0xd0d1e6, 0xa6bddb, 0x67a9cf, 0x3690c0, 0x02818a, 0x016c59, 0x014636],\n    Viridis: [0x440154, 0x482777, 0x3f4a8a, 0x31678e, 0x26838f, 0x1f9d8a, 0x6cce5a, 0xb6de2b, 0xfee825],\n    Spectral: [\n        0x9e0142,\n        0xd53e4f,\n        0xf46d43,\n        0xfdae61,\n        0xfee08b,\n        0xffffbf,\n        0xe6f598,\n        0xabdda4,\n        0x66c2a5,\n        0x3288bd,\n        0x5e4fa2,\n    ],\n    RdYlGn: [\n        0xa50026,\n        0xd73027,\n        0xf46d43,\n        0xfdae61,\n        0xfee08b,\n        0xffffbf,\n        0xd9ef8b,\n        0xa6d96a,\n        0x66bd63,\n        0x1a9850,\n        0x006837,\n    ],\n    RdBu: [\n        0x67001f,\n        0xb2182b,\n        0xd6604d,\n        0xf4a582,\n        0xfddbc7,\n        0xf7f7f7,\n        0xd1e5f0,\n        0x92c5de,\n        0x4393c3,\n        0x2166ac,\n        0x053061,\n    ],\n    PiYG: [\n        0x8e0152,\n        0xc51b7d,\n        0xde77ae,\n        0xf1b6da,\n        0xfde0ef,\n        0xf7f7f7,\n        0xe6f5d0,\n        0xb8e186,\n        0x7fbc41,\n        0x4d9221,\n        0x276419,\n    ],\n    PRGn: [\n        0x40004b,\n        0x762a83,\n        0x9970ab,\n        0xc2a5cf,\n        0xe7d4e8,\n        0xf7f7f7,\n        0xd9f0d3,\n        0xa6dba0,\n        0x5aae61,\n        0x1b7837,\n        0x00441b,\n    ],\n    RdYlBu: [\n        0xa50026,\n        0xd73027,\n        0xf46d43,\n        0xfdae61,\n        0xfee090,\n        0xffffbf,\n        0xe0f3f8,\n        0xabd9e9,\n        0x74add1,\n        0x4575b4,\n        0x313695,\n    ],\n    BrBG: [\n        0x543005,\n        0x8c510a,\n        0xbf812d,\n        0xdfc27d,\n        0xf6e8c3,\n        0xf5f5f5,\n        0xc7eae5,\n        0x80cdc1,\n        0x35978f,\n        0x01665e,\n        0x003c30,\n    ],\n    RdGy: [\n        0x67001f,\n        0xb2182b,\n        0xd6604d,\n        0xf4a582,\n        0xfddbc7,\n        0xffffff,\n        0xe0e0e0,\n        0xbababa,\n        0x878787,\n        0x4d4d4d,\n        0x1a1a1a,\n    ],\n    PuOr: [\n        0x7f3b08,\n        0xb35806,\n        0xe08214,\n        0xfdb863,\n        0xfee0b6,\n        0xf7f7f7,\n        0xd8daeb,\n        0xb2abd2,\n        0x8073ac,\n        0x542788,\n        0x2d004b,\n    ],\n    Set2: [0x66c2a5, 0xfc8d62, 0x8da0cb, 0xe78ac3, 0xa6d854, 0xffd92f, 0xe5c494, 0xb3b3b3],\n    Accent: [0x7fc97f, 0xbeaed4, 0xfdc086, 0xffff99, 0x386cb0, 0xf0027f, 0xbf5b17, 0x666666],\n    Set1: [0xe41a1c, 0x377eb8, 0x4daf4a, 0x984ea3, 0xff7f00, 0xffff33, 0xa65628, 0xf781bf, 0x999999],\n    Set3: [\n        0x8dd3c7,\n        0xffffb3,\n        0xbebada,\n        0xfb8072,\n        0x80b1d3,\n        0xfdb462,\n        0xb3de69,\n        0xfccde5,\n        0xd9d9d9,\n        0xbc80bd,\n        0xccebc5,\n        0xffed6f,\n    ],\n    Dark2: [0x1b9e77, 0xd95f02, 0x7570b3, 0xe7298a, 0x66a61e, 0xe6ab02, 0xa6761d, 0x666666],\n    Paired: [\n        0xa6cee3,\n        0x1f78b4,\n        0xb2df8a,\n        0x33a02c,\n        0xfb9a99,\n        0xe31a1c,\n        0xfdbf6f,\n        0xff7f00,\n        0xcab2d6,\n        0x6a3d9a,\n        0xffff99,\n        0xb15928,\n    ],\n    Pastel2: [0xb3e2cd, 0xfdcdac, 0xcbd5e8, 0xf4cae4, 0xe6f5c9, 0xfff2ae, 0xf1e2cc, 0xcccccc],\n    Pastel1: [0xfbb4ae, 0xb3cde3, 0xccebc5, 0xdecbe4, 0xfed9a6, 0xffffcc, 0xe5d8bd, 0xfddaec, 0xf2f2f2],\n};\n/**\n * X11 color names\n * http://www.w3.org/TR/css3-color/#svg-color\n *\n * @example chroma.Object.keys(w3cx11).slice(0, 4)\n */\nconst w3cx11 = {\n    aliceblue: 0xf0f8ff,\n    antiquewhite: 0xfaebd7,\n    aqua: 0x00ffff,\n    aquamarine: 0x7fffd4,\n    azure: 0xf0ffff,\n    beige: 0xf5f5dc,\n    bisque: 0xffe4c4,\n    black: 0x000000,\n    blanchedalmond: 0xffebcd,\n    blue: 0x0000ff,\n    blueviolet: 0x8a2be2,\n    brown: 0xa52a2a,\n    burlywood: 0xdeb887,\n    cadetblue: 0x5f9ea0,\n    chartreuse: 0x7fff00,\n    chocolate: 0xd2691e,\n    coral: 0xff7f50,\n    cornflower: 0x6495ed,\n    cornflowerblue: 0x6495ed,\n    cornsilk: 0xfff8dc,\n    crimson: 0xdc143c,\n    cyan: 0x00ffff,\n    darkblue: 0x00008b,\n    darkcyan: 0x008b8b,\n    darkgoldenrod: 0xb8860b,\n    darkgray: 0xa9a9a9,\n    darkgreen: 0x006400,\n    darkgrey: 0xa9a9a9,\n    darkkhaki: 0xbdb76b,\n    darkmagenta: 0x8b008b,\n    darkolivegreen: 0x556b2f,\n    darkorange: 0xff8c00,\n    darkorchid: 0x9932cc,\n    darkred: 0x8b0000,\n    darksalmon: 0xe9967a,\n    darkseagreen: 0x8fbc8f,\n    darkslateblue: 0x483d8b,\n    darkslategray: 0x2f4f4f,\n    darkslategrey: 0x2f4f4f,\n    darkturquoise: 0x00ced1,\n    darkviolet: 0x9400d3,\n    deeppink: 0xff1493,\n    deepskyblue: 0x00bfff,\n    dimgray: 0x696969,\n    dimgrey: 0x696969,\n    dodgerblue: 0x1e90ff,\n    firebrick: 0xb22222,\n    floralwhite: 0xfffaf0,\n    forestgreen: 0x228b22,\n    fuchsia: 0xff00ff,\n    gainsboro: 0xdcdcdc,\n    ghostwhite: 0xf8f8ff,\n    gold: 0xffd700,\n    goldenrod: 0xdaa520,\n    gray: 0x808080,\n    green: 0x008000,\n    greenyellow: 0xadff2f,\n    grey: 0x808080,\n    honeydew: 0xf0fff0,\n    hotpink: 0xff69b4,\n    indianred: 0xcd5c5c,\n    indigo: 0x4b0082,\n    ivory: 0xfffff0,\n    khaki: 0xf0e68c,\n    laserlemon: 0xffff54,\n    lavender: 0xe6e6fa,\n    lavenderblush: 0xfff0f5,\n    lawngreen: 0x7cfc00,\n    lemonchiffon: 0xfffacd,\n    lightblue: 0xadd8e6,\n    lightcoral: 0xf08080,\n    lightcyan: 0xe0ffff,\n    lightgoldenrod: 0xfafad2,\n    lightgoldenrodyellow: 0xfafad2,\n    lightgray: 0xd3d3d3,\n    lightgreen: 0x90ee90,\n    lightgrey: 0xd3d3d3,\n    lightpink: 0xffb6c1,\n    lightsalmon: 0xffa07a,\n    lightseagreen: 0x20b2aa,\n    lightskyblue: 0x87cefa,\n    lightslategray: 0x778899,\n    lightslategrey: 0x778899,\n    lightsteelblue: 0xb0c4de,\n    lightyellow: 0xffffe0,\n    lime: 0x00ff00,\n    limegreen: 0x32cd32,\n    linen: 0xfaf0e6,\n    magenta: 0xff00ff,\n    maroon: 0x800000,\n    maroon2: 0x7f0000,\n    maroon3: 0xb03060,\n    mediumaquamarine: 0x66cdaa,\n    mediumblue: 0x0000cd,\n    mediumorchid: 0xba55d3,\n    mediumpurple: 0x9370db,\n    mediumseagreen: 0x3cb371,\n    mediumslateblue: 0x7b68ee,\n    mediumspringgreen: 0x00fa9a,\n    mediumturquoise: 0x48d1cc,\n    mediumvioletred: 0xc71585,\n    midnightblue: 0x191970,\n    mintcream: 0xf5fffa,\n    mistyrose: 0xffe4e1,\n    moccasin: 0xffe4b5,\n    navajowhite: 0xffdead,\n    navy: 0x000080,\n    oldlace: 0xfdf5e6,\n    olive: 0x808000,\n    olivedrab: 0x6b8e23,\n    orange: 0xffa500,\n    orangered: 0xff4500,\n    orchid: 0xda70d6,\n    palegoldenrod: 0xeee8aa,\n    palegreen: 0x98fb98,\n    paleturquoise: 0xafeeee,\n    palevioletred: 0xdb7093,\n    papayawhip: 0xffefd5,\n    peachpuff: 0xffdab9,\n    peru: 0xcd853f,\n    pink: 0xffc0cb,\n    plum: 0xdda0dd,\n    powderblue: 0xb0e0e6,\n    purple: 0x800080,\n    purple2: 0x7f007f,\n    purple3: 0xa020f0,\n    rebeccapurple: 0x663399,\n    red: 0xff0000,\n    rosybrown: 0xbc8f8f,\n    royalblue: 0x4169e1,\n    saddlebrown: 0x8b4513,\n    salmon: 0xfa8072,\n    sandybrown: 0xf4a460,\n    seagreen: 0x2e8b57,\n    seashell: 0xfff5ee,\n    sienna: 0xa0522d,\n    silver: 0xc0c0c0,\n    skyblue: 0x87ceeb,\n    slateblue: 0x6a5acd,\n    slategray: 0x708090,\n    slategrey: 0x708090,\n    snow: 0xfffafa,\n    springgreen: 0x00ff7f,\n    steelblue: 0x4682b4,\n    tan: 0xd2b48c,\n    teal: 0x008080,\n    thistle: 0xd8bfd8,\n    tomato: 0xff6347,\n    turquoise: 0x40e0d0,\n    violet: 0xee82ee,\n    wheat: 0xf5deb3,\n    white: 0xffffff,\n    whitesmoke: 0xf5f5f5,\n    yellow: 0xffff00,\n    yellowgreen: 0x9acd32,\n};\n/**\n * Return a new [[CubeHelix]].\n *\n * @example chroma.cubehelix() // use the default helix\n * @example chroma.cubehelix().start(200).rotations(-0.5).gamma(0.8).lightness([0.3, 0.8])\n */\nfunction cubehelix(start = 300, rotations = -1.5, hue = 1, gamma = 1, lightness = [0, 1]) {\n    const f = ((t) => f.at(t));\n    Object.getOwnPropertyNames(CubeHelix.prototype).forEach((key) => (f[key] = CubeHelix.prototype[key]));\n    f.start(start);\n    f.rotations(rotations);\n    f.hue(hue);\n    f.gamma(gamma);\n    f.lightness(lightness);\n    return f;\n}\nclass CubeHelix {\n    start(s) {\n        if (undefined === s) {\n            return this._start;\n        }\n        this._start = s;\n        return this;\n    }\n    rotations(r) {\n        if (undefined === r) {\n            return this._rotations;\n        }\n        this._rotations = r;\n        return this;\n    }\n    gamma(g) {\n        if (undefined === g) {\n            return this._gamma;\n        }\n        this._gamma = g;\n        return this;\n    }\n    hue(h) {\n        if (undefined === h) {\n            return this._hue;\n        }\n        this._hue = Array.isArray(h) ? h : [h, h];\n        return this;\n    }\n    lightness(h) {\n        if (undefined === h) {\n            return this._lightness;\n        }\n        this._lightness = Array.isArray(h) ? h : [h, h];\n        return this;\n    }\n    /**\n     * Convert to a [[Scale]].\n     *\n     * @example chroma.cubehelix().scale().correctLightness().domain(2, 22)\n     */\n    scale() {\n        return scale(this);\n    }\n    at(fract) {\n        const a = TWOPI * ((this._start + 120) / 360 + this._rotations * fract);\n        const l = lerp(this._lightness[0], this._lightness[1], fract) ** this._gamma;\n        const h = lerp(this._hue[0], this._hue[1], fract);\n        const amp = (h * l * (1 - l)) / 2;\n        const cos_a = cos(a);\n        const sin_a = sin(a);\n        const r = l + amp * (-0.14861 * cos_a + 1.78277 * sin_a);\n        const g = l + amp * (-0.29227 * cos_a - 0.90649 * sin_a);\n        const b = l + amp * (+1.97294 * cos_a);\n        return rgb([r * 255, g * 255, b * 255, 1]);\n    }\n}\n/**\n * Create a new random [Color] from a random point in the RGB color space.\n * @param randomSource A function which returns random `number`s in the interval [0; 1). Useful if you want to\n *     create a deterministic sequence of "random" colors. Defaults to `Math.random`.\n */\nfunction random(randomSource = Math.random) {\n    return num((randomSource() * 16777216) | 0);\n}\n/**\n * Create a valid RGB color (`.clipped() == false`) from a random point in the CIELAB color space. This results in\n * more colors in the RGB color space where humans can perceive more differences.\n * @param randomSource A function which returns random `number`s in the interval [0; 1). Useful if you want to\n *     create a deterministic sequence of "random" colors. Defaults to `Math.random`.\n * @example chroma.random((() => { let i = 0; return () => (i = (i *Math.SQRT2) % 1); })())\n */\n// export function randomLab(randomSource = Math.random) {\n// \tconst labAMin = -87,\n// \t\tlabAMax = 99,\n// \t\tlabBMin = -108,\n// \t\tlabBMax = 95\n// \tlet maxIterations = 100\n// \twhile (maxIterations--) {\n// \t\tconst u = randomSource(),\n// \t\t\tv = randomSource(),\n// \t\t\tw = randomSource()\n// \t\t// The following matrix multiplication transform the random point (u v w) in the unit cube into the\n// \t\t// oriented bounding box (OBB) of the projection of the RGB space into the LAB space. This is necessary to\n// \t\t// avoid a huge number of misses.\n// \t\tconst color = lab(\n// \t\t\tu * -53.903 + v * -88.755 + w * 71.7 + 99.707,\n// \t\t\tu * -82.784 + v * 187.036 + w * -2.422 + -28.17,\n// \t\t\tu * -75.813 + v * -141.406 + w * -48.261 + 152.469,\n// \t\t)\n// \t\tconsole.log(color.lab())\n// \t\tconsole.log(color.rgba(false, false))\n// \t\tif (!color.clipped()) return color\n// \t}\n// \tthrow new Error("Could find a random color in 100 iterations")\n// }\n/**\n * Mixes two colors. The mix ratio is a value between 0 and 1.\n * The color mixing produces different results based the color space used for interpolation.\n *\n * @param col2\n * @param f\n * @param m\n * @example chroma.mix(\'red\', \'blue\')\n * @example chroma.mix(\'red\', \'blue\', 0.25)\n * @example chroma.mix(\'red\', \'blue\', 0.75)\n *\n * @example chroma.mix(\'red\', \'blue\', 0.5, \'rgb\')\n * @example chroma.mix(\'red\', \'blue\', 0.5, \'hsl\')\n * @example chroma.mix(\'red\', \'blue\', 0.5, \'lab\')\n * @example chroma.mix(\'red\', \'blue\', 0.5, \'lch\')\n * @example chroma.mix(\'red\', \'blue\', 0.5, \'lrgb\')\n */\nfunction mix(col1, col2, f = 0.5, m = "rgb") {\n    const c1 = color(col1);\n    const c2 = color(col2);\n    const res = interpolators[m] && interpolators[m](c1, c2, f, m);\n    if (!res) {\n        throw new Error("color mode " + m + " is not supported");\n    }\n    return res.alpha(lerp(c1.alpha(), c2.alpha(), f));\n}\n/**\n * Parse a CSS color. See [MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/color) for all the possible\n * variants.\n *\n * @example chroma.css(\'hsl(2rad 90% 50% / 0.9)\')\n * @example chroma.css(\'laserlemon\')\n */\nfunction css(cssString) {\n    const [r, g, b, a] = css2rgb(cssString);\n    return new Color(r, g, b, a);\n}\nfunction cmyk(...args) {\n    return guess(args, "cmyk");\n}\nfunction gl(...args) {\n    return guess(args, "gl");\n}\nfunction hcg(...args) {\n    return guess(args, "hcg");\n}\nfunction lch(...args) {\n    return guess(args, "lch");\n}\nfunction hsi(...args) {\n    return guess(args, "hsi");\n}\nfunction hsl(...args) {\n    return guess(args, "hsl");\n}\nfunction hsv(...args) {\n    return guess(args, "hsv");\n}\n/**\n *\n * @param temperature\n * @example chroma.kelvin(2000) // candle light\n * @example chroma.kelvin(3500) // sunset\n * @example chroma.kelvin(6500) // daylight\n * @example x0_1 => chroma.kelvin(x0_1 * 30000) // effective range: [0; 30000]\n */\nfunction kelvin(temperature) {\n    const [r, g, b] = kelvin2rgb(temperature);\n    return new Color(r, g, b);\n}\nfunction lab(...args) {\n    return guess(args, "lab");\n}\n/**\n * @example chroma.num(0x663399) // rebeccapurple\n */\nfunction num(num) {\n    const [r, g, b] = num2rgb(num);\n    return new Color(r, g, b);\n}\nfunction rgb(...args) {\n    return guess(args, "rgb");\n}\nfunction xyz(...args) {\n    return guess(args, "xyz");\n}\n/**\n * Similar to mix, but accepts more than two colors.\n *\n * @example colors = [\'#ddd\', \'yellow\', \'red\', \'teal\']\n * @example chroma.average(colors) // default = \'rgb\'\n * @example chroma.average(colors, \'lab\')\n * @example chroma.average(colors, \'lch\')\n * @example chroma.average(colors, \'lrgb\')\n * @example chroma.average([\'red\', \'rgba(0,0,0,0.5)\']).css()\n */\nfunction average(chromables, mode = "rgb") {\n    const colors = chromables.map((c) => color(c));\n    if (mode == "lrgb") {\n        return _average_lrgb(colors);\n    }\n    if (mode == "num") {\n        let numSum = 0, alphaSum = 0;\n        for (const col of colors) {\n            numSum += col.num();\n            alphaSum += col.alpha();\n        }\n        return num(numSum / colors.length).alpha(alphaSum / colors.length);\n    }\n    const xyz = [0, 0, 0];\n    let dx = 0;\n    let dy = 0;\n    let alphaSum = 0;\n    for (const c of colors) {\n        const xyz2 = c[mode]();\n        alphaSum += c.alpha();\n        for (let i = 0; i < xyz.length; i++) {\n            if (mode.charAt(i) == "h") {\n                const A = xyz2[i] * DEG2RAD;\n                dx += cos(A);\n                dy += sin(A);\n            }\n            else {\n                xyz[i] += xyz2[i];\n            }\n        }\n    }\n    for (let i = 0; i < xyz.length; i++) {\n        if (mode.charAt(i) == "h") {\n            const A = atan2(dy / colors.length, dx / colors.length) * RAD2DEG;\n            xyz[i] = (A + 360) % 360;\n        }\n        else {\n            xyz[i] = xyz[i] / colors.length;\n        }\n    }\n    return guess(xyz, mode).alpha(alphaSum / colors.length);\n}\nfunction bezier(...args) {\n    const chromables = Array.isArray(args[0]) ? args[0] : args;\n    const f = _bezier(chromables);\n    f.scale = CubeHelix.prototype.scale;\n    return f;\n}\n/**\n * Blends two colors using RGB channel-wise blend functions.\n * @param bottom\n * @param top\n * @param mode\n * @example chroma.blend(\'4CBBFC\', \'EEEE22\', \'multiply\')\n * @example chroma.blend(\'4CBBFC\', \'EEEE22\', \'darken\')\n * @example chroma.blend(\'4CBBFC\', \'EEEE22\', \'lighten\')\n */\nfunction blend(bottom, top, mode) {\n    if (!blend_fs[mode]) {\n        throw new Error("unknown blend mode " + mode);\n    }\n    return blend_fs[mode](bottom, top);\n}\nconst blend_fs = {\n    normal: blend_f(each((a, _) => a)),\n    multiply: blend_f(each((a, b) => (a * b) / 255)),\n    screen: blend_f(each(_screen)),\n    overlay: blend_f(each(_overlay)),\n    darken: blend_f(each(min)),\n    lighten: blend_f(each(max)),\n    dodge: blend_f(each(_dodge)),\n    burn: blend_f(each(_burn)),\n};\nfunction scale(...args) {\n    const f = ((t) => f._at(t));\n    Object.getOwnPropertyNames(Scale.prototype).forEach((key) => (f[key] = Scale.prototype[key]));\n    if (Array.isArray(args[0]))\n        args = args[0];\n    if (args.length == 1 && "string" == typeof args[0])\n        args = brewer[args[0]];\n    f._init("function" == typeof args[0] ? args[0] : args.map((a) => color(a)));\n    //f.setColors(args.length > 1 ? args : args[0])\n    return f;\n}\nclass Scale {\n    classes(classes) {\n        if (undefined === classes) {\n            return this._classes;\n        }\n        if (Array.isArray(classes)) {\n            this._classes = classes;\n            this.domain(classes[0], classes[classes.length - 1]);\n        }\n        else {\n            if (classes % 1 != 0 || classes < 1)\n                throw new Error("invalid classes param");\n            // const d = analyze(this.domain())\n            this._classes = limits(this.domain(), "e", classes);\n        }\n        return this;\n    }\n    domain(...domain) {\n        if (undefined === domain[0]) {\n            return "function" !== typeof this._colors\n                ? this._pos.map((p) => lerp(this._min, this._max, p))\n                : [this._min, this._max];\n        }\n        this._min = domain[0];\n        this._max = domain[domain.length - 1];\n        if (2 == domain.length) {\n            if ("function" !== typeof this._colors) {\n                // equidistant positions\n                this._pos = this._colors.map((_, c) => c / (this._colors.length - 1));\n            }\n        }\n        else if ("function" !== typeof this._colors && domain.length == this._colors.length) {\n            this._pos = domain.map((d) => lerpInv(this._min, this._max, d));\n        }\n        else {\n            throw new Error("invalid domain " + domain);\n        }\n        return this;\n    }\n    mode(mode) {\n        if (undefined === mode) {\n            return this._mode;\n        }\n        this._mode = mode;\n        this._resetCache();\n        return this;\n    }\n    /**\n     * Set the output format return by `this(x)` and `this.colors(n)`.\n     * @param outputFormat The color format to use. Pass `undefined` to return [Color] objects.\n     * @return `this`\n     * @example chroma.scale("red", "white").out("hex")(0) // == "#ff0000"\n     * @example chroma.scale("red", "white").out("num").colors(2) // == [0xff0000, 0xffffff]\n     */\n    out(outputFormat) {\n        this._out = outputFormat;\n        return this;\n    }\n    /**\n     * This makes sure the lightness range is spread evenly across a color scale. Especially useful when working\n     * with [multi-hue color scales](https://www.vis4.net/blog/2013/09/mastering-multi-hued-color-scales/), where\n     * simple gamma correction can\'t help you very much.\n     *\n     * @example chroma.scale(\'black\',\'red\',\'yellow\',\'white\')\n     * @example chroma.scale(\'black\',\'red\',\'yellow\',\'white\').correctLightness()\n     */\n    correctLightness(enableCorrectLightness = true) {\n        if (this._correctLightness != enableCorrectLightness) {\n            this._resetCache();\n            const colors = this._colors;\n            if (enableCorrectLightness && "function" !== typeof colors) {\n                // make sure that the colors have ascending or descending lightnesses\n                let sign = 0;\n                for (let i = 1; i < colors.length; i++) {\n                    const sign2 = colors[i].lab()[0] - colors[i - 1].lab()[0];\n                    if (0 == sign) {\n                        sign = sign2;\n                    }\n                    else if (sign * sign2 < 0) {\n                        throw new Error("scale color lightnesses must be monotonic");\n                    }\n                }\n            }\n        }\n        this._correctLightness = enableCorrectLightness;\n        return this;\n    }\n    padding(paddingLeft, paddingRight = paddingLeft) {\n        if (!paddingLeft) {\n            return [this._paddingLeft, this._paddingRight];\n        }\n        this._paddingLeft = paddingLeft;\n        this._paddingRight = paddingRight;\n        return this;\n    }\n    /**\n     * Get a number of equidistant colors.\n     * @param numColors The number of colors to return.\n     * @param format Output format. Defaults to `"hex"`. Pass `"color"` to get {@link Color} objects.\n     * @returns If `numColors` is `undefined`, the colors which define this [Scale]. If `numColors` is 1,\n     * `[this((min + max) / 2)]`. Otherwise, an array where the first element is `this(min)`, the last one is\n     * `this(max)` and the rest are equidistant samples between min and max.\n     * @example chroma.scale(\'OrRd\').colors(5)\n     * @example chroma.scale([\'white\', \'black\']).colors(12)\n     */\n    colors(numColors, format = "hex") {\n        let result;\n        if (undefined === numColors) {\n            result = this._colors.slice();\n        }\n        else if (numColors == 1) {\n            result = [this._color((this._min + this._max) / 2)];\n        }\n        else if (numColors > 1) {\n            result = Array.from({ length: numColors }, (_, i) => this._color(lerp(this._min, this._max, i / (numColors - 1))));\n        }\n        else {\n            // returns all colors based on the defined classes\n            let samples;\n            if (this._classes && this._classes.length > 2) {\n                samples = Array.from({ length: this._classes.length - 1 }, (_, i) => (this._classes[i] + this._classes[i + 1]) * 0.5);\n            }\n            else {\n                samples = this.domain(); // TODO?!\n            }\n            result = samples.map((s) => this._color(s));\n        }\n        return (format != "color" ? result.map((c) => c[format]()) : result);\n    }\n    cache(enableCache) {\n        if (undefined === enableCache) {\n            return !!this._cache;\n        }\n        this._cache = enableCache ? this._cache || new Map() : undefined;\n        return this;\n    }\n    gamma(gamma) {\n        if (undefined === gamma) {\n            return this._gamma;\n        }\n        this._gamma = gamma;\n        return this;\n    }\n    /**\n     * @ignore\n     */\n    _at(t) {\n        const c = this._color(t);\n        return this._out ? c[this._out]() : c;\n    }\n    /**\n     * @ignore\n     */\n    _init(colorsOrFunction) {\n        this._colors = colorsOrFunction;\n        if ("function" != typeof colorsOrFunction) {\n            this._pos = colorsOrFunction.map((_, i) => i / (colorsOrFunction.length - 1));\n        }\n        this._mode = "rgb";\n        this.domain(0, 1);\n        this._paddingLeft = 0;\n        this._paddingRight = 0;\n        this._correctLightness = false;\n        this._cache = new Map();\n        this._gamma = 1;\n    }\n    _getClass(value) {\n        return this._classes.findIndex((cls) => value <= cls) - 1;\n    }\n    _color(val, bypassMap = false) {\n        let t;\n        if (!bypassMap) {\n            const min = this._min, max = this._max;\n            if (this._classes && this._classes.length > 2) {\n                const c = this._getClass(val);\n                t = c / (this._classes.length - 2);\n            }\n            else if (max !== min) {\n                t = (val - min) / (max - min);\n            }\n            else {\n                t = 1;\n            }\n            if (this._correctLightness) {\n                t = this._tCorrectedLightness(t);\n            }\n        }\n        else {\n            t = val;\n        }\n        t = t ** this._gamma;\n        t = (this._paddingLeft + t) / (1 + this._paddingLeft + this._paddingRight);\n        //\tt = this._paddingLeft + t * (1 - this._paddingLeft - this._paddingRight)\n        t = clamp(t, 0, 1);\n        const tHash = t;\n        const cacheResult = this._cache && this._cache.get(tHash);\n        if (cacheResult) {\n            return cacheResult;\n        }\n        else {\n            let col;\n            if (Array.isArray(this._colors)) {\n                for (let i = 0; i < this._pos.length; i++) {\n                    const p = this._pos[i];\n                    if (t <= p) {\n                        col = this._colors[i];\n                        break;\n                    }\n                    if (t >= p && i == this._pos.length - 1) {\n                        col = this._colors[i];\n                        break;\n                    }\n                    if (t > p && t < this._pos[i + 1]) {\n                        t = (t - p) / (this._pos[i + 1] - p);\n                        col = mix(this._colors[i], this._colors[i + 1], t, this._mode);\n                        break;\n                    }\n                }\n            }\n            else {\n                col = this._colors(t);\n            }\n            if (this._cache) {\n                // tslint:disable-next-line\n                this._cache.set(tHash, col);\n            }\n            // tslint:disable-next-line\n            return col;\n        }\n    }\n    _tCorrectedLightness(t0_1) {\n        const L0 = this._color(0, true).lab()[0];\n        const L1 = this._color(1, true).lab()[0];\n        const L_ideal = lerp(L0, L1, t0_1);\n        return bisect((t) => this._color(t, true).lab()[0] - L_ideal, 0, 1, 8);\n    }\n    _resetCache() {\n        if (this._cache)\n            this._cache.clear();\n    }\n}\nvar scales;\n(function (scales) {\n    /**\n     * @example chroma.scales.cool()\n     */\n    function cool() {\n        return scale([hsl(180, 1, 0.9), hsl(250, 0.7, 0.4)]);\n    }\n    scales.cool = cool;\n    /**\n     * @example chroma.scales.hot()\n     */\n    function hot() {\n        return scale(["#000", "#f00", "#ff0", "#fff"]).mode("rgb");\n    }\n    scales.hot = hot;\n})(scales || (scales = {}));\n/**\n * Computes the WCAG contrast ratio between two colors. A minimum contrast of 4.5:1\n * [is recommended](http://www.w3.org/TR/WCAG20-TECHS/G18.html) to ensure that text is still readable against a\n * background color.\n *\n * @param a\n * @param b\n */\nfunction contrast(a, b) {\n    const l1 = color(a).luminance();\n    const l2 = color(b).luminance();\n    if (l1 > l2) {\n        return (l1 + 0.05) / (l2 + 0.05);\n    }\n    else {\n        return (l2 + 0.05) / (l1 + 0.05);\n    }\n}\n/**\n * Compute the [euclidean distance](https://en.wikipedia.org/wiki/Euclidean_distance#Three_dimensions) between two\n * colors in a given color space.\n * @param a First color.\n * @param b Second color.\n * @param mode The color space in which to compute the distance. Defaults to "lab".\n * @example chroma.distance(\'#fff\', \'#ff0\', \'rgb\')\n * @example chroma.distance(\'#fff\', \'#f0f\', \'rgb\')\n * @example chroma.distance(\'#fff\', \'#ff0\')\n * @example chroma.distance(\'#fff\', \'#f0f\')\n */\nfunction distance(a, b, mode = "lab") {\n    const l1 = color(a)[mode]();\n    const l2 = color(b)[mode]();\n    const channelDifferences = l1.map((channelValue, channelIndex) => channelValue - l2[channelIndex]);\n    return hypot(...channelDifferences);\n}\n/**\n * Computes color difference as developed by the Colour Measurement Committee of the Society of Dyers and Colourists\n * (CMC) in 1984. The implementation is adapted from Bruce Lindbloom. The parameters L and C are weighting factors\n * for lightness and chromaticity.\n * @param reference\n * @param sample\n * @param L\n * @param C\n * @example [r = \'#ededee\', s = \'#edeeed\', chroma.deltaE(r, s)]\n * @example [r = \'#ececee\', s = \'#eceeec\', chroma.deltaE(r, s)]\n * @example [r = \'#e9e9ee\', s = \'#e9eee9\', chroma.deltaE(r, s)]\n * @example [r = \'#e4e4ee\', s = \'#e4eee4\', chroma.deltaE(r, s)]\n * @example [r = \'#e0e0ee\', s = \'#e0eee0\', chroma.deltaE(r, s)]\n */\nfunction deltaE(reference, sample, L = 1, C = 1) {\n    const [L1, a1, b1] = color(reference).lab();\n    const [L2, a2, b2] = color(sample).lab();\n    const c1 = sqrt(a1 * a1 + b1 * b1);\n    const c2 = sqrt(a2 * a2 + b2 * b2);\n    const sl = L1 < 16.0 ? 0.511 : (0.040975 * L1) / (1.0 + 0.01765 * L1);\n    const sc = (0.0638 * c1) / (1.0 + 0.0131 * c1) + 0.638;\n    const h1 = norm360(c1 < 0.000001 ? 0.0 : atan2(b1, a1) * RAD2DEG);\n    const t = h1 >= 164.0 && h1 <= 345.0\n        ? 0.56 + abs(0.2 * cos((h1 + 168.0) * DEG2RAD))\n        : 0.36 + abs(0.4 * cos((h1 + 35.0) * DEG2RAD));\n    const c4 = c1 * c1 * c1 * c1;\n    const f = sqrt(c4 / (c4 + 1900.0));\n    const sh = sc * (f * t + 1.0 - f);\n    const delL = L1 - L2;\n    const delC = c1 - c2;\n    const delA = a1 - a2;\n    const delB = b1 - b2;\n    const dH2 = delA * delA + delB * delB - delC * delC;\n    const v1 = delL / (L * sl);\n    const v2 = delC / (C * sc);\n    const v3 = sh;\n    return sqrt(v1 * v1 + v2 * v2 + dH2 / (v3 * v3));\n}\nfunction analyze(data) {\n    const r = {\n        min: Infinity,\n        max: -Infinity,\n        sum: 0,\n        values: [],\n        count: 0,\n    };\n    function add(val) {\n        if (val != undefined && !isNaN(val)) {\n            r.values.push(val);\n            r.sum += val;\n            if (val < r.min)\n                r.min = val;\n            if (val > r.max)\n                r.max = val;\n            r.count += 1;\n        }\n    }\n    data.forEach((val) => add(val));\n    r.domain = [r.min, r.max];\n    r.limits = function (mode, num) {\n        return limits(this, mode, num);\n    };\n    return r;\n}\nfunction limits(data, mode = "e", num = 7) {\n    const info = Array.isArray(data) ? analyze(data) : data;\n    const { min, max, values } = info;\n    values.sort((a, b) => a - b);\n    if (num == 1) {\n        return [min, max];\n    }\n    if (mode.startsWith("c")) {\n        return [min, max];\n    }\n    else if (mode.startsWith("e")) {\n        return Array.from({ length: num + 1 }, (_, i) => lerp(min, max, i / num));\n    }\n    else if (mode.startsWith("l")) {\n        if (min <= 0) {\n            throw new Error("Logarithmic scales are only possible for values > 0");\n        }\n        const min_log = Math.LOG10E * log(min);\n        const max_log = Math.LOG10E * log(max);\n        return Array.from({ length: num + 1 }, (_, i) => 10 ** lerp(min_log, max_log, i / num));\n    }\n    else if (mode.startsWith("q")) {\n        return Array.from({ length: num + 1 }, (_, i) => {\n            const p = ((values.length - 1) * i) / num;\n            const pb = floor(p);\n            return pb == p ? values[pb] : lerp(values[pb], values[pb + 1], p - pb);\n        });\n    }\n    else if (mode.startsWith("k")) {\n        // implementation based on\n        // http://code.google.com/p/figue/source/browse/trunk/figue.js#336\n        // simplified for 1-d input values\n        const n = values.length;\n        const assignments = new Array(n);\n        const clusterSizes = new Array(num);\n        let repeat = true;\n        let nb_iters = 0;\n        let centroids = Array.from({ length: num + 1 }, (_, i) => lerp(min, max, i / num));\n        do {\n            // assignment step\n            clusterSizes.fill(0);\n            for (let i = 0; i < values.length; i++) {\n                const value = values[i];\n                const minDistIndex = indexOfMax(centroids, (c) => -abs(c - value));\n                clusterSizes[minDistIndex]++;\n                assignments[i] = minDistIndex;\n            }\n            // update centroids step\n            const newCentroids = new Array(num).fill(0);\n            for (let i = 0; i < assignments.length; i++) {\n                const cluster = assignments[i];\n                newCentroids[cluster] += values[i];\n            }\n            for (let j = 0; j < newCentroids.length; j++) {\n                newCentroids[j] /= clusterSizes[j];\n            }\n            // check convergence\n            repeat = newCentroids.some((nc, j) => nc != centroids[j]);\n            centroids = newCentroids;\n        } while (nb_iters++ < 200 && repeat);\n        // finished k-means clustering\n        // the next part is borrowed from gabrielflor.it\n        const kClusters = Array.from({ length: num }, () => []);\n        for (let i = 0; i < assignments.length; i++) {\n            const cluster = assignments[i];\n            kClusters[cluster].push(values[i]);\n        }\n        const tmpKMeansBreaks = [];\n        for (const kCluster of kClusters) {\n            tmpKMeansBreaks.push(kCluster[0], kCluster[kCluster.length - 1]);\n        }\n        tmpKMeansBreaks.sort((a, b) => a - b);\n        const limits = [];\n        limits.push(tmpKMeansBreaks[0]);\n        for (let i = 1; i < tmpKMeansBreaks.length; i += 2) {\n            const v = tmpKMeansBreaks[i];\n            if (!isNaN(v) && limits.indexOf(v) == -1) {\n                limits.push(v);\n            }\n        }\n        return limits;\n    }\n    else {\n        throw new Error("unknown mode");\n    }\n}\nconst interpolators = {};\n// const _guess_formats: { p: number; test: (args: any[]) => ColorFormat | undefined }[] = []\nconst _input = {};\nfunction linear_interpolator(col1, col2, f, m) {\n    const xyz1 = col1[m]();\n    const xyz2 = col2[m]();\n    return guess([\n        lerp(xyz1[0], xyz2[0], f),\n        lerp(xyz1[1], xyz2[1], f),\n        lerp(xyz1[2], xyz2[2], f),\n        lerp(col1.alpha(), col2.alpha(), f),\n    ], m);\n}\ninterpolators.xyz = interpolators.rgb = interpolators.lab = linear_interpolator;\ninterpolators.num = function (col1, col2, f) {\n    const n1 = col1.num();\n    const n2 = col2.num();\n    return num(lerp(n1, n2, f));\n};\ninterpolators.lrgb = function (col1, col2, f) {\n    const [r1, g1, b1, a1] = col1.rgba(false, false);\n    const [r2, g2, b2, a2] = col2.rgba(false, false);\n    return new Color(sqrt(r1 ** 2 * (1 - f) + r2 ** 2 * f), sqrt(g1 ** 2 * (1 - f) + g2 ** 2 * f), sqrt(b1 ** 2 * (1 - f) + b2 ** 2 * f), lerp(a1, a2, f));\n};\nfunction _bezier(chromables) {\n    const colors = chromables.map((c) => color(c));\n    const [lab0, lab1, lab2, lab3] = colors.map((c) => c.lab());\n    if (2 == chromables.length) {\n        // linear interpolation\n        return (t) => {\n            return lab([0, 1, 2].map((i) => lerp(lab0[i], lab1[i], t)));\n        };\n    }\n    else if (3 == chromables.length) {\n        // quadratic bezier interpolation\n        const bezier2 = (p0, p1, p2, t) => (1 - t) ** 2 * p0 + 2 * (1 - t) * t * p1 + t ** 2 * p2;\n        return (t) => lab([0, 1, 2].map((i) => bezier2(lab0[i], lab1[i], lab2[i], t)));\n    }\n    else if (4 == chromables.length) {\n        // cubic bezier interpolation\n        const bezier3 = (p0, p1, p2, p3, t) => (1 - t) ** 3 * p0 + 3 * (1 - t) ** 2 * t * p1 + 3 * (1 - t) * t ** 2 * p2 + t ** 3 * p3;\n        return (t) => lab([0, 1, 2].map((i) => bezier3(lab0[i], lab1[i], lab2[i], lab3[i], t)));\n    }\n    else if (5 == chromables.length) {\n        const I0 = _bezier(colors.slice(0, 3));\n        const I1 = _bezier(colors.slice(2, 5));\n        return (t) => (t < 0.5 ? I0(t * 2) : I1((t - 0.5) * 2));\n    }\n    else\n        throw new Error();\n}\nfunction guess(args, mode) {\n    if (Array.isArray(args[0]))\n        args = args[0];\n    if (!mode) {\n        if (args.length == 1 && args[0] in w3cx11) {\n            mode = "name";\n        }\n        else if (args.length == 1 && "string" == typeof args[0]) {\n            mode = "css";\n        }\n        else if (args.length == 3) {\n            mode = "rgb";\n        }\n        else if (args.length == 4 && "number" == typeof args[3] && args[3] >= 0 && args[3] <= 1) {\n            mode = "rgb";\n        }\n        else if (args.length == 1 && "number" == typeof args[0] && args[0] >= 0 && args[0] <= 0xffffff) {\n            mode = "num";\n        }\n        else\n            throw new Error("could not guess mode. args " + JSON.stringify(args));\n    }\n    const channels = _input[mode](...args);\n    return new Color(channels[0], channels[1], channels[2], undefined !== channels[3] ? channels[3] : 1);\n}\nfunction _average_lrgb(colors) {\n    let rSquareSum = 0, gSquareSum = 0, bSquareSum = 0, alphaSum = 0;\n    for (const col of colors) {\n        const [r, g, b, alpha] = col.rgba(false, false);\n        rSquareSum += r ** 2;\n        gSquareSum += g ** 2;\n        bSquareSum += b ** 2;\n        alphaSum += alpha;\n    }\n    return new Color(sqrt(rSquareSum) / colors.length, sqrt(gSquareSum) / colors.length, sqrt(bSquareSum) / colors.length, alphaSum / colors.length);\n}\nfunction hex2rgb(hex) {\n    let m;\n    if ((m = hex.match(/^#?([A-F\\d]{2})([A-F\\d]{2})([A-F\\d]{2})([A-F\\d]{2})?$/i))) {\n        return [parseInt(m[1], 16), parseInt(m[2], 16), parseInt(m[3], 16), m[4] ? parseInt(m[4], 16) / 255 : 1];\n    }\n    else if ((m = hex.match(/^#?([A-F\\d])([A-F\\d])([A-F\\d])([A-F\\d])?$/i))) {\n        return [\n            parseInt(m[1], 16) * 0x11,\n            parseInt(m[2], 16) * 0x11,\n            parseInt(m[3], 16) * 0x11,\n            m[4] ? (parseInt(m[4], 16) * 0x11) / 255 : 1,\n        ];\n    }\n    throw new Error("invalid hex color: " + hex);\n}\n// interface ColorModes {\n// \tcmyk: CMYK\n// \tgl: GL\n// \trgb: RGB\n// \trgba: RGBA\n// \tlab: LAB\n// \thsl: HSL\n// \thsv: HSV\n// \thsi: HSI\n// \txyz: XYZ\n// \thcg: HCG\n// \tlch: LCH\n// \thex: string\n// \tnum: number\n// \tname: string\n// \tkelvin: number\n// \tcss: string\n// }\nfunction rgb2hex(r255, g255, b255, a1, mode = "rgb") {\n    r255 = clamp(round(r255), 0, 255);\n    g255 = clamp(round(g255), 0, 255);\n    b255 = clamp(round(b255), 0, 255);\n    const rgb = (r255 << 16) | (g255 << 8) | b255;\n    const rgbString = rgb.toString(16).padStart(6, "0");\n    const alphaString = round(clamp(a1) * 255)\n        .toString(16)\n        .padStart(2, "0");\n    return "#" + ("argb" == mode ? alphaString + rgbString : "rgba" == mode ? rgbString + alphaString : rgbString);\n}\n_input.lrgb = _input.rgb;\n_input.hex = hex2rgb;\n_input.hsl = hsl2rgb;\nfunction norm360(degrees) {\n    return ((degrees % 360) + 360) % 360;\n}\n_input.hsv = hsv2rgb;\nfunction num2rgb(num) {\n    if (!("number" == typeof num && num >= 0 && num <= 0xffffff)) {\n        throw new Error("unknown num color: " + num);\n    }\n    const r = num >> 16;\n    const g = (num >> 8) & 0xff;\n    const b = num & 0xff;\n    return [r, g, b, 1];\n}\nfunction rgb2num(r255, g255, b255, a1 = 1, mode = "rgb") {\n    const rgbNum = (round(r255) << 16) | (round(g255) << 8) | round(b255);\n    if ("rgb" === mode) {\n        return rgbNum;\n    }\n    else if ("rgba" === mode) {\n        return (rgbNum << 8) | (round(a1 * 255) << 24);\n    }\n    else {\n        return (round(a1 * 255) << 24) | rgbNum;\n    }\n}\n_input.num = num2rgb;\nconst WS = "\\\\s*";\nconst FLOAT = "([+-]?(?:\\\\d*\\\\.?)?\\\\d+(?:[eE][+-]?\\\\d+)?)";\nconst CSS_RGB_REGEX = new RegExp(["^rgba?\\\\(", FLOAT, ",", FLOAT, ",", FLOAT, "(?:,", FLOAT + "(%)?", ")?\\\\)$"].join(WS), "i");\nconst CSS_RGB_WS_REGEX = new RegExp(["^rgba?\\\\(", FLOAT, FLOAT, FLOAT, "(?:/", FLOAT + "(%)?", ")?\\\\)$"].join(WS), "i");\nconst CSS_RGB_PERCENT_REGEX = new RegExp(["^rgba?\\\\(", FLOAT + "%", ",", FLOAT + "%", ",", FLOAT + "%", "(?:,", FLOAT + "(%)?", ")?\\\\)$"].join(WS), "i");\nconst CSS_RGB_WS_PERCENT_REGEX = new RegExp(["^rgba?\\\\(", FLOAT + "%", FLOAT + "%", FLOAT + "%", "(?:/", FLOAT + "(%)?", ")?\\\\)$"].join(WS), "i");\nconst CSS_HSL_REGEX = new RegExp(["^hsla?\\\\(", FLOAT + "(deg|rad|turn)?", ",", FLOAT + "%", ",", FLOAT + "%", "(?:,", FLOAT + "(%)?", ")?\\\\)$"].join(WS), "i");\nconst CSS_HSL_WS_REGEX = new RegExp(["^hsla?\\\\(", FLOAT + "(deg|rad|turn)?\\\\s+" + FLOAT + "%", FLOAT + "%", "(?:/", FLOAT + "(%)?", ")?\\\\)$"].join(WS), "i");\nfunction css2rgb(css) {\n    if (w3cx11 && w3cx11.hasOwnProperty(css)) {\n        return num2rgb(w3cx11[css.toLowerCase()]);\n    }\n    let m;\n    if ((m = css.match(CSS_RGB_REGEX) || css.match(CSS_RGB_WS_REGEX))) {\n        return [\n            clamp(+m[1], 0, 255),\n            clamp(+m[2], 0, 255),\n            clamp(+m[3], 0, 255),\n            m[4] ? clamp(m[5] ? +m[4] / 100 : +m[4]) : 1,\n        ];\n    }\n    else if ((m = css.match(CSS_RGB_PERCENT_REGEX) || css.match(CSS_RGB_WS_PERCENT_REGEX))) {\n        return [\n            clamp(+m[1] / 100) * 255,\n            clamp(+m[2] / 100) * 255,\n            clamp(+m[3] / 100) * 255,\n            m[4] ? clamp(m[5] ? +m[4] / 100 : +m[4]) : 1,\n        ];\n    }\n    else if ((m = css.match(CSS_HSL_REGEX) || css.match(CSS_HSL_WS_REGEX))) {\n        const CONVERSION = { deg: 1, rad: RAD2DEG, turn: 360 };\n        const angleUnit = (m[2] ? m[2].toLowerCase() : "deg");\n        return hsl2rgb((((+m[1] * CONVERSION[angleUnit]) % 360) + 360) % 360, clamp(+m[3] / 100), clamp(+m[4] / 100), m[5] ? clamp(m[6] ? +m[5] / 100 : +m[5]) : 1);\n    }\n    else {\n        return hex2rgb(css);\n    }\n}\nfunction rgb2css(r, g, b, a = 1) {\n    if (a >= 1) {\n        return "rgb(" + [r, g, b].map(round).join(",") + ")";\n    }\n    else {\n        return "rgba(" + [r, g, b].map(round).join(",") + "," + a + ")";\n    }\n}\nfunction rnd(a) {\n    return round(a * 100) / 100;\n}\nfunction hsl2css([h, s, l], alpha) {\n    const mode = alpha < 1 ? "hsla" : "hsl";\n    return (mode +\n        "(" +\n        rnd(h) +\n        "," +\n        rnd(s * 100) +\n        "%" +\n        "," +\n        rnd(l * 100) +\n        "%" +\n        ("hsla" == mode ? "," + rnd(alpha) : "") +\n        ")");\n}\n_input.css = css2rgb;\n_input.name = function (name) {\n    return num2rgb(w3cx11[name]);\n};\nfunction lch2lab(l, c, hueDegrees) {\n    /*\n    Convert from a qualitative parameter h and a quantitative parameter l to a 24-bit pixel.\n    These formulas were invented by David Dalrymple to obtain maximum contrast without going\n    out of gamut if the parameters are in the range 0-1.\n\n    A saturation multiplier was added by Gregor Aisch\n     */\n    return [l, cos(hueDegrees * DEG2RAD) * c, sin(hueDegrees * DEG2RAD) * c];\n}\nfunction lch2rgb(l, c, hDegrees, alpha1 = 1) {\n    const [, a, b] = lch2lab(l, c, hDegrees);\n    return cielab2rgb(l, a, b, alpha1);\n}\nfunction lab2lch(l, a, b) {\n    const c = hypot(a, b);\n    const h = (atan2(b, a) * RAD2DEG + 360) % 360;\n    return [l, c, h];\n}\nfunction rgb2lch(r255, g255, b255) {\n    const [l, a, b2] = rgb2lab(r255, g255, b255);\n    return lab2lch(l, a, b2);\n}\n_input.lch = lch2rgb;\nfunction rgb2cmyk(r255, g255, b255) {\n    r255 /= 255;\n    g255 /= 255;\n    b255 /= 255;\n    const k = 1 - max(r255, g255, b255);\n    if (1 == k)\n        return [0, 0, 0, 1];\n    const c = (1 - r255 - k) / (1 - k);\n    const m = (1 - g255 - k) / (1 - k);\n    const y = (1 - b255 - k) / (1 - k);\n    return [c, m, y, k];\n}\nfunction cmyk2rgb(c1, m1, y1, k1, alpha1 = 1) {\n    if (k1 == 1) {\n        return [0, 0, 0, alpha1];\n    }\n    const r255 = 255 * (1 - c1) * (1 - k1);\n    const g255 = 255 * (1 - m1) * (1 - k1);\n    const b255 = 255 * (1 - y1) * (1 - k1);\n    return [r255, g255, b255, alpha1];\n}\n_input.cmyk = cmyk2rgb;\n_input.gl = function (r, g, b, a = 1) {\n    return [r * 255, g * 255, b * 255, a];\n};\n//function rgb2luminance(r: number, g: number, b: number) {\n//\t// https://en.wikipedia.org/wiki/Relative_luminance\n//\tconst [, Y] = rgb2xyz(r, g, b)\n//\treturn Y\n//}\nfunction rgbChannel2RgbLinear(x255) {\n    const x1 = x255 / 255;\n    // http://entropymine.com/imageworsener/srgbformula/\n    if (x1 <= 0.04045) {\n        return x1 / 12.92;\n    }\n    else {\n        return ((x1 + 0.055) / 1.055) ** 2.4;\n    }\n}\nfunction rgbLinearChannel2Rgb(xLinear1) {\n    if (xLinear1 <= 0.0031308) {\n        return 255 * (12.92 * xLinear1);\n    }\n    else {\n        return 255 * ((1 + 0.055) * xLinear1 ** (1 / 2.4) - 0.055);\n    }\n}\nfunction kelvin2rgb(kelvin) {\n    const t = kelvin / 100;\n    let r, g, b;\n    if (t < 66) {\n        r = 255;\n        g = -155.25485562709179 - 0.44596950469579133 * (t - 2) + 104.49216199393888 * log(t - 2);\n        b = t < 20 ? 0 : -254.76935184120902 + 0.8274096064007395 * (t - 10) + 115.67994401066147 * log(t - 10);\n    }\n    else {\n        r = 351.97690566805693 + 0.114206453784165 * (t - 55) - 40.25366309332127 * log(t - 55);\n        g = 325.4494125711974 + 0.07943456536662342 * (t - 50) - 28.0852963507957 * log(t - 50);\n        b = 255;\n    }\n    return [r, g, b];\n}\n_input.rgb = (...args) => args;\nfunction rgb2kelvin(r255, g255, b255) {\n    console.log(b255 - r255);\n    if (g255 + b255 < 158.61) {\n        console.log("0 < t < 20");\n        // calc from green\n        return round(newtonIterate1d((t) => g255 - (-155.25485562709179 - 0.44596950469579133 * (t - 2) + 104.49216199393888 * log(t - 2)), 15, 4) * 100);\n    }\n    else if (b255 - r255 < 0) {\n        console.log("20 < t < 66");\n        return round(newtonIterate1d((t) => b255 - (-254.76935184120902 + 0.8274096064007395 * (t - 10) + 115.67994401066147 * log(t - 10)), 43, 4) * 100);\n    }\n    else {\n        console.log("0 < t < 400, start= " + (-1.4 * (r255 + g255) + 755));\n        return round(newtonIterate1d((t) => r255 - (351.97690566805693 + 0.114206453784165 * (t - 55) - 40.25366309332127 * log(t - 55)), -1.4 * (r255 + g255) + 755, 8) * 100);\n    }\n}\n_input.temperature = _input.kelvin = _input.K = kelvin2rgb;\nfunction blend_f(f) {\n    return function (bottom, top) {\n        const [r, g, b] = f(color(top).rgb(), color(bottom).rgb());\n        return rgb(r, g, b);\n    };\n}\nfunction each(f) {\n    return function (c1, c2) {\n        return c1.map((e, i) => f(e, c2[i]));\n    };\n}\nfunction _screen(a, b) {\n    return 255 * (1 - (1 - a / 255) * (1 - b / 255));\n}\nfunction _overlay(a, b) {\n    if (b < 128) {\n        return (2 * a * b) / 255;\n    }\n    else {\n        return 255 * (1 - 2 * (1 - a / 255) * (1 - b / 255));\n    }\n}\nfunction _burn(a, b) {\n    return 255 * (1 - (1 - b / 255) / (a / 255));\n}\nfunction _dodge(a, b) {\n    if (a == 255) {\n        return 255;\n    }\n    return 255 * min(1, b / 255 / (1 - a / 255));\n}\n/**\n * r, g, b can be in any interval (0-1 or 0-255)\n * @param r\n * @param g\n * @param b\n */\nfunction rgb2hexhue(r, g, b) {\n    const m = min(r, g, b);\n    const M = max(r, g, b);\n    const delta = M - m;\n    let hueTurnX6; // angle as value between 0 and 6\n    if (0 == delta) {\n        hueTurnX6 = 0;\n    }\n    else if (r == M) {\n        // second term to make sure the value is > 0\n        hueTurnX6 = (g - b) / delta + (g < b ? 6 : 0);\n    }\n    else if (g == M) {\n        hueTurnX6 = 2 + (b - r) / delta;\n    }\n    else {\n        hueTurnX6 = 4 + (r - g) / delta;\n    }\n    return [hueTurnX6 * 60, m, M];\n}\nfunction hcxm2rgb(hueDegrees, c1, x1, m1, alpha1) {\n    const m255 = m1 * 255;\n    const cm255 = c1 * 255 + m255;\n    const xm255 = x1 * 255 + m255;\n    if (hueDegrees < 60) {\n        return [cm255, xm255, m255, alpha1];\n    }\n    else if (hueDegrees < 120) {\n        return [xm255, cm255, m255, alpha1];\n    }\n    else if (hueDegrees < 180) {\n        return [m255, cm255, xm255, alpha1];\n    }\n    else if (hueDegrees < 240) {\n        return [m255, xm255, cm255, alpha1];\n    }\n    else if (hueDegrees < 300) {\n        return [xm255, m255, cm255, alpha1];\n    }\n    else {\n        return [cm255, m255, xm255, alpha1];\n    }\n}\n/**\n * https://en.wikipedia.org/w/index.php?title=HSL_and_HSV&oldid=856714654#From_HSL\n */\nfunction hsl2rgb(hueDegrees, s1, l1, alpha1 = 1) {\n    hueDegrees = norm360(hueDegrees);\n    const c1 = (1 - abs(2 * l1 - 1)) * s1;\n    return hcxm2rgb(hueDegrees, c1, c1 * (1 - abs(((hueDegrees / 60) % 2) - 1)), l1 - c1 / 2, alpha1);\n}\nfunction rgb2hsl(r255, g255, b255) {\n    const [hue, min1, max1] = rgb2hexhue(r255 / 255, g255 / 255, b255 / 255);\n    const l1 = (max1 + min1) / 2;\n    let s1;\n    if (max1 == min1) {\n        s1 = 0;\n    }\n    else {\n        s1 = l1 < 0.5 ? (max1 - min1) / (max1 + min1) : (max1 - min1) / (2 - max1 - min1);\n    }\n    return [hue, s1, l1];\n}\nfunction hsv2rgb(hueDegrees, s1, v1, alpha1 = 1) {\n    hueDegrees = norm360(hueDegrees);\n    const c1 = v1 * s1;\n    return hcxm2rgb(hueDegrees, c1, c1 * (1 - abs(((hueDegrees / 60) % 2) - 1)), v1 - c1, alpha1);\n}\nfunction rgb2hsv(r255, g255, b255) {\n    const [hue, min255, max255] = rgb2hexhue(r255, g255, b255);\n    const delta255 = max255 - min255;\n    const v1 = max255 / 255.0;\n    const s1 = max255 == 0 ? 0 : delta255 / max255;\n    return [hue, s1, v1];\n}\nfunction hcg2rgb(hueDegrees, c1, g1, alpha1 = 1) {\n    hueDegrees = norm360(hueDegrees);\n    const p = g1 * (1 - c1);\n    return hcxm2rgb(hueDegrees, c1, c1 * (1 - abs(((hueDegrees / 60) % 2) - 1)), p, alpha1);\n}\nfunction rgb2hcg(r255, g255, b255) {\n    const [hue, min255, max255] = rgb2hexhue(r255, g255, b255);\n    const c1 = (max255 - min255) / 255;\n    const _g1 = c1 < 1 ? min255 / 255 / (1 - c1) : 0;\n    return [hue, c1, _g1];\n}\n_input.hcg = hcg2rgb;\nfunction cielab2rgb(LStar100, aStar, bStar, alpha = 1) {\n    const [x, y, z] = cielab2xyz(LStar100, aStar, bStar);\n    return xyz2rgb(x, y, z, alpha);\n}\nfunction cielab2xyz(LStar100, aStar, bStar) {\n    function fInv(t) {\n        if (t > LAB_delta) {\n            return t ** 3;\n        }\n        else {\n            return LAB_3DeltaPow2 * (t - 4 / 29);\n        }\n    }\n    return [\n        LAB_Xn * fInv((LStar100 + 16) / 116 + aStar / 500),\n        LAB_Yn * fInv((LStar100 + 16) / 116),\n        LAB_Zn * fInv((LStar100 + 16) / 116 - bStar / 200),\n    ];\n}\nfunction xyz2cielab(x, y, z) {\n    // https://en.wikipedia.org/w/index.php?title=CIELAB_color_space&oldid=849576085#Forward_transformation\n    function f(t) {\n        if (t > LAB_deltaPow3) {\n            return cbrt(t);\n        }\n        else {\n            return t / LAB_3DeltaPow2 + 4 / 29;\n        }\n    }\n    return [116 * f(y / LAB_Yn) - 16, 500 * (f(x / LAB_Xn) - f(y / LAB_Yn)), 200 * (f(y / LAB_Yn) - f(z / LAB_Zn))];\n}\n// const LAB_CONSTANTS = {\nconst LAB_Kn = 18;\nconst LAB_Xn = 0.95047;\nconst LAB_Yn = 1;\nconst LAB_Zn = 1.08883;\nconst LAB_delta = 0.206896552; // delta = 6 / 29\nconst LAB_3DeltaPow2 = 0.12841855; // 3 * delta ** 2\nconst LAB_deltaPow3 = 0.008856452; // delta ** 3\n// }\nfunction rgb2lab(r255, g255, b255) {\n    const [x, y, z] = rgb2xyz(r255, g255, b255);\n    return xyz2cielab(x, y, z);\n}\nfunction rgb2xyz(r255, g255, b255) {\n    // https://en.wikipedia.org/wiki/SRGB#The_reverse_transformation\n    const r1Linear = rgbChannel2RgbLinear(r255);\n    const g1Linear = rgbChannel2RgbLinear(g255);\n    const b1Linear = rgbChannel2RgbLinear(b255);\n    const X = 0.4124564 * r1Linear + 0.3575761 * g1Linear + 0.1804375 * b1Linear;\n    const Y = 0.2126729 * r1Linear + 0.7151522 * g1Linear + 0.072175 * b1Linear;\n    const Z = 0.0193339 * r1Linear + 0.119192 * g1Linear + 0.9503041 * b1Linear;\n    return [X, Y, Z];\n}\nfunction xyz2rgb(X1, Y1, Z1, alpha1 = 1) {\n    // https://en.wikipedia.org/wiki/SRGB#The_forward_transformation_(CIE_XYZ_to_sRGB)\n    const r1Linear = 3.2404542 * X1 - 1.5371385 * Y1 - 0.4985314 * Z1;\n    const g1Linear = -0.969266 * X1 + 1.8760108 * Y1 + 0.041556 * Z1;\n    const b1Linear = 0.0556434 * X1 - 0.2040259 * Y1 + 1.0572252 * Z1;\n    return [rgbLinearChannel2Rgb(r1Linear), rgbLinearChannel2Rgb(g1Linear), rgbLinearChannel2Rgb(b1Linear), alpha1];\n}\n_input.xyz = xyz2rgb;\n_input.lab = cielab2rgb;\n/**\n * For HSI, we use the direct angle calculation. I.e. atan2(beta, alpha). See wikipedia link. This is why we don\'t use\n * hcxm2rgb.\n */\nfunction hsi2rgb(hueDegrees, s1, i1, alpha1 = 1) {\n    /*\n    borrowed from here:\n    http://hummer.stanford.edu/museinfo/doc/examples/humdrum/keyscape2/hsi2rgb.cpp\n     */\n    let r, g, b;\n    let hRad = hueDegrees * DEG2RAD;\n    if (hRad < (2 * PI) / 3) {\n        b = (1 - s1) / 3;\n        r = (1 + (s1 * cos(hRad)) / cos(PI / 3 - hRad)) / 3;\n        g = 1 - (b + r);\n    }\n    else if (hRad < (4 * PI) / 3) {\n        hRad -= (2 * PI) / 3;\n        r = (1 - s1) / 3;\n        g = (1 + (s1 * cos(hRad)) / cos(PI / 3 - hRad)) / 3;\n        b = 1 - (r + g);\n    }\n    else {\n        hRad -= (4 * PI) / 3;\n        g = (1 - s1) / 3;\n        b = (1 + (s1 * cos(hRad)) / cos(PI / 3 - hRad)) / 3;\n        r = 1 - (g + b);\n    }\n    return [3 * i1 * r * 255, 3 * i1 * g * 255, 3 * i1 * b * 255, alpha1];\n}\n/**\n * For HSI, we use the direct angle calculation. I.e. atan2(beta, alpha). See wikipedia link. This is why we don\'t use\n * rgb2hexhue.\n */\nfunction rgb2hsi(r255, g255, b255) {\n    // See https://en.wikipedia.org/wiki/HSL_and_HSV#Hue_and_chroma\n    // See https://en.wikipedia.org/wiki/HSL_and_HSV#Lightness\n    const r1 = r255 / 255;\n    const g1 = g255 / 255;\n    const b1 = b255 / 255;\n    const i1 = (r1 + g1 + b1) / 3;\n    if (r1 == g1 && g1 == b1) {\n        return [0, 0, i1];\n    }\n    else {\n        const alpha = (1 / 2) * (2 * r1 - g1 - b1);\n        const beta = (sqrt(3) / 2) * (g1 - b1);\n        const hRad = atan2(beta, alpha);\n        const min1 = min(r1, g1, b1);\n        const s1 = 1 - min1 / i1;\n        return [(hRad < 0 ? 2 * PI + hRad : hRad) * RAD2DEG, s1, i1];\n    }\n}\n_input.hsi = hsi2rgb;\ninterpolators.hsv = interpolators.hsl = interpolators.hsi = interpolators.lch = interpolators.hcg = function interpolate_hsx(color1, color2, f, m) {\n    const [a1, b1, c1] = color1[m]();\n    const [a2, b2, c2] = color2[m]();\n    function lerpHue(hue1, hue2, f) {\n        const dh = norm360(hue2 - hue1 + 180) - 180;\n        return hue1 + f * dh;\n    }\n    return color(("h" == m.charAt(0) ? lerpHue : lerp)(a1, a2, f), lerp(b1, b2, f), ("h" == m.charAt(2) ? lerpHue : lerp)(c1, c2, f), m);\n};\nfunction indexOfMax(arr, f) {\n    let maxValue = -Infinity, maxValueIndex = -1;\n    for (let i = 0; i < arr.length; i++) {\n        const value = f(arr[i]);\n        if (value > maxValue) {\n            maxValue = value;\n            maxValueIndex = i;\n        }\n    }\n    return maxValueIndex;\n}\nfunction withMax(arr, f) {\n    return arr[indexOfMax(arr, f)];\n}\n\n\n\n\n//# sourceURL=webpack://workshop/../nla/tsgl/node_modules/chroma.ts/dist/index.es.js?')},4220:module=>{eval("module.exports = {\n  0: 'NONE',\n  1: 'ONE',\n  2: 'LINE_LOOP',\n  3: 'LINE_STRIP',\n  4: 'TRIANGLES',\n  5: 'TRIANGLE_STRIP',\n  6: 'TRIANGLE_FAN',\n  256: 'DEPTH_BUFFER_BIT',\n  512: 'NEVER',\n  513: 'LESS',\n  514: 'EQUAL',\n  515: 'LEQUAL',\n  516: 'GREATER',\n  517: 'NOTEQUAL',\n  518: 'GEQUAL',\n  519: 'ALWAYS',\n  768: 'SRC_COLOR',\n  769: 'ONE_MINUS_SRC_COLOR',\n  770: 'SRC_ALPHA',\n  771: 'ONE_MINUS_SRC_ALPHA',\n  772: 'DST_ALPHA',\n  773: 'ONE_MINUS_DST_ALPHA',\n  774: 'DST_COLOR',\n  775: 'ONE_MINUS_DST_COLOR',\n  776: 'SRC_ALPHA_SATURATE',\n  1024: 'STENCIL_BUFFER_BIT',\n  1028: 'FRONT',\n  1029: 'BACK',\n  1032: 'FRONT_AND_BACK',\n  1280: 'INVALID_ENUM',\n  1281: 'INVALID_VALUE',\n  1282: 'INVALID_OPERATION',\n  1285: 'OUT_OF_MEMORY',\n  1286: 'INVALID_FRAMEBUFFER_OPERATION',\n  2304: 'CW',\n  2305: 'CCW',\n  2849: 'LINE_WIDTH',\n  2884: 'CULL_FACE',\n  2885: 'CULL_FACE_MODE',\n  2886: 'FRONT_FACE',\n  2928: 'DEPTH_RANGE',\n  2929: 'DEPTH_TEST',\n  2930: 'DEPTH_WRITEMASK',\n  2931: 'DEPTH_CLEAR_VALUE',\n  2932: 'DEPTH_FUNC',\n  2960: 'STENCIL_TEST',\n  2961: 'STENCIL_CLEAR_VALUE',\n  2962: 'STENCIL_FUNC',\n  2963: 'STENCIL_VALUE_MASK',\n  2964: 'STENCIL_FAIL',\n  2965: 'STENCIL_PASS_DEPTH_FAIL',\n  2966: 'STENCIL_PASS_DEPTH_PASS',\n  2967: 'STENCIL_REF',\n  2968: 'STENCIL_WRITEMASK',\n  2978: 'VIEWPORT',\n  3024: 'DITHER',\n  3042: 'BLEND',\n  3088: 'SCISSOR_BOX',\n  3089: 'SCISSOR_TEST',\n  3106: 'COLOR_CLEAR_VALUE',\n  3107: 'COLOR_WRITEMASK',\n  3317: 'UNPACK_ALIGNMENT',\n  3333: 'PACK_ALIGNMENT',\n  3379: 'MAX_TEXTURE_SIZE',\n  3386: 'MAX_VIEWPORT_DIMS',\n  3408: 'SUBPIXEL_BITS',\n  3410: 'RED_BITS',\n  3411: 'GREEN_BITS',\n  3412: 'BLUE_BITS',\n  3413: 'ALPHA_BITS',\n  3414: 'DEPTH_BITS',\n  3415: 'STENCIL_BITS',\n  3553: 'TEXTURE_2D',\n  4352: 'DONT_CARE',\n  4353: 'FASTEST',\n  4354: 'NICEST',\n  5120: 'BYTE',\n  5121: 'UNSIGNED_BYTE',\n  5122: 'SHORT',\n  5123: 'UNSIGNED_SHORT',\n  5124: 'INT',\n  5125: 'UNSIGNED_INT',\n  5126: 'FLOAT',\n  5386: 'INVERT',\n  5890: 'TEXTURE',\n  6401: 'STENCIL_INDEX',\n  6402: 'DEPTH_COMPONENT',\n  6406: 'ALPHA',\n  6407: 'RGB',\n  6408: 'RGBA',\n  6409: 'LUMINANCE',\n  6410: 'LUMINANCE_ALPHA',\n  7680: 'KEEP',\n  7681: 'REPLACE',\n  7682: 'INCR',\n  7683: 'DECR',\n  7936: 'VENDOR',\n  7937: 'RENDERER',\n  7938: 'VERSION',\n  9728: 'NEAREST',\n  9729: 'LINEAR',\n  9984: 'NEAREST_MIPMAP_NEAREST',\n  9985: 'LINEAR_MIPMAP_NEAREST',\n  9986: 'NEAREST_MIPMAP_LINEAR',\n  9987: 'LINEAR_MIPMAP_LINEAR',\n  10240: 'TEXTURE_MAG_FILTER',\n  10241: 'TEXTURE_MIN_FILTER',\n  10242: 'TEXTURE_WRAP_S',\n  10243: 'TEXTURE_WRAP_T',\n  10497: 'REPEAT',\n  10752: 'POLYGON_OFFSET_UNITS',\n  16384: 'COLOR_BUFFER_BIT',\n  32769: 'CONSTANT_COLOR',\n  32770: 'ONE_MINUS_CONSTANT_COLOR',\n  32771: 'CONSTANT_ALPHA',\n  32772: 'ONE_MINUS_CONSTANT_ALPHA',\n  32773: 'BLEND_COLOR',\n  32774: 'FUNC_ADD',\n  32777: 'BLEND_EQUATION_RGB',\n  32778: 'FUNC_SUBTRACT',\n  32779: 'FUNC_REVERSE_SUBTRACT',\n  32819: 'UNSIGNED_SHORT_4_4_4_4',\n  32820: 'UNSIGNED_SHORT_5_5_5_1',\n  32823: 'POLYGON_OFFSET_FILL',\n  32824: 'POLYGON_OFFSET_FACTOR',\n  32854: 'RGBA4',\n  32855: 'RGB5_A1',\n  32873: 'TEXTURE_BINDING_2D',\n  32926: 'SAMPLE_ALPHA_TO_COVERAGE',\n  32928: 'SAMPLE_COVERAGE',\n  32936: 'SAMPLE_BUFFERS',\n  32937: 'SAMPLES',\n  32938: 'SAMPLE_COVERAGE_VALUE',\n  32939: 'SAMPLE_COVERAGE_INVERT',\n  32968: 'BLEND_DST_RGB',\n  32969: 'BLEND_SRC_RGB',\n  32970: 'BLEND_DST_ALPHA',\n  32971: 'BLEND_SRC_ALPHA',\n  33071: 'CLAMP_TO_EDGE',\n  33170: 'GENERATE_MIPMAP_HINT',\n  33189: 'DEPTH_COMPONENT16',\n  33306: 'DEPTH_STENCIL_ATTACHMENT',\n  33635: 'UNSIGNED_SHORT_5_6_5',\n  33648: 'MIRRORED_REPEAT',\n  33901: 'ALIASED_POINT_SIZE_RANGE',\n  33902: 'ALIASED_LINE_WIDTH_RANGE',\n  33984: 'TEXTURE0',\n  33985: 'TEXTURE1',\n  33986: 'TEXTURE2',\n  33987: 'TEXTURE3',\n  33988: 'TEXTURE4',\n  33989: 'TEXTURE5',\n  33990: 'TEXTURE6',\n  33991: 'TEXTURE7',\n  33992: 'TEXTURE8',\n  33993: 'TEXTURE9',\n  33994: 'TEXTURE10',\n  33995: 'TEXTURE11',\n  33996: 'TEXTURE12',\n  33997: 'TEXTURE13',\n  33998: 'TEXTURE14',\n  33999: 'TEXTURE15',\n  34000: 'TEXTURE16',\n  34001: 'TEXTURE17',\n  34002: 'TEXTURE18',\n  34003: 'TEXTURE19',\n  34004: 'TEXTURE20',\n  34005: 'TEXTURE21',\n  34006: 'TEXTURE22',\n  34007: 'TEXTURE23',\n  34008: 'TEXTURE24',\n  34009: 'TEXTURE25',\n  34010: 'TEXTURE26',\n  34011: 'TEXTURE27',\n  34012: 'TEXTURE28',\n  34013: 'TEXTURE29',\n  34014: 'TEXTURE30',\n  34015: 'TEXTURE31',\n  34016: 'ACTIVE_TEXTURE',\n  34024: 'MAX_RENDERBUFFER_SIZE',\n  34041: 'DEPTH_STENCIL',\n  34055: 'INCR_WRAP',\n  34056: 'DECR_WRAP',\n  34067: 'TEXTURE_CUBE_MAP',\n  34068: 'TEXTURE_BINDING_CUBE_MAP',\n  34069: 'TEXTURE_CUBE_MAP_POSITIVE_X',\n  34070: 'TEXTURE_CUBE_MAP_NEGATIVE_X',\n  34071: 'TEXTURE_CUBE_MAP_POSITIVE_Y',\n  34072: 'TEXTURE_CUBE_MAP_NEGATIVE_Y',\n  34073: 'TEXTURE_CUBE_MAP_POSITIVE_Z',\n  34074: 'TEXTURE_CUBE_MAP_NEGATIVE_Z',\n  34076: 'MAX_CUBE_MAP_TEXTURE_SIZE',\n  34338: 'VERTEX_ATTRIB_ARRAY_ENABLED',\n  34339: 'VERTEX_ATTRIB_ARRAY_SIZE',\n  34340: 'VERTEX_ATTRIB_ARRAY_STRIDE',\n  34341: 'VERTEX_ATTRIB_ARRAY_TYPE',\n  34342: 'CURRENT_VERTEX_ATTRIB',\n  34373: 'VERTEX_ATTRIB_ARRAY_POINTER',\n  34466: 'NUM_COMPRESSED_TEXTURE_FORMATS',\n  34467: 'COMPRESSED_TEXTURE_FORMATS',\n  34660: 'BUFFER_SIZE',\n  34661: 'BUFFER_USAGE',\n  34816: 'STENCIL_BACK_FUNC',\n  34817: 'STENCIL_BACK_FAIL',\n  34818: 'STENCIL_BACK_PASS_DEPTH_FAIL',\n  34819: 'STENCIL_BACK_PASS_DEPTH_PASS',\n  34877: 'BLEND_EQUATION_ALPHA',\n  34921: 'MAX_VERTEX_ATTRIBS',\n  34922: 'VERTEX_ATTRIB_ARRAY_NORMALIZED',\n  34930: 'MAX_TEXTURE_IMAGE_UNITS',\n  34962: 'ARRAY_BUFFER',\n  34963: 'ELEMENT_ARRAY_BUFFER',\n  34964: 'ARRAY_BUFFER_BINDING',\n  34965: 'ELEMENT_ARRAY_BUFFER_BINDING',\n  34975: 'VERTEX_ATTRIB_ARRAY_BUFFER_BINDING',\n  35040: 'STREAM_DRAW',\n  35044: 'STATIC_DRAW',\n  35048: 'DYNAMIC_DRAW',\n  35632: 'FRAGMENT_SHADER',\n  35633: 'VERTEX_SHADER',\n  35660: 'MAX_VERTEX_TEXTURE_IMAGE_UNITS',\n  35661: 'MAX_COMBINED_TEXTURE_IMAGE_UNITS',\n  35663: 'SHADER_TYPE',\n  35664: 'FLOAT_VEC2',\n  35665: 'FLOAT_VEC3',\n  35666: 'FLOAT_VEC4',\n  35667: 'INT_VEC2',\n  35668: 'INT_VEC3',\n  35669: 'INT_VEC4',\n  35670: 'BOOL',\n  35671: 'BOOL_VEC2',\n  35672: 'BOOL_VEC3',\n  35673: 'BOOL_VEC4',\n  35674: 'FLOAT_MAT2',\n  35675: 'FLOAT_MAT3',\n  35676: 'FLOAT_MAT4',\n  35678: 'SAMPLER_2D',\n  35680: 'SAMPLER_CUBE',\n  35712: 'DELETE_STATUS',\n  35713: 'COMPILE_STATUS',\n  35714: 'LINK_STATUS',\n  35715: 'VALIDATE_STATUS',\n  35716: 'INFO_LOG_LENGTH',\n  35717: 'ATTACHED_SHADERS',\n  35718: 'ACTIVE_UNIFORMS',\n  35719: 'ACTIVE_UNIFORM_MAX_LENGTH',\n  35720: 'SHADER_SOURCE_LENGTH',\n  35721: 'ACTIVE_ATTRIBUTES',\n  35722: 'ACTIVE_ATTRIBUTE_MAX_LENGTH',\n  35724: 'SHADING_LANGUAGE_VERSION',\n  35725: 'CURRENT_PROGRAM',\n  36003: 'STENCIL_BACK_REF',\n  36004: 'STENCIL_BACK_VALUE_MASK',\n  36005: 'STENCIL_BACK_WRITEMASK',\n  36006: 'FRAMEBUFFER_BINDING',\n  36007: 'RENDERBUFFER_BINDING',\n  36048: 'FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE',\n  36049: 'FRAMEBUFFER_ATTACHMENT_OBJECT_NAME',\n  36050: 'FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL',\n  36051: 'FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE',\n  36053: 'FRAMEBUFFER_COMPLETE',\n  36054: 'FRAMEBUFFER_INCOMPLETE_ATTACHMENT',\n  36055: 'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT',\n  36057: 'FRAMEBUFFER_INCOMPLETE_DIMENSIONS',\n  36061: 'FRAMEBUFFER_UNSUPPORTED',\n  36064: 'COLOR_ATTACHMENT0',\n  36096: 'DEPTH_ATTACHMENT',\n  36128: 'STENCIL_ATTACHMENT',\n  36160: 'FRAMEBUFFER',\n  36161: 'RENDERBUFFER',\n  36162: 'RENDERBUFFER_WIDTH',\n  36163: 'RENDERBUFFER_HEIGHT',\n  36164: 'RENDERBUFFER_INTERNAL_FORMAT',\n  36168: 'STENCIL_INDEX8',\n  36176: 'RENDERBUFFER_RED_SIZE',\n  36177: 'RENDERBUFFER_GREEN_SIZE',\n  36178: 'RENDERBUFFER_BLUE_SIZE',\n  36179: 'RENDERBUFFER_ALPHA_SIZE',\n  36180: 'RENDERBUFFER_DEPTH_SIZE',\n  36181: 'RENDERBUFFER_STENCIL_SIZE',\n  36194: 'RGB565',\n  36336: 'LOW_FLOAT',\n  36337: 'MEDIUM_FLOAT',\n  36338: 'HIGH_FLOAT',\n  36339: 'LOW_INT',\n  36340: 'MEDIUM_INT',\n  36341: 'HIGH_INT',\n  36346: 'SHADER_COMPILER',\n  36347: 'MAX_VERTEX_UNIFORM_VECTORS',\n  36348: 'MAX_VARYING_VECTORS',\n  36349: 'MAX_FRAGMENT_UNIFORM_VECTORS',\n  37440: 'UNPACK_FLIP_Y_WEBGL',\n  37441: 'UNPACK_PREMULTIPLY_ALPHA_WEBGL',\n  37442: 'CONTEXT_LOST_WEBGL',\n  37443: 'UNPACK_COLORSPACE_CONVERSION_WEBGL',\n  37444: 'BROWSER_DEFAULT_WEBGL'\n}\n\n\n//# sourceURL=webpack://workshop/../nla/tsgl/node_modules/gl-constants/1.0/numbers.js?")},956:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var gl10 = __webpack_require__(4220)\n\nmodule.exports = function lookupConstant (number) {\n  return gl10[number]\n}\n\n\n//# sourceURL=webpack://workshop/../nla/tsgl/node_modules/gl-constants/lookup.js?")},5416:(module,__unused_webpack_exports,__webpack_require__)=>{eval("\nvar sprintf = __webpack_require__(4564).sprintf;\nvar glConstants = __webpack_require__(956);\nvar shaderName = __webpack_require__(5917);\nvar addLineNumbers = __webpack_require__(3888);\n\nmodule.exports = formatCompilerError;\n\nfunction formatCompilerError(errLog, src, type) {\n    \"use strict\";\n\n    var name = shaderName(src) || 'of unknown name (see npm glsl-shader-name)';\n\n    var typeName = 'unknown type';\n    if (type !== undefined) {\n        typeName = type === glConstants.FRAGMENT_SHADER ? 'fragment' : 'vertex'\n    }\n\n    var longForm = sprintf('Error compiling %s shader %s:\\n', typeName, name);\n    var shortForm = sprintf(\"%s%s\", longForm, errLog);\n\n    var errorStrings = errLog.split('\\n');\n    var errors = {};\n\n    for (var i = 0; i < errorStrings.length; i++) {\n        var errorString = errorStrings[i];\n        if (errorString === '' || errorString === \"\\0\") continue;\n        var lineNo = parseInt(errorString.split(':')[2]);\n        if (isNaN(lineNo)) {\n            throw new Error(sprintf('Could not parse error: %s', errorString));\n        }\n        errors[lineNo] = errorString;\n    }\n\n    var lines = addLineNumbers(src).split('\\n');\n\n    for (var i = 0; i < lines.length; i++) {\n        if (!errors[i+3] && !errors[i+2] && !errors[i+1]) continue;\n        var line = lines[i];\n        longForm += line + '\\n';\n        if (errors[i+1]) {\n            var e = errors[i+1];\n            e = e.substr(e.split(':', 3).join(':').length + 1).trim();\n            longForm += sprintf('^^^ %s\\n\\n', e);\n        }\n    }\n\n    return {\n        long: longForm.trim(),\n        short: shortForm.trim()\n    };\n}\n\n\n\n//# sourceURL=webpack://workshop/../nla/tsgl/node_modules/gl-format-compiler-error/index.js?")},5917:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var tokenize = __webpack_require__(7526)\nvar atob     = __webpack_require__(2490)\n\nmodule.exports = getName\n\nfunction getName(src) {\n  var tokens = Array.isArray(src)\n    ? src\n    : tokenize(src)\n\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n    if (token.type !== 'preprocessor') continue\n    var match = token.data.match(/\\#define\\s+SHADER_NAME(_B64)?\\s+(.+)$/)\n    if (!match) continue\n    if (!match[2]) continue\n\n    var b64  = match[1]\n    var name = match[2]\n\n    return (b64 ? atob(name) : name).trim()\n  }\n}\n\n\n//# sourceURL=webpack://workshop/../nla/tsgl/node_modules/glsl-shader-name/index.js?")},6158:(module,__unused_webpack_exports,__webpack_require__)=>{eval("module.exports = tokenize\r\n\r\nvar literals100 = __webpack_require__(7369)\r\n  , operators = __webpack_require__(9628)\r\n  , builtins100 = __webpack_require__(293)\r\n  , literals300es = __webpack_require__(1792)\r\n  , builtins300es = __webpack_require__(1992)\r\n\r\nvar NORMAL = 999          // <-- never emitted\r\n  , TOKEN = 9999          // <-- never emitted\r\n  , BLOCK_COMMENT = 0\r\n  , LINE_COMMENT = 1\r\n  , PREPROCESSOR = 2\r\n  , OPERATOR = 3\r\n  , INTEGER = 4\r\n  , FLOAT = 5\r\n  , IDENT = 6\r\n  , BUILTIN = 7\r\n  , KEYWORD = 8\r\n  , WHITESPACE = 9\r\n  , EOF = 10\r\n  , HEX = 11\r\n\r\nvar map = [\r\n    'block-comment'\r\n  , 'line-comment'\r\n  , 'preprocessor'\r\n  , 'operator'\r\n  , 'integer'\r\n  , 'float'\r\n  , 'ident'\r\n  , 'builtin'\r\n  , 'keyword'\r\n  , 'whitespace'\r\n  , 'eof'\r\n  , 'integer'\r\n]\r\n\r\nfunction tokenize(opt) {\r\n  var i = 0\r\n    , total = 0\r\n    , mode = NORMAL\r\n    , c\r\n    , last\r\n    , content = []\r\n    , tokens = []\r\n    , token_idx = 0\r\n    , token_offs = 0\r\n    , line = 1\r\n    , col = 0\r\n    , start = 0\r\n    , isnum = false\r\n    , isoperator = false\r\n    , input = ''\r\n    , len\r\n\r\n  opt = opt || {}\r\n  var allBuiltins = builtins100\r\n  var allLiterals = literals100\r\n  if (opt.version === '300 es') {\r\n    allBuiltins = builtins300es\r\n    allLiterals = literals300es\r\n  }\r\n\r\n  // cache by name\r\n  var builtinsDict = {}, literalsDict = {}\r\n  for (var i = 0; i < allBuiltins.length; i++) {\r\n    builtinsDict[allBuiltins[i]] = true\r\n  }\r\n  for (var i = 0; i < allLiterals.length; i++) {\r\n    literalsDict[allLiterals[i]] = true\r\n  }\r\n\r\n  return function(data) {\r\n    tokens = []\r\n    if (data !== null) return write(data)\r\n    return end()\r\n  }\r\n\r\n  function token(data) {\r\n    if (data.length) {\r\n      tokens.push({\r\n        type: map[mode]\r\n      , data: data\r\n      , position: start\r\n      , line: line\r\n      , column: col\r\n      })\r\n    }\r\n  }\r\n\r\n  function write(chunk) {\r\n    i = 0\r\n\r\n    if (chunk.toString) chunk = chunk.toString()\r\n\r\n    input += chunk.replace(/\\r\\n/g, '\\n')\r\n    len = input.length\r\n\r\n\r\n    var last\r\n\r\n    while(c = input[i], i < len) {\r\n      last = i\r\n\r\n      switch(mode) {\r\n        case BLOCK_COMMENT: i = block_comment(); break\r\n        case LINE_COMMENT: i = line_comment(); break\r\n        case PREPROCESSOR: i = preprocessor(); break\r\n        case OPERATOR: i = operator(); break\r\n        case INTEGER: i = integer(); break\r\n        case HEX: i = hex(); break\r\n        case FLOAT: i = decimal(); break\r\n        case TOKEN: i = readtoken(); break\r\n        case WHITESPACE: i = whitespace(); break\r\n        case NORMAL: i = normal(); break\r\n      }\r\n\r\n      if(last !== i) {\r\n        switch(input[last]) {\r\n          case '\\n': col = 0; ++line; break\r\n          default: ++col; break\r\n        }\r\n      }\r\n    }\r\n\r\n    total += i\r\n    input = input.slice(i)\r\n    return tokens\r\n  }\r\n\r\n  function end(chunk) {\r\n    if(content.length) {\r\n      token(content.join(''))\r\n    }\r\n\r\n    mode = EOF\r\n    token('(eof)')\r\n    return tokens\r\n  }\r\n\r\n  function normal() {\r\n    content = content.length ? [] : content\r\n\r\n    if(last === '/' && c === '*') {\r\n      start = total + i - 1\r\n      mode = BLOCK_COMMENT\r\n      last = c\r\n      return i + 1\r\n    }\r\n\r\n    if(last === '/' && c === '/') {\r\n      start = total + i - 1\r\n      mode = LINE_COMMENT\r\n      last = c\r\n      return i + 1\r\n    }\r\n\r\n    if(c === '#') {\r\n      mode = PREPROCESSOR\r\n      start = total + i\r\n      return i\r\n    }\r\n\r\n    if(/\\s/.test(c)) {\r\n      mode = WHITESPACE\r\n      start = total + i\r\n      return i\r\n    }\r\n\r\n    isnum = /\\d/.test(c)\r\n    isoperator = /[^\\w_]/.test(c)\r\n\r\n    start = total + i\r\n    mode = isnum ? INTEGER : isoperator ? OPERATOR : TOKEN\r\n    return i\r\n  }\r\n\r\n  function whitespace() {\r\n    if(/[^\\s]/g.test(c)) {\r\n      token(content.join(''))\r\n      mode = NORMAL\r\n      return i\r\n    }\r\n    content.push(c)\r\n    last = c\r\n    return i + 1\r\n  }\r\n\r\n  function preprocessor() {\r\n    if((c === '\\r' || c === '\\n') && last !== '\\\\') {\r\n      token(content.join(''))\r\n      mode = NORMAL\r\n      return i\r\n    }\r\n    content.push(c)\r\n    last = c\r\n    return i + 1\r\n  }\r\n\r\n  function line_comment() {\r\n    return preprocessor()\r\n  }\r\n\r\n  function block_comment() {\r\n    if(c === '/' && last === '*') {\r\n      content.push(c)\r\n      token(content.join(''))\r\n      mode = NORMAL\r\n      return i + 1\r\n    }\r\n\r\n    content.push(c)\r\n    last = c\r\n    return i + 1\r\n  }\r\n\r\n  function operator() {\r\n    if(last === '.' && /\\d/.test(c)) {\r\n      mode = FLOAT\r\n      return i\r\n    }\r\n\r\n    if(last === '/' && c === '*') {\r\n      mode = BLOCK_COMMENT\r\n      return i\r\n    }\r\n\r\n    if(last === '/' && c === '/') {\r\n      mode = LINE_COMMENT\r\n      return i\r\n    }\r\n\r\n    if(c === '.' && content.length) {\r\n      while(determine_operator(content));\r\n\r\n      mode = FLOAT\r\n      return i\r\n    }\r\n\r\n    if(c === ';' || c === ')' || c === '(') {\r\n      if(content.length) while(determine_operator(content));\r\n      token(c)\r\n      mode = NORMAL\r\n      return i + 1\r\n    }\r\n\r\n    var is_composite_operator = content.length === 2 && c !== '='\r\n    if(/[\\w_\\d\\s]/.test(c) || is_composite_operator) {\r\n      while(determine_operator(content));\r\n      mode = NORMAL\r\n      return i\r\n    }\r\n\r\n    content.push(c)\r\n    last = c\r\n    return i + 1\r\n  }\r\n\r\n  function determine_operator(buf) {\r\n    var j = 0\r\n      , idx\r\n      , res\r\n\r\n    do {\r\n      idx = operators.indexOf(buf.slice(0, buf.length + j).join(''))\r\n      res = operators[idx]\r\n\r\n      if(idx === -1) {\r\n        if(j-- + buf.length > 0) continue\r\n        res = buf.slice(0, 1).join('')\r\n      }\r\n\r\n      token(res)\r\n\r\n      start += res.length\r\n      content = content.slice(res.length)\r\n      return content.length\r\n    } while(1)\r\n  }\r\n\r\n  function hex() {\r\n    if(/[^a-fA-F0-9]/.test(c)) {\r\n      token(content.join(''))\r\n      mode = NORMAL\r\n      return i\r\n    }\r\n\r\n    content.push(c)\r\n    last = c\r\n    return i + 1\r\n  }\r\n\r\n  function integer() {\r\n    if(c === '.') {\r\n      content.push(c)\r\n      mode = FLOAT\r\n      last = c\r\n      return i + 1\r\n    }\r\n\r\n    if(/[eE]/.test(c)) {\r\n      content.push(c)\r\n      mode = FLOAT\r\n      last = c\r\n      return i + 1\r\n    }\r\n\r\n    if(c === 'x' && content.length === 1 && content[0] === '0') {\r\n      mode = HEX\r\n      content.push(c)\r\n      last = c\r\n      return i + 1\r\n    }\r\n\r\n    if(/[^\\d]/.test(c)) {\r\n      token(content.join(''))\r\n      mode = NORMAL\r\n      return i\r\n    }\r\n\r\n    content.push(c)\r\n    last = c\r\n    return i + 1\r\n  }\r\n\r\n  function decimal() {\r\n    if(c === 'f') {\r\n      content.push(c)\r\n      last = c\r\n      i += 1\r\n    }\r\n\r\n    if(/[eE]/.test(c)) {\r\n      content.push(c)\r\n      last = c\r\n      return i + 1\r\n    }\r\n\r\n    if ((c === '-' || c === '+') && /[eE]/.test(last)) {\r\n      content.push(c)\r\n      last = c\r\n      return i + 1\r\n    }\r\n\r\n    if(/[^\\d]/.test(c)) {\r\n      token(content.join(''))\r\n      mode = NORMAL\r\n      return i\r\n    }\r\n\r\n    content.push(c)\r\n    last = c\r\n    return i + 1\r\n  }\r\n\r\n  function readtoken() {\r\n    if(/[^\\d\\w_]/.test(c)) {\r\n      var contentstr = content.join('')\r\n      if(literalsDict[contentstr]) {\r\n        mode = KEYWORD\r\n      } else if(builtinsDict[contentstr]) {\r\n        mode = BUILTIN\r\n      } else {\r\n        mode = IDENT\r\n      }\r\n      token(content.join(''))\r\n      mode = NORMAL\r\n      return i\r\n    }\r\n    content.push(c)\r\n    last = c\r\n    return i + 1\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://workshop/../nla/tsgl/node_modules/glsl-tokenizer/index.js?")},1992:(module,__unused_webpack_exports,__webpack_require__)=>{eval("// 300es builtins/reserved words that were previously valid in v100\r\nvar v100 = __webpack_require__(293)\r\n\r\n// The texture2D|Cube functions have been removed\r\n// And the gl_ features are updated\r\nv100 = v100.slice().filter(function (b) {\r\n  return !/^(gl\\_|texture)/.test(b)\r\n})\r\n\r\nmodule.exports = v100.concat([\r\n  // the updated gl_ constants\r\n    'gl_VertexID'\r\n  , 'gl_InstanceID'\r\n  , 'gl_Position'\r\n  , 'gl_PointSize'\r\n  , 'gl_FragCoord'\r\n  , 'gl_FrontFacing'\r\n  , 'gl_FragDepth'\r\n  , 'gl_PointCoord'\r\n  , 'gl_MaxVertexAttribs'\r\n  , 'gl_MaxVertexUniformVectors'\r\n  , 'gl_MaxVertexOutputVectors'\r\n  , 'gl_MaxFragmentInputVectors'\r\n  , 'gl_MaxVertexTextureImageUnits'\r\n  , 'gl_MaxCombinedTextureImageUnits'\r\n  , 'gl_MaxTextureImageUnits'\r\n  , 'gl_MaxFragmentUniformVectors'\r\n  , 'gl_MaxDrawBuffers'\r\n  , 'gl_MinProgramTexelOffset'\r\n  , 'gl_MaxProgramTexelOffset'\r\n  , 'gl_DepthRangeParameters'\r\n  , 'gl_DepthRange'\r\n\r\n  // other builtins\r\n  , 'trunc'\r\n  , 'round'\r\n  , 'roundEven'\r\n  , 'isnan'\r\n  , 'isinf'\r\n  , 'floatBitsToInt'\r\n  , 'floatBitsToUint'\r\n  , 'intBitsToFloat'\r\n  , 'uintBitsToFloat'\r\n  , 'packSnorm2x16'\r\n  , 'unpackSnorm2x16'\r\n  , 'packUnorm2x16'\r\n  , 'unpackUnorm2x16'\r\n  , 'packHalf2x16'\r\n  , 'unpackHalf2x16'\r\n  , 'outerProduct'\r\n  , 'transpose'\r\n  , 'determinant'\r\n  , 'inverse'\r\n  , 'texture'\r\n  , 'textureSize'\r\n  , 'textureProj'\r\n  , 'textureLod'\r\n  , 'textureOffset'\r\n  , 'texelFetch'\r\n  , 'texelFetchOffset'\r\n  , 'textureProjOffset'\r\n  , 'textureLodOffset'\r\n  , 'textureProjLod'\r\n  , 'textureProjLodOffset'\r\n  , 'textureGrad'\r\n  , 'textureGradOffset'\r\n  , 'textureProjGrad'\r\n  , 'textureProjGradOffset'\r\n])\r\n\n\n//# sourceURL=webpack://workshop/../nla/tsgl/node_modules/glsl-tokenizer/lib/builtins-300es.js?")},293:module=>{eval("module.exports = [\r\n  // Keep this list sorted\r\n  'abs'\r\n  , 'acos'\r\n  , 'all'\r\n  , 'any'\r\n  , 'asin'\r\n  , 'atan'\r\n  , 'ceil'\r\n  , 'clamp'\r\n  , 'cos'\r\n  , 'cross'\r\n  , 'dFdx'\r\n  , 'dFdy'\r\n  , 'degrees'\r\n  , 'distance'\r\n  , 'dot'\r\n  , 'equal'\r\n  , 'exp'\r\n  , 'exp2'\r\n  , 'faceforward'\r\n  , 'floor'\r\n  , 'fract'\r\n  , 'gl_BackColor'\r\n  , 'gl_BackLightModelProduct'\r\n  , 'gl_BackLightProduct'\r\n  , 'gl_BackMaterial'\r\n  , 'gl_BackSecondaryColor'\r\n  , 'gl_ClipPlane'\r\n  , 'gl_ClipVertex'\r\n  , 'gl_Color'\r\n  , 'gl_DepthRange'\r\n  , 'gl_DepthRangeParameters'\r\n  , 'gl_EyePlaneQ'\r\n  , 'gl_EyePlaneR'\r\n  , 'gl_EyePlaneS'\r\n  , 'gl_EyePlaneT'\r\n  , 'gl_Fog'\r\n  , 'gl_FogCoord'\r\n  , 'gl_FogFragCoord'\r\n  , 'gl_FogParameters'\r\n  , 'gl_FragColor'\r\n  , 'gl_FragCoord'\r\n  , 'gl_FragData'\r\n  , 'gl_FragDepth'\r\n  , 'gl_FragDepthEXT'\r\n  , 'gl_FrontColor'\r\n  , 'gl_FrontFacing'\r\n  , 'gl_FrontLightModelProduct'\r\n  , 'gl_FrontLightProduct'\r\n  , 'gl_FrontMaterial'\r\n  , 'gl_FrontSecondaryColor'\r\n  , 'gl_LightModel'\r\n  , 'gl_LightModelParameters'\r\n  , 'gl_LightModelProducts'\r\n  , 'gl_LightProducts'\r\n  , 'gl_LightSource'\r\n  , 'gl_LightSourceParameters'\r\n  , 'gl_MaterialParameters'\r\n  , 'gl_MaxClipPlanes'\r\n  , 'gl_MaxCombinedTextureImageUnits'\r\n  , 'gl_MaxDrawBuffers'\r\n  , 'gl_MaxFragmentUniformComponents'\r\n  , 'gl_MaxLights'\r\n  , 'gl_MaxTextureCoords'\r\n  , 'gl_MaxTextureImageUnits'\r\n  , 'gl_MaxTextureUnits'\r\n  , 'gl_MaxVaryingFloats'\r\n  , 'gl_MaxVertexAttribs'\r\n  , 'gl_MaxVertexTextureImageUnits'\r\n  , 'gl_MaxVertexUniformComponents'\r\n  , 'gl_ModelViewMatrix'\r\n  , 'gl_ModelViewMatrixInverse'\r\n  , 'gl_ModelViewMatrixInverseTranspose'\r\n  , 'gl_ModelViewMatrixTranspose'\r\n  , 'gl_ModelViewProjectionMatrix'\r\n  , 'gl_ModelViewProjectionMatrixInverse'\r\n  , 'gl_ModelViewProjectionMatrixInverseTranspose'\r\n  , 'gl_ModelViewProjectionMatrixTranspose'\r\n  , 'gl_MultiTexCoord0'\r\n  , 'gl_MultiTexCoord1'\r\n  , 'gl_MultiTexCoord2'\r\n  , 'gl_MultiTexCoord3'\r\n  , 'gl_MultiTexCoord4'\r\n  , 'gl_MultiTexCoord5'\r\n  , 'gl_MultiTexCoord6'\r\n  , 'gl_MultiTexCoord7'\r\n  , 'gl_Normal'\r\n  , 'gl_NormalMatrix'\r\n  , 'gl_NormalScale'\r\n  , 'gl_ObjectPlaneQ'\r\n  , 'gl_ObjectPlaneR'\r\n  , 'gl_ObjectPlaneS'\r\n  , 'gl_ObjectPlaneT'\r\n  , 'gl_Point'\r\n  , 'gl_PointCoord'\r\n  , 'gl_PointParameters'\r\n  , 'gl_PointSize'\r\n  , 'gl_Position'\r\n  , 'gl_ProjectionMatrix'\r\n  , 'gl_ProjectionMatrixInverse'\r\n  , 'gl_ProjectionMatrixInverseTranspose'\r\n  , 'gl_ProjectionMatrixTranspose'\r\n  , 'gl_SecondaryColor'\r\n  , 'gl_TexCoord'\r\n  , 'gl_TextureEnvColor'\r\n  , 'gl_TextureMatrix'\r\n  , 'gl_TextureMatrixInverse'\r\n  , 'gl_TextureMatrixInverseTranspose'\r\n  , 'gl_TextureMatrixTranspose'\r\n  , 'gl_Vertex'\r\n  , 'greaterThan'\r\n  , 'greaterThanEqual'\r\n  , 'inversesqrt'\r\n  , 'length'\r\n  , 'lessThan'\r\n  , 'lessThanEqual'\r\n  , 'log'\r\n  , 'log2'\r\n  , 'matrixCompMult'\r\n  , 'max'\r\n  , 'min'\r\n  , 'mix'\r\n  , 'mod'\r\n  , 'normalize'\r\n  , 'not'\r\n  , 'notEqual'\r\n  , 'pow'\r\n  , 'radians'\r\n  , 'reflect'\r\n  , 'refract'\r\n  , 'sign'\r\n  , 'sin'\r\n  , 'smoothstep'\r\n  , 'sqrt'\r\n  , 'step'\r\n  , 'tan'\r\n  , 'texture2D'\r\n  , 'texture2DLod'\r\n  , 'texture2DProj'\r\n  , 'texture2DProjLod'\r\n  , 'textureCube'\r\n  , 'textureCubeLod'\r\n  , 'texture2DLodEXT'\r\n  , 'texture2DProjLodEXT'\r\n  , 'textureCubeLodEXT'\r\n  , 'texture2DGradEXT'\r\n  , 'texture2DProjGradEXT'\r\n  , 'textureCubeGradEXT'\r\n]\r\n\n\n//# sourceURL=webpack://workshop/../nla/tsgl/node_modules/glsl-tokenizer/lib/builtins.js?")},1792:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var v100 = __webpack_require__(7369)\r\n\r\nmodule.exports = v100.slice().concat([\r\n   'layout'\r\n  , 'centroid'\r\n  , 'smooth'\r\n  , 'case'\r\n  , 'mat2x2'\r\n  , 'mat2x3'\r\n  , 'mat2x4'\r\n  , 'mat3x2'\r\n  , 'mat3x3'\r\n  , 'mat3x4'\r\n  , 'mat4x2'\r\n  , 'mat4x3'\r\n  , 'mat4x4'\r\n  , 'uvec2'\r\n  , 'uvec3'\r\n  , 'uvec4'\r\n  , 'samplerCubeShadow'\r\n  , 'sampler2DArray'\r\n  , 'sampler2DArrayShadow'\r\n  , 'isampler2D'\r\n  , 'isampler3D'\r\n  , 'isamplerCube'\r\n  , 'isampler2DArray'\r\n  , 'usampler2D'\r\n  , 'usampler3D'\r\n  , 'usamplerCube'\r\n  , 'usampler2DArray'\r\n  , 'coherent'\r\n  , 'restrict'\r\n  , 'readonly'\r\n  , 'writeonly'\r\n  , 'resource'\r\n  , 'atomic_uint'\r\n  , 'noperspective'\r\n  , 'patch'\r\n  , 'sample'\r\n  , 'subroutine'\r\n  , 'common'\r\n  , 'partition'\r\n  , 'active'\r\n  , 'filter'\r\n  , 'image1D'\r\n  , 'image2D'\r\n  , 'image3D'\r\n  , 'imageCube'\r\n  , 'iimage1D'\r\n  , 'iimage2D'\r\n  , 'iimage3D'\r\n  , 'iimageCube'\r\n  , 'uimage1D'\r\n  , 'uimage2D'\r\n  , 'uimage3D'\r\n  , 'uimageCube'\r\n  , 'image1DArray'\r\n  , 'image2DArray'\r\n  , 'iimage1DArray'\r\n  , 'iimage2DArray'\r\n  , 'uimage1DArray'\r\n  , 'uimage2DArray'\r\n  , 'image1DShadow'\r\n  , 'image2DShadow'\r\n  , 'image1DArrayShadow'\r\n  , 'image2DArrayShadow'\r\n  , 'imageBuffer'\r\n  , 'iimageBuffer'\r\n  , 'uimageBuffer'\r\n  , 'sampler1DArray'\r\n  , 'sampler1DArrayShadow'\r\n  , 'isampler1D'\r\n  , 'isampler1DArray'\r\n  , 'usampler1D'\r\n  , 'usampler1DArray'\r\n  , 'isampler2DRect'\r\n  , 'usampler2DRect'\r\n  , 'samplerBuffer'\r\n  , 'isamplerBuffer'\r\n  , 'usamplerBuffer'\r\n  , 'sampler2DMS'\r\n  , 'isampler2DMS'\r\n  , 'usampler2DMS'\r\n  , 'sampler2DMSArray'\r\n  , 'isampler2DMSArray'\r\n  , 'usampler2DMSArray'\r\n])\r\n\n\n//# sourceURL=webpack://workshop/../nla/tsgl/node_modules/glsl-tokenizer/lib/literals-300es.js?")},7369:module=>{eval("module.exports = [\r\n  // current\r\n    'precision'\r\n  , 'highp'\r\n  , 'mediump'\r\n  , 'lowp'\r\n  , 'attribute'\r\n  , 'const'\r\n  , 'uniform'\r\n  , 'varying'\r\n  , 'break'\r\n  , 'continue'\r\n  , 'do'\r\n  , 'for'\r\n  , 'while'\r\n  , 'if'\r\n  , 'else'\r\n  , 'in'\r\n  , 'out'\r\n  , 'inout'\r\n  , 'float'\r\n  , 'int'\r\n  , 'uint'\r\n  , 'void'\r\n  , 'bool'\r\n  , 'true'\r\n  , 'false'\r\n  , 'discard'\r\n  , 'return'\r\n  , 'mat2'\r\n  , 'mat3'\r\n  , 'mat4'\r\n  , 'vec2'\r\n  , 'vec3'\r\n  , 'vec4'\r\n  , 'ivec2'\r\n  , 'ivec3'\r\n  , 'ivec4'\r\n  , 'bvec2'\r\n  , 'bvec3'\r\n  , 'bvec4'\r\n  , 'sampler1D'\r\n  , 'sampler2D'\r\n  , 'sampler3D'\r\n  , 'samplerCube'\r\n  , 'sampler1DShadow'\r\n  , 'sampler2DShadow'\r\n  , 'struct'\r\n\r\n  // future\r\n  , 'asm'\r\n  , 'class'\r\n  , 'union'\r\n  , 'enum'\r\n  , 'typedef'\r\n  , 'template'\r\n  , 'this'\r\n  , 'packed'\r\n  , 'goto'\r\n  , 'switch'\r\n  , 'default'\r\n  , 'inline'\r\n  , 'noinline'\r\n  , 'volatile'\r\n  , 'public'\r\n  , 'static'\r\n  , 'extern'\r\n  , 'external'\r\n  , 'interface'\r\n  , 'long'\r\n  , 'short'\r\n  , 'double'\r\n  , 'half'\r\n  , 'fixed'\r\n  , 'unsigned'\r\n  , 'input'\r\n  , 'output'\r\n  , 'hvec2'\r\n  , 'hvec3'\r\n  , 'hvec4'\r\n  , 'dvec2'\r\n  , 'dvec3'\r\n  , 'dvec4'\r\n  , 'fvec2'\r\n  , 'fvec3'\r\n  , 'fvec4'\r\n  , 'sampler2DRect'\r\n  , 'sampler3DRect'\r\n  , 'sampler2DRectShadow'\r\n  , 'sizeof'\r\n  , 'cast'\r\n  , 'namespace'\r\n  , 'using'\r\n]\r\n\n\n//# sourceURL=webpack://workshop/../nla/tsgl/node_modules/glsl-tokenizer/lib/literals.js?")},9628:module=>{eval("module.exports = [\r\n    '<<='\r\n  , '>>='\r\n  , '++'\r\n  , '--'\r\n  , '<<'\r\n  , '>>'\r\n  , '<='\r\n  , '>='\r\n  , '=='\r\n  , '!='\r\n  , '&&'\r\n  , '||'\r\n  , '+='\r\n  , '-='\r\n  , '*='\r\n  , '/='\r\n  , '%='\r\n  , '&='\r\n  , '^^'\r\n  , '^='\r\n  , '|='\r\n  , '('\r\n  , ')'\r\n  , '['\r\n  , ']'\r\n  , '.'\r\n  , '!'\r\n  , '~'\r\n  , '*'\r\n  , '/'\r\n  , '%'\r\n  , '+'\r\n  , '-'\r\n  , '<'\r\n  , '>'\r\n  , '&'\r\n  , '^'\r\n  , '|'\r\n  , '?'\r\n  , ':'\r\n  , '='\r\n  , ','\r\n  , ';'\r\n  , '{'\r\n  , '}'\r\n]\r\n\n\n//# sourceURL=webpack://workshop/../nla/tsgl/node_modules/glsl-tokenizer/lib/operators.js?")},7526:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var tokenize = __webpack_require__(6158)\r\n\r\nmodule.exports = tokenizeString\r\n\r\nfunction tokenizeString(str, opt) {\r\n  var generator = tokenize(opt)\r\n  var tokens = []\r\n\r\n  tokens = tokens.concat(generator(str))\r\n  tokens = tokens.concat(generator(null))\r\n\r\n  return tokens\r\n}\r\n\n\n//# sourceURL=webpack://workshop/../nla/tsgl/node_modules/glsl-tokenizer/string.js?")},7841:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("/*!\n * pad-left <https://github.com/jonschlinkert/pad-left>\n *\n * Copyright (c) 2014-2015, Jon Schlinkert.\n * Licensed under the MIT license.\n */\n\n\n\nvar repeat = __webpack_require__(3913);\n\nmodule.exports = function padLeft(str, num, ch) {\n  ch = typeof ch !== 'undefined' ? (ch + '') : ' ';\n  return repeat(ch, num) + str;\n};\n\n//# sourceURL=webpack://workshop/../nla/tsgl/node_modules/pad-left/index.js?")},3913:module=>{"use strict";eval("/*!\n * repeat-string <https://github.com/jonschlinkert/repeat-string>\n *\n * Copyright (c) 2014-2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n\n\n/**\n * Results cache\n */\n\nvar res = '';\nvar cache;\n\n/**\n * Expose `repeat`\n */\n\nmodule.exports = repeat;\n\n/**\n * Repeat the given `string` the specified `number`\n * of times.\n *\n * **Example:**\n *\n * ```js\n * var repeat = require('repeat-string');\n * repeat('A', 5);\n * //=> AAAAA\n * ```\n *\n * @param {String} `string` The string to repeat\n * @param {Number} `number` The number of times to repeat the string\n * @return {String} Repeated string\n * @api public\n */\n\nfunction repeat(str, num) {\n  if (typeof str !== 'string') {\n    throw new TypeError('expected a string');\n  }\n\n  // cover common, quick use cases\n  if (num === 1) return str;\n  if (num === 2) return str + str;\n\n  var max = str.length * num;\n  if (cache !== str || typeof cache === 'undefined') {\n    cache = str;\n    res = '';\n  } else if (res.length >= max) {\n    return res.substr(0, max);\n  }\n\n  while (max > res.length && num > 1) {\n    if (num & 1) {\n      res += str;\n    }\n\n    num >>= 1;\n    str += str;\n  }\n\n  res += str;\n  res = res.substr(0, max);\n  return res;\n}\n\n\n//# sourceURL=webpack://workshop/../nla/tsgl/node_modules/repeat-string/index.js?")},4564:(module,exports,__webpack_require__)=>{eval("var __WEBPACK_AMD_DEFINE_RESULT__;/* global window, exports, define */\n\n!function() {\n    'use strict'\n\n    var re = {\n        not_string: /[^s]/,\n        not_bool: /[^t]/,\n        not_type: /[^T]/,\n        not_primitive: /[^v]/,\n        number: /[diefg]/,\n        numeric_arg: /[bcdiefguxX]/,\n        json: /[j]/,\n        not_json: /[^j]/,\n        text: /^[^\\x25]+/,\n        modulo: /^\\x25{2}/,\n        placeholder: /^\\x25(?:([1-9]\\d*)\\$|\\(([^)]+)\\))?(\\+)?(0|'[^$])?(-)?(\\d+)?(?:\\.(\\d+))?([b-gijostTuvxX])/,\n        key: /^([a-z_][a-z_\\d]*)/i,\n        key_access: /^\\.([a-z_][a-z_\\d]*)/i,\n        index_access: /^\\[(\\d+)\\]/,\n        sign: /^[+-]/\n    }\n\n    function sprintf(key) {\n        // `arguments` is not an array, but should be fine for this call\n        return sprintf_format(sprintf_parse(key), arguments)\n    }\n\n    function vsprintf(fmt, argv) {\n        return sprintf.apply(null, [fmt].concat(argv || []))\n    }\n\n    function sprintf_format(parse_tree, argv) {\n        var cursor = 1, tree_length = parse_tree.length, arg, output = '', i, k, ph, pad, pad_character, pad_length, is_positive, sign\n        for (i = 0; i < tree_length; i++) {\n            if (typeof parse_tree[i] === 'string') {\n                output += parse_tree[i]\n            }\n            else if (typeof parse_tree[i] === 'object') {\n                ph = parse_tree[i] // convenience purposes only\n                if (ph.keys) { // keyword argument\n                    arg = argv[cursor]\n                    for (k = 0; k < ph.keys.length; k++) {\n                        if (arg == undefined) {\n                            throw new Error(sprintf('[sprintf] Cannot access property \"%s\" of undefined value \"%s\"', ph.keys[k], ph.keys[k-1]))\n                        }\n                        arg = arg[ph.keys[k]]\n                    }\n                }\n                else if (ph.param_no) { // positional argument (explicit)\n                    arg = argv[ph.param_no]\n                }\n                else { // positional argument (implicit)\n                    arg = argv[cursor++]\n                }\n\n                if (re.not_type.test(ph.type) && re.not_primitive.test(ph.type) && arg instanceof Function) {\n                    arg = arg()\n                }\n\n                if (re.numeric_arg.test(ph.type) && (typeof arg !== 'number' && isNaN(arg))) {\n                    throw new TypeError(sprintf('[sprintf] expecting number but found %T', arg))\n                }\n\n                if (re.number.test(ph.type)) {\n                    is_positive = arg >= 0\n                }\n\n                switch (ph.type) {\n                    case 'b':\n                        arg = parseInt(arg, 10).toString(2)\n                        break\n                    case 'c':\n                        arg = String.fromCharCode(parseInt(arg, 10))\n                        break\n                    case 'd':\n                    case 'i':\n                        arg = parseInt(arg, 10)\n                        break\n                    case 'j':\n                        arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0)\n                        break\n                    case 'e':\n                        arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential()\n                        break\n                    case 'f':\n                        arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg)\n                        break\n                    case 'g':\n                        arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg)\n                        break\n                    case 'o':\n                        arg = (parseInt(arg, 10) >>> 0).toString(8)\n                        break\n                    case 's':\n                        arg = String(arg)\n                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)\n                        break\n                    case 't':\n                        arg = String(!!arg)\n                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)\n                        break\n                    case 'T':\n                        arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase()\n                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)\n                        break\n                    case 'u':\n                        arg = parseInt(arg, 10) >>> 0\n                        break\n                    case 'v':\n                        arg = arg.valueOf()\n                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)\n                        break\n                    case 'x':\n                        arg = (parseInt(arg, 10) >>> 0).toString(16)\n                        break\n                    case 'X':\n                        arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase()\n                        break\n                }\n                if (re.json.test(ph.type)) {\n                    output += arg\n                }\n                else {\n                    if (re.number.test(ph.type) && (!is_positive || ph.sign)) {\n                        sign = is_positive ? '+' : '-'\n                        arg = arg.toString().replace(re.sign, '')\n                    }\n                    else {\n                        sign = ''\n                    }\n                    pad_character = ph.pad_char ? ph.pad_char === '0' ? '0' : ph.pad_char.charAt(1) : ' '\n                    pad_length = ph.width - (sign + arg).length\n                    pad = ph.width ? (pad_length > 0 ? pad_character.repeat(pad_length) : '') : ''\n                    output += ph.align ? sign + arg + pad : (pad_character === '0' ? sign + pad + arg : pad + sign + arg)\n                }\n            }\n        }\n        return output\n    }\n\n    var sprintf_cache = Object.create(null)\n\n    function sprintf_parse(fmt) {\n        if (sprintf_cache[fmt]) {\n            return sprintf_cache[fmt]\n        }\n\n        var _fmt = fmt, match, parse_tree = [], arg_names = 0\n        while (_fmt) {\n            if ((match = re.text.exec(_fmt)) !== null) {\n                parse_tree.push(match[0])\n            }\n            else if ((match = re.modulo.exec(_fmt)) !== null) {\n                parse_tree.push('%')\n            }\n            else if ((match = re.placeholder.exec(_fmt)) !== null) {\n                if (match[2]) {\n                    arg_names |= 1\n                    var field_list = [], replacement_field = match[2], field_match = []\n                    if ((field_match = re.key.exec(replacement_field)) !== null) {\n                        field_list.push(field_match[1])\n                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {\n                            if ((field_match = re.key_access.exec(replacement_field)) !== null) {\n                                field_list.push(field_match[1])\n                            }\n                            else if ((field_match = re.index_access.exec(replacement_field)) !== null) {\n                                field_list.push(field_match[1])\n                            }\n                            else {\n                                throw new SyntaxError('[sprintf] failed to parse named argument key')\n                            }\n                        }\n                    }\n                    else {\n                        throw new SyntaxError('[sprintf] failed to parse named argument key')\n                    }\n                    match[2] = field_list\n                }\n                else {\n                    arg_names |= 2\n                }\n                if (arg_names === 3) {\n                    throw new Error('[sprintf] mixing positional and named placeholders is not (yet) supported')\n                }\n\n                parse_tree.push(\n                    {\n                        placeholder: match[0],\n                        param_no:    match[1],\n                        keys:        match[2],\n                        sign:        match[3],\n                        pad_char:    match[4],\n                        align:       match[5],\n                        width:       match[6],\n                        precision:   match[7],\n                        type:        match[8]\n                    }\n                )\n            }\n            else {\n                throw new SyntaxError('[sprintf] unexpected placeholder')\n            }\n            _fmt = _fmt.substring(match[0].length)\n        }\n        return sprintf_cache[fmt] = parse_tree\n    }\n\n    /**\n     * export to either browser or node.js\n     */\n    /* eslint-disable quote-props */\n    if (true) {\n        exports.sprintf = sprintf\n        exports.vsprintf = vsprintf\n    }\n    if (typeof window !== 'undefined') {\n        window['sprintf'] = sprintf\n        window['vsprintf'] = vsprintf\n\n        if (true) {\n            !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n                return {\n                    'sprintf': sprintf,\n                    'vsprintf': vsprintf\n                }\n            }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n        }\n    }\n    /* eslint-enable quote-props */\n}(); // eslint-disable-line\n\n\n//# sourceURL=webpack://workshop/../nla/tsgl/node_modules/sprintf-js/src/sprintf.js?")},8149:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "mG": () => (/* binding */ __awaiter)\n/* harmony export */ });\n/* unused harmony exports __extends, __assign, __rest, __decorate, __param, __metadata, __generator, __createBinding, __exportStar, __values, __read, __spread, __spreadArrays, __spreadArray, __await, __asyncGenerator, __asyncDelegator, __asyncValues, __makeTemplateObject, __importStar, __importDefault, __classPrivateFieldGet, __classPrivateFieldSet */\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== "function" && b !== null)\r\n        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === "function")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nfunction __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nfunction __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError("Generator is already executing.");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nvar __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nfunction __exportStar(m, o) {\r\n    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === "number") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i["return"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nfunction __spreadArray(to, from) {\r\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\r\n        to[j] = from[i];\r\n    return to;\r\n}\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume("next", value); }\r\n    function reject(value) { resume("throw", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nfunction __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o["default"] = v;\r\n};\r\n\r\nfunction __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nfunction __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nfunction __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError("attempted to get private field on non-instance");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nfunction __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError("attempted to set private field on non-instance");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n\n\n//# sourceURL=webpack://workshop/../nla/tsgl/node_modules/tslib/tslib.es6.js?')},7392:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "$_": () => (/* binding */ color),\n/* harmony export */   "iv": () => (/* binding */ css),\n/* harmony export */   "gl": () => (/* binding */ gl),\n/* harmony export */   "bA": () => (/* binding */ scale)\n/* harmony export */ });\n/* unused harmony exports Color, CubeHelix, Scale, analyze, average, bezier, black, blend, brewer, cmyk, contrast, cubehelix, deltaE, distance, hcg, hsi, hsl, hsv, kelvin, lab, lch, limits, mix, num, random, rgb, scales, w3cx11, white, xyz */\n/**\n * @license\n *\n * js - JavaScript library for color conversions\n *\n * Copyright (c) 2011-2017, Gregor Aisch\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * 3. The name Gregor Aisch may not be used to endorse or promote products\n *    derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n// tslint:disable:no-unnecessary-qualifier\nconst { abs, atan2, cos, floor, log, min, max, round, sign, sin, sqrt, cbrt, PI, hypot } = Math;\nfunction lerp(a, b, f) {\n    return a + (b - a) * f;\n}\nfunction lerpInv(a, b, f) {\n    return (f - a) / (b - a);\n}\nfunction clamp(x, min = 0, max = 1) {\n    return x < min ? min : x > max ? max : x;\n}\nfunction newtonIterate1d(f, xStart, max_steps, eps = 1e-8) {\n    let x = xStart, fx;\n    while (max_steps-- && abs((fx = f(x))) > eps) {\n        const dfdx = (f(x + eps) - fx) / eps;\n        console.log("fx / dfdx", fx / dfdx, "fx", fx, "x", x);\n        x = x - fx / dfdx;\n    }\n    return x;\n}\nfunction bisect(f, a, b, steps) {\n    //assert(a < b)\n    let fA = f(a);\n    // let fB = f(b)\n    //assert(fA * fB < 0)\n    while (steps--) {\n        const c = (a + b) / 2;\n        const fC = f(c);\n        // console.log("fC", fC, "c", c)\n        if (sign(fA) == sign(fC)) {\n            a = c;\n            fA = fC;\n        }\n        else {\n            b = c;\n            // fB = fC\n        }\n    }\n    //assert(a <= (b + a) / 2)\n    //assert(b >= (b + a) / 2)\n    return (a + b) / 2;\n}\nconst TWOPI = 2 * PI;\nconst DEG2RAD = PI / 180;\nconst RAD2DEG = 180 / PI;\nfunction color(...args) {\n    if (args[0] instanceof Color) {\n        return args[0];\n    }\n    if (args.length > 1 && "string" == typeof args[args.length - 1]) {\n        return guess(args.slice(0, args.length - 1), args[args.length - 1]);\n    }\n    else if (Array.isArray(args[0])) {\n        return guess(args[0]);\n    }\n    else {\n        return guess(args);\n    }\n}\nclass Color {\n    /** @internal */\n    constructor(r, g, b, a = 1) {\n        this.r = r;\n        this.g = g;\n        this.b = b;\n        this.a = a;\n    }\n    // public shade() {\n    // \tconst shades: [string, string, number][] = [\n    // \t\t["ff0000", "red"],\n    // \t\t["ffa500", "orange"],\n    // \t\t["ffff00", "yellow"],\n    // \t\t["008000", "green"],\n    // \t\t["0000ff", "blue"],\n    // \t\t["ee82ee", "violet"],\n    // \t\t["a52a2a", "brown"],\n    // \t\t["000000", "black"],\n    // \t\t["808080", "grey"],\n    // \t\t["ffffff", "white"],\n    // \t] as any\n    // \tfunction angleDiff(a: number, b: number) {\n    // \t\tconst d = (a - b) % 360\n    // \t\tif (d > 180) return d - 360\n    // \t\tif (d < -180) return d + 360\n    // \t\treturn d\n    // \t}\n    // \tshades.forEach(arr => arr.push(color(arr[0]).hsl()[0]))\n    // \tconst [h, s, l] = this.hsl()\n    // \tif (l > 0.9) return "white"\n    // \tif (l > 0.8 && s < 0.2) return "white"\n    // \tif (s < 0.1) return "grey"\n    // \tif (s < 0.4 && h > 0 && h < 48) return "brown"\n    // \tconst distanceInXYZ: { [hue: number]: number } = { 0: 0 }\n    // \tfor (let i = 60; i <= 360; i += 60) {\n    // \t\tdistanceInXYZ[i] =\n    // \t\t\tdistanceInXYZ[i - 60] + distance(hsl(i - 60, 1, 0.5), hsl(i, 1, 0.5), "xyz")\n    // \t}\n    // \t// console.log(distanceInXYZ)\n    // \tconst shadeEnds: { [hue: number]: number } = {\n    // \t\t0: 9,\n    // \t\t38: 48,\n    // \t\t60: 65,\n    // \t\t120: 165,\n    // \t\t240: 245,\n    // \t\t300: 338,\n    // \t\t360: 369,\n    // \t}\n    // \tconst getColorDistanceAlongXYZHue = (hueDegrees: number) => {\n    // \t\tconst base = hueDegrees - (hueDegrees % 60)\n    // \t\treturn (\n    // \t\t\tdistanceInXYZ[base] + distance(hsl(base, 1, 0.5), hsl(hueDegrees, 1, 0.5), "xyz")\n    // \t\t)\n    // \t}\n    // \tconst colorXYZD = getColorDistanceAlongXYZHue(this.hsl()[0])\n    // \tconst md = distanceInXYZ[360]\n    // \tconst shadeHue =\n    // \t\t(Object.keys(shadeEnds) as any[]).find(shadeHue => shadeEnds[shadeHue | 0] >= this.hsl()[0])! % 360\n    // \treturn shades.find(([_hex, _name, _hue]) => (_hue | 0) === shadeHue)![1]\n    // \t// process.exit()\n    // \treturn withMax(shades, ([_hex, _name, _hue]) => {\n    // \t\treturn -abs(angleDiff(this.hsl()[0], _hue))\n    // \t})[1]\n    // \treturn withMax(shades, ([_hex, _name, _hue]) => {\n    // \t\tconst [thisL, thisA, thisB] = this.lab()\n    // \t\tconst [L, A, B] = color(_hex).lab()\n    // \t\treturn -hypot(thisL - L, thisA - A, thisB - B)\n    // \t})[1]\n    // }\n    /**\n     * @see [[mix]]\n     */\n    mix(col2, f, m = "rgb") {\n        return mix(this, col2, f, m);\n    }\n    rgb(doRound = true, clamp_ = true) {\n        const f = (t) => {\n            if (doRound)\n                t = round(t);\n            if (clamp_)\n                t = clamp(t, 0, 255);\n            return t;\n        };\n        const { r, g, b } = this;\n        return [f(r), f(g), f(b)];\n    }\n    rgba(doRound = true, clamp_ = true) {\n        const f = (t) => {\n            if (doRound)\n                t = round(t);\n            if (clamp_)\n                t = clamp(t, 0, 255);\n            return t;\n        };\n        const { r, g, b, a } = this;\n        return [f(r), f(g), f(b), a];\n    }\n    /**\n     * Return a hex-string representation of this color.\n     *\n     * @param mode\n     * @see #num for a hex-number representation.\n     * @example chroma.color(\'yellow\').alpha(0.7).hex()\n     * @example chroma.color(\'yellow\').alpha(0.7).hex(\'rgba\')\n     * @example chroma.color(\'yellow\').alpha(0.7).hex(\'argb\')\n     */\n    hex(mode = "rgb") {\n        const { r, g, b, a } = this;\n        return rgb2hex(r, g, b, a, mode);\n    }\n    /**\n     * Returns the [HSL] representation of this color. hue will always be in [0;360). Values are never NaN.\n     *\n     * @example chroma.color(\'purple\').hsl()\n     */\n    hsl() {\n        const { r, g, b } = this;\n        return rgb2hsl(r, g, b);\n    }\n    /**\n     * Returns the [HSL] representation of this color. hue will always be in [0;360). Values are never NaN.\n     *\n     * @example chroma.color(\'purple\').hsv()\n     */\n    hsv() {\n        const { r, g, b } = this;\n        return rgb2hsv(r, g, b);\n    }\n    /**\n     * Returns the [HSL] representation of this color. hue will always be in [0;360). Values are never NaN.\n     *\n     * @example chroma.color(\'purple\').hcg()\n     */\n    hcg() {\n        const { r, g, b } = this;\n        return rgb2hcg(r, g, b);\n    }\n    /**\n     * Returns a CSS `rgb(...)` or `hsl(...)` string representation that can be used as CSS-color definition. The alpha\n     * value is not output if it 1.\n     * @example chroma.color(\'teal\').css() // == "rgb(0,128,128)"\n     * @example chroma.color(\'teal\').alpha(0.5).css() // == "rgba(0,128,128,0.5)"\n     * @example chroma.color(\'teal\').css(\'hsl\') // == "hsl(180,100%,25.1%)"\n     */\n    css(mode = "rgb") {\n        if ("rgb" == mode) {\n            const { r, g, b, a } = this;\n            return rgb2css(r, g, b, a);\n        }\n        else if ("hsl" == mode) {\n            return hsl2css(this.hsl(), this.alpha());\n        }\n        else {\n            throw new Error();\n        }\n    }\n    name(closest = false) {\n        const thisNum = this.num();\n        const name = Object.keys(w3cx11).find((name) => w3cx11[name] == thisNum);\n        if (!name && closest) {\n            const [thisLStar, thisAStar, thisBStar] = this.lab();\n            return withMax(Object.keys(w3cx11), (name) => {\n                const [lStar, aStar, bStar] = num(w3cx11[name]).lab();\n                return -hypot(thisLStar - lStar, thisAStar - aStar, thisBStar - bStar);\n            });\n        }\n        return name;\n    }\n    /**\n     * Get the [CMYK](#CMYK) representation of this color.\n     *\n     * @example chroma.color(\'red\').cmyk()\n     */\n    cmyk() {\n        const { r, g, b } = this;\n        return rgb2cmyk(r, g, b);\n    }\n    /**\n     * Returns the [GL] representation of this color.\n     * @example chroma.color(\'33cc00\').gl()\n     */\n    gl() {\n        const { r, g, b, a } = this;\n        return [r / 255, g / 255, b / 255, a];\n    }\n    luminance(lum1) {\n        const { r, g, b, a } = this;\n        const [, Y] = rgb2xyz(r, g, b);\n        if (undefined === lum1) {\n            return Y;\n        }\n        const inverseLerp = (a, b, val) => (val - a) / (b - a);\n        if (lum1 > Y) {\n            // lerp to white\n            return mix(this, white, inverseLerp(Y, 1, lum1), "xyz").alpha(a);\n        }\n        else {\n            // lerp to black\n            return mix(black, this, inverseLerp(0, Y, lum1), "xyz").alpha(a);\n        }\n    }\n    /**\n     * Get color temperature of this color in Kelvin. This only makes sense for colors close to those output by\n     * kelvin\n     *\n     * @example [c = chroma.color(\'#ff3300\'), c.temperature()]\n     * @example [c = chroma.color(\'#ffe3cd\'), c.temperature()]\n     * @example [c = chroma.color(\'#b3ccff\'), c.temperature()]\n     */\n    temperature() {\n        const { r, g, b } = this;\n        return rgb2kelvin(r, g, b);\n    }\n    /**\n     * Returns a new [Color] with a channel changed.\n     * @example chroma.color(\'skyblue\').set(\'hsl.h\', 0) // change hue to 0 deg (=red)\n     * @example chroma.color(\'hotpink\').set(\'lch.c\', 30) // set chromaticity to 30\n     * @example chroma.color(\'orangered\').set(\'lab.l\', x => x / 2) // half Lab lightness\n     * @example chroma.color(\'darkseagreen\').set(\'lch.c\', x => x * 2) // double Lch saturation\n     */\n    set(modeAndChannel, value) {\n        const [mode, channel] = modeAndChannel.split(".");\n        const src = this[mode]();\n        const i = mode.indexOf(channel);\n        if (-1 == i)\n            throw new Error("invalid channel");\n        src[i] = "number" == typeof value ? value : value(src[i]);\n        return color(src, mode).alpha(this.a);\n    }\n    /**\n     * Returns whether this color is outside the RGB color cube and will be clipped/clamped when calling .rgb()\n     *\n     * @example [c = chroma.lch( 20, 40, 50), c.clipped()]\n     * @example [c = chroma.lch( 40, 40, 50), c.clipped()]\n     * @example [c = chroma.lch( 60, 40, 50), c.clipped()]\n     * @example [c = chroma.lch( 80, 40, 50), c.clipped()]\n     * @example [c = chroma.lch(100, 40, 50), c.clipped()]\n     */\n    clipped() {\n        const { r, g, b } = this;\n        return !(0 <= r && r <= 255 && 0 <= g && g <= 255 && 0 <= b && b <= 255);\n    }\n    /**\n     * Returns black or white, whichever has the highest contrast to `this`.\n     * In the readme you should see the result of this.\n     *\n     * @example chroma.color(\'red\')\n     * @example chroma.color(\'yellow\')\n     */\n    textColor() {\n        return this.luminance() > 0.5 ? black : white;\n    }\n    alpha(alpha1) {\n        if (undefined === alpha1) {\n            return this.a;\n        }\n        const { r, g, b } = this;\n        return rgb(r, g, b, alpha1);\n    }\n    darker(amount = 1) {\n        const [l, a, b] = this.lab();\n        return lab(l - LAB_Kn * amount, a, b, this.alpha());\n    }\n    /**\n     *\n     * @param amount\n     * @example chroma.color(\'hotpink\')\n     * @example chroma.color(\'hotpink\').brighter()\n     * @example chroma.color(\'hotpink\').brighter(2)\n     * @example chroma.color(\'hotpink\').brighter(3)\n     */\n    brighter(amount = 1) {\n        return this.darker(-amount);\n    }\n    /**\n     * Returns a new [Color] with increased saturation.\n     * @param amount How much.\n     * @example chroma.color(\'slategray\')\n     * @example chroma.color(\'slategray\').saturate()\n     * @example chroma.color(\'slategray\').saturate(2)\n     * @example chroma.color(\'slategray\').saturate(3)\n     */\n    saturate(amount = 1) {\n        const [l, c, h] = this.lch();\n        return lch(l, max(0, c + amount * LAB_Kn), h, this.alpha());\n    }\n    /**\n     * Equivalent to `saturate(-amount)`.\n     * @see #saturate\n     */\n    desaturate(amount = 1) {\n        return this.saturate(-amount);\n    }\n    premultiplied() {\n        const { r, g, b, a } = this;\n        return rgb(r * a, g * a, b * a, a);\n    }\n    /**\n     * Returns the [HSI] representation of this color. hue will always be in [0; 360). Values are never NaN.\n     *\n     * @example chroma.color(\'purple\').hsi()\n     */\n    hsi() {\n        const { r, g, b } = this;\n        return rgb2hsi(r, g, b);\n    }\n    /**\n     * Returns the [LAB] representation of this color.\n     *\n     * @example chroma.color(\'purple\').lab()\n     */\n    lab() {\n        const { r, g, b } = this;\n        return rgb2lab(r, g, b);\n    }\n    /**\n     * Return a hex-num of this color.\n     *\n     * @param mode\n     * @see #num for a hex-number representation.\n     * @example chroma.color(\'yellow\').alpha(0.7).hex()\n     * @example chroma.color(\'yellow\').alpha(0.7).hex(\'rgba\')\n     * @example chroma.color(\'yellow\').alpha(0.7).hex(\'argb\')\n     */\n    num(mode = "rgb") {\n        const { r, g, b, a } = this;\n        return rgb2num(r, g, b, a, mode);\n    }\n    /**\n     * Returns the [LCH] representation of this color. hue will always be in [0; 360). Values are never NaN.\n     *\n     * @example chroma.color(\'purple\').lch()\n     */\n    lch() {\n        const { r, g, b } = this;\n        return rgb2lch(r, g, b);\n    }\n    /**\n     * Returns the [XYZ] representation of this color. hue will always be in [0; 360). Values are never NaN.\n     *\n     * @example chroma.color(\'purple\').xyz()\n     */\n    xyz() {\n        const { r, g, b } = this;\n        return rgb2xyz(r, g, b);\n    }\n    /**\n     * Whether this [Color](#Color) is identical (strict equality of r, g, b, a) to `color`.\n     */\n    equals(color) {\n        const { r, g, b, a } = this;\n        const { r: r2, g: g2, b: b2, a: a2 } = color;\n        return r == r2 && g == g2 && b == b2 && a == a2;\n    }\n    hashCode() {\n        return this.num("rgba");\n    }\n    /**\n     * @example chroma.color(\'red\').toSource() // == "rgb(255, 0, 0)"\n     * @example chroma.rgb(-2, 100.02, 200, 0.5).toSource() // == "rgb(-2, 100.02, 200, 0.5)"\n     */\n    toSource() {\n        const { r, g, b, a } = this;\n        return "chroma.rgb(" + r + ", " + g + ", " + b + (a === 1 ? ")" : ", " + a + ")");\n    }\n}\nColor.prototype.toString = Color.prototype.css;\nColor.prototype.kelvin = Color.prototype.temperature;\n/**\n * @example chroma.black\n */\nconst black = new Color(0, 0, 0, 1);\n/**\n * @example chroma.black\n */\nconst white = new Color(255, 255, 255, 1);\nconst brewer = {\n    OrRd: [0xfff7ec, 0xfee8c8, 0xfdd49e, 0xfdbb84, 0xfc8d59, 0xef6548, 0xd7301f, 0xb30000, 0x7f0000],\n    PuBu: [0xfff7fb, 0xece7f2, 0xd0d1e6, 0xa6bddb, 0x74a9cf, 0x3690c0, 0x0570b0, 0x045a8d, 0x023858],\n    BuPu: [0xf7fcfd, 0xe0ecf4, 0xbfd3e6, 0x9ebcda, 0x8c96c6, 0x8c6bb1, 0x88419d, 0x810f7c, 0x4d004b],\n    Oranges: [0xfff5eb, 0xfee6ce, 0xfdd0a2, 0xfdae6b, 0xfd8d3c, 0xf16913, 0xd94801, 0xa63603, 0x7f2704],\n    BuGn: [0xf7fcfd, 0xe5f5f9, 0xccece6, 0x99d8c9, 0x66c2a4, 0x41ae76, 0x238b45, 0x006d2c, 0x00441b],\n    YlOrBr: [0xffffe5, 0xfff7bc, 0xfee391, 0xfec44f, 0xfe9929, 0xec7014, 0xcc4c02, 0x993404, 0x662506],\n    YlGn: [0xffffe5, 0xf7fcb9, 0xd9f0a3, 0xaddd8e, 0x78c679, 0x41ab5d, 0x238443, 0x006837, 0x004529],\n    Reds: [0xfff5f0, 0xfee0d2, 0xfcbba1, 0xfc9272, 0xfb6a4a, 0xef3b2c, 0xcb181d, 0xa50f15, 0x67000d],\n    RdPu: [0xfff7f3, 0xfde0dd, 0xfcc5c0, 0xfa9fb5, 0xf768a1, 0xdd3497, 0xae017e, 0x7a0177, 0x49006a],\n    Greens: [0xf7fcf5, 0xe5f5e0, 0xc7e9c0, 0xa1d99b, 0x74c476, 0x41ab5d, 0x238b45, 0x006d2c, 0x00441b],\n    YlGnBu: [0xffffd9, 0xedf8b1, 0xc7e9b4, 0x7fcdbb, 0x41b6c4, 0x1d91c0, 0x225ea8, 0x253494, 0x081d58],\n    Purples: [0xfcfbfd, 0xefedf5, 0xdadaeb, 0xbcbddc, 0x9e9ac8, 0x807dba, 0x6a51a3, 0x54278f, 0x3f007d],\n    GnBu: [0xf7fcf0, 0xe0f3db, 0xccebc5, 0xa8ddb5, 0x7bccc4, 0x4eb3d3, 0x2b8cbe, 0x0868ac, 0x084081],\n    Greys: [0xffffff, 0xf0f0f0, 0xd9d9d9, 0xbdbdbd, 0x969696, 0x737373, 0x525252, 0x252525, 0x000000],\n    YlOrRd: [0xffffcc, 0xffeda0, 0xfed976, 0xfeb24c, 0xfd8d3c, 0xfc4e2a, 0xe31a1c, 0xbd0026, 0x800026],\n    PuRd: [0xf7f4f9, 0xe7e1ef, 0xd4b9da, 0xc994c7, 0xdf65b0, 0xe7298a, 0xce1256, 0x980043, 0x67001f],\n    Blues: [0xf7fbff, 0xdeebf7, 0xc6dbef, 0x9ecae1, 0x6baed6, 0x4292c6, 0x2171b5, 0x08519c, 0x08306b],\n    PuBuGn: [0xfff7fb, 0xece2f0, 0xd0d1e6, 0xa6bddb, 0x67a9cf, 0x3690c0, 0x02818a, 0x016c59, 0x014636],\n    Viridis: [0x440154, 0x482777, 0x3f4a8a, 0x31678e, 0x26838f, 0x1f9d8a, 0x6cce5a, 0xb6de2b, 0xfee825],\n    Spectral: [\n        0x9e0142,\n        0xd53e4f,\n        0xf46d43,\n        0xfdae61,\n        0xfee08b,\n        0xffffbf,\n        0xe6f598,\n        0xabdda4,\n        0x66c2a5,\n        0x3288bd,\n        0x5e4fa2,\n    ],\n    RdYlGn: [\n        0xa50026,\n        0xd73027,\n        0xf46d43,\n        0xfdae61,\n        0xfee08b,\n        0xffffbf,\n        0xd9ef8b,\n        0xa6d96a,\n        0x66bd63,\n        0x1a9850,\n        0x006837,\n    ],\n    RdBu: [\n        0x67001f,\n        0xb2182b,\n        0xd6604d,\n        0xf4a582,\n        0xfddbc7,\n        0xf7f7f7,\n        0xd1e5f0,\n        0x92c5de,\n        0x4393c3,\n        0x2166ac,\n        0x053061,\n    ],\n    PiYG: [\n        0x8e0152,\n        0xc51b7d,\n        0xde77ae,\n        0xf1b6da,\n        0xfde0ef,\n        0xf7f7f7,\n        0xe6f5d0,\n        0xb8e186,\n        0x7fbc41,\n        0x4d9221,\n        0x276419,\n    ],\n    PRGn: [\n        0x40004b,\n        0x762a83,\n        0x9970ab,\n        0xc2a5cf,\n        0xe7d4e8,\n        0xf7f7f7,\n        0xd9f0d3,\n        0xa6dba0,\n        0x5aae61,\n        0x1b7837,\n        0x00441b,\n    ],\n    RdYlBu: [\n        0xa50026,\n        0xd73027,\n        0xf46d43,\n        0xfdae61,\n        0xfee090,\n        0xffffbf,\n        0xe0f3f8,\n        0xabd9e9,\n        0x74add1,\n        0x4575b4,\n        0x313695,\n    ],\n    BrBG: [\n        0x543005,\n        0x8c510a,\n        0xbf812d,\n        0xdfc27d,\n        0xf6e8c3,\n        0xf5f5f5,\n        0xc7eae5,\n        0x80cdc1,\n        0x35978f,\n        0x01665e,\n        0x003c30,\n    ],\n    RdGy: [\n        0x67001f,\n        0xb2182b,\n        0xd6604d,\n        0xf4a582,\n        0xfddbc7,\n        0xffffff,\n        0xe0e0e0,\n        0xbababa,\n        0x878787,\n        0x4d4d4d,\n        0x1a1a1a,\n    ],\n    PuOr: [\n        0x7f3b08,\n        0xb35806,\n        0xe08214,\n        0xfdb863,\n        0xfee0b6,\n        0xf7f7f7,\n        0xd8daeb,\n        0xb2abd2,\n        0x8073ac,\n        0x542788,\n        0x2d004b,\n    ],\n    Set2: [0x66c2a5, 0xfc8d62, 0x8da0cb, 0xe78ac3, 0xa6d854, 0xffd92f, 0xe5c494, 0xb3b3b3],\n    Accent: [0x7fc97f, 0xbeaed4, 0xfdc086, 0xffff99, 0x386cb0, 0xf0027f, 0xbf5b17, 0x666666],\n    Set1: [0xe41a1c, 0x377eb8, 0x4daf4a, 0x984ea3, 0xff7f00, 0xffff33, 0xa65628, 0xf781bf, 0x999999],\n    Set3: [\n        0x8dd3c7,\n        0xffffb3,\n        0xbebada,\n        0xfb8072,\n        0x80b1d3,\n        0xfdb462,\n        0xb3de69,\n        0xfccde5,\n        0xd9d9d9,\n        0xbc80bd,\n        0xccebc5,\n        0xffed6f,\n    ],\n    Dark2: [0x1b9e77, 0xd95f02, 0x7570b3, 0xe7298a, 0x66a61e, 0xe6ab02, 0xa6761d, 0x666666],\n    Paired: [\n        0xa6cee3,\n        0x1f78b4,\n        0xb2df8a,\n        0x33a02c,\n        0xfb9a99,\n        0xe31a1c,\n        0xfdbf6f,\n        0xff7f00,\n        0xcab2d6,\n        0x6a3d9a,\n        0xffff99,\n        0xb15928,\n    ],\n    Pastel2: [0xb3e2cd, 0xfdcdac, 0xcbd5e8, 0xf4cae4, 0xe6f5c9, 0xfff2ae, 0xf1e2cc, 0xcccccc],\n    Pastel1: [0xfbb4ae, 0xb3cde3, 0xccebc5, 0xdecbe4, 0xfed9a6, 0xffffcc, 0xe5d8bd, 0xfddaec, 0xf2f2f2],\n};\n/**\n * X11 color names\n * http://www.w3.org/TR/css3-color/#svg-color\n *\n * @example chroma.Object.keys(w3cx11).slice(0, 4)\n */\nconst w3cx11 = {\n    aliceblue: 0xf0f8ff,\n    antiquewhite: 0xfaebd7,\n    aqua: 0x00ffff,\n    aquamarine: 0x7fffd4,\n    azure: 0xf0ffff,\n    beige: 0xf5f5dc,\n    bisque: 0xffe4c4,\n    black: 0x000000,\n    blanchedalmond: 0xffebcd,\n    blue: 0x0000ff,\n    blueviolet: 0x8a2be2,\n    brown: 0xa52a2a,\n    burlywood: 0xdeb887,\n    cadetblue: 0x5f9ea0,\n    chartreuse: 0x7fff00,\n    chocolate: 0xd2691e,\n    coral: 0xff7f50,\n    cornflower: 0x6495ed,\n    cornflowerblue: 0x6495ed,\n    cornsilk: 0xfff8dc,\n    crimson: 0xdc143c,\n    cyan: 0x00ffff,\n    darkblue: 0x00008b,\n    darkcyan: 0x008b8b,\n    darkgoldenrod: 0xb8860b,\n    darkgray: 0xa9a9a9,\n    darkgreen: 0x006400,\n    darkgrey: 0xa9a9a9,\n    darkkhaki: 0xbdb76b,\n    darkmagenta: 0x8b008b,\n    darkolivegreen: 0x556b2f,\n    darkorange: 0xff8c00,\n    darkorchid: 0x9932cc,\n    darkred: 0x8b0000,\n    darksalmon: 0xe9967a,\n    darkseagreen: 0x8fbc8f,\n    darkslateblue: 0x483d8b,\n    darkslategray: 0x2f4f4f,\n    darkslategrey: 0x2f4f4f,\n    darkturquoise: 0x00ced1,\n    darkviolet: 0x9400d3,\n    deeppink: 0xff1493,\n    deepskyblue: 0x00bfff,\n    dimgray: 0x696969,\n    dimgrey: 0x696969,\n    dodgerblue: 0x1e90ff,\n    firebrick: 0xb22222,\n    floralwhite: 0xfffaf0,\n    forestgreen: 0x228b22,\n    fuchsia: 0xff00ff,\n    gainsboro: 0xdcdcdc,\n    ghostwhite: 0xf8f8ff,\n    gold: 0xffd700,\n    goldenrod: 0xdaa520,\n    gray: 0x808080,\n    green: 0x008000,\n    greenyellow: 0xadff2f,\n    grey: 0x808080,\n    honeydew: 0xf0fff0,\n    hotpink: 0xff69b4,\n    indianred: 0xcd5c5c,\n    indigo: 0x4b0082,\n    ivory: 0xfffff0,\n    khaki: 0xf0e68c,\n    laserlemon: 0xffff54,\n    lavender: 0xe6e6fa,\n    lavenderblush: 0xfff0f5,\n    lawngreen: 0x7cfc00,\n    lemonchiffon: 0xfffacd,\n    lightblue: 0xadd8e6,\n    lightcoral: 0xf08080,\n    lightcyan: 0xe0ffff,\n    lightgoldenrod: 0xfafad2,\n    lightgoldenrodyellow: 0xfafad2,\n    lightgray: 0xd3d3d3,\n    lightgreen: 0x90ee90,\n    lightgrey: 0xd3d3d3,\n    lightpink: 0xffb6c1,\n    lightsalmon: 0xffa07a,\n    lightseagreen: 0x20b2aa,\n    lightskyblue: 0x87cefa,\n    lightslategray: 0x778899,\n    lightslategrey: 0x778899,\n    lightsteelblue: 0xb0c4de,\n    lightyellow: 0xffffe0,\n    lime: 0x00ff00,\n    limegreen: 0x32cd32,\n    linen: 0xfaf0e6,\n    magenta: 0xff00ff,\n    maroon: 0x800000,\n    maroon2: 0x7f0000,\n    maroon3: 0xb03060,\n    mediumaquamarine: 0x66cdaa,\n    mediumblue: 0x0000cd,\n    mediumorchid: 0xba55d3,\n    mediumpurple: 0x9370db,\n    mediumseagreen: 0x3cb371,\n    mediumslateblue: 0x7b68ee,\n    mediumspringgreen: 0x00fa9a,\n    mediumturquoise: 0x48d1cc,\n    mediumvioletred: 0xc71585,\n    midnightblue: 0x191970,\n    mintcream: 0xf5fffa,\n    mistyrose: 0xffe4e1,\n    moccasin: 0xffe4b5,\n    navajowhite: 0xffdead,\n    navy: 0x000080,\n    oldlace: 0xfdf5e6,\n    olive: 0x808000,\n    olivedrab: 0x6b8e23,\n    orange: 0xffa500,\n    orangered: 0xff4500,\n    orchid: 0xda70d6,\n    palegoldenrod: 0xeee8aa,\n    palegreen: 0x98fb98,\n    paleturquoise: 0xafeeee,\n    palevioletred: 0xdb7093,\n    papayawhip: 0xffefd5,\n    peachpuff: 0xffdab9,\n    peru: 0xcd853f,\n    pink: 0xffc0cb,\n    plum: 0xdda0dd,\n    powderblue: 0xb0e0e6,\n    purple: 0x800080,\n    purple2: 0x7f007f,\n    purple3: 0xa020f0,\n    rebeccapurple: 0x663399,\n    red: 0xff0000,\n    rosybrown: 0xbc8f8f,\n    royalblue: 0x4169e1,\n    saddlebrown: 0x8b4513,\n    salmon: 0xfa8072,\n    sandybrown: 0xf4a460,\n    seagreen: 0x2e8b57,\n    seashell: 0xfff5ee,\n    sienna: 0xa0522d,\n    silver: 0xc0c0c0,\n    skyblue: 0x87ceeb,\n    slateblue: 0x6a5acd,\n    slategray: 0x708090,\n    slategrey: 0x708090,\n    snow: 0xfffafa,\n    springgreen: 0x00ff7f,\n    steelblue: 0x4682b4,\n    tan: 0xd2b48c,\n    teal: 0x008080,\n    thistle: 0xd8bfd8,\n    tomato: 0xff6347,\n    turquoise: 0x40e0d0,\n    violet: 0xee82ee,\n    wheat: 0xf5deb3,\n    white: 0xffffff,\n    whitesmoke: 0xf5f5f5,\n    yellow: 0xffff00,\n    yellowgreen: 0x9acd32,\n};\n/**\n * Return a new [[CubeHelix]].\n *\n * @example chroma.cubehelix() // use the default helix\n * @example chroma.cubehelix().start(200).rotations(-0.5).gamma(0.8).lightness([0.3, 0.8])\n */\nfunction cubehelix(start = 300, rotations = -1.5, hue = 1, gamma = 1, lightness = [0, 1]) {\n    const f = ((t) => f.at(t));\n    Object.getOwnPropertyNames(CubeHelix.prototype).forEach((key) => (f[key] = CubeHelix.prototype[key]));\n    f.start(start);\n    f.rotations(rotations);\n    f.hue(hue);\n    f.gamma(gamma);\n    f.lightness(lightness);\n    return f;\n}\nclass CubeHelix {\n    start(s) {\n        if (undefined === s) {\n            return this._start;\n        }\n        this._start = s;\n        return this;\n    }\n    rotations(r) {\n        if (undefined === r) {\n            return this._rotations;\n        }\n        this._rotations = r;\n        return this;\n    }\n    gamma(g) {\n        if (undefined === g) {\n            return this._gamma;\n        }\n        this._gamma = g;\n        return this;\n    }\n    hue(h) {\n        if (undefined === h) {\n            return this._hue;\n        }\n        this._hue = Array.isArray(h) ? h : [h, h];\n        return this;\n    }\n    lightness(h) {\n        if (undefined === h) {\n            return this._lightness;\n        }\n        this._lightness = Array.isArray(h) ? h : [h, h];\n        return this;\n    }\n    /**\n     * Convert to a [[Scale]].\n     *\n     * @example chroma.cubehelix().scale().correctLightness().domain(2, 22)\n     */\n    scale() {\n        return scale(this);\n    }\n    at(fract) {\n        const a = TWOPI * ((this._start + 120) / 360 + this._rotations * fract);\n        const l = lerp(this._lightness[0], this._lightness[1], fract) ** this._gamma;\n        const h = lerp(this._hue[0], this._hue[1], fract);\n        const amp = (h * l * (1 - l)) / 2;\n        const cos_a = cos(a);\n        const sin_a = sin(a);\n        const r = l + amp * (-0.14861 * cos_a + 1.78277 * sin_a);\n        const g = l + amp * (-0.29227 * cos_a - 0.90649 * sin_a);\n        const b = l + amp * (+1.97294 * cos_a);\n        return rgb([r * 255, g * 255, b * 255, 1]);\n    }\n}\n/**\n * Create a new random [Color] from a random point in the RGB color space.\n * @param randomSource A function which returns random `number`s in the interval [0; 1). Useful if you want to\n *     create a deterministic sequence of "random" colors. Defaults to `Math.random`.\n */\nfunction random(randomSource = Math.random) {\n    return num((randomSource() * 16777216) | 0);\n}\n/**\n * Create a valid RGB color (`.clipped() == false`) from a random point in the CIELAB color space. This results in\n * more colors in the RGB color space where humans can perceive more differences.\n * @param randomSource A function which returns random `number`s in the interval [0; 1). Useful if you want to\n *     create a deterministic sequence of "random" colors. Defaults to `Math.random`.\n * @example chroma.random((() => { let i = 0; return () => (i = (i *Math.SQRT2) % 1); })())\n */\n// export function randomLab(randomSource = Math.random) {\n// \tconst labAMin = -87,\n// \t\tlabAMax = 99,\n// \t\tlabBMin = -108,\n// \t\tlabBMax = 95\n// \tlet maxIterations = 100\n// \twhile (maxIterations--) {\n// \t\tconst u = randomSource(),\n// \t\t\tv = randomSource(),\n// \t\t\tw = randomSource()\n// \t\t// The following matrix multiplication transform the random point (u v w) in the unit cube into the\n// \t\t// oriented bounding box (OBB) of the projection of the RGB space into the LAB space. This is necessary to\n// \t\t// avoid a huge number of misses.\n// \t\tconst color = lab(\n// \t\t\tu * -53.903 + v * -88.755 + w * 71.7 + 99.707,\n// \t\t\tu * -82.784 + v * 187.036 + w * -2.422 + -28.17,\n// \t\t\tu * -75.813 + v * -141.406 + w * -48.261 + 152.469,\n// \t\t)\n// \t\tconsole.log(color.lab())\n// \t\tconsole.log(color.rgba(false, false))\n// \t\tif (!color.clipped()) return color\n// \t}\n// \tthrow new Error("Could find a random color in 100 iterations")\n// }\n/**\n * Mixes two colors. The mix ratio is a value between 0 and 1.\n * The color mixing produces different results based the color space used for interpolation.\n *\n * @param col2\n * @param f\n * @param m\n * @example chroma.mix(\'red\', \'blue\')\n * @example chroma.mix(\'red\', \'blue\', 0.25)\n * @example chroma.mix(\'red\', \'blue\', 0.75)\n *\n * @example chroma.mix(\'red\', \'blue\', 0.5, \'rgb\')\n * @example chroma.mix(\'red\', \'blue\', 0.5, \'hsl\')\n * @example chroma.mix(\'red\', \'blue\', 0.5, \'lab\')\n * @example chroma.mix(\'red\', \'blue\', 0.5, \'lch\')\n * @example chroma.mix(\'red\', \'blue\', 0.5, \'lrgb\')\n */\nfunction mix(col1, col2, f = 0.5, m = "rgb") {\n    const c1 = color(col1);\n    const c2 = color(col2);\n    const res = interpolators[m] && interpolators[m](c1, c2, f, m);\n    if (!res) {\n        throw new Error("color mode " + m + " is not supported");\n    }\n    return res.alpha(lerp(c1.alpha(), c2.alpha(), f));\n}\n/**\n * Parse a CSS color. See [MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/color) for all the possible\n * variants.\n *\n * @example chroma.css(\'hsl(2rad 90% 50% / 0.9)\')\n * @example chroma.css(\'laserlemon\')\n */\nfunction css(cssString) {\n    const [r, g, b, a] = css2rgb(cssString);\n    return new Color(r, g, b, a);\n}\nfunction cmyk(...args) {\n    return guess(args, "cmyk");\n}\nfunction gl(...args) {\n    return guess(args, "gl");\n}\nfunction hcg(...args) {\n    return guess(args, "hcg");\n}\nfunction lch(...args) {\n    return guess(args, "lch");\n}\nfunction hsi(...args) {\n    return guess(args, "hsi");\n}\nfunction hsl(...args) {\n    return guess(args, "hsl");\n}\nfunction hsv(...args) {\n    return guess(args, "hsv");\n}\n/**\n *\n * @param temperature\n * @example chroma.kelvin(2000) // candle light\n * @example chroma.kelvin(3500) // sunset\n * @example chroma.kelvin(6500) // daylight\n * @example x0_1 => chroma.kelvin(x0_1 * 30000) // effective range: [0; 30000]\n */\nfunction kelvin(temperature) {\n    const [r, g, b] = kelvin2rgb(temperature);\n    return new Color(r, g, b);\n}\nfunction lab(...args) {\n    return guess(args, "lab");\n}\n/**\n * @example chroma.num(0x663399) // rebeccapurple\n */\nfunction num(num) {\n    const [r, g, b] = num2rgb(num);\n    return new Color(r, g, b);\n}\nfunction rgb(...args) {\n    return guess(args, "rgb");\n}\nfunction xyz(...args) {\n    return guess(args, "xyz");\n}\n/**\n * Similar to mix, but accepts more than two colors.\n *\n * @example colors = [\'#ddd\', \'yellow\', \'red\', \'teal\']\n * @example chroma.average(colors) // default = \'rgb\'\n * @example chroma.average(colors, \'lab\')\n * @example chroma.average(colors, \'lch\')\n * @example chroma.average(colors, \'lrgb\')\n * @example chroma.average([\'red\', \'rgba(0,0,0,0.5)\']).css()\n */\nfunction average(chromables, mode = "rgb") {\n    const colors = chromables.map((c) => color(c));\n    if (mode == "lrgb") {\n        return _average_lrgb(colors);\n    }\n    if (mode == "num") {\n        let numSum = 0, alphaSum = 0;\n        for (const col of colors) {\n            numSum += col.num();\n            alphaSum += col.alpha();\n        }\n        return num(numSum / colors.length).alpha(alphaSum / colors.length);\n    }\n    const xyz = [0, 0, 0];\n    let dx = 0;\n    let dy = 0;\n    let alphaSum = 0;\n    for (const c of colors) {\n        const xyz2 = c[mode]();\n        alphaSum += c.alpha();\n        for (let i = 0; i < xyz.length; i++) {\n            if (mode.charAt(i) == "h") {\n                const A = xyz2[i] * DEG2RAD;\n                dx += cos(A);\n                dy += sin(A);\n            }\n            else {\n                xyz[i] += xyz2[i];\n            }\n        }\n    }\n    for (let i = 0; i < xyz.length; i++) {\n        if (mode.charAt(i) == "h") {\n            const A = atan2(dy / colors.length, dx / colors.length) * RAD2DEG;\n            xyz[i] = (A + 360) % 360;\n        }\n        else {\n            xyz[i] = xyz[i] / colors.length;\n        }\n    }\n    return guess(xyz, mode).alpha(alphaSum / colors.length);\n}\nfunction bezier(...args) {\n    const chromables = Array.isArray(args[0]) ? args[0] : args;\n    const f = _bezier(chromables);\n    f.scale = CubeHelix.prototype.scale;\n    return f;\n}\n/**\n * Blends two colors using RGB channel-wise blend functions.\n * @param bottom\n * @param top\n * @param mode\n * @example chroma.blend(\'4CBBFC\', \'EEEE22\', \'multiply\')\n * @example chroma.blend(\'4CBBFC\', \'EEEE22\', \'darken\')\n * @example chroma.blend(\'4CBBFC\', \'EEEE22\', \'lighten\')\n */\nfunction blend(bottom, top, mode) {\n    if (!blend_fs[mode]) {\n        throw new Error("unknown blend mode " + mode);\n    }\n    return blend_fs[mode](bottom, top);\n}\nconst blend_fs = {\n    normal: blend_f(each((a, _) => a)),\n    multiply: blend_f(each((a, b) => (a * b) / 255)),\n    screen: blend_f(each(_screen)),\n    overlay: blend_f(each(_overlay)),\n    darken: blend_f(each(min)),\n    lighten: blend_f(each(max)),\n    dodge: blend_f(each(_dodge)),\n    burn: blend_f(each(_burn)),\n};\nfunction scale(...args) {\n    const f = ((t) => f._at(t));\n    Object.getOwnPropertyNames(Scale.prototype).forEach((key) => (f[key] = Scale.prototype[key]));\n    if (Array.isArray(args[0]))\n        args = args[0];\n    if (args.length == 1 && "string" == typeof args[0])\n        args = brewer[args[0]];\n    f._init("function" == typeof args[0] ? args[0] : args.map((a) => color(a)));\n    //f.setColors(args.length > 1 ? args : args[0])\n    return f;\n}\nclass Scale {\n    classes(classes) {\n        if (undefined === classes) {\n            return this._classes;\n        }\n        if (Array.isArray(classes)) {\n            this._classes = classes;\n            this.domain(classes[0], classes[classes.length - 1]);\n        }\n        else {\n            if (classes % 1 != 0 || classes < 1)\n                throw new Error("invalid classes param");\n            // const d = analyze(this.domain())\n            this._classes = limits(this.domain(), "e", classes);\n        }\n        return this;\n    }\n    domain(...domain) {\n        if (undefined === domain[0]) {\n            return "function" !== typeof this._colors\n                ? this._pos.map((p) => lerp(this._min, this._max, p))\n                : [this._min, this._max];\n        }\n        this._min = domain[0];\n        this._max = domain[domain.length - 1];\n        if (2 == domain.length) {\n            if ("function" !== typeof this._colors) {\n                // equidistant positions\n                this._pos = this._colors.map((_, c) => c / (this._colors.length - 1));\n            }\n        }\n        else if ("function" !== typeof this._colors && domain.length == this._colors.length) {\n            this._pos = domain.map((d) => lerpInv(this._min, this._max, d));\n        }\n        else {\n            throw new Error("invalid domain " + domain);\n        }\n        return this;\n    }\n    mode(mode) {\n        if (undefined === mode) {\n            return this._mode;\n        }\n        this._mode = mode;\n        this._resetCache();\n        return this;\n    }\n    /**\n     * Set the output format return by `this(x)` and `this.colors(n)`.\n     * @param outputFormat The color format to use. Pass `undefined` to return [Color] objects.\n     * @return `this`\n     * @example chroma.scale("red", "white").out("hex")(0) // == "#ff0000"\n     * @example chroma.scale("red", "white").out("num").colors(2) // == [0xff0000, 0xffffff]\n     */\n    out(outputFormat) {\n        this._out = outputFormat;\n        return this;\n    }\n    /**\n     * This makes sure the lightness range is spread evenly across a color scale. Especially useful when working\n     * with [multi-hue color scales](https://www.vis4.net/blog/2013/09/mastering-multi-hued-color-scales/), where\n     * simple gamma correction can\'t help you very much.\n     *\n     * @example chroma.scale(\'black\',\'red\',\'yellow\',\'white\')\n     * @example chroma.scale(\'black\',\'red\',\'yellow\',\'white\').correctLightness()\n     */\n    correctLightness(enableCorrectLightness = true) {\n        if (this._correctLightness != enableCorrectLightness) {\n            this._resetCache();\n            const colors = this._colors;\n            if (enableCorrectLightness && "function" !== typeof colors) {\n                // make sure that the colors have ascending or descending lightnesses\n                let sign = 0;\n                for (let i = 1; i < colors.length; i++) {\n                    const sign2 = colors[i].lab()[0] - colors[i - 1].lab()[0];\n                    if (0 == sign) {\n                        sign = sign2;\n                    }\n                    else if (sign * sign2 < 0) {\n                        throw new Error("scale color lightnesses must be monotonic");\n                    }\n                }\n            }\n        }\n        this._correctLightness = enableCorrectLightness;\n        return this;\n    }\n    padding(paddingLeft, paddingRight = paddingLeft) {\n        if (!paddingLeft) {\n            return [this._paddingLeft, this._paddingRight];\n        }\n        this._paddingLeft = paddingLeft;\n        this._paddingRight = paddingRight;\n        return this;\n    }\n    /**\n     * Get a number of equidistant colors.\n     * @param numColors The number of colors to return.\n     * @param format Output format. Defaults to `"hex"`. Pass `"color"` to get {@link Color} objects.\n     * @returns If `numColors` is `undefined`, the colors which define this [Scale]. If `numColors` is 1,\n     * `[this((min + max) / 2)]`. Otherwise, an array where the first element is `this(min)`, the last one is\n     * `this(max)` and the rest are equidistant samples between min and max.\n     * @example chroma.scale(\'OrRd\').colors(5)\n     * @example chroma.scale([\'white\', \'black\']).colors(12)\n     */\n    colors(numColors, format = "hex") {\n        let result;\n        if (undefined === numColors) {\n            result = this._colors.slice();\n        }\n        else if (numColors == 1) {\n            result = [this._color((this._min + this._max) / 2)];\n        }\n        else if (numColors > 1) {\n            result = Array.from({ length: numColors }, (_, i) => this._color(lerp(this._min, this._max, i / (numColors - 1))));\n        }\n        else {\n            // returns all colors based on the defined classes\n            let samples;\n            if (this._classes && this._classes.length > 2) {\n                samples = Array.from({ length: this._classes.length - 1 }, (_, i) => (this._classes[i] + this._classes[i + 1]) * 0.5);\n            }\n            else {\n                samples = this.domain(); // TODO?!\n            }\n            result = samples.map((s) => this._color(s));\n        }\n        return (format != "color" ? result.map((c) => c[format]()) : result);\n    }\n    cache(enableCache) {\n        if (undefined === enableCache) {\n            return !!this._cache;\n        }\n        this._cache = enableCache ? this._cache || new Map() : undefined;\n        return this;\n    }\n    gamma(gamma) {\n        if (undefined === gamma) {\n            return this._gamma;\n        }\n        this._gamma = gamma;\n        return this;\n    }\n    /**\n     * @ignore\n     */\n    _at(t) {\n        const c = this._color(t);\n        return this._out ? c[this._out]() : c;\n    }\n    /**\n     * @ignore\n     */\n    _init(colorsOrFunction) {\n        this._colors = colorsOrFunction;\n        if ("function" != typeof colorsOrFunction) {\n            this._pos = colorsOrFunction.map((_, i) => i / (colorsOrFunction.length - 1));\n        }\n        this._mode = "rgb";\n        this.domain(0, 1);\n        this._paddingLeft = 0;\n        this._paddingRight = 0;\n        this._correctLightness = false;\n        this._cache = new Map();\n        this._gamma = 1;\n    }\n    _getClass(value) {\n        return this._classes.findIndex((cls) => value <= cls) - 1;\n    }\n    _color(val, bypassMap = false) {\n        let t;\n        if (!bypassMap) {\n            const min = this._min, max = this._max;\n            if (this._classes && this._classes.length > 2) {\n                const c = this._getClass(val);\n                t = c / (this._classes.length - 2);\n            }\n            else if (max !== min) {\n                t = (val - min) / (max - min);\n            }\n            else {\n                t = 1;\n            }\n            if (this._correctLightness) {\n                t = this._tCorrectedLightness(t);\n            }\n        }\n        else {\n            t = val;\n        }\n        t = t ** this._gamma;\n        t = (this._paddingLeft + t) / (1 + this._paddingLeft + this._paddingRight);\n        //\tt = this._paddingLeft + t * (1 - this._paddingLeft - this._paddingRight)\n        t = clamp(t, 0, 1);\n        const tHash = t;\n        const cacheResult = this._cache && this._cache.get(tHash);\n        if (cacheResult) {\n            return cacheResult;\n        }\n        else {\n            let col;\n            if (Array.isArray(this._colors)) {\n                for (let i = 0; i < this._pos.length; i++) {\n                    const p = this._pos[i];\n                    if (t <= p) {\n                        col = this._colors[i];\n                        break;\n                    }\n                    if (t >= p && i == this._pos.length - 1) {\n                        col = this._colors[i];\n                        break;\n                    }\n                    if (t > p && t < this._pos[i + 1]) {\n                        t = (t - p) / (this._pos[i + 1] - p);\n                        col = mix(this._colors[i], this._colors[i + 1], t, this._mode);\n                        break;\n                    }\n                }\n            }\n            else {\n                col = this._colors(t);\n            }\n            if (this._cache) {\n                // tslint:disable-next-line\n                this._cache.set(tHash, col);\n            }\n            // tslint:disable-next-line\n            return col;\n        }\n    }\n    _tCorrectedLightness(t0_1) {\n        const L0 = this._color(0, true).lab()[0];\n        const L1 = this._color(1, true).lab()[0];\n        const L_ideal = lerp(L0, L1, t0_1);\n        return bisect((t) => this._color(t, true).lab()[0] - L_ideal, 0, 1, 8);\n    }\n    _resetCache() {\n        if (this._cache)\n            this._cache.clear();\n    }\n}\nvar scales;\n(function (scales) {\n    /**\n     * @example chroma.scales.cool()\n     */\n    function cool() {\n        return scale([hsl(180, 1, 0.9), hsl(250, 0.7, 0.4)]);\n    }\n    scales.cool = cool;\n    /**\n     * @example chroma.scales.hot()\n     */\n    function hot() {\n        return scale(["#000", "#f00", "#ff0", "#fff"]).mode("rgb");\n    }\n    scales.hot = hot;\n})(scales || (scales = {}));\n/**\n * Computes the WCAG contrast ratio between two colors. A minimum contrast of 4.5:1\n * [is recommended](http://www.w3.org/TR/WCAG20-TECHS/G18.html) to ensure that text is still readable against a\n * background color.\n *\n * @param a\n * @param b\n */\nfunction contrast(a, b) {\n    const l1 = color(a).luminance();\n    const l2 = color(b).luminance();\n    if (l1 > l2) {\n        return (l1 + 0.05) / (l2 + 0.05);\n    }\n    else {\n        return (l2 + 0.05) / (l1 + 0.05);\n    }\n}\n/**\n * Compute the [euclidean distance](https://en.wikipedia.org/wiki/Euclidean_distance#Three_dimensions) between two\n * colors in a given color space.\n * @param a First color.\n * @param b Second color.\n * @param mode The color space in which to compute the distance. Defaults to "lab".\n * @example chroma.distance(\'#fff\', \'#ff0\', \'rgb\')\n * @example chroma.distance(\'#fff\', \'#f0f\', \'rgb\')\n * @example chroma.distance(\'#fff\', \'#ff0\')\n * @example chroma.distance(\'#fff\', \'#f0f\')\n */\nfunction distance(a, b, mode = "lab") {\n    const l1 = color(a)[mode]();\n    const l2 = color(b)[mode]();\n    const channelDifferences = l1.map((channelValue, channelIndex) => channelValue - l2[channelIndex]);\n    return hypot(...channelDifferences);\n}\n/**\n * Computes color difference as developed by the Colour Measurement Committee of the Society of Dyers and Colourists\n * (CMC) in 1984. The implementation is adapted from Bruce Lindbloom. The parameters L and C are weighting factors\n * for lightness and chromaticity.\n * @param reference\n * @param sample\n * @param L\n * @param C\n * @example [r = \'#ededee\', s = \'#edeeed\', chroma.deltaE(r, s)]\n * @example [r = \'#ececee\', s = \'#eceeec\', chroma.deltaE(r, s)]\n * @example [r = \'#e9e9ee\', s = \'#e9eee9\', chroma.deltaE(r, s)]\n * @example [r = \'#e4e4ee\', s = \'#e4eee4\', chroma.deltaE(r, s)]\n * @example [r = \'#e0e0ee\', s = \'#e0eee0\', chroma.deltaE(r, s)]\n */\nfunction deltaE(reference, sample, L = 1, C = 1) {\n    const [L1, a1, b1] = color(reference).lab();\n    const [L2, a2, b2] = color(sample).lab();\n    const c1 = sqrt(a1 * a1 + b1 * b1);\n    const c2 = sqrt(a2 * a2 + b2 * b2);\n    const sl = L1 < 16.0 ? 0.511 : (0.040975 * L1) / (1.0 + 0.01765 * L1);\n    const sc = (0.0638 * c1) / (1.0 + 0.0131 * c1) + 0.638;\n    const h1 = norm360(c1 < 0.000001 ? 0.0 : atan2(b1, a1) * RAD2DEG);\n    const t = h1 >= 164.0 && h1 <= 345.0\n        ? 0.56 + abs(0.2 * cos((h1 + 168.0) * DEG2RAD))\n        : 0.36 + abs(0.4 * cos((h1 + 35.0) * DEG2RAD));\n    const c4 = c1 * c1 * c1 * c1;\n    const f = sqrt(c4 / (c4 + 1900.0));\n    const sh = sc * (f * t + 1.0 - f);\n    const delL = L1 - L2;\n    const delC = c1 - c2;\n    const delA = a1 - a2;\n    const delB = b1 - b2;\n    const dH2 = delA * delA + delB * delB - delC * delC;\n    const v1 = delL / (L * sl);\n    const v2 = delC / (C * sc);\n    const v3 = sh;\n    return sqrt(v1 * v1 + v2 * v2 + dH2 / (v3 * v3));\n}\nfunction analyze(data) {\n    const r = {\n        min: Infinity,\n        max: -Infinity,\n        sum: 0,\n        values: [],\n        count: 0,\n    };\n    function add(val) {\n        if (val != undefined && !isNaN(val)) {\n            r.values.push(val);\n            r.sum += val;\n            if (val < r.min)\n                r.min = val;\n            if (val > r.max)\n                r.max = val;\n            r.count += 1;\n        }\n    }\n    data.forEach((val) => add(val));\n    r.domain = [r.min, r.max];\n    r.limits = function (mode, num) {\n        return limits(this, mode, num);\n    };\n    return r;\n}\nfunction limits(data, mode = "e", num = 7) {\n    const info = Array.isArray(data) ? analyze(data) : data;\n    const { min, max, values } = info;\n    values.sort((a, b) => a - b);\n    if (num == 1) {\n        return [min, max];\n    }\n    if (mode.startsWith("c")) {\n        return [min, max];\n    }\n    else if (mode.startsWith("e")) {\n        return Array.from({ length: num + 1 }, (_, i) => lerp(min, max, i / num));\n    }\n    else if (mode.startsWith("l")) {\n        if (min <= 0) {\n            throw new Error("Logarithmic scales are only possible for values > 0");\n        }\n        const min_log = Math.LOG10E * log(min);\n        const max_log = Math.LOG10E * log(max);\n        return Array.from({ length: num + 1 }, (_, i) => 10 ** lerp(min_log, max_log, i / num));\n    }\n    else if (mode.startsWith("q")) {\n        return Array.from({ length: num + 1 }, (_, i) => {\n            const p = ((values.length - 1) * i) / num;\n            const pb = floor(p);\n            return pb == p ? values[pb] : lerp(values[pb], values[pb + 1], p - pb);\n        });\n    }\n    else if (mode.startsWith("k")) {\n        // implementation based on\n        // http://code.google.com/p/figue/source/browse/trunk/figue.js#336\n        // simplified for 1-d input values\n        const n = values.length;\n        const assignments = new Array(n);\n        const clusterSizes = new Array(num);\n        let repeat = true;\n        let nb_iters = 0;\n        let centroids = Array.from({ length: num + 1 }, (_, i) => lerp(min, max, i / num));\n        do {\n            // assignment step\n            clusterSizes.fill(0);\n            for (let i = 0; i < values.length; i++) {\n                const value = values[i];\n                const minDistIndex = indexOfMax(centroids, (c) => -abs(c - value));\n                clusterSizes[minDistIndex]++;\n                assignments[i] = minDistIndex;\n            }\n            // update centroids step\n            const newCentroids = new Array(num).fill(0);\n            for (let i = 0; i < assignments.length; i++) {\n                const cluster = assignments[i];\n                newCentroids[cluster] += values[i];\n            }\n            for (let j = 0; j < newCentroids.length; j++) {\n                newCentroids[j] /= clusterSizes[j];\n            }\n            // check convergence\n            repeat = newCentroids.some((nc, j) => nc != centroids[j]);\n            centroids = newCentroids;\n        } while (nb_iters++ < 200 && repeat);\n        // finished k-means clustering\n        // the next part is borrowed from gabrielflor.it\n        const kClusters = Array.from({ length: num }, () => []);\n        for (let i = 0; i < assignments.length; i++) {\n            const cluster = assignments[i];\n            kClusters[cluster].push(values[i]);\n        }\n        const tmpKMeansBreaks = [];\n        for (const kCluster of kClusters) {\n            tmpKMeansBreaks.push(kCluster[0], kCluster[kCluster.length - 1]);\n        }\n        tmpKMeansBreaks.sort((a, b) => a - b);\n        const limits = [];\n        limits.push(tmpKMeansBreaks[0]);\n        for (let i = 1; i < tmpKMeansBreaks.length; i += 2) {\n            const v = tmpKMeansBreaks[i];\n            if (!isNaN(v) && limits.indexOf(v) == -1) {\n                limits.push(v);\n            }\n        }\n        return limits;\n    }\n    else {\n        throw new Error("unknown mode");\n    }\n}\nconst interpolators = {};\n// const _guess_formats: { p: number; test: (args: any[]) => ColorFormat | undefined }[] = []\nconst _input = {};\nfunction linear_interpolator(col1, col2, f, m) {\n    const xyz1 = col1[m]();\n    const xyz2 = col2[m]();\n    return guess([\n        lerp(xyz1[0], xyz2[0], f),\n        lerp(xyz1[1], xyz2[1], f),\n        lerp(xyz1[2], xyz2[2], f),\n        lerp(col1.alpha(), col2.alpha(), f),\n    ], m);\n}\ninterpolators.xyz = interpolators.rgb = interpolators.lab = linear_interpolator;\ninterpolators.num = function (col1, col2, f) {\n    const n1 = col1.num();\n    const n2 = col2.num();\n    return num(lerp(n1, n2, f));\n};\ninterpolators.lrgb = function (col1, col2, f) {\n    const [r1, g1, b1, a1] = col1.rgba(false, false);\n    const [r2, g2, b2, a2] = col2.rgba(false, false);\n    return new Color(sqrt(r1 ** 2 * (1 - f) + r2 ** 2 * f), sqrt(g1 ** 2 * (1 - f) + g2 ** 2 * f), sqrt(b1 ** 2 * (1 - f) + b2 ** 2 * f), lerp(a1, a2, f));\n};\nfunction _bezier(chromables) {\n    const colors = chromables.map((c) => color(c));\n    const [lab0, lab1, lab2, lab3] = colors.map((c) => c.lab());\n    if (2 == chromables.length) {\n        // linear interpolation\n        return (t) => {\n            return lab([0, 1, 2].map((i) => lerp(lab0[i], lab1[i], t)));\n        };\n    }\n    else if (3 == chromables.length) {\n        // quadratic bezier interpolation\n        const bezier2 = (p0, p1, p2, t) => (1 - t) ** 2 * p0 + 2 * (1 - t) * t * p1 + t ** 2 * p2;\n        return (t) => lab([0, 1, 2].map((i) => bezier2(lab0[i], lab1[i], lab2[i], t)));\n    }\n    else if (4 == chromables.length) {\n        // cubic bezier interpolation\n        const bezier3 = (p0, p1, p2, p3, t) => (1 - t) ** 3 * p0 + 3 * (1 - t) ** 2 * t * p1 + 3 * (1 - t) * t ** 2 * p2 + t ** 3 * p3;\n        return (t) => lab([0, 1, 2].map((i) => bezier3(lab0[i], lab1[i], lab2[i], lab3[i], t)));\n    }\n    else if (5 == chromables.length) {\n        const I0 = _bezier(colors.slice(0, 3));\n        const I1 = _bezier(colors.slice(2, 5));\n        return (t) => (t < 0.5 ? I0(t * 2) : I1((t - 0.5) * 2));\n    }\n    else\n        throw new Error();\n}\nfunction guess(args, mode) {\n    if (Array.isArray(args[0]))\n        args = args[0];\n    if (!mode) {\n        if (args.length == 1 && args[0] in w3cx11) {\n            mode = "name";\n        }\n        else if (args.length == 1 && "string" == typeof args[0]) {\n            mode = "css";\n        }\n        else if (args.length == 3) {\n            mode = "rgb";\n        }\n        else if (args.length == 4 && "number" == typeof args[3] && args[3] >= 0 && args[3] <= 1) {\n            mode = "rgb";\n        }\n        else if (args.length == 1 && "number" == typeof args[0] && args[0] >= 0 && args[0] <= 0xffffff) {\n            mode = "num";\n        }\n        else\n            throw new Error("could not guess mode. args " + JSON.stringify(args));\n    }\n    const channels = _input[mode](...args);\n    return new Color(channels[0], channels[1], channels[2], undefined !== channels[3] ? channels[3] : 1);\n}\nfunction _average_lrgb(colors) {\n    let rSquareSum = 0, gSquareSum = 0, bSquareSum = 0, alphaSum = 0;\n    for (const col of colors) {\n        const [r, g, b, alpha] = col.rgba(false, false);\n        rSquareSum += r ** 2;\n        gSquareSum += g ** 2;\n        bSquareSum += b ** 2;\n        alphaSum += alpha;\n    }\n    return new Color(sqrt(rSquareSum) / colors.length, sqrt(gSquareSum) / colors.length, sqrt(bSquareSum) / colors.length, alphaSum / colors.length);\n}\nfunction hex2rgb(hex) {\n    let m;\n    if ((m = hex.match(/^#?([A-F\\d]{2})([A-F\\d]{2})([A-F\\d]{2})([A-F\\d]{2})?$/i))) {\n        return [parseInt(m[1], 16), parseInt(m[2], 16), parseInt(m[3], 16), m[4] ? parseInt(m[4], 16) / 255 : 1];\n    }\n    else if ((m = hex.match(/^#?([A-F\\d])([A-F\\d])([A-F\\d])([A-F\\d])?$/i))) {\n        return [\n            parseInt(m[1], 16) * 0x11,\n            parseInt(m[2], 16) * 0x11,\n            parseInt(m[3], 16) * 0x11,\n            m[4] ? (parseInt(m[4], 16) * 0x11) / 255 : 1,\n        ];\n    }\n    throw new Error("invalid hex color: " + hex);\n}\n// interface ColorModes {\n// \tcmyk: CMYK\n// \tgl: GL\n// \trgb: RGB\n// \trgba: RGBA\n// \tlab: LAB\n// \thsl: HSL\n// \thsv: HSV\n// \thsi: HSI\n// \txyz: XYZ\n// \thcg: HCG\n// \tlch: LCH\n// \thex: string\n// \tnum: number\n// \tname: string\n// \tkelvin: number\n// \tcss: string\n// }\nfunction rgb2hex(r255, g255, b255, a1, mode = "rgb") {\n    r255 = clamp(round(r255), 0, 255);\n    g255 = clamp(round(g255), 0, 255);\n    b255 = clamp(round(b255), 0, 255);\n    const rgb = (r255 << 16) | (g255 << 8) | b255;\n    const rgbString = rgb.toString(16).padStart(6, "0");\n    const alphaString = round(clamp(a1) * 255)\n        .toString(16)\n        .padStart(2, "0");\n    return "#" + ("argb" == mode ? alphaString + rgbString : "rgba" == mode ? rgbString + alphaString : rgbString);\n}\n_input.lrgb = _input.rgb;\n_input.hex = hex2rgb;\n_input.hsl = hsl2rgb;\nfunction norm360(degrees) {\n    return ((degrees % 360) + 360) % 360;\n}\n_input.hsv = hsv2rgb;\nfunction num2rgb(num) {\n    if (!("number" == typeof num && num >= 0 && num <= 0xffffff)) {\n        throw new Error("unknown num color: " + num);\n    }\n    const r = num >> 16;\n    const g = (num >> 8) & 0xff;\n    const b = num & 0xff;\n    return [r, g, b, 1];\n}\nfunction rgb2num(r255, g255, b255, a1 = 1, mode = "rgb") {\n    const rgbNum = (round(r255) << 16) | (round(g255) << 8) | round(b255);\n    if ("rgb" === mode) {\n        return rgbNum;\n    }\n    else if ("rgba" === mode) {\n        return (rgbNum << 8) | (round(a1 * 255) << 24);\n    }\n    else {\n        return (round(a1 * 255) << 24) | rgbNum;\n    }\n}\n_input.num = num2rgb;\nconst WS = "\\\\s*";\nconst FLOAT = "([+-]?(?:\\\\d*\\\\.?)?\\\\d+(?:[eE][+-]?\\\\d+)?)";\nconst CSS_RGB_REGEX = new RegExp(["^rgba?\\\\(", FLOAT, ",", FLOAT, ",", FLOAT, "(?:,", FLOAT + "(%)?", ")?\\\\)$"].join(WS), "i");\nconst CSS_RGB_WS_REGEX = new RegExp(["^rgba?\\\\(", FLOAT, FLOAT, FLOAT, "(?:/", FLOAT + "(%)?", ")?\\\\)$"].join(WS), "i");\nconst CSS_RGB_PERCENT_REGEX = new RegExp(["^rgba?\\\\(", FLOAT + "%", ",", FLOAT + "%", ",", FLOAT + "%", "(?:,", FLOAT + "(%)?", ")?\\\\)$"].join(WS), "i");\nconst CSS_RGB_WS_PERCENT_REGEX = new RegExp(["^rgba?\\\\(", FLOAT + "%", FLOAT + "%", FLOAT + "%", "(?:/", FLOAT + "(%)?", ")?\\\\)$"].join(WS), "i");\nconst CSS_HSL_REGEX = new RegExp(["^hsla?\\\\(", FLOAT + "(deg|rad|turn)?", ",", FLOAT + "%", ",", FLOAT + "%", "(?:,", FLOAT + "(%)?", ")?\\\\)$"].join(WS), "i");\nconst CSS_HSL_WS_REGEX = new RegExp(["^hsla?\\\\(", FLOAT + "(deg|rad|turn)?\\\\s+" + FLOAT + "%", FLOAT + "%", "(?:/", FLOAT + "(%)?", ")?\\\\)$"].join(WS), "i");\nfunction css2rgb(css) {\n    if (w3cx11 && w3cx11.hasOwnProperty(css)) {\n        return num2rgb(w3cx11[css.toLowerCase()]);\n    }\n    let m;\n    if ((m = css.match(CSS_RGB_REGEX) || css.match(CSS_RGB_WS_REGEX))) {\n        return [\n            clamp(+m[1], 0, 255),\n            clamp(+m[2], 0, 255),\n            clamp(+m[3], 0, 255),\n            m[4] ? clamp(m[5] ? +m[4] / 100 : +m[4]) : 1,\n        ];\n    }\n    else if ((m = css.match(CSS_RGB_PERCENT_REGEX) || css.match(CSS_RGB_WS_PERCENT_REGEX))) {\n        return [\n            clamp(+m[1] / 100) * 255,\n            clamp(+m[2] / 100) * 255,\n            clamp(+m[3] / 100) * 255,\n            m[4] ? clamp(m[5] ? +m[4] / 100 : +m[4]) : 1,\n        ];\n    }\n    else if ((m = css.match(CSS_HSL_REGEX) || css.match(CSS_HSL_WS_REGEX))) {\n        const CONVERSION = { deg: 1, rad: RAD2DEG, turn: 360 };\n        const angleUnit = (m[2] ? m[2].toLowerCase() : "deg");\n        return hsl2rgb((((+m[1] * CONVERSION[angleUnit]) % 360) + 360) % 360, clamp(+m[3] / 100), clamp(+m[4] / 100), m[5] ? clamp(m[6] ? +m[5] / 100 : +m[5]) : 1);\n    }\n    else {\n        return hex2rgb(css);\n    }\n}\nfunction rgb2css(r, g, b, a = 1) {\n    if (a >= 1) {\n        return "rgb(" + [r, g, b].map(round).join(",") + ")";\n    }\n    else {\n        return "rgba(" + [r, g, b].map(round).join(",") + "," + a + ")";\n    }\n}\nfunction rnd(a) {\n    return round(a * 100) / 100;\n}\nfunction hsl2css([h, s, l], alpha) {\n    const mode = alpha < 1 ? "hsla" : "hsl";\n    return (mode +\n        "(" +\n        rnd(h) +\n        "," +\n        rnd(s * 100) +\n        "%" +\n        "," +\n        rnd(l * 100) +\n        "%" +\n        ("hsla" == mode ? "," + rnd(alpha) : "") +\n        ")");\n}\n_input.css = css2rgb;\n_input.name = function (name) {\n    return num2rgb(w3cx11[name]);\n};\nfunction lch2lab(l, c, hueDegrees) {\n    /*\n    Convert from a qualitative parameter h and a quantitative parameter l to a 24-bit pixel.\n    These formulas were invented by David Dalrymple to obtain maximum contrast without going\n    out of gamut if the parameters are in the range 0-1.\n\n    A saturation multiplier was added by Gregor Aisch\n     */\n    return [l, cos(hueDegrees * DEG2RAD) * c, sin(hueDegrees * DEG2RAD) * c];\n}\nfunction lch2rgb(l, c, hDegrees, alpha1 = 1) {\n    const [, a, b] = lch2lab(l, c, hDegrees);\n    return cielab2rgb(l, a, b, alpha1);\n}\nfunction lab2lch(l, a, b) {\n    const c = hypot(a, b);\n    const h = (atan2(b, a) * RAD2DEG + 360) % 360;\n    return [l, c, h];\n}\nfunction rgb2lch(r255, g255, b255) {\n    const [l, a, b2] = rgb2lab(r255, g255, b255);\n    return lab2lch(l, a, b2);\n}\n_input.lch = lch2rgb;\nfunction rgb2cmyk(r255, g255, b255) {\n    r255 /= 255;\n    g255 /= 255;\n    b255 /= 255;\n    const k = 1 - max(r255, g255, b255);\n    if (1 == k)\n        return [0, 0, 0, 1];\n    const c = (1 - r255 - k) / (1 - k);\n    const m = (1 - g255 - k) / (1 - k);\n    const y = (1 - b255 - k) / (1 - k);\n    return [c, m, y, k];\n}\nfunction cmyk2rgb(c1, m1, y1, k1, alpha1 = 1) {\n    if (k1 == 1) {\n        return [0, 0, 0, alpha1];\n    }\n    const r255 = 255 * (1 - c1) * (1 - k1);\n    const g255 = 255 * (1 - m1) * (1 - k1);\n    const b255 = 255 * (1 - y1) * (1 - k1);\n    return [r255, g255, b255, alpha1];\n}\n_input.cmyk = cmyk2rgb;\n_input.gl = function (r, g, b, a = 1) {\n    return [r * 255, g * 255, b * 255, a];\n};\n//function rgb2luminance(r: number, g: number, b: number) {\n//\t// https://en.wikipedia.org/wiki/Relative_luminance\n//\tconst [, Y] = rgb2xyz(r, g, b)\n//\treturn Y\n//}\nfunction rgbChannel2RgbLinear(x255) {\n    const x1 = x255 / 255;\n    // http://entropymine.com/imageworsener/srgbformula/\n    if (x1 <= 0.04045) {\n        return x1 / 12.92;\n    }\n    else {\n        return ((x1 + 0.055) / 1.055) ** 2.4;\n    }\n}\nfunction rgbLinearChannel2Rgb(xLinear1) {\n    if (xLinear1 <= 0.0031308) {\n        return 255 * (12.92 * xLinear1);\n    }\n    else {\n        return 255 * ((1 + 0.055) * xLinear1 ** (1 / 2.4) - 0.055);\n    }\n}\nfunction kelvin2rgb(kelvin) {\n    const t = kelvin / 100;\n    let r, g, b;\n    if (t < 66) {\n        r = 255;\n        g = -155.25485562709179 - 0.44596950469579133 * (t - 2) + 104.49216199393888 * log(t - 2);\n        b = t < 20 ? 0 : -254.76935184120902 + 0.8274096064007395 * (t - 10) + 115.67994401066147 * log(t - 10);\n    }\n    else {\n        r = 351.97690566805693 + 0.114206453784165 * (t - 55) - 40.25366309332127 * log(t - 55);\n        g = 325.4494125711974 + 0.07943456536662342 * (t - 50) - 28.0852963507957 * log(t - 50);\n        b = 255;\n    }\n    return [r, g, b];\n}\n_input.rgb = (...args) => args;\nfunction rgb2kelvin(r255, g255, b255) {\n    console.log(b255 - r255);\n    if (g255 + b255 < 158.61) {\n        console.log("0 < t < 20");\n        // calc from green\n        return round(newtonIterate1d((t) => g255 - (-155.25485562709179 - 0.44596950469579133 * (t - 2) + 104.49216199393888 * log(t - 2)), 15, 4) * 100);\n    }\n    else if (b255 - r255 < 0) {\n        console.log("20 < t < 66");\n        return round(newtonIterate1d((t) => b255 - (-254.76935184120902 + 0.8274096064007395 * (t - 10) + 115.67994401066147 * log(t - 10)), 43, 4) * 100);\n    }\n    else {\n        console.log("0 < t < 400, start= " + (-1.4 * (r255 + g255) + 755));\n        return round(newtonIterate1d((t) => r255 - (351.97690566805693 + 0.114206453784165 * (t - 55) - 40.25366309332127 * log(t - 55)), -1.4 * (r255 + g255) + 755, 8) * 100);\n    }\n}\n_input.temperature = _input.kelvin = _input.K = kelvin2rgb;\nfunction blend_f(f) {\n    return function (bottom, top) {\n        const [r, g, b] = f(color(top).rgb(), color(bottom).rgb());\n        return rgb(r, g, b);\n    };\n}\nfunction each(f) {\n    return function (c1, c2) {\n        return c1.map((e, i) => f(e, c2[i]));\n    };\n}\nfunction _screen(a, b) {\n    return 255 * (1 - (1 - a / 255) * (1 - b / 255));\n}\nfunction _overlay(a, b) {\n    if (b < 128) {\n        return (2 * a * b) / 255;\n    }\n    else {\n        return 255 * (1 - 2 * (1 - a / 255) * (1 - b / 255));\n    }\n}\nfunction _burn(a, b) {\n    return 255 * (1 - (1 - b / 255) / (a / 255));\n}\nfunction _dodge(a, b) {\n    if (a == 255) {\n        return 255;\n    }\n    return 255 * min(1, b / 255 / (1 - a / 255));\n}\n/**\n * r, g, b can be in any interval (0-1 or 0-255)\n * @param r\n * @param g\n * @param b\n */\nfunction rgb2hexhue(r, g, b) {\n    const m = min(r, g, b);\n    const M = max(r, g, b);\n    const delta = M - m;\n    let hueTurnX6; // angle as value between 0 and 6\n    if (0 == delta) {\n        hueTurnX6 = 0;\n    }\n    else if (r == M) {\n        // second term to make sure the value is > 0\n        hueTurnX6 = (g - b) / delta + (g < b ? 6 : 0);\n    }\n    else if (g == M) {\n        hueTurnX6 = 2 + (b - r) / delta;\n    }\n    else {\n        hueTurnX6 = 4 + (r - g) / delta;\n    }\n    return [hueTurnX6 * 60, m, M];\n}\nfunction hcxm2rgb(hueDegrees, c1, x1, m1, alpha1) {\n    const m255 = m1 * 255;\n    const cm255 = c1 * 255 + m255;\n    const xm255 = x1 * 255 + m255;\n    if (hueDegrees < 60) {\n        return [cm255, xm255, m255, alpha1];\n    }\n    else if (hueDegrees < 120) {\n        return [xm255, cm255, m255, alpha1];\n    }\n    else if (hueDegrees < 180) {\n        return [m255, cm255, xm255, alpha1];\n    }\n    else if (hueDegrees < 240) {\n        return [m255, xm255, cm255, alpha1];\n    }\n    else if (hueDegrees < 300) {\n        return [xm255, m255, cm255, alpha1];\n    }\n    else {\n        return [cm255, m255, xm255, alpha1];\n    }\n}\n/**\n * https://en.wikipedia.org/w/index.php?title=HSL_and_HSV&oldid=856714654#From_HSL\n */\nfunction hsl2rgb(hueDegrees, s1, l1, alpha1 = 1) {\n    hueDegrees = norm360(hueDegrees);\n    const c1 = (1 - abs(2 * l1 - 1)) * s1;\n    return hcxm2rgb(hueDegrees, c1, c1 * (1 - abs(((hueDegrees / 60) % 2) - 1)), l1 - c1 / 2, alpha1);\n}\nfunction rgb2hsl(r255, g255, b255) {\n    const [hue, min1, max1] = rgb2hexhue(r255 / 255, g255 / 255, b255 / 255);\n    const l1 = (max1 + min1) / 2;\n    let s1;\n    if (max1 == min1) {\n        s1 = 0;\n    }\n    else {\n        s1 = l1 < 0.5 ? (max1 - min1) / (max1 + min1) : (max1 - min1) / (2 - max1 - min1);\n    }\n    return [hue, s1, l1];\n}\nfunction hsv2rgb(hueDegrees, s1, v1, alpha1 = 1) {\n    hueDegrees = norm360(hueDegrees);\n    const c1 = v1 * s1;\n    return hcxm2rgb(hueDegrees, c1, c1 * (1 - abs(((hueDegrees / 60) % 2) - 1)), v1 - c1, alpha1);\n}\nfunction rgb2hsv(r255, g255, b255) {\n    const [hue, min255, max255] = rgb2hexhue(r255, g255, b255);\n    const delta255 = max255 - min255;\n    const v1 = max255 / 255.0;\n    const s1 = max255 == 0 ? 0 : delta255 / max255;\n    return [hue, s1, v1];\n}\nfunction hcg2rgb(hueDegrees, c1, g1, alpha1 = 1) {\n    hueDegrees = norm360(hueDegrees);\n    const p = g1 * (1 - c1);\n    return hcxm2rgb(hueDegrees, c1, c1 * (1 - abs(((hueDegrees / 60) % 2) - 1)), p, alpha1);\n}\nfunction rgb2hcg(r255, g255, b255) {\n    const [hue, min255, max255] = rgb2hexhue(r255, g255, b255);\n    const c1 = (max255 - min255) / 255;\n    const _g1 = c1 < 1 ? min255 / 255 / (1 - c1) : 0;\n    return [hue, c1, _g1];\n}\n_input.hcg = hcg2rgb;\nfunction cielab2rgb(LStar100, aStar, bStar, alpha = 1) {\n    const [x, y, z] = cielab2xyz(LStar100, aStar, bStar);\n    return xyz2rgb(x, y, z, alpha);\n}\nfunction cielab2xyz(LStar100, aStar, bStar) {\n    function fInv(t) {\n        if (t > LAB_delta) {\n            return t ** 3;\n        }\n        else {\n            return LAB_3DeltaPow2 * (t - 4 / 29);\n        }\n    }\n    return [\n        LAB_Xn * fInv((LStar100 + 16) / 116 + aStar / 500),\n        LAB_Yn * fInv((LStar100 + 16) / 116),\n        LAB_Zn * fInv((LStar100 + 16) / 116 - bStar / 200),\n    ];\n}\nfunction xyz2cielab(x, y, z) {\n    // https://en.wikipedia.org/w/index.php?title=CIELAB_color_space&oldid=849576085#Forward_transformation\n    function f(t) {\n        if (t > LAB_deltaPow3) {\n            return cbrt(t);\n        }\n        else {\n            return t / LAB_3DeltaPow2 + 4 / 29;\n        }\n    }\n    return [116 * f(y / LAB_Yn) - 16, 500 * (f(x / LAB_Xn) - f(y / LAB_Yn)), 200 * (f(y / LAB_Yn) - f(z / LAB_Zn))];\n}\n// const LAB_CONSTANTS = {\nconst LAB_Kn = 18;\nconst LAB_Xn = 0.95047;\nconst LAB_Yn = 1;\nconst LAB_Zn = 1.08883;\nconst LAB_delta = 0.206896552; // delta = 6 / 29\nconst LAB_3DeltaPow2 = 0.12841855; // 3 * delta ** 2\nconst LAB_deltaPow3 = 0.008856452; // delta ** 3\n// }\nfunction rgb2lab(r255, g255, b255) {\n    const [x, y, z] = rgb2xyz(r255, g255, b255);\n    return xyz2cielab(x, y, z);\n}\nfunction rgb2xyz(r255, g255, b255) {\n    // https://en.wikipedia.org/wiki/SRGB#The_reverse_transformation\n    const r1Linear = rgbChannel2RgbLinear(r255);\n    const g1Linear = rgbChannel2RgbLinear(g255);\n    const b1Linear = rgbChannel2RgbLinear(b255);\n    const X = 0.4124564 * r1Linear + 0.3575761 * g1Linear + 0.1804375 * b1Linear;\n    const Y = 0.2126729 * r1Linear + 0.7151522 * g1Linear + 0.072175 * b1Linear;\n    const Z = 0.0193339 * r1Linear + 0.119192 * g1Linear + 0.9503041 * b1Linear;\n    return [X, Y, Z];\n}\nfunction xyz2rgb(X1, Y1, Z1, alpha1 = 1) {\n    // https://en.wikipedia.org/wiki/SRGB#The_forward_transformation_(CIE_XYZ_to_sRGB)\n    const r1Linear = 3.2404542 * X1 - 1.5371385 * Y1 - 0.4985314 * Z1;\n    const g1Linear = -0.969266 * X1 + 1.8760108 * Y1 + 0.041556 * Z1;\n    const b1Linear = 0.0556434 * X1 - 0.2040259 * Y1 + 1.0572252 * Z1;\n    return [rgbLinearChannel2Rgb(r1Linear), rgbLinearChannel2Rgb(g1Linear), rgbLinearChannel2Rgb(b1Linear), alpha1];\n}\n_input.xyz = xyz2rgb;\n_input.lab = cielab2rgb;\n/**\n * For HSI, we use the direct angle calculation. I.e. atan2(beta, alpha). See wikipedia link. This is why we don\'t use\n * hcxm2rgb.\n */\nfunction hsi2rgb(hueDegrees, s1, i1, alpha1 = 1) {\n    /*\n    borrowed from here:\n    http://hummer.stanford.edu/museinfo/doc/examples/humdrum/keyscape2/hsi2rgb.cpp\n     */\n    let r, g, b;\n    let hRad = hueDegrees * DEG2RAD;\n    if (hRad < (2 * PI) / 3) {\n        b = (1 - s1) / 3;\n        r = (1 + (s1 * cos(hRad)) / cos(PI / 3 - hRad)) / 3;\n        g = 1 - (b + r);\n    }\n    else if (hRad < (4 * PI) / 3) {\n        hRad -= (2 * PI) / 3;\n        r = (1 - s1) / 3;\n        g = (1 + (s1 * cos(hRad)) / cos(PI / 3 - hRad)) / 3;\n        b = 1 - (r + g);\n    }\n    else {\n        hRad -= (4 * PI) / 3;\n        g = (1 - s1) / 3;\n        b = (1 + (s1 * cos(hRad)) / cos(PI / 3 - hRad)) / 3;\n        r = 1 - (g + b);\n    }\n    return [3 * i1 * r * 255, 3 * i1 * g * 255, 3 * i1 * b * 255, alpha1];\n}\n/**\n * For HSI, we use the direct angle calculation. I.e. atan2(beta, alpha). See wikipedia link. This is why we don\'t use\n * rgb2hexhue.\n */\nfunction rgb2hsi(r255, g255, b255) {\n    // See https://en.wikipedia.org/wiki/HSL_and_HSV#Hue_and_chroma\n    // See https://en.wikipedia.org/wiki/HSL_and_HSV#Lightness\n    const r1 = r255 / 255;\n    const g1 = g255 / 255;\n    const b1 = b255 / 255;\n    const i1 = (r1 + g1 + b1) / 3;\n    if (r1 == g1 && g1 == b1) {\n        return [0, 0, i1];\n    }\n    else {\n        const alpha = (1 / 2) * (2 * r1 - g1 - b1);\n        const beta = (sqrt(3) / 2) * (g1 - b1);\n        const hRad = atan2(beta, alpha);\n        const min1 = min(r1, g1, b1);\n        const s1 = 1 - min1 / i1;\n        return [(hRad < 0 ? 2 * PI + hRad : hRad) * RAD2DEG, s1, i1];\n    }\n}\n_input.hsi = hsi2rgb;\ninterpolators.hsv = interpolators.hsl = interpolators.hsi = interpolators.lch = interpolators.hcg = function interpolate_hsx(color1, color2, f, m) {\n    const [a1, b1, c1] = color1[m]();\n    const [a2, b2, c2] = color2[m]();\n    function lerpHue(hue1, hue2, f) {\n        const dh = norm360(hue2 - hue1 + 180) - 180;\n        return hue1 + f * dh;\n    }\n    return color(("h" == m.charAt(0) ? lerpHue : lerp)(a1, a2, f), lerp(b1, b2, f), ("h" == m.charAt(2) ? lerpHue : lerp)(c1, c2, f), m);\n};\nfunction indexOfMax(arr, f) {\n    let maxValue = -Infinity, maxValueIndex = -1;\n    for (let i = 0; i < arr.length; i++) {\n        const value = f(arr[i]);\n        if (value > maxValue) {\n            maxValue = value;\n            maxValueIndex = i;\n        }\n    }\n    return maxValueIndex;\n}\nfunction withMax(arr, f) {\n    return arr[indexOfMax(arr, f)];\n}\n\n\n\n\n//# sourceURL=webpack://workshop/./node_modules/chroma.ts/dist/index.es.js?')}}]);