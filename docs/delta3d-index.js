(self.webpackChunkworkshop=self.webpackChunkworkshop||[]).push([[634],{7205:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var chroma_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7392);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9526);\n/* harmony import */ var ts3dutils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2182);\n/* harmony import */ var tsgl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(9392);\nconst _jsxFileName = "C:\\\\Users\\\\aval\\\\tsdev\\\\workshop\\\\src\\\\delta3d\\\\index.tsx";\n\n\n\n\n\n\nconst hfcDefault = chroma_ts__WEBPACK_IMPORTED_MODULE_0__/* .color */ .$_("blue").gl()\n\nclass CyclicVertexBuffer {\n   __init() {this.pos = 0}\n\n  \n\n   __init2() {this.lastUploaded = 0}\n\n  \n\n   constructor(\n      gl,\n     capacity,\n  ) {;this.gl = gl;this.capacity = capacity;CyclicVertexBuffer.prototype.__init.call(this);CyclicVertexBuffer.prototype.__init2.call(this);\n    this.buffer = gl.createBuffer()\n    this.data = new Float32Array(3 * capacity)\n  }\n\n   push(v) {\n    this.data[this.pos++] = v.x\n    this.data[this.pos++] = v.y\n    this.data[this.pos++] = v.z\n  }\n\n   upload() {\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer)\n    this.gl.bufferData(this.gl.ARRAY_BUFFER, this.data, this.gl.DYNAMIC_DRAW)\n  }\n}\n\nclass SGN {\n  __init3() {this.children = []}\n  \n  \n\n   constructor(\n     transform = ts3dutils__WEBPACK_IMPORTED_MODULE_2__.M4.IDENTITY,\n     mesh,\n     color,\n    ...children\n  ) {;this.transform = transform;this.mesh = mesh;this.color = color;SGN.prototype.__init3.call(this);\n    children.forEach((c) => this.add(c))\n  }\n\n   add(...nodes) {\n    for (const node of nodes) {\n      this.children.push(node)\n      node.parent = this\n    }\n  }\n\n   getTransform(sgn) {\n    let result = sgn.transform\n    while (sgn.parent != this) {\n      sgn = sgn.parent\n      result = sgn.transform.times(result)\n    }\n    return result\n  }\n\n   withGimbal() {\n    this.gimbal = true\n    return this\n  }\n}\n\nconst tree = new SGN()\n\nconst sleep = (ms) =>\n  new Promise((resolve, reject) => setTimeout(resolve, ms))\n\nconst rodLength = 12\n\nfunction posToZOffsets(zBases, p) {\n  return zBases.map((zBase) => {\n    const xyD = p.xy().distanceTo(zBase)\n    return p.z + Math.sqrt(rodLength * rodLength - xyD * xyD) + 1\n  })\n}\n\nfunction trilaterate(\n  c1,\n  r1,\n  c2,\n  r2,\n  c3,\n  r3,\n) {\n  const eX = c1.to(c2).unit()\n  const eY = c1.to(c3).rejectedFrom1(eX).unit()\n  const sys = ts3dutils__WEBPACK_IMPORTED_MODULE_2__.M4.forSys(eX, eY, undefined, c1)\n  const d = c1.to(c2).length()\n  const i = c1.to(c3).dot(eX)\n  const j = c1.to(c3).dot(eY)\n  const x = (r1 * r1 - r2 * r2 + d * d) / (2 * d)\n  const y = (r1 * r1 - r3 * r3 - 2 * i * x + i * i + j * j) / (2 * j)\n  const pSys = (0,ts3dutils__WEBPACK_IMPORTED_MODULE_2__.V)(x, y, Math.sqrt(r1 * r1 - x * x - y * y))\n  return sys.transformPoint(pSys)\n}\n\nfunction quickhull(gl) {\n  const viewState = {\n    pos: (0,ts3dutils__WEBPACK_IMPORTED_MODULE_2__.V)(0.75, 0, 1),\n    lookDir: (0,ts3dutils__WEBPACK_IMPORTED_MODULE_2__.V)(0, 0, -1),\n    axisPoss: [0, 0, 0],\n  }\n  const saveViewState = () => {\n    localStorage.setItem(\n      "viewState",\n      JSON.stringify({\n        pos: viewState.pos.toArray(),\n        lookDir: viewState.lookDir.toArray(),\n        axisPoss: viewState.axisPoss,\n      }),\n    )\n  }\n  const loadViewState = () => {\n    if (null != localStorage.getItem("viewState")) {\n      const json = JSON.parse(localStorage.getItem("viewState"))\n      viewState.pos = ts3dutils__WEBPACK_IMPORTED_MODULE_2__.V3.fromArray(json.pos)\n      viewState.lookDir = ts3dutils__WEBPACK_IMPORTED_MODULE_2__.V3.fromArray(json.lookDir)\n      viewState.axisPoss = json.axisPoss || viewState.axisPoss\n    }\n  }\n  loadViewState()\n\n  const cubeMesh = tsgl__WEBPACK_IMPORTED_MODULE_3__/* .Mesh.cube */ .Kj.cube()\n  console.log("cubeMesh", cubeMesh)\n  const pointerMesh = tsgl__WEBPACK_IMPORTED_MODULE_3__/* .Mesh.rotation */ .Kj.rotation(\n    [ts3dutils__WEBPACK_IMPORTED_MODULE_2__.V3.O, (0,ts3dutils__WEBPACK_IMPORTED_MODULE_2__.V)(1, 0, 1)],\n    { anchor: ts3dutils__WEBPACK_IMPORTED_MODULE_2__.V3.O, dir1: ts3dutils__WEBPACK_IMPORTED_MODULE_2__.V3.Z },\n    ts3dutils__WEBPACK_IMPORTED_MODULE_2__/* .TAU */ .gc,\n    16,\n  )\n  const planeMesh = tsgl__WEBPACK_IMPORTED_MODULE_3__/* .Mesh.plane */ .Kj.plane()\n  const sphereMesh = tsgl__WEBPACK_IMPORTED_MODULE_3__/* .Mesh.sphere */ .Kj.sphere(1)\n    .computeWireframeFromFlatTrianglesClosedMesh()\n    .compile()\n  const spiralMesh = tsgl__WEBPACK_IMPORTED_MODULE_3__/* .Mesh.spiral */ .Kj.spiral(\n    [(0,ts3dutils__WEBPACK_IMPORTED_MODULE_2__.V)(-0.1, 1), (0,ts3dutils__WEBPACK_IMPORTED_MODULE_2__.V)(0, 1.1), (0,ts3dutils__WEBPACK_IMPORTED_MODULE_2__.V)(0.1, 1, 0)],\n    { anchor: ts3dutils__WEBPACK_IMPORTED_MODULE_2__.V3.O, dir1: ts3dutils__WEBPACK_IMPORTED_MODULE_2__.V3.X },\n    ts3dutils__WEBPACK_IMPORTED_MODULE_2__/* .TAU */ .gc * 320,\n    16 * 320,\n    0.2,\n  )\n    .computeNormalsFromFlatTriangles()\n    .compile()\n  console.log("spiralMesh", spiralMesh)\n  const cylinderMesh = tsgl__WEBPACK_IMPORTED_MODULE_3__/* .Mesh.rotation */ .Kj.rotation(\n    [ts3dutils__WEBPACK_IMPORTED_MODULE_2__.V3.Y, ts3dutils__WEBPACK_IMPORTED_MODULE_2__.V3.XY],\n    { anchor: ts3dutils__WEBPACK_IMPORTED_MODULE_2__.V3.O, dir1: ts3dutils__WEBPACK_IMPORTED_MODULE_2__.V3.X },\n    2 * Math.PI,\n    16,\n    true,\n  )\n  const platformMesh = tsgl__WEBPACK_IMPORTED_MODULE_3__/* .Mesh.rotation */ .Kj.rotation(\n    [ts3dutils__WEBPACK_IMPORTED_MODULE_2__.V3.O, ts3dutils__WEBPACK_IMPORTED_MODULE_2__.V3.X, (0,ts3dutils__WEBPACK_IMPORTED_MODULE_2__.V)(1, 0, 1), ts3dutils__WEBPACK_IMPORTED_MODULE_2__.V3.Z],\n    {\n      anchor: ts3dutils__WEBPACK_IMPORTED_MODULE_2__.V3.O,\n      dir1: ts3dutils__WEBPACK_IMPORTED_MODULE_2__.V3.Z,\n    },\n    ts3dutils__WEBPACK_IMPORTED_MODULE_2__.PI * 2,\n    3,\n  )\n  const trackLine = new tsgl__WEBPACK_IMPORTED_MODULE_3__/* .Buffer */ .lW(gl.ARRAY_BUFFER, Float32Array)\n  let pos = 0\n  const jointColors = chroma_ts__WEBPACK_IMPORTED_MODULE_0__/* .scale */ .bA("yellow", "black").colors(6, "gl")\n  console.log(sphereMesh)\n  const zAssemblies = []\n  const spindles = []\n  const zAssemblyJoinPoints = []\n  const platformJoinPoints = []\n  const joints = []\n  let platform\n  const bars = []\n  tree.add(\n    new SGN(\n      ts3dutils__WEBPACK_IMPORTED_MODULE_2__.M4.translate((0,ts3dutils__WEBPACK_IMPORTED_MODULE_2__.V)(-0.5, -0.5, -1)).scale(30, 30, 1),\n      cubeMesh,\n      chroma_ts__WEBPACK_IMPORTED_MODULE_0__/* .css */ .iv("lightgreen").gl(),\n    ).withGimbal(),\n    (platform = new SGN(\n      ts3dutils__WEBPACK_IMPORTED_MODULE_2__.M4.translate(0, 0, 5),\n      undefined,\n      undefined,\n      new SGN(\n        ts3dutils__WEBPACK_IMPORTED_MODULE_2__.M4.scale(3, 3, 1).rotateZ(Math.PI / 3),\n        platformMesh,\n        chroma_ts__WEBPACK_IMPORTED_MODULE_0__/* .css */ .iv("orange").gl(),\n      ),\n      new SGN(ts3dutils__WEBPACK_IMPORTED_MODULE_2__.M4.translate(0, 0, -1), pointerMesh, chroma_ts__WEBPACK_IMPORTED_MODULE_0__/* .css */ .iv("silver").gl()),\n      ...[0, 1, 2].flatMap((i) =>\n        [0, 1].map(\n          (j) =>\n            (platformJoinPoints[i * 2 + j] = new SGN(\n              ts3dutils__WEBPACK_IMPORTED_MODULE_2__.M4.scale(0.2)\n                .translate(1.5, j ? 1.5 : -1.5, 0.5)\n                .rotateZ(ts3dutils__WEBPACK_IMPORTED_MODULE_2__/* .TAU */ .gc * ((1 / 3) * i)),\n              sphereMesh,\n              jointColors[i * 2 + j],\n            )),\n        ),\n      ),\n    )),\n    ...[0, 1, 2, 3, 4, 5].map(\n      (i) => (joints[i] = new SGN(undefined, cylinderMesh, jointColors[i])),\n    ),\n    ...[0, 1, 2].map(\n      (i) =>\n        new SGN(\n          ts3dutils__WEBPACK_IMPORTED_MODULE_2__.M4.translate(10, 0, 0).rotateZ(((ts3dutils__WEBPACK_IMPORTED_MODULE_2__.PI * 2) / 3) * i),\n          undefined,\n          undefined,\n\n          (spindles[i] = new SGN(\n            ts3dutils__WEBPACK_IMPORTED_MODULE_2__.M4.rotateY(-ts3dutils__WEBPACK_IMPORTED_MODULE_2__.PI / 2),\n            spiralMesh,\n            chroma_ts__WEBPACK_IMPORTED_MODULE_0__/* .css */ .iv("green").gl(),\n          )),\n          new SGN(\n            ts3dutils__WEBPACK_IMPORTED_MODULE_2__.M4.scale(0.4).translate(-2.5, 0, 0),\n            cubeMesh,\n            chroma_ts__WEBPACK_IMPORTED_MODULE_0__/* .css */ .iv("cyan").gl(),\n          ),\n          (zAssemblies[i] = new SGN(\n            ts3dutils__WEBPACK_IMPORTED_MODULE_2__.M4.translate(0, 0, viewState.axisPoss[i]),\n            undefined,\n            undefined,\n\n            new SGN(\n              ts3dutils__WEBPACK_IMPORTED_MODULE_2__.M4.translate(-0.5, -0.5).scale(2, 3, 1),\n              cubeMesh,\n              chroma_ts__WEBPACK_IMPORTED_MODULE_0__/* .css */ .iv("blue").gl(),\n            ),\n            ...[0, 1].map(\n              (j) =>\n                (zAssemblyJoinPoints[i * 2 + j] = new SGN(\n                  ts3dutils__WEBPACK_IMPORTED_MODULE_2__.M4.scale(0.2).translate(-1, j ? 1.5 : -1.5, 0.5),\n                  sphereMesh,\n                  jointColors[i * 2 + j],\n                )),\n            ),\n          )),\n        ),\n    ),\n  )\n  const zBases = [0, 1, 2].map((i) =>\n    tree.getTransform(zAssemblies[i]).transformPoint((0,ts3dutils__WEBPACK_IMPORTED_MODULE_2__.V)(-2.5, 0, 0)).xy(),\n  ) \n\n  function fixJoints() {\n    ;[0, 1, 2].forEach((i) => {\n      zAssemblies[i].transform = ts3dutils__WEBPACK_IMPORTED_MODULE_2__.M4.translate(0, 0, viewState.axisPoss[i])\n      spindles[i].transform = ts3dutils__WEBPACK_IMPORTED_MODULE_2__.M4.scale(1, 0.5, 0.5)\n        .rotateX((ts3dutils__WEBPACK_IMPORTED_MODULE_2__/* .TAU */ .gc * -viewState.axisPoss[i]) / 0.2)\n        .rotateY(-ts3dutils__WEBPACK_IMPORTED_MODULE_2__.PI / 2)\n    })\n\n    const [p1, p2, p3] = [0, 1, 2].map((i) =>\n      tree.getTransform(zAssemblies[i]).transformPoint((0,ts3dutils__WEBPACK_IMPORTED_MODULE_2__.V)(-2.5, 0, 0)),\n    )\n    const platCenter = trilaterate(p2, rodLength, p1, rodLength, p3, rodLength)\n    platform.transform = ts3dutils__WEBPACK_IMPORTED_MODULE_2__.M4.translate(platCenter)\n    for (let i = 0; i < 6; i++) {\n      const a = tree.getTransform(zAssemblyJoinPoints[i]).O\n      const b = tree.getTransform(platformJoinPoints[i]).O\n      joints[i].transform = ts3dutils__WEBPACK_IMPORTED_MODULE_2__.M4.scale(rodLength, 0.1, 0.1)\n        .rotateAB(ts3dutils__WEBPACK_IMPORTED_MODULE_2__.V3.X, a.to(b))\n        .translate(a)\n    }\n  }\n\n  viewState.axisPoss = posToZOffsets(zBases, ts3dutils__WEBPACK_IMPORTED_MODULE_2__.V3.O)\n  fixJoints()\n  // const cubeMesh = Mesh.cube()\n  const shader = tsgl__WEBPACK_IMPORTED_MODULE_3__/* .Shader.create */ .ex.create\n\n\n\n\n\n\n\n(\n    `\n\tuniform mat4 ts_ModelViewMatrix;\n\tuniform mat3 ts_NormalMatrix;\n\tuniform mat4 ts_ModelViewProjectionMatrix;\n\tuniform float pointSize;\n\n\tattribute vec4 ts_Vertex;\n\tattribute vec3 ts_Normal;\n\n\tvarying vec3 coordUVQ;\n\tvarying vec2 coord;\n\tvarying vec3 normal;\n\tvarying vec3 position;\n\n\tvoid main() {\n\n\t  gl_Position = ts_ModelViewProjectionMatrix * ts_Vertex;\n\t  gl_PointSize = pointSize;\n\n\t  normal =ts_Normal;\n\t  vec4 position4 = ts_ModelViewMatrix * ts_Vertex;\n\t  position = position4.xyz;\n\t}\n  `,\n    `\n\tprecision highp float;\n\n\tuniform sampler2D texture;\n\tuniform vec3 lightPos;\n\tuniform vec4 color;\n\n\tvarying vec3 coordUVQ;\n\tvarying vec2 coord;\n\tvarying vec3 normal;\n\tvarying vec3 position;\n\n\tvoid main() {\n\t\tvec3 normal1 = normalize(normal);\n\t\tvec3 lightPos = vec3(1000, 2000, 4000);\n\t\tvec3 lightDir = normalize(position.xyz - lightPos);\n        float uMaterialShininess = 256.0;\n\t\tfloat lightIntensity = 0.2 + 0.8 * max(0.0, -dot(lightDir, normal1));\n\t\tgl_FragColor = vec4(normal,1.0);\n\t\tgl_FragColor = vec4(vec3(color) * lightIntensity, 1);\n\t}\n\t  `,\n  )\n\n  gl.clearColor(1, 1, 1, 0)\n  gl.cullFace(gl.BACK)\n\n  // setup camera\n  const cam1 = () => {\n    gl.matrixMode(gl.PROJECTION)\n    gl.loadIdentity()\n    gl.perspective(70, gl.canvas.width / gl.canvas.height, 0.1, 1000)\n    gl.lookAt((0,ts3dutils__WEBPACK_IMPORTED_MODULE_2__.V)(0, 0.5, 2.2), ts3dutils__WEBPACK_IMPORTED_MODULE_2__.V3.O, ts3dutils__WEBPACK_IMPORTED_MODULE_2__.V3.Y)\n    gl.matrixMode(gl.MODELVIEW)\n  }\n  const cam2 = () => {\n    gl.matrixMode(gl.PROJECTION)\n    gl.loadIdentity()\n    gl.perspective(70, gl.canvas.width / gl.canvas.height, 0.1, 1000)\n    gl.lookAt((0,ts3dutils__WEBPACK_IMPORTED_MODULE_2__.V)(0.75, 0, 1), (0,ts3dutils__WEBPACK_IMPORTED_MODULE_2__.V)(0.75, 0, 0), ts3dutils__WEBPACK_IMPORTED_MODULE_2__.V3.Y)\n    gl.matrixMode(gl.MODELVIEW)\n  }\n  cam2()\n  gl.pointSize(10)\n\n  gl.enable(gl.CULL_FACE)\n  gl.enable(gl.DEPTH_TEST)\n  gl.enable(gl.BLEND)\n  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)\n  const pressedKeys = {}\n  console.log(gl.canvas)\n  gl.canvas.contentEditable = "true" // make canvas focusable\n  gl.canvas.focus()\n  gl.canvas.onkeydown = function (e) {\n    pressedKeys[e.key] = true\n\n    if ("2" === e.key) {\n      cam2()\n    }\n    if ("1" === e.key) {\n      cam1()\n    }\n  }\n  gl.canvas.onkeypress = function (e) {\n    const dir = new ts3dutils__WEBPACK_IMPORTED_MODULE_2__.V3(0, 0, 0)\n  }\n  gl.canvas.onkeyup = function (e) {\n    pressedKeys[e.key] = false\n  }\n  let lastPos = ts3dutils__WEBPACK_IMPORTED_MODULE_2__.V3.O\n  let rot = ts3dutils__WEBPACK_IMPORTED_MODULE_2__.M4.IDENTITY\n  const zRot = 0\n  const yRot = 0\n  gl.canvas.onmousemove2 = function (e) {\n    const pagePos = (0,ts3dutils__WEBPACK_IMPORTED_MODULE_2__.V)(e.pageX, e.pageY)\n    const delta = lastPos.to(pagePos)\n    if (e.buttons & 1) {\n      // zRot -= delta.x * 0.25 * DEG\n      rot = rot.rotateZ(delta.x * 0.25 * ts3dutils__WEBPACK_IMPORTED_MODULE_2__/* .DEG */ .Co)\n      rot = rot.rotateX(delta.y * 0.25 * ts3dutils__WEBPACK_IMPORTED_MODULE_2__/* .DEG */ .Co)\n      // rot = rot.rotate(V3.O, rot.X, delta.y * 0.25 * DEG)\n      // yRot = clamp(yRot - delta.y * 0.25 * DEG, -85 * DEG, 85 * DEG)\n    }\n    lastPos = pagePos\n  }\n  gl.canvas.onmousemove = function (e) {\n    const pagePos = (0,ts3dutils__WEBPACK_IMPORTED_MODULE_2__.V)(e.pageX, e.pageY)\n    const delta = lastPos.to(pagePos)\n    if (e.buttons & 1) {\n      // zRot -= delta.x * 0.25 * DEG\n      const rot = ts3dutils__WEBPACK_IMPORTED_MODULE_2__.M4.rotateY(-delta.x * 0.25 * ts3dutils__WEBPACK_IMPORTED_MODULE_2__/* .DEG */ .Co).rotateX(\n        -delta.y * 0.25 * ts3dutils__WEBPACK_IMPORTED_MODULE_2__/* .DEG */ .Co,\n      )\n      viewState.lookDir = rot.transformVector(viewState.lookDir).unit()\n      // rot = rot.rotate(V3.O, rot.X, delta.y * 0.25 * DEG)\n      // yRot = clamp(yRot - delta.y * 0.25 * DEG, -85 * DEG, 85 * DEG)\n    }\n    lastPos = pagePos\n  }\n\n  function renderNode(sgn) {\n    gl.pushMatrix()\n    gl.multMatrix(sgn.transform)\n\n    if (sgn.gimbal) {\n      gl.drawGimbal(0.1)\n    }\n    if (sgn.mesh) {\n      shader\n        .uniforms({\n          color: sgn.color,\n          pointSize: 12,\n          lightPos: (0,ts3dutils__WEBPACK_IMPORTED_MODULE_2__.V)(100, 0, 100).toLength(-1),\n        })\n        .draw(sgn.mesh)\n    }\n    sgn.children.forEach(renderNode)\n    gl.popMatrix()\n  }\n\n  function keyDir(plusKey, minusKey) {\n    return +!!pressedKeys[plusKey] - +!!pressedKeys[minusKey]\n  }\n\n  const keys = [\n    ["u", "j"],\n    ["i", "k"],\n    ["o", "l"],\n  ] \n  trackLine.data[pos++] = ts3dutils__WEBPACK_IMPORTED_MODULE_2__.V3.O\n  trackLine.data[pos++] = ts3dutils__WEBPACK_IMPORTED_MODULE_2__.V3.O\n  return gl.animate(function (abs, _diff) {\n    const targetPos = ts3dutils__WEBPACK_IMPORTED_MODULE_2__.M4.rotateX(70 * ts3dutils__WEBPACK_IMPORTED_MODULE_2__/* .DEG */ .Co)\n      .translate(0, 0, 3)\n      .transformPoint(ts3dutils__WEBPACK_IMPORTED_MODULE_2__.V3.polar(2, abs / 500, 1 + abs / 100000))\n    viewState.axisPoss = posToZOffsets(zBases, targetPos)\n    trackLine.data[pos++] = targetPos\n    trackLine.compile()\n    fixJoints()\n    for (let i = 0; i < 3; i++) {\n      const speed = 0.1 * keyDir(...keys[i])\n      if (speed !== 0) {\n        viewState.axisPoss[i] += speed\n        fixJoints()\n        saveViewState()\n      }\n    }\n    const speed = new ts3dutils__WEBPACK_IMPORTED_MODULE_2__.V3(\n      +!!pressedKeys.w - +!!pressedKeys.s,\n      +!!pressedKeys.a - +!!pressedKeys.d,\n      +!!pressedKeys.e - +!!pressedKeys.q + +!!pressedKeys[" "],\n    ).times(0.05)\n    if (!speed.likeO()) {\n      const lookDirZ = viewState.lookDir\n\n      viewState.pos = viewState.pos.plus(\n        ts3dutils__WEBPACK_IMPORTED_MODULE_2__.M4.forSys(lookDirZ, ts3dutils__WEBPACK_IMPORTED_MODULE_2__.V3.Y.cross(lookDirZ).unit()).transformVector(speed),\n      )\n      saveViewState()\n    }\n    gl.matrixMode(gl.PROJECTION)\n    gl.loadIdentity()\n    gl.perspective(70, gl.canvas.width / gl.canvas.height, 0.1, 1000)\n    gl.lookAt(viewState.pos, viewState.pos.plus(viewState.lookDir), ts3dutils__WEBPACK_IMPORTED_MODULE_2__.V3.Y)\n    gl.matrixMode(gl.MODELVIEW)\n\n    // const angleDeg = (abs / 1000) * 10\n    // const angleDeg = 0\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)\n    gl.loadIdentity()\n    gl.rotate(-90, 1, 0, 0)\n    // gl.rotate(yRot / DEG, 0, 1, 0)\n    // gl.rotate(-zRot / DEG, 0, 0, 1)\n    //gl.multMatrix(rot)\n    gl.drawGimbal(0.1)\n\n    renderNode(tree)\n    shader\n      .uniforms({ color: chroma_ts__WEBPACK_IMPORTED_MODULE_0__/* .css */ .iv("red").gl() })\n      .drawBuffers({ ts_Vertex: trackLine }, undefined, gl.LINE_STRIP)\n\n    //shader\n    // .uniforms({\n    //  color: chroma.css("grey").gl(),\n    // pointSize: 10,\n    // })\n    //.drawBuffers(pointMesh.vertexBuffers, undefined, gl.POINTS)\n    //shader.uniforms({ color: [1, 1, 0, 1] }).draw(pointMesh, gl.LINES)\n    //shader.uniforms({ color: [0, 0, 0, 0.5] }).draw(pointMesh,\n    // gl.TRIANGLES) gl.pushMatrix() gl.translate(30, 0, 0)\n  })\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (() => {\n  const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null)\n\n  ;(0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const tsgl = tsgl__WEBPACK_IMPORTED_MODULE_3__/* .TSGLContext.create */ .ZG.create({ canvas: canvasRef.current })\n    tsgl.fixCanvasRes()\n    tsgl.addResizeListener()\n    quickhull(tsgl)\n  }, [])\n\n  return (\n    react__WEBPACK_IMPORTED_MODULE_1__.createElement(\'div\', { style: { display: "flex", flexDirection: "column", height: "100%" }, __self: undefined, __source: {fileName: _jsxFileName, lineNumber: 542}}\n      , react__WEBPACK_IMPORTED_MODULE_1__.createElement(\'canvas\', { ref: canvasRef, style: { flexGrow: 1 }, tabIndex: 0, __self: undefined, __source: {fileName: _jsxFileName, lineNumber: 543}} )\n    )\n  )\n});\n\n\n//# sourceURL=webpack://workshop/./src/delta3d/index.tsx?')}}]);