(self.webpackChunkworkshop=self.webpackChunkworkshop||[]).push([[182],{2182:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "mN": () => (/* binding */ $r),\n  "Co": () => (/* binding */ et),\n  "M4": () => (/* binding */ Or),\n  "uK": () => (/* binding */ K),\n  "wU": () => (/* binding */ h),\n  "bE": () => (/* binding */ a),\n  "Fw": () => (/* binding */ br),\n  "PI": () => (/* binding */ i),\n  "gc": () => (/* binding */ o),\n  "yu": () => (/* binding */ xr),\n  "V": () => (/* binding */ gr),\n  "V3": () => (/* binding */ Ar),\n  "zy": () => (/* binding */ W),\n  "Nv": () => (/* binding */ Ct),\n  "hS": () => (/* binding */ Yt),\n  "qC": () => (/* binding */ Tt),\n  "hu": () => (/* binding */ y),\n  "yP": () => (/* binding */ w),\n  "nY": () => (/* binding */ At),\n  "OD": () => (/* binding */ A),\n  "J8": () => (/* binding */ ar),\n  "uZ": () => (/* binding */ U),\n  "en": () => (/* binding */ qt),\n  "p3": () => (/* binding */ x),\n  "n1": () => (/* binding */ ct),\n  "t7": () => (/* binding */ F),\n  "kL": () => (/* binding */ b),\n  "zj": () => (/* binding */ kt),\n  "hO": () => (/* binding */ pr),\n  "At": () => (/* binding */ L),\n  "Tw": () => (/* binding */ ir),\n  "AW": () => (/* binding */ Ut)\n});\n\n// UNUSED EXPORTS: EllipticE, EllipticF, GOLDEN_RATIO, Matrix, P3XY, P3YZ, VV, Vector, absSum, arithmeticGeometricMean, arrayCopy, arrayCopyBlocks, arrayCopyStep, arrayEquals, arrayHashCode, arraySamples, assertBetween, assertInts, assertNever, assertNumbers, assertReals, bagToggle, between, binaryIndexOf, binaryInsert, bisect, callSource, canonAngle, ceil10, checkDerivate, clear, combinations, concatenated, defaultRoundFunction, disableConsole, doubleSignedArea, enableConsole, eq, eq02, eqAngle, equals, firstUnsorted, floatHashCode, floor10, forceFinite, fuzzyBetween, fuzzyUniques, fuzzyUniquesF, gaussLegendre24Weights, gaussLegendre24Xs, gaussLegendreQuadrature24, ge, getIntervals, getLast, getRoots, glq24_11, glqInSteps, gt, hasConstructor, hashCode, indexWithMax, isCCW, le, lt, mapFilter, mapPush, max, midpointRuleQuadrature, min, mod, newtonIterate, newtonIterate2d, newtonIterate2dWithDerivatives, newtonIterateSmart, newtonIterateWithDerivative, newtonIterateWithDerivative2, numberToStr, pqFormula, rad2deg, remove, removeAll, removeIndex, removeJSComments, removeMatch, setLast, sliceStep, snap, snap0, snap2, snapEPS, solveCubicReal2, splicePure, sum, sumInPlaceTree, time, toSource, toString, toggle, vArrGet, vArrSet, zeroAngle\n\n;// CONCATENATED MODULE: ./node_modules/javasetmap.ts/lib/index.es.js\n/**\r\n * Java style map.\r\n */\r\nclass JavaMap {\r\n    constructor() {\r\n        this[Symbol.toStringTag] = "Map";\r\n        this._map = new Map();\r\n        this._size = 0;\r\n    }\r\n    toString() {\r\n        return ("{" +\r\n            Array.from(this.entries2())\r\n                .map(({ key, value }) => key + ":" + value)\r\n                .join(", ") +\r\n            "}");\r\n    }\r\n    forEach(callbackfn, thisArg) {\r\n        for (const bucket of this._map.values()) {\r\n            for (const { key, value } of bucket) {\r\n                callbackfn.call(thisArg, value, key, this);\r\n            }\r\n        }\r\n    }\r\n    *keys() {\r\n        for (const bucket of this._map.values()) {\r\n            for (const { key } of bucket) {\r\n                yield key;\r\n            }\r\n        }\r\n    }\r\n    *values() {\r\n        for (const bucket of this._map.values()) {\r\n            for (const { value } of bucket) {\r\n                yield value;\r\n            }\r\n        }\r\n    }\r\n    [Symbol.iterator]() {\r\n        return this.entries();\r\n    }\r\n    set(key, value) {\r\n        this.set2(key, value);\r\n        return this;\r\n    }\r\n    /**\r\n     * Like {@link #set} except it returns true if key was new and false if the value was only updated.\r\n     *\r\n     */\r\n    set2(key, val) {\r\n        const hashCode = key.hashCode(), bucket = this._map.get(hashCode);\r\n        //assert(hashCode === (hashCode | 0))\r\n        if (bucket) {\r\n            const pairIndex = bucket.findIndex((pair) => pair.key.equals(key));\r\n            if (-1 == pairIndex) {\r\n                bucket.push({ key: key, value: val });\r\n            }\r\n            else {\r\n                bucket[pairIndex].value = val;\r\n                return false;\r\n            }\r\n        }\r\n        else {\r\n            this._map.set(hashCode, [{ key: key, value: val }]);\r\n        }\r\n        this._size++;\r\n        return true;\r\n    }\r\n    has(key) {\r\n        const hashCode = key.hashCode(), bucket = this._map.get(hashCode);\r\n        //assert(hashCode === (hashCode | 0))\r\n        return undefined !== bucket && bucket.some((pair) => pair.key.equals(key));\r\n    }\r\n    get(key) {\r\n        const hashCode = key.hashCode(), bucket = this._map.get(hashCode), pair = bucket && bucket.find((pair) => pair.key.equals(key));\r\n        return pair && pair.value;\r\n    }\r\n    getLike(key) {\r\n        for (const hashCode of key.hashCodes()) {\r\n            const bucket = this._map.get(hashCode);\r\n            const canonVal = bucket && bucket.find((x) => x.key.like(key));\r\n            if (canonVal)\r\n                return canonVal;\r\n        }\r\n    }\r\n    setLike(key, val) {\r\n        return !this.getLike(key) && this.set(key, val);\r\n    }\r\n    delete(key) {\r\n        const hashCode = key.hashCode(), bucket = this._map.get(hashCode);\r\n        if (bucket) {\r\n            const index = bucket.findIndex((x) => x.key.equals(key));\r\n            if (-1 != index) {\r\n                if (1 == bucket.length) {\r\n                    this._map.delete(hashCode);\r\n                }\r\n                else {\r\n                    bucket.splice(index, 1);\r\n                }\r\n                this._size--;\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    deleteLike(key) {\r\n        for (const hashCode of key.hashCodes()) {\r\n            const bucket = this._map.get(hashCode);\r\n            if (bucket) {\r\n                const index = bucket.findIndex((x) => x.key.like(key));\r\n                if (-1 != index) {\r\n                    const deleted = bucket[index];\r\n                    if (1 == bucket.length) {\r\n                        this._map.delete(hashCode);\r\n                    }\r\n                    else {\r\n                        bucket.splice(index, 1);\r\n                    }\r\n                    this._size--;\r\n                    return deleted;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    *entries2() {\r\n        for (const bucket of this._map.values()) {\r\n            yield* bucket;\r\n        }\r\n    }\r\n    *entries() {\r\n        for (const bucket of this._map.values()) {\r\n            for (const { key, value } of bucket) {\r\n                yield [key, value];\r\n            }\r\n        }\r\n    }\r\n    clear() {\r\n        this._map.clear();\r\n        this._size = 0;\r\n    }\r\n    get size() {\r\n        return this._size;\r\n    }\r\n}\n\nclass JavaSet {\r\n    constructor(iterable) {\r\n        this[Symbol.toStringTag] = "Set";\r\n        this[Symbol.iterator] = JavaSet.prototype.values;\r\n        this.keys = JavaSet.prototype.values;\r\n        this._map = new Map();\r\n        this._size = 0;\r\n        if (iterable) {\r\n            this.addAll(iterable);\r\n        }\r\n    }\r\n    forEach(callbackfn, thisArg) {\r\n        for (const [value] of this.entries()) {\r\n            callbackfn.call(thisArg, value, value, this);\r\n        }\r\n    }\r\n    add(val) {\r\n        this.add2(val);\r\n        return this;\r\n    }\r\n    add2(val) {\r\n        // you can\'t use this.canonicalize here, as there is no way to differentiate if val\r\n        // is new or if val was === the exisitng value (not only .equals)\r\n        const hashCode = val.hashCode(), bucket = this._map.get(hashCode);\r\n        if (bucket) {\r\n            if (bucket.some((x) => x.equals(val))) {\r\n                return false;\r\n            }\r\n            bucket.push(val);\r\n        }\r\n        else {\r\n            this._map.set(hashCode, [val]);\r\n        }\r\n        this._size++;\r\n        return true;\r\n    }\r\n    addAll(iterable) {\r\n        for (const val of iterable) {\r\n            this.add(val);\r\n        }\r\n        return this;\r\n    }\r\n    canonicalize(val) {\r\n        const hashCode = val.hashCode(), bucket = this._map.get(hashCode);\r\n        if (bucket) {\r\n            const existing = bucket.find((x) => x.equals(val));\r\n            if (existing) {\r\n                return existing;\r\n            }\r\n            bucket.push(val);\r\n        }\r\n        else {\r\n            this._map.set(hashCode, [val]);\r\n        }\r\n        this._size++;\r\n        return val;\r\n    }\r\n    has(val) {\r\n        const hashCode = val.hashCode(), bucket = this._map.get(hashCode);\r\n        return undefined !== bucket && bucket.some((x) => x.equals(val));\r\n    }\r\n    getLike(val) {\r\n        for (const hashCode of val.hashCodes()) {\r\n            const bucket = this._map.get(hashCode);\r\n            const canonVal = bucket && bucket.find((x) => x.like(val));\r\n            if (canonVal)\r\n                return canonVal;\r\n        }\r\n    }\r\n    canonicalizeLike(val) {\r\n        // if this.getLike(val) is defined, return it, otherwise add val and return val\r\n        return this.getLike(val) || this.canonicalize(val);\r\n    }\r\n    addLike(val) {\r\n        return !this.getLike(val) && this.add(val);\r\n    }\r\n    delete(val) {\r\n        const hashCode = val.hashCode(), bucket = this._map.get(hashCode);\r\n        if (bucket) {\r\n            const index = bucket.findIndex((x) => x.equals(val));\r\n            if (-1 != index) {\r\n                if (1 == bucket.length) {\r\n                    this._map.delete(hashCode);\r\n                }\r\n                else {\r\n                    bucket.splice(index, 1);\r\n                }\r\n                this._size--;\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    deleteLike(val) {\r\n        for (const hashCode of val.hashCodes()) {\r\n            const bucket = this._map.get(hashCode);\r\n            if (bucket) {\r\n                const index = bucket.findIndex((x) => x.like(val));\r\n                if (-1 != index) {\r\n                    const deleted = bucket[index];\r\n                    if (1 == bucket.length) {\r\n                        this._map.delete(hashCode);\r\n                    }\r\n                    else {\r\n                        bucket.splice(index, 1);\r\n                    }\r\n                    this._size--;\r\n                    return deleted;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    *values() {\r\n        for (const bucket of this._map.values()) {\r\n            yield* bucket;\r\n        }\r\n    }\r\n    *entries() {\r\n        for (const bucket of this._map.values()) {\r\n            for (const value of bucket) {\r\n                yield [value, value];\r\n            }\r\n        }\r\n    }\r\n    clear() {\r\n        this._map.clear();\r\n        this._size = 0;\r\n    }\r\n    get size() {\r\n        return this._size;\r\n    }\r\n    toString() {\r\n        return "{" + Array.from(this.values()).join(", ") + "}";\r\n    }\r\n}\r\nclass Pair {\r\n    constructor(left, right) {\r\n        this.left = left;\r\n        this.right = right;\r\n    }\r\n    hashCode() {\r\n        return this.left.hashCode() * 31 + this.right.hashCode();\r\n    }\r\n    equals(other) {\r\n        return (this == other ||\r\n            (Object.getPrototypeOf(other) == Pair.prototype &&\r\n                this.left.equals(other.left) &&\r\n                this.right.equals(other.right)));\r\n    }\r\n    toString() {\r\n        return "(" + this.left.toString() + ", " + this.right.toString() + ")";\r\n    }\r\n    toSource() {\r\n        return ("new Pair(" +\r\n            this.left.toSource() +\r\n            ", " +\r\n            this.right.toSource() +\r\n            ")");\r\n    }\r\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/ts3dutils/lib/index.es.min.js\nconst r=/^(abstract|boolean|break|byte|case|catch|char|class|const|continue|debugger|default|delete|do|double|else|enum|export|extends|false|final|finally|float|for|function|goto|if|implements|import|in|instanceof|int|interface|long|native|new|null|package|private|protected|public|return|short|static|super|switch|synchronized|this|throw|throws|transient|true|try|typeof|undefined|var|void|volatile|while|with)$/,n=[];function e(t,r=0){switch(typeof t){case"undefined":return"undefined";case"function":return t.toString();case"number":case"boolean":return""+t;case"string":return JSON.stringify(t);case"object":return null==t?"null":t.sce;default:throw Error(typeof t)}}function s(t,r){t.prototype.toSource||Object.defineProperty(t.prototype,"toSource",{value:r,writable:!0,configurable:!0,enumerable:!1})}s(Boolean,Boolean.prototype.toString),s(Function,Function.prototype.toString),s(Number,Number.prototype.toString),s(RegExp,RegExp.prototype.toString),s(Date,(function(){return"new Date("+this.getTime()+")"})),s(String,(function(){return JSON.stringify(this)})),s(Array,(function(){if(n.includes(this))return"CIRCULAR_REFERENCE";n.push(this);let t="[";for(let r=0;r<this.length;r++)t+="\\n\\t"+e(this[r]).replace(/\\r\\n|\\n|\\r/g,"$&\\t"),r!==this.length-1&&(t+=",");return t+=0===this.length?"]":"\\n]",n.pop(),t})),s(Object,(function(){if(n.includes(this))return"CIRCULAR_REFERENCE";n.push(this);let t="{";const s=Object.keys(this).sort();for(let n=0;n<s.length;n++){const o=s[n];t+="\\n\\t"+(/^[a-z_$][0-9a-z_$]*$/gi.test(i=o)&&!r.test(i)?o:JSON.stringify(o))+": "+e(this[o]).replace(/\\r\\n|\\n|\\r/g,"$&\\t"),n!==s.length-1&&(t+=",")}var i;return t+=0===s.length?"}":"\\n}",n.pop(),t}));const i=Math.PI,o=2*i,h="production"!="production",a=1/(1<<26);let u;function c(){u=console.log,console.log=function(){}}function l(){u&&(console.log=u)}function f(t,r){return t.constructor==r}function w(t,...r){var n,e;if(h)for(let s=0;s<r.length;s++)if(!(r[s]instanceof t))throw Error("assertInst objs["+s+"] is not a "+t.prototype.name+". "+(null===(e=null===(n=r[s])||void 0===n?void 0:n.constructor)||void 0===e?void 0:e.name)+r[s]);return!0}function M(...t){if(h)for(let r=0;r<t.length;r++)if("number"!=typeof t[r])throw Error(`assertNumbers arguments[${r}] is not a number. ${typeof t[r]} == typeof ${t[r]}`)}function d(...t){if(h)for(let r=0;r<t.length;r++)if("number"!=typeof t[r]||t[r]%1!=0)throw Error(`assertNumbers arguments[${r}] is not an int. ${typeof t[r]} == typeof ${t[r]}`)}function m(...t){if(h)for(let r=0;r<t.length;r++){const n=t[r];if("number"!=typeof n||isNaN(n)||!isFinite(n))throw Error(`assertNumbers arguments[${r}] = ${n} is not a real.`)}}function y(t,...r){if(h&&!t)throw Error("assert failed: "+r.map((t=>"function"==typeof t?t():t||"")).join("\\n"));return!0}function p(t){throw Error(t)}function A(t,...r){if(h&&!t())throw Error("assertf failed: "+t.toString()+r.map((t=>"function"==typeof t?t():t||"")).join("\\n"))}function g(t,r,n,e){if(h&&!D(n,t,r))throw Error(`${n} is not in [${t}, ${r}] (${e})`)}function F(t,r,n){return t*(1-n)+r*n}function b(t,r,n){return(n-t)/(r-t)}const v=Number.prototype.toString;Number.prototype.toString=function(t){return i==this?"PI":v.call(this,t)};const x=(t,r=a)=>Math.abs(t)<=r,E=(t,r,n=a)=>Math.abs(t-r)<=n,S=(t,r,n=a)=>t-r<-n,N=(t,r,n=a)=>r-t<-n,O=(t,r,n=a)=>t-r<=n,j=(t,r,n=a)=>r-t<=n,k=(t,r)=>z(t-r),z=t=>(t%(2*Math.PI)+2*Math.PI+a)%(2*Math.PI)<2*a,B=(t,r)=>Math.abs(t-r)<=a?r:t,$=(t,...r)=>r.reduce(((t,r)=>Math.abs(t-r)<=a?r:t),t),I=(t,r,...n)=>n.reduce(((t,n)=>Math.abs(t-n)<=r?n:t),t),P=(t,r=a)=>Math.abs(t)<=r?0:t,R=t=>(t%(2*Math.PI)+2*Math.PI)%(2*Math.PI),T=(/* unused pure expression or super */ null && (x));function V(t,r,n){if(void 0===n||0==+n)return t(r);if(n=+n,isNaN(r=+r)||"number"!=typeof n||n%1!=0)return NaN;let e=r.toString().split("e");return e=(r=t(+(e[0]+"e"+(e[1]?+e[1]-n:-n)))).toString().split("e"),+(e[0]+"e"+(e[1]?+e[1]+n:n))}const L=V.bind(void 0,Math.round),X=V.bind(void 0,Math.floor),Y=V.bind(void 0,Math.ceil),Z=1.618033988749895;function C(t,r){return(t%r+r)%r}function U(t,r,n){return M(t,r,n),Math.max(r,Math.min(n,t))}function D(t,r,n){return M(t,r,n),r<=t&&t<=n}function q(t,r,n){return M(t,r,n),O(r,t)&&O(t,n)}function _(t,r,n){const e=t.get(r);e?e.push(n):t.set(r,[n])}function J(t){const r=t=>Math.floor(t*(1<<26))/(1<<26),n=new Map;for(let e=0;e<t.length;e++){const s=t[e],i=r(s);let o;n.has(i)||(o=n.get(i-1/(1<<26)))&&E(o,s)||(o=n.get(i+1/(1<<26)))&&E(o,s)||n.set(i,s)}return Array.from(n.values())}function G(t,r){const n=t=>Math.floor(t*(1<<26))/(1<<26),e=new Map;for(let s=0;s<t.length;s++){const i=t[s],o=n(r(i));let h;e.has(o)||(h=e.get(o-1/(1<<26)))&&E(h,r(i))||(h=e.get(o+1/(1<<26)))&&E(h,r(i))||e.set(o,i)}return Array.from(e.values())}function W(t,r,...n){Object.getOwnPropertyNames(r).forEach((e=>{n.includes(e)||(t.hasOwnProperty(e)&&console.warn("target ",t," already has property ",e,t[e]),Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(r,e)))}))}let H=t=>t;function Q(t){const r=parseFloat(t.replace(",",".").replace(/^[^0-9,.\\-]/,""));return Number.isFinite(r)?r:0}const K=(t,r)=>t-r;function tt(t){return~~(t*(1<<28))}function*rt(t){for(let r=0;r<t;r++)for(let n=r;n<t;n++)yield{i:r,j:n}}function nt(t,r){A((()=>S(0,t))),A((()=>S(0,r)));let n=t,e=r,s=30;for(;s--&&n!=e;)[n,e]=[(n+e)/2,Math.sqrt(n*e)];return y(-1!=s),n}const et=.017453292519943295;function st(t){return t/et}function it(t,r){let n,e,s=1/0;function i(r,i){const o=Math.abs(r-t);return console.log(r,i,o),o<s&&(s=o,n=r,e=i),0==o}if(i(parseFloat(t.toFixed(r)),t.toFixed(r)))return e+"=";const o=""+t,h=o.substr(0,o.indexOf(".")+1),a=o.substr(o.indexOf(".")+1);for(let t=0;t<r;t++)for(let n=t+1;n<=r;n++){const r=a.substr(0,t),s=a.substr(t,n);if(i(parseFloat(h+r+s.repeat(Math.ceil((17-t)/s.length))),h+r+s.split("").map((t=>t+"Ì„")).join("")))return e+"="}return e+(n<t?"-":"+")}function ot(t){const r=performance.now();return t(),performance.now()-r}function ht(t){let r=0;for(let n=0;n<t.length;n++)r=31*r+at(t[n])|0;return 0|r}function at(t){return"number"==typeof t||void 0===t?0|t:Array.isArray(t)?ht(t):null===t?0:t.hashCode()}function ut(t){return t.toString()}function ct(t){return console.log(t),t}function lt(t,r){const n=t*t/4-r;if(n<-a)return[];if(n<=a)return[-t/2];{const r=Math.sqrt(n);return[-t/2-r,-t/2+r]}}function ft(t,r,n,e){if(x(t))return x(r)?[-e/n]:lt(n/r,e/r);const s=t;t=r/s;const i=(3*(r=n/s)-t*t)/3/3,o=i*i*i,h=(2*t*t*t-9*t*r+27*(n=e/s))/27,u=h/2,c=u*u+o;if(c<-a/8){const r=Math.sqrt(-o),n=-h/(2*r),e=Math.acos(n<-1?-1:n>1?1:n),s=2*Math.cbrt(r);return[s*Math.cos(e/3)-t/3,s*Math.cos((e+2*Math.PI)/3)-t/3,s*Math.cos((e+4*Math.PI)/3)-t/3]}if(c<=a/8){if(0==u)return[-t/3];const r=u<0?Math.cbrt(-u):-Math.cbrt(u);return[2*r-t/3,-r-t/3]}{const r=Math.sqrt(c);return[Math.cbrt(-u+r)-Math.cbrt(u+r)-t/3]}}function wt(t,r,n,e,s=0){const i=1e-4;let o=0;for(let h=n;h<e;h+=(e-n)/100){const n=r(h),e=(t(h+i)-t(h))/i;y((o+=+!E(e,n,.1))<=s,`df2 == ${e} != ${r(h)} = df(t)`)}}function Mt(t,r,n,e){y(r<n);let s=t(r),i=t(n);for(y(s*i<0);e--;){const e=(n+r)/2,o=t(e);Math.sign(s)==Math.sign(o)?(r=e,s=o):(n=e,i=o)}return y(r<=(n+r)/2),y(n>=(n+r)/2),F(r,n,.5)}function dt(t,...r){return t+"("+r.map(e).join(",")+")"}function mt(t){return t.replace(/\\/\\/[^\\r\\n]+(?:\\r\\n|\\n\\r|\\r|\\n|$)|\\/\\*(?:[^*]|\\*[^/])+\\*\\/|"(?:[^"\\\\]|\\\\.)+"|\'(?:[^\'\\\\]|\\\\.)+\'|[`}](?:[^`$\\\\]|\\$[^{]|\\\\.)+(?:`|\\${)|(?:\\/(?:(?:(?!\\\\*\\/).)|\\\\\\\\|\\\\\\/|[^\\\\]\\[(?:\\\\\\\\|\\\\]|[^]])+])+\\/)|[^`"\']/g,(t=>t.startsWith("//")||t.startsWith("/*")?"":t))}Object.map=function(t,r,n){const e={};for(const s in t)e[s]=r.call(n,t[s],s,t);return e},String.prototype.capitalizeFirstLetter=function(){return this.charAt(0).toUpperCase()+this.slice(1)},String.prototype.equals=function(t){return this==t},Object.defineProperty(Object.prototype,"sce",{get:function(){return this.toSource()},configurable:!0});const yt=(/* unused pure expression or super */ null && ([-.06405689286260563,.06405689286260563,-.1911188674736163,.1911188674736163,-.3150426796961634,.3150426796961634,-.4337935076260451,.4337935076260451,-.5454214713888396,.5454214713888396,-.6480936519369755,.6480936519369755,-.7401241915785544,.7401241915785544,-.820001985973903,.820001985973903,-.8864155270044011,.8864155270044011,-.9382745520027328,.9382745520027328,-.9747285559713095,.9747285559713095,-.9951872199970213,.9951872199970213])),pt=(/* unused pure expression or super */ null && ([.12793819534675216,.12793819534675216,.1258374563468283,.1258374563468283,.12167047292780339,.12167047292780339,.1155056680537256,.1155056680537256,.10744427011596563,.10744427011596563,.09761865210411388,.09761865210411388,.08619016153195327,.08619016153195327,.0733464814110803,.0733464814110803,.05929858491543678,.05929858491543678,.04427743881741981,.04427743881741981,.028531388628933663,.028531388628933663,.0123412297999872,.0123412297999872]));function At(...t){if(h)for(let t=0;t<arguments.length;t++)if(!(arguments[t]instanceof Ar||arguments[t]instanceof jr))throw Error("assertVectors arguments["+t+"] is not a vector. "+typeof arguments[t]+" == typeof "+arguments[t]);return!0}function gt(t,r,n){return Ft((e=>t(r+(e+1)/2*(n-r))))/2*(n-r)}function Ft(t){return sr(Ct(24,(r=>pt[r]*t(yt[r]))))}function bt(t,r,n,e){const s=(n-r)/e;return sr(Ct(e,(n=>Ft((e=>t(r+s*n+(e+1)/2*s))))))/2*s}function vt(t,r,n,e=32){const s=(n-r)/e;return sr(Ct(e,(t=>r+s/2+s*t)).map(t))*s}function xt(t,r){return gt((t=>Math.pow(1-r*Math.pow(Math.sin(t),2),-.5)),0,t)}function Et(t,r){return gt((t=>Math.pow(1-r*Math.pow(Math.sin(t),2),.5)),0,t)}function St(t,r,n){return t.sort(((t,r)=>t-r)),E(t[0],r)||t.splice(0,0,r),E(mr(t),n)||t.push(n),Ct(t.length-1,(r=>[t[r],t[r+1]]))}function Nt(t,r){const n=Ot(t,r);return y(0!=n),n<0}function Ot(t,r){y(!r.likeO(),"!normal.likeO()");const n=r.maxAbsDim(),e=t.map(((t,r,e)=>{const s=e[(r+1)%e.length];switch(n){case 0:return(s.y-t.y)*(s.z+t.z);case 1:return(s.z-t.z)*(s.x+t.x);case 2:return(s.x-t.x)*(s.y+t.y)}})).reduce(((t,r)=>t+r));return B(e*Math.sign(r.e(n)),0)}function jt(t,r,n=4,e,s=1){e=e||1e-8;for(let i=0;i<n;i++){const n=t(r),i=Er.jacobi(t,r,n,e);y(!i.isZero());const o=i.solveLinearSystem(new jr(new Float64Array(n))).v;y(!isNaN(o[0]));for(let t=0;t<r.length;t++)r[t]-=o[t]*s}return r}function kt(t,r,n=8,e=1e-8){if("number"==typeof e){let s=r;for(let r=0;r<n;r++){const r=t(s);s-=r/((t(s+e)-r)/e)}return s}return zt(t,r,n,e)}function zt(t,r,n=4,e){let s=r;for(let r=0;r<n;r++){const r=t(s),n=e(s);(isNaN(r)||isNaN(n))&&console.log(),s-=r/n,isNaN(r)&&console.log()}return s}function Bt(t,r,n=8,e=-1/0,s=1/0){y(n%1==0);let i=r;for(let r=0;r<n;r++){const[r,n]=t(i);if((isNaN(r)||isNaN(n))&&console.log(),i-=r/n,0==n||i<e||s<i)return}return i}function $t(t,r,n=4,e,s=1e-6){let i=r;for(let r=0;r<n;r++){const r=t(i),o=e(i);if(Math.abs(o)<s&&Math.abs(r)<s)return kt(e,i,n,e);(isNaN(r)||isNaN(o))&&console.log(),i-=r/o,isNaN(r)&&console.log()}return i}function It(t,r,n,e,s){const i=1e-6;s=s||4;let o,h,u=n,c=e;do{o=t(u,c),h=r(u,c);const n=t(u+i,c)-o,e=t(u,c+i)-o,s=r(u+i,c)-h,a=r(u,c+i)-h,l=(n*a-e*s)/i;u-=(a*o-e*h)/l,c-=(-s*o+n*h)/l}while(--s&&Math.pow(o,2)+Math.pow(h,2)>a);if(!(Math.pow(o,2)+Math.pow(h,2)>a))return new Ar(u,c,0);console.log(Math.pow(o,2)+Math.pow(h,2))}function Pt(t,r,n,e,s,i,o,h,u){s=s||4;let c,l,f=n,w=e;do{c=t(f,w),l=r(f,w);const n=i(f,w),e=o(f,w),s=h(f,w),a=u(f,w),M=n*a-e*s;f-=(a*c-e*l)/M,w-=(-s*c+n*l)/M}while(--s&&c*c+l*l>a/32);if(s)return gr(f,w,0)}function Rt(t,r,n,e,s){const i=[];for(let o=r;o<=n;o+=e){const r=e*Math.abs(s(o));if(Math.abs(t(o))<=r){let r=zt(t,o,16,s);x(t(r))&&!x(s(r))||(r=kt(s,o,16)),x(t(r))&&!i.some((t=>E(t,r)))&&i.push(r)}}return i}function Tt(t,r,n){const e=t[r];t[r]=t[n],t[n]=e}function Vt(t,r,n,e,s){for(d(r,e,s),e+=s,s+=r;s-- >r;)n[--e]=t[s];return n}function Lt(t,r,n,e,s,i,o){let h=r+o*n,a=s+o*i;for(;h>r;)e[a-=i]=t[h-=n]}function Xt(t,r,n,e,s,i,o,h){for(let a=0;a<h;a++)Vt(t,r+n*a,e,s+i*a,o)}function Yt(t,r,n=1){M(t,n);const e=Math.ceil((r-t)/n),s=Array(e);for(let r=t,i=0;i<e;r+=n,i++)s[i]=r;return s}function Zt(t,r,n=64){return Ct(n,(e=>F(t,r,e/(n-1))))}function Ct(t,r){M(t),y("function"==typeof r);const n=Array(t);let e=t;for(;e--;)n[e]=r(e,t);return n}function Ut(t,r){let n,e=t.length,s=-1/0;for(;e--;){const i=t[e],o=r(i,e,t);o>s&&(s=o,n=i)}return n}function Dt(t){let r=t.length,n=0;for(;r--;)n+=Math.abs(t[r]);return n}function qt(t,r){return t[C(r,t.length)]}function _t(t,r,n,e,s=1){M(r,e),r<0&&(r=t.length+r),n<=0&&(n=t.length+n);const i=Math.ceil((n-r)/e),o=Array(i);let h=0;for(let i=r;i<n;i+=e)for(let r=i;r<Math.min(i+s,n);r++)o[h++]=t[r];return y(i==h),o}function Jt(t,r=0,n=0,...e){const s=t.length,i=n<0?0:n;let o;o=r<0?Math.abs(r)>s?0:s+r:r>s?s:r;const h=t.length-i+e.length,a=Array(h);let u=h,c=t.length;for(;c-- >o+i;)a[--u]=t[c];for(c=e.length;c--;)a[--u]=e[c];for(c=o;c--;)a[--u]=e[c];return a}function Gt(t,r){if(t===r)return!0;if(Object.getPrototypeOf(r)!==Array.prototype)return!1;if(t.length!==r.length)return!1;for(let n=0;n<t.length;n++)if(!Wt(t[n],r[n]))return!1;return!0}function Wt(t,r){return Array.isArray(t)?Gt(t,r):"object"==typeof t?t.equals(r):t===r}function Ht(t,r){const n=t.length,e=[];for(let s=0;s<n;s++)if(s in t){const n=r(t[s],s,t);n&&e.push(n)}return e}function Qt(t,...r){return t.splice(0,t.length,...r)}function Kt(t){return Array.prototype.concat.apply([],t)}function tr(t){let r=t.length,n=1/0;for(;r--;){const e=t[r];n>e&&(n=e)}return n}function rr(t){let r=t.length,n=-1/0;for(;r--;){const e=t[r];n<e&&(n=e)}return n}function nr(t,r){if(0==t.length)return-1;let n=t.length,e=-1,s=-1/0;for(;n--;){const i=r(t[n],n,t);i>s&&(s=i,e=n)}return e}function er(t){let r=t.length,n=0;for(;r--;)n+=t[r];return n}function sr(t){if(0==t.length)return 0;let r=t.length;for(;1!=r;){const n=Math.floor(r/2),e=Math.ceil(r/2);for(let r=0;r<n;r++)t[r]+=t[r+e];r=e}return t[0]}function ir(t){const r=new Set(t);return Array.from(r)}function or(t,r){const n=t.indexOf(r);return-1!=n&&(t.splice(n,1),!0)}function hr(t,r){const n=t[r];return t.splice(r,1),n}function ar(t,r){const n=t[r];return r==t.length-1?t.pop():t[r]=t.pop(),n}function ur(t,r){const n=t.findIndex(r);if(-1!=n)return hr(t,n)}function cr(t,r){let n=r.length;for(;n--;)or(t,r[n])}function lr(t,r){const n=t.indexOf(r);return-1!=n?(t.splice(n,1),!1):(t.push(r),!0)}function fr(t,r){const n=t.indexOf(r);return-1!=n?(ar(t,n),!1):(t.push(r),!0)}function wr(t,r,n=((t,r)=>t-r)){let e,s,i=0,o=t.length-1;for(;i<=o;)if(e=(i+o)/2|0,s=t[e],n(s,r)<0)i=e+1;else{if(!(n(s,r)>0))return e;o=e-1}return-i-1}function Mr(t,r,n=K){let e,s,i=0,o=t.length;for(;i<o;)e=~~((i+o)/2),s=t[e],n(s,r)<0?i=e+1:o=e;t.splice(i,0,r)}function dr(t,r){for(let n=1;n<t.length;n++)if(r(t[n-1],t[n])>0)return n;return-1}function mr(t){return t[t.length-1]}function yr(t,r){return t[t.length-1]=r}function pr(t,r){if(r.sort(((t,r)=>t-r)),0===r.length)return t;if(1===r.length)return t.splice(r[0],1),t;let n=r[0],e=r[0],s=0;for(let i=r[0];i<t.length;i++)if(i!==e)t[n++]=t[i];else{if(s++,!(s<r.length))return t.splice(n,i+1-n),t;e=r[s]}throw Error("illegal state")}class Ar{constructor(t,r,n){this.x=t,this.y=r,this.z=n,M(t,r,n)}static random(){return new Ar(Math.random(),Math.random(),Math.random())}static parallel(t,r){return t.dot(r)-t.length()*r.length()}static randomUnit(){const t=2*Math.random()*Math.PI,r=2*Math.random()-1,n=Math.sqrt(1-Math.pow(r,2));return new Ar(n*Math.cos(t),n*Math.sin(t),r)}static fromAngles(t,r){throw Error()}static fromFunction(t){return new Ar(t(0),t(1),t(2))}static min(t,r){return new Ar(Math.min(t.x,r.x),Math.min(t.y,r.y),Math.min(t.z,r.z))}static max(t,r){return new Ar(Math.max(t.x,r.x),Math.max(t.y,r.y),Math.max(t.z,r.z))}static lerp(t,r,n){return new Ar(t.x*(1-n)+r.x*n,t.y*(1-n)+r.y*n,t.z*(1-n)+r.z*n)}static fromArray(t){return new Ar(t[0],t[1],t[2])}static angleBetween(t,r){return t.angleTo(r)}static zip(t,...r){return y(t instanceof Function),new Ar(t.apply(void 0,r.map((t=>t.x))),t.apply(void 0,r.map((t=>t.y))),t.apply(void 0,r.map((t=>t.z))))}static normalOnPoints(t,r,n){return At(t,r,n),t.to(r).cross(t.to(n))}static add(...t){At(...t);let r=0,n=0,e=0,s=t.length;for(;s--;)r+=t[s].x,n+=t[s].y,e+=t[s].z;return new Ar(r,n,e)}static sub(...t){At(...t);let r=t[0].x,n=t[0].y,e=t[0].z,s=t.length;for(;s--;)r-=t[s].x,n-=t[s].y,e-=t[s].z;return new Ar(r,n,e)}static pack(t,r,n=0,e=0,s=t.length-n){const i=r||new Float32Array(3*s);y(i.length-e>=3*s,"dest.length - destStart >= v3count * 3",i.length,e,3*s);let o=s,h=n,a=e;for(;o--;){const r=t[h++];i[a++]=r.x,i[a++]=r.y,i[a++]=r.z}return i}static unpack(t,r,n=0,e=0,s=(t.length-n)/3){y((r=r||Array(s)).length-e>=s,"dest.length - destStart >= v3count");let i=s,o=n,h=e;for(;i--;)r[h++]=new Ar(t[o++],t[o++],t[o++]);return r}static packXY(t,r,n=0,e=0,s=t.length-n){const i=r||new Float32Array(2*s);y(i.length-e>=s,"dest.length - destStart >= v3count");let o=s,h=n,a=e;for(;o--;){const r=t[h++];i[a++]=r.x,i[a++]=r.y}return i}static unpackXY(t,r,n=0,e=0,s=Math.min(t.length/2,r&&r.length||1/0)-e){y((r=r||Array(s)).length-e>=s,"dest.length - destStart >= v3count"),y(t.length-n>=2*s,"dest.length - destStart >= v3count");let i=s,o=n,h=e;for(;i--;)r[h++]=new Ar(t[o++],t[o++],0);return r}static perturbed(t,r){return t.perturbed(r)}static polar(t,r,n=0){return new Ar(t*Math.cos(r),t*Math.sin(r),n)}static sphere(t,r,n=1){return new Ar(n*Math.cos(r)*Math.cos(t),n*Math.cos(r)*Math.sin(t),n*Math.sin(r))}static inverseLerp(t,r,n){const e=t.to(r);return t.to(n).dot(e)/e.squared()}get 0(){return this.x}get 1(){return this.y}get 2(){return this.z}get u(){return this.x}get v(){return this.y}perturbed(t=.8*a){return this.map((r=>r+(Math.random()-.5)*t))}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}e(t){return y(t>=0&&t<3),0==t?this.x:1==t?this.y:this.z}negated(){return new Ar(-this.x,-this.y,-this.z)}abs(){return new Ar(Math.abs(this.x),Math.abs(this.y),Math.abs(this.z))}plus(t){return At(t),new Ar(this.x+t.x,this.y+t.y,this.z+t.z)}schur(t){return new Ar(this.x*t.x,this.y*t.y,this.z*t.z)}divv(t){return new Ar(this.x/t.x,this.y/t.y,this.z/t.z)}minus(t){return At(t),new Ar(this.x-t.x,this.y-t.y,this.z-t.z)}to(t){return At(t),t.minus(this)}times(t){return M(t),new Ar(this.x*t,this.y*t,this.z*t)}div(t){return M(t),new Ar(this.x/t,this.y/t,this.z/t)}dot(t){return w(Ar,t),this.x*t.x+this.y*t.y+this.z*t.z}lerp(t,r){return At(t),M(r),Ar.lerp(this,t,r)}squared(){return this.dot(this)}distanceTo(t){return At(t),Math.hypot(this.x-t.x,this.y-t.y,this.z-t.z)}distanceToSquared(t){return At(t),this.minus(t).squared()}toSource(){return Ar.NAMEMAP.get(this)||this.toString()}nonParallelVector(){const t=this.abs();return t.x<=t.y&&t.x<=t.z?Ar.X:t.y<=t.x&&t.y<=t.z?Ar.Y:Ar.Z}slerp(t,r){At(t),M(r);const n=Math.sin,e=this.angleTo(t);return this.times(n((1-r)*e)/n(e)).plus(t.times(n(r*e)/n(e)))}min(t){return new Ar(Math.min(this.x,t.x),Math.min(this.y,t.y),Math.min(this.z,t.z))}max(t){return new Ar(Math.max(this.x,t.x),Math.max(this.y,t.y),Math.max(this.z,t.z))}equals(t){return this==t||this.x==t.x&&this.y==t.y&&this.z==t.z}cross(t){return new Ar(this.y*t.z-this.z*t.y,this.z*t.x-this.x*t.z,this.x*t.y-this.y*t.x)}minElement(){return Math.min(this.x,this.y,this.z)}maxElement(){return Math.max(this.x,this.y,this.z)}toArray(t=3){return[this.x,this.y,this.z].slice(0,t)}getPerpendicular(){if(x(this.x)&&x(this.y)){if(x(this.z))throw Error("zero vector");return Ar.Y}return new Ar(-this.y,this.x,0)}dim(){return 3}els(){return[this.x,this.y,this.z]}angleXY(){return Math.atan2(this.y,this.x)}lengthXY(){return Math.hypot(this.x,this.y)}squaredXY(){return this.x*this.x+this.y*this.y}xy(){return new Ar(this.x,this.y,0)}map(t){return new Ar(t(this.x,"x"),t(this.y,"y"),t(this.z,"z"))}toString(t){return t=t||H,Ar.NAMEMAP.get(this)||"V("+[this.x,this.y,this.z].map(t).join(", ")+")"}angleTo(t){return y(1==arguments.length),At(t),y(!this.likeO()),y(!t.likeO()),Math.acos(Math.min(1,this.dot(t)/this.length()/t.length()))}angleRelativeNormal(t,r){return y(2==arguments.length),At(t,r),A((()=>r.hasLength(1))),Math.atan2(this.cross(t).dot(r),this.dot(t))}isParallelTo(t){At(t),y(!this.likeO()),y(!t.likeO());const r=this.dot(t);return E(this.squared()*t.squared(),r*r)}isPerpendicularTo(t){return At(t),y(!this.likeO(),"!this.likeO()"),y(!t.likeO(),"!vector.likeO()"),x(this.dot(t))}isReverseDirTo(t){At(t),y(!this.likeO()),y(!t.likeO());const r=this.dot(t);return E(Math.sqrt(this.squared()*t.squared()),r)}length(){return Math.hypot(this.x,this.y,this.z)}likeO(){return this.like(Ar.O)}like(t){return t===this||t instanceof Ar&&E(this.x,t.x)&&E(this.y,t.y)&&E(this.z,t.z)}likeOrReversed(t){return E(Math.abs(this.dot(t)),Math.sqrt(this.squared()*t.squared()))}unit(){return y(!this.likeO(),"cannot normalize zero vector"),this.div(this.length())}normalized(){throw Error("documentation stub. use .unit()")}toLength(t){return M(t),this.times(t/this.length())}projectedOn(t){return At(t),t.times(this.dot(t)/t.dot(t))}rejectedFrom(t){return At(t),this.minus(t.times(this.dot(t)/t.dot(t)))}rejectedFrom1(t){return At(t),y(t.hasLength(1)),this.minus(t.times(this.dot(t)))}rejectedLength(t){return At(t),Math.sqrt(this.dot(this)-Math.pow(this.dot(t),2)/t.dot(t))}rejected1Length(t){return At(t),y(t.hasLength(1)),Math.sqrt(this.dot(this)-Math.pow(this.dot(t),2))}hasLength(t){return M(t),E(t,this.length())}absSum(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}minAbsElement(){return Math.min(Math.abs(this.x),Math.abs(this.y),Math.min(this.z))}maxAbsElement(){return Math.max(Math.abs(this.x),Math.abs(this.y),Math.abs(this.z))}maxAbsDim(){const t=Math.abs(this.x),r=Math.abs(this.y),n=Math.abs(this.z);return t>=r?t>=n?0:2:r>=n?1:2}minAbsDim(){const t=Math.abs(this.x),r=Math.abs(this.y),n=Math.abs(this.z);return t<r?t<n?0:2:r<n?1:2}withElement(t,r){return y(["x","y","z"].includes(t),""+t),M(r),"x"==t?new Ar(r,this.y,this.z):"y"==t?new Ar(this.x,r,this.z):new Ar(this.x,this.y,r)}hashCode(){function t(t){return~~(t*(1<<28))}return~~(31*(31*t(this.x)+t(this.y))+t(this.z))}hashCodes(){const t=~~(31*(31*~~(this.x*(1<<28)-.5)+~~(this.y*(1<<28)-.5))+~~(this.z*(1<<28)-.5));return[~~t,~~(t+961),~~(t+31),~~(t+31+961),~~(t+1),~~(t+1+961),~~(t+1+31),~~(t+1+31+961)]}compareTo(t){return this.x!=t.x?this.x-t.x:this.y!=t.y?this.y-t.y:this.z-t.z}compareTo2(t,r=a){return E(this.x,t.x,r)?E(this.y,t.y,r)?E(this.z,t.z,r)?0:this.z-t.z:this.y-t.y:this.x-t.x}toAngles(){return{theta:Math.atan2(this.y,this.x),phi:Math.asin(this.z/this.length())}}}function gr(t,r,n){if(3==arguments.length)return new Ar(parseFloat(t),parseFloat(r),parseFloat(n));if(2==arguments.length)return new Ar(parseFloat(t),parseFloat(r),0);if(1==arguments.length&&"object"==typeof t){if(t instanceof Ar)return t;if(t instanceof Array||t instanceof Float32Array||t instanceof Float64Array){if(2==t.length)return new Ar(parseFloat(t[0]),parseFloat(t[1]),0);if(3==t.length)return new Ar(parseFloat(t[0]),parseFloat(t[1]),parseFloat(t[2]))}else if("x"in t&&"y"in t)return new Ar(parseFloat(t.x),parseFloat(t.y),"z"in t?parseFloat(t.z):0)}throw Error("invalid arguments"+arguments)}Ar.O=new Ar(0,0,0),Ar.X=new Ar(1,0,0),Ar.Y=new Ar(0,1,0),Ar.Z=new Ar(0,0,1),Ar.XY=new Ar(1,1,0),Ar.XYZ=new Ar(1,1,1),Ar.INF=new Ar(1/0,1/0,1/0),Ar.UNITS=[Ar.X,Ar.Y,Ar.Z],Ar.NAMEMAP=(new JavaMap).set(Ar.O,"V3.O").set(Ar.X,"V3.X").set(Ar.Y,"V3.Y").set(Ar.Z,"V3.Z").set(Ar.XYZ,"V3.XYZ").set(Ar.INF,"V3.INF");const Fr={normal1:Ar.X,w:0},br={normal1:Ar.Y,w:0},vr={normal1:Ar.Z,w:0};class xr{mirror(t){return this.transform(Or.mirror(t))}mirroredX(){return this.mirror(Fr)}mirrorY(){return this.mirror(br)}mirrorZ(){return this.mirror(vr)}project(t){return this.transform(Or.project(t))}projectXY(){return this.transform(Or.project(vr))}projectYZ(){return this.transform(Or.project(Fr))}projectZX(){return this.transform(Or.project(br))}translate(...t){return this.transform(Or.translate.apply(void 0,t),dt(".translate",...t))}scale(...t){return this.transform(Or.scale.apply(void 0,t),dt(".scale",...t))}rotateX(t){return this.transform(Or.rotateX(t),`.rotateX(${t})`)}rotateY(t){return this.transform(Or.rotateY(t),`.rotateY(${t})`)}rotateZ(t){return this.transform(Or.rotateZ(t),`.rotateZ(${t})`)}rotate(t,r,n){return this.transform(Or.rotateLine(t,r,n),dt(".rotate",t,r,n))}rotateAB(t,r){return this.transform(Or.rotateAB(t,r),dt(".rotateAB",t,r))}eulerZXZ(t,r,n){throw Error()}shearX(t,r){return this.transform(new Or([1,t,r,0,0,1,0,0,0,0,1,0,0,0,0,1]))}foo(){return this.transform(Or.FOO)}fooInv(){return this.transform(Or.FOO_INV)}visit(t,...r){let n=Object.getPrototypeOf(this);for(;!t.hasOwnProperty(n.constructor.name)&&n!==xr.prototype;)n=Object.getPrototypeOf(n);if(t.hasOwnProperty(n.constructor.name))return t[n.constructor.name].apply(this,r);throw Error("No implementation for "+this.constructor.name)}}class Er{constructor(t,r,n){this.width=t,this.height=r,this.m=n,d(t,r),A((()=>0<t)),A((()=>0<r)),y(t*r==n.length,"width * height == m.length",t,r,n.length)}static random(t,r){return Er.fromFunction(t,r,(()=>Math.random()))}static fromFunction(t,r,n){const e=new Float64Array(r*t);let s=r*t;for(;s--;)e[s]=n(Math.floor(s/t),s%t,s);return new Er(t,r,e)}static identityN(t){d(t);const r=new Float64Array(t*t);let n=t*(t+1);for(;n;)n-=t+1,r[n]=1;return new Er(t,t,r)}static permutation(t,r,n){d(t,r,n),A((()=>0<=r&&r<t)),A((()=>0<=n&&n<t));const e=new Float64Array(t*t);let s=t*(t+1);for(;s;)s-=t+1,e[s]=1;return e[r*t+r]=0,e[n*t+n]=0,e[r*t+n]=1,e[n*t+r]=1,new Er(t,t,e)}static fromRowArrays(...t){if(0==t.length)throw Error("cannot have 0 vector");const r=t.length,n=t[0].length,e=new Float64Array(r*n);Vt(t[0],0,e,0,n);for(let s=1;s<r;s++){if(t[s].length!=n)throw Error("all row arrays must be the same length");Vt(t[s],0,e,s*n,n)}return this.new(n,r,e)}static fromColVectors(t){return Er.fromColArrays(...t.map((t=>t.v)))}static forWidthHeight(t,r){return new Er(t,r,new Float64Array(t*r))}static fromColArrays(...t){if(0==t.length)throw Error("cannot have 0 vector");const r=t.length,n=t[0].length,e=new Float64Array(n*r);Lt(t[0],0,1,e,0,r,n);for(let s=1;s<r;s++){if(t[s].length!=n)throw Error("all col arrays must be the same length");Lt(t[s],0,1,e,s,r,n)}return this.new(r,n,e)}static product(...t){const[r,n]=Array.isArray(t[0])?[t[0],t[1]]:[t,void 0];if(0==r.length)throw Error("Can\'t guess matrix size.");return 1==r.length?Er.copy(r[0],n):Er.copy(r.reduce(((t,r)=>t.times(r))),n)}static jacobi(t,r,n=t(r),e=1e-6){const s=Er.forWidthHeight(r.length,n.length);for(let i=0;i<r.length;i++){r[i]+=e;const o=t(r);for(let t=0;t<n.length;t++){const r=(o[t]-n[t])/e;s.setEl(t,i,r)}r[i]-=e}return s}static copy(t,r=t.new()){w(Er,t,r),y(t.width==r.width),y(t.height==r.height),y(r!=t,"result != src");const n=t.m,e=r.m;let s=n.length;for(;s--;)e[s]=n[s];return r}static new(t,r,n){return new Er(t,r,n)}copy(){return Er.copy(this)}e(t,r){return d(t,r),y(0<=t&&t<this.height,"rowIndex out of bounds "+t),y(0<=r&&r<this.width,"colIndex out of bounds "+r),this.m[t*this.width+r]}setEl(t,r,n){d(t,r),y(0<=t&&t<this.height,"rowIndex out of bounds "+t),y(0<=r&&r<this.width,"colIndex out of bounds "+r),M(n),this.m[t*this.width+r]=n}plus(t){y(this.width==t.width),y(this.height==t.height);const r=this.new();let n=this.m.length;for(;n--;)r.m[n]=this.m[n]+t.m[n];return r}minus(t){y(this.width==t.width),y(this.height==t.height);const r=this.new();let n=this.m.length;for(;n--;)r.m[n]=this.m[n]-t.m[n];return r}mulScalar(t){M(t);const r=this.new();let n=this.m.length;for(;n--;)r.m[n]=this.m[n]*t;return r}divScalar(t){M(t);const r=this.new();let n=this.m.length;for(;n--;)r.m[n]=this.m[n]/t;return r}new(){return new Er(this.width,this.height,new Float64Array(this.width*this.height))}toString(t,r,n){y("string"==typeof(t=t||(t=>t.toFixed(6)))(0),typeof t(0)),y(!r||r.length==this.width),y(!n||n.length==this.height);const e=Array.from(this.m).map(t),s=Ct(this.height,(t=>e.slice(t*this.width,(t+1)*this.width)));r&&s.unshift(Array.from(r)),n&&s.forEach(((t,e)=>t.unshift(n[e-(r?1:0)]||"")));const i=Ct(this.width,(t=>rr(s.map((r=>r[t].length)))));return s.map(((t,e)=>t.map(((t,s)=>(0==e&&r||0==s&&n?String.prototype.padEnd:String.prototype.padStart).call(t,i[s]))).join("  "))).map((t=>t+"\\n")).join("")}row(t){d(t),y(0<=t&&t<this.height,"rowIndex out of bounds "+t);const r=new Float64Array(this.width);return Vt(this.m,t*this.width,r,0,this.width),new jr(r)}col(t){d(t),y(0<=t&&t<this.width,"colIndex out of bounds "+t);const r=new Float64Array(this.height);return Lt(this.m,t,this.width,r,0,1,this.height),new jr(r)}dim(){return{width:this.width,height:this.height}}dimString(){return this.width+"x"+this.height}equals(t){if(t.constructor!=this.constructor)return!1;if(this.width!=t.width||this.height!=t.height)return!1;let r=this.m.length;for(;r--;)if(this.m[r]!=t.m[r])return!1;return!0}equalsMatrix(t,r=a){if(w(Er,t),this.width!=t.width||this.height!=t.height)return!1;let n=this.m.length;for(;n--;)if(Math.abs(this.m[n]-t.m[n])>r)return!1;return!0}hashCode(){let t=0,r=this.m.length;for(;r--;)t=31*t+tt(this.m[r]);return t}isZero(){let t=this.m.length;for(;t--;)if(!x(this.m[t]))return!1;return!0}isOrthogonal(){return this.isSquare()&&this.transposed().times(this).equalsMatrix(Er.identityN(this.width))}luDecomposition(){const t=this.width,r=this.height,n=this.asRowArrays(Float64Array),e=Ct(r,(()=>new Float64Array(r))),s=Er.identityN(r).asRowArrays(Float64Array);let i=0;for(let o=0;o<t;o++){i=o;let h=0,a=-1,u=0;for(let t=i;t<r;t++){const r=n[t][o];u+=+(0!=r),Math.abs(r)>h&&(h=Math.abs(r),a=t)}if(0!=h&&(y(-1!==a),Tt(n,i,a),Tt(e,i,a),Tt(s,i,a),e[i][o]=1,1<u))for(let s=i+1;s<r;s++){const r=n[s][o]/n[i][o];e[s][o]=r;for(let e=o;e<t;e++)n[s][e]-=r*n[i][e]}}return{L:Er.fromRowArrays(...e),U:Er.fromRowArrays(...n),P:Er.fromRowArrays(...s)}}qrDecompositionGivensRotation(){const t=this.copy();function r(t,r,n,e,s){const i=Er.identityN(t);return i.setEl(r,r,e),i.setEl(n,n,e),i.setEl(r,n,s),i.setEl(n,r,-s),i}let n=Er.identityN(this.height);for(let e=0;e<this.width;e++)for(let s=e+1;s<this.height;s++){const i=t.e(e,e),o=t.e(s,e);if(0==o)continue;const h=Math.hypot(i,o),a=i/h,u=o/h;for(let r=e;r<this.width;r++){const n=t.e(e,r)*a+t.e(s,r)*u,i=t.e(s,r)*a-t.e(e,r)*u;t.setEl(e,r,n),t.setEl(s,r,i)}n=r(this.height,e,s,a,u).times(n)}return{Q:n.transposed(),R:t}}isPermutation(){return!(!this.isSquare()||this.m.some((t=>!x(t)&&!E(1,t)))||this.asRowArrays(Array).some((t=>1!=t.filter((t=>E(1,t))).length))||this.asColArrays(Array).some((t=>1!=t.filter((t=>E(1,t))).length)))}isDiagonal(t){let r=this.m.length;for(;r--;)if(0!=r%(this.width+1)&&!x(this.m[r],t))return!1;return!0}isIdentity(t){return this.isLowerUnitriangular(t)&&this.isUpperTriangular(t)}isUpperTriangular(t){return this.isSquare()&&this.isUpperTrapezoidal(t)}isUpperTrapezoidal(t=a){for(let r=1;r<this.height;r++)for(let n=0;n<r;n++)if(!x(this.m[r*this.width+n],t))return!1;return!0}isSymmetric(t=a){if(!this.isSquare())return!1;for(let r=0;r<this.height-1;r++)for(let n=r+1;n<this.width;n++){const e=this.m[r*this.width+n],s=this.m[n*this.width+r];if(!E(e,s,t))return!1}return!0}solveLinearSystem(t){w(jr,t);const{L:r,U:n,P:e}=this.luDecomposition(),s=r.solveForwards(e.timesVector(t));return n.solveBackwards(s)}isLowerUnitriangular(t=a){if(!this.isSquare())return!1;for(let r=0;r<this.height-1;r++)for(let n=r;n<this.width;n++){const e=this.m[r*this.width+n];if(r==n?!E(1,e,t):!x(e,t))return!1}return!0}isLowerTriangular(t){return this.isSquare()&&this.isLowerTrapezoidal(t)}isLowerTrapezoidal(t=a){for(let r=0;r<this.height-1;r++)for(let n=r+1;n<this.width;n++)if(!x(this.m[r*this.width+n],t))return!1;return!0}solveBackwards(t){At(t),y(this.height==t.dim(),"this.height == x.dim()"),y(this.isUpperTriangular(),"this.isUpperTriangular()\\n"+this.toString());const r=new Float64Array(this.width);let n=this.height;for(;n--;){let e=t.v[n];for(let t=n+1;t<this.width;t++)e-=r[t]*this.e(n,t);r[n]=e/this.e(n,n)}return new jr(r)}solveBackwardsMatrix(t){const r=Array(t.width);let n=t.width;for(;n--;)r[n]=this.solveBackwards(t.col(n));return Er.fromColVectors(r)}solveForwardsMatrix(t){const r=Array(t.width);let n=t.width;for(;n--;)r[n]=this.solveForwards(t.col(n));return Er.fromColVectors(r)}solveForwards(t){At(t),y(this.height==t.dim(),"this.height == x.dim()"),A((()=>this.isLowerTriangular()),this.toString());const r=new Float64Array(this.width);for(let n=0;n<this.height;n++){let e=t.v[n];for(let t=0;t<n;t++)e-=r[t]*this.e(n,t);r[n]=e/this.e(n,n)}return new jr(r)}rank(){const t=this.luDecomposition().U;let r=this.height,n=this.height;for(;r--;)n-=+t.row(r).isZero();return n}rowsIndependent(){return this.height==this.rank()}colsIndependent(){return this.width==this.rank()}asRowArrays(t=Float64Array){return Ct(this.height,(r=>this.rowArray(r,t)))}asColArrays(t=Float64Array){return Ct(this.width,(r=>this.colArray(r,t)))}rowArray(t,r=Float64Array){const n=new r(this.width);return Vt(this.m,t*this.width,n,0,this.width)}colArray(t,r=Float64Array){const n=new r(this.width);return Lt(this.m,t,this.height,n,0,1,this.height),n}subMatrix(t,r,n,e){y(0<t&&0<r&&0<n&&0<e),y(t+r<=this.width&&n+e<=this.height);const s=new Float64Array(r*e);return Xt(this.m,t,this.width,s,0,r,e,r),new Er(r,e,s)}map(t){return new Er(this.width,this.height,this.m.map(t))}dimEquals(t){return w(Er,t),this.width==t.width&&this.height==t.height}inversed(){if(this.isSquare()){if(2==this.width)return this.inversed2();if(3==this.width)return this.inversed3();if(4==this.width)return this.inversed4()}const{L:t,U:r,P:n}=this.luDecomposition(),e=t.solveForwardsMatrix(n);return r.solveBackwardsMatrix(e)}inversed2(){A((()=>2==this.width&&2==this.height));const t=Er.forWidthHeight(2,2),r=this.m,n=t.m,e=r[0]*r[3]-r[1]*n[2];return n[0]=r[3]/e,n[1]=-r[2]/e,n[2]=-r[1]/e,n[3]=r[0]/e,t}inversed3(t=Er.forWidthHeight(3,3)){w(Er,t),A((()=>3==this.width&&3==this.height)),A((()=>3==t.width&&3==t.height)),y((()=>this!=t));const r=this.m,n=t.m;n[0]=r[4]*r[8]-r[5]*r[7],n[1]=-r[1]*r[8]+r[2]*r[7],n[2]=r[1]*r[5]-r[2]*r[4],n[3]=-r[3]*r[8]+r[5]*r[6],n[4]=r[0]*r[8]-r[2]*r[6],n[5]=-r[0]*r[5]+r[2]*r[3],n[6]=r[3]*r[7]-r[4]*r[6],n[7]=-r[0]*r[7]+r[1]*r[6],n[8]=r[0]*r[4]-r[1]*r[3];const e=r[0]*n[0]+r[1]*n[3]+r[2]*n[6];let s=9;for(;s--;)n[s]/=e;return t}inversed4(t=Er.forWidthHeight(4,4)){w(Er,t),A((()=>4==this.width&&4==this.height)),A((()=>4==t.width&&4==t.height)),y((()=>this!=t));const r=this.m,n=t.m;n[0]=r[5]*r[10]*r[15]-r[5]*r[14]*r[11]-r[6]*r[9]*r[15]+r[6]*r[13]*r[11]+r[7]*r[9]*r[14]-r[7]*r[13]*r[10],n[1]=-r[1]*r[10]*r[15]+r[1]*r[14]*r[11]+r[2]*r[9]*r[15]-r[2]*r[13]*r[11]-r[3]*r[9]*r[14]+r[3]*r[13]*r[10],n[2]=r[1]*r[6]*r[15]-r[1]*r[14]*r[7]-r[2]*r[5]*r[15]+r[2]*r[13]*r[7]+r[3]*r[5]*r[14]-r[3]*r[13]*r[6],n[3]=-r[1]*r[6]*r[11]+r[1]*r[10]*r[7]+r[2]*r[5]*r[11]-r[2]*r[9]*r[7]-r[3]*r[5]*r[10]+r[3]*r[9]*r[6],n[4]=-r[4]*r[10]*r[15]+r[4]*r[14]*r[11]+r[6]*r[8]*r[15]-r[6]*r[12]*r[11]-r[7]*r[8]*r[14]+r[7]*r[12]*r[10],n[5]=r[0]*r[10]*r[15]-r[0]*r[14]*r[11]-r[2]*r[8]*r[15]+r[2]*r[12]*r[11]+r[3]*r[8]*r[14]-r[3]*r[12]*r[10],n[6]=-r[0]*r[6]*r[15]+r[0]*r[14]*r[7]+r[2]*r[4]*r[15]-r[2]*r[12]*r[7]-r[3]*r[4]*r[14]+r[3]*r[12]*r[6],n[7]=r[0]*r[6]*r[11]-r[0]*r[10]*r[7]-r[2]*r[4]*r[11]+r[2]*r[8]*r[7]+r[3]*r[4]*r[10]-r[3]*r[8]*r[6],n[8]=r[4]*r[9]*r[15]-r[4]*r[13]*r[11]-r[5]*r[8]*r[15]+r[5]*r[12]*r[11]+r[7]*r[8]*r[13]-r[7]*r[12]*r[9],n[9]=-r[0]*r[9]*r[15]+r[0]*r[13]*r[11]+r[1]*r[8]*r[15]-r[1]*r[12]*r[11]-r[3]*r[8]*r[13]+r[3]*r[12]*r[9],n[10]=r[0]*r[5]*r[15]-r[0]*r[13]*r[7]-r[1]*r[4]*r[15]+r[1]*r[12]*r[7]+r[3]*r[4]*r[13]-r[3]*r[12]*r[5],n[11]=-r[0]*r[5]*r[11]+r[0]*r[9]*r[7]+r[1]*r[4]*r[11]-r[1]*r[8]*r[7]-r[3]*r[4]*r[9]+r[3]*r[8]*r[5],n[12]=-r[4]*r[9]*r[14]+r[4]*r[13]*r[10]+r[5]*r[8]*r[14]-r[5]*r[12]*r[10]-r[6]*r[8]*r[13]+r[6]*r[12]*r[9],n[13]=r[0]*r[9]*r[14]-r[0]*r[13]*r[10]-r[1]*r[8]*r[14]+r[1]*r[12]*r[10]+r[2]*r[8]*r[13]-r[2]*r[12]*r[9],n[14]=-r[0]*r[5]*r[14]+r[0]*r[13]*r[6]+r[1]*r[4]*r[14]-r[1]*r[12]*r[6]-r[2]*r[4]*r[13]+r[2]*r[12]*r[5],n[15]=r[0]*r[5]*r[10]-r[0]*r[9]*r[6]-r[1]*r[4]*r[10]+r[1]*r[8]*r[6]+r[2]*r[4]*r[9]-r[2]*r[8]*r[5];const e=r[0]*n[0]+r[1]*n[4]+r[2]*n[8]+r[3]*n[12];let s=16;for(;s--;)n[s]/=e;return t}canMultiply(t){return w(Er,t),this.width==t.height}times(t){w(Er,t),y(this.canMultiply(t),`Cannot multiply this ${this.dimString()} by matrix ${t.dimString()}`);const r=t.width,n=this.height,e=this.width,s=new Float64Array(r*n);let i=n;for(;i--;){let n=r;for(;n--;){let o=0,h=e;for(;h--;)o+=this.m[i*e+h]*t.m[h*r+n];s[i*r+n]=o}}return new Er(r,n,s)}timesVector(t){At(t),y(this.width==t.dim());const r=this.height,n=this.width,e=new Float64Array(r);let s=r;for(;s--;){let r=0,i=n;for(;i--;)r+=this.m[s*n+i]*t.v[i];e[s]=r}return new jr(e)}transposed(){const t=this.height,r=this.width,n=new Float64Array(t*r);let e=r;for(;e--;){let s=t;for(;s--;)n[e*t+s]=this.m[s*r+e]}return new Er(t,r,n)}transpose(){const t=this.height,r=this.width,n=this.m;let e=t;for(;e--;){let s=Math.min(e,r);for(;s--;){const i=n[e*r+s];n[e*r+s]=n[s*t+e],n[s*t+e]=i}}this.width=t,this.height=r}isSquare(){return this.height==this.width}diagonal(){if(!this.isSquare())throw Error("!!");const t=new Float64Array(this.width);let r=this.width*(this.width+1),n=this.width;for(;n--;)r-=this.width+1,t[n]=this.m[r];return new jr(t)}maxEl(){return rr(this.m)}minEl(){return tr(this.m)}maxAbsColSum(){let t=0,r=this.width;for(;r--;){let n=0,e=this.height;for(;e--;)n+=Math.abs(this.m[e*this.width+r]);t=Math.max(t,n)}return t}maxAbsRowSum(){let t=0,r=this.height;for(;r--;){let n=0,e=this.width;for(;e--;)n+=Math.abs(this.m[r*this.width+e]);t=Math.max(t,n)}return t}getTriangularDeterminant(){y(this.isUpperTriangular()||this.isLowerTriangular(),"not a triangular matrix");let t=1,r=this.width*(this.width+1);for(;r;)r-=this.width+1,t*=this.m[r];return t}getDeterminant(){return this.luDecomposition().U.getTriangularDeterminant()}hasFullRank(){return Math.min(this.width,this.height)==this.rank()}permutationAsIndexMap(){A((()=>this.isPermutation()));const t=Array(this.height);let r=this.height;for(;r--;){const n=r*this.width;let e=n;for(;this.m[e]<.5;)e++;t[r]=e-n}return t}getDependentRowIndexes(t=this.luDecomposition()){const{L:r,U:n,P:e}=t,s=Array(this.height);let i=this.height;for(;i--&&n.row(i).length()<a;)s[i]=!0;let o=this.height;for(;o--;)if(s[o]){let t=Math.min(o,this.width);for(;t--;)0!==r.e(o,t)&&(s[t]=!0)}console.log("m\\n",this.toString((t=>""+t))),console.log("L\\n",r.toString((t=>""+t))),console.log("U\\n",n.toString((t=>""+t))),console.log("P\\n",e.toString((t=>""+t)));const h=e.permutationAsIndexMap();return s.map(((t,r)=>t&&h[r])).filter((t=>null!=t))}lerp(t,r,n=this.new()){w(Er,t,n),M(r),y(this.width==t.width&&this.height==t.height);const e=1-r;let s=this.m.length;for(;s--;)n.m[s]=e*this.m[s]+r*t.m[s];return n}}const{PI:Sr,abs:Nr}=Math;class Or extends Er{constructor(...t){let r;if(0==t.length)r=new Float64Array(16);else{const n=Kt(t);y(16==n.length,"flattened.length == 16 "+n.length),r=new Float64Array(n)}super(4,4,r)}static inverse(t,r=new Or){return t.inversed4(r)}static permutation4(t,r,n=new Or){d(t,r),A((()=>0<=t&&t<4)),A((()=>0<=r&&r<4));const e=n.m;return Or.identity(n),e[4*t+t]=0,e[4*r+r]=0,e[4*t+r]=1,e[4*r+t]=1,n}static transpose(t,r=new Or){w(Or,t),w(Or,r),y(t!=r,"matrix != result");const n=t.m,e=r.m;return e[0]=n[0],e[1]=n[4],e[2]=n[8],e[3]=n[12],e[4]=n[1],e[5]=n[5],e[6]=n[9],e[7]=n[13],e[8]=n[2],e[9]=n[6],e[10]=n[10],e[11]=n[14],e[12]=n[3],e[13]=n[7],e[14]=n[11],e[15]=n[15],r}static multiply(t,r,n=new Or){w(Or,t,r),w(Or,n),y(t!=n,"left != result"),y(r!=n,"right != result");const e=t.m,s=r.m,i=n.m;return i[0]=e[0]*s[0]+e[1]*s[4]+(e[2]*s[8]+e[3]*s[12]),i[1]=e[0]*s[1]+e[1]*s[5]+(e[2]*s[9]+e[3]*s[13]),i[2]=e[0]*s[2]+e[1]*s[6]+(e[2]*s[10]+e[3]*s[14]),i[3]=e[0]*s[3]+e[1]*s[7]+(e[2]*s[11]+e[3]*s[15]),i[4]=e[4]*s[0]+e[5]*s[4]+(e[6]*s[8]+e[7]*s[12]),i[5]=e[4]*s[1]+e[5]*s[5]+(e[6]*s[9]+e[7]*s[13]),i[6]=e[4]*s[2]+e[5]*s[6]+(e[6]*s[10]+e[7]*s[14]),i[7]=e[4]*s[3]+e[5]*s[7]+(e[6]*s[11]+e[7]*s[15]),i[8]=e[8]*s[0]+e[9]*s[4]+(e[10]*s[8]+e[11]*s[12]),i[9]=e[8]*s[1]+e[9]*s[5]+(e[10]*s[9]+e[11]*s[13]),i[10]=e[8]*s[2]+e[9]*s[6]+(e[10]*s[10]+e[11]*s[14]),i[11]=e[8]*s[3]+e[9]*s[7]+(e[10]*s[11]+e[11]*s[15]),i[12]=e[12]*s[0]+e[13]*s[4]+(e[14]*s[8]+e[15]*s[12]),i[13]=e[12]*s[1]+e[13]*s[5]+(e[14]*s[9]+e[15]*s[13]),i[14]=e[12]*s[2]+e[13]*s[6]+(e[14]*s[10]+e[15]*s[14]),i[15]=e[12]*s[3]+e[13]*s[7]+(e[14]*s[11]+e[15]*s[15]),n}static product(...t){const[r,n]=Array.isArray(t[0])?[t[0],t[1]]:[t,new Or];if(0==r.length)return Or.identity(n);if(1==r.length)return Or.copy(r[0],n);if(2==r.length)return Or.multiply(r[0],r[1],n);let e=Or.temp0,s=Or.temp1;Or.multiply(r[0],r[1],e);for(let t=2;t<r.length-1;t++)Or.multiply(e,r[t],s),[e,s]=[s,e];return Or.multiply(e,mr(r),n)}static forSys(t,r,n=t.cross(r),e=Ar.O){return At(t,r,n,e),new Or(t.x,r.x,n.x,e.x,t.y,r.y,n.y,e.y,t.z,r.z,n.z,e.z,0,0,0,1)}static forRows(t,r,n,e=Ar.O){return At(t,r,n,e),new Or(t.x,t.y,t.z,0,r.x,r.y,r.z,0,n.x,n.y,n.z,0,e.x,e.y,e.z,1)}static identity(t=new Or){w(Or,t);const r=t.m;return r[0]=r[5]=r[10]=r[15]=1,r[1]=r[2]=r[3]=r[4]=r[6]=r[7]=r[8]=r[9]=r[11]=r[12]=r[13]=r[14]=0,t}static fromFunction4(t,r=new Or){y("function"==typeof t),w(Or,r);const n=r.m;let e=16;for(;e--;)n[e]=t(Math.floor(e/4),e%4,e);return r}static perspective(t,r,n,e,s=new Or){return Or.perspectiveRad(t*et,r,n,e,s)}static perspectiveRad(t,r,n,e,s=new Or){w(Or,s),M(t,r,n,e);const i=Math.tan(t/2)*n,o=i*r;return Or.frustum(-o,o,-i,i,n,e,s)}static perspectivePlane(t,r=new Or){w(Or,r);const n=r.m;return n[0]=1,n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=1,n[6]=0,n[7]=0,n[8]=0,n[9]=0,n[10]=1,n[11]=0,n[12]=t.normal1.x,n[13]=t.normal1.y,n[14]=t.normal1.z,n[15]=-t.w,r}static frustum(t,r,n,e,s,i,o=new Or){M(t,r,n,e,s,i),y(0<s,"0 < near"),y(s<i,"near < far"),w(Or,o);const h=o.m;return h[0]=2*s/(r-t),h[1]=0,h[2]=(r+t)/(r-t),h[3]=0,h[4]=0,h[5]=2*s/(e-n),h[6]=(e+n)/(e-n),h[7]=0,h[8]=0,h[9]=0,h[10]=-(i+s)/(i-s),h[11]=-2*i*s/(i-s),h[12]=0,h[13]=0,h[14]=-1,h[15]=0,o}static projectPlanePoint(t,r,n=new Or){At(t,r.normal1),w(Or,n);const e=n.m,s=r.normal1,i=r.w,o=s.dot(t);return e[0]=t.x*s.x+i-o,e[1]=t.x*s.y,e[2]=t.x*s.z,e[3]=-i*t.x,e[4]=t.y*s.x,e[5]=t.y*s.y+i-o,e[6]=t.y*s.z,e[7]=-i*t.y,e[8]=t.z*s.x,e[9]=t.z*s.y,e[10]=t.z*s.z+i-o,e[11]=-i*t.z,e[12]=s.x,e[13]=s.y,e[14]=s.z,e[15]=-o,n}static ortho(t,r,n,e,s,i,o=new Or){M(t,r,n,e,s,i),w(Or,o);const h=o.m;return h[0]=2/(r-t),h[1]=0,h[2]=0,h[3]=-(r+t)/(r-t),h[4]=0,h[5]=2/(e-n),h[6]=0,h[7]=-(e+n)/(e-n),h[8]=0,h[9]=0,h[10]=-2/(i-s),h[11]=-(i+s)/(i-s),h[12]=0,h[13]=0,h[14]=0,h[15]=1,o}static scale(...t){let r,n,e,s;t[0]instanceof Ar?(y(t.length<=2),({x:r,y:n,z:e}=t[0]),s=t[1]):"number"!=typeof t[1]?(r=n=e=t[0],s=t[1]):(y(t.length<=4),r=t[0],n=t[1],e=null!=t[2]?t[2]:1,s=t[3]),null==s&&(s=new Or),w(Or,s),M(r,n,e);const i=s.m;return i[0]=r,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=n,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=e,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,s}static translate(...t){let r,n,e,s;t[0]instanceof Ar?(y(t.length<=2),({x:r,y:n,z:e}=t[0]),s=t[1]):(y(t.length<=4),r=t[0],n=null!=t[1]?t[1]:0,e=null!=t[2]?t[2]:0,s=t[3]),null==s&&(s=new Or),w(Or,s),M(r,n,e);const i=s.m;return i[0]=1,i[1]=0,i[2]=0,i[3]=r,i[4]=0,i[5]=1,i[6]=0,i[7]=n,i[8]=0,i[9]=0,i[10]=1,i[11]=e,i[12]=0,i[13]=0,i[14]=0,i[15]=1,s}static rotate(t,r,n){null==n&&(n=new Or),w(Or,n);let{x:e,y:s,z:i}=r;y(!new Ar(e,s,i).likeO(),"!V(x, y, z).likeO()");const o=n.m,h=Math.sqrt(e*e+s*s+i*i);e/=h,s/=h,i/=h;const a=Math.cos(t),u=Math.sin(t),c=1-a;return o[0]=e*e*c+a,o[1]=e*s*c-i*u,o[2]=e*i*c+s*u,o[3]=0,o[4]=s*e*c+i*u,o[5]=s*s*c+a,o[6]=s*i*c-e*u,o[7]=0,o[8]=i*e*c-s*u,o[9]=i*s*c+e*u,o[10]=i*i*c+a,o[11]=0,o[12]=0,o[13]=0,o[14]=0,o[15]=1,n}static lookAt(t,r,n,e=new Or){At(t,r,n),w(Or,e);const s=e.m,i=t.minus(r).unit(),o=n.cross(i).unit(),h=i.cross(o).unit();return s[0]=o.x,s[1]=o.y,s[2]=o.z,s[3]=-o.dot(t),s[4]=h.x,s[5]=h.y,s[6]=h.z,s[7]=-h.dot(t),s[8]=i.x,s[9]=i.y,s[10]=i.z,s[11]=-i.dot(t),s[12]=0,s[13]=0,s[14]=0,s[15]=1,e}static rotateX(t){M(t);const r=Math.sin(t),n=Math.cos(t);return new Or([1,0,0,0,0,n,-r,0,0,r,n,0,0,0,0,1])}static rotateY(t){const r=Math.sin(t),n=Math.cos(t);return new Or([n,0,r,0,0,1,0,0,-r,0,n,0,0,0,0,1])}static rotateZ(t){const r=Math.sin(t),n=Math.cos(t);return new Or([n,-r,0,0,r,n,0,0,0,0,1,0,0,0,0,1])}static rotateAB(t,r,n=new Or){At(t,r),w(Or,n);const e=t.cross(r),s=e.length();if(x(s))return Or.identity(n);const i=Math.atan2(s,t.dot(r));return Or.rotateLine(Ar.O,e,i,n)}static rotateLine(t,r,n,e=new Or){At(t,r),M(n),w(Or,e),r=r.unit();const s=t.x,i=t.y,o=t.z,h=r.x,a=r.y,u=r.z,c=e.m,l=Math.cos(n),f=Math.sin(n);return c[0]=h*h+(a*a+u*u)*l,c[1]=h*a*(1-l)-u*f,c[2]=h*u*(1-l)+a*f,c[3]=(s*(a*a+u*u)-h*(i*a+o*u))*(1-l)+(i*u-o*a)*f,c[4]=h*a*(1-l)+u*f,c[5]=a*a+(h*h+u*u)*l,c[6]=a*u*(1-l)-h*f,c[7]=(i*(h*h+u*u)-a*(s*h+o*u))*(1-l)+(o*h-s*u)*f,c[8]=h*u*(1-l)-a*f,c[9]=a*u*(1-l)+h*f,c[10]=u*u+(h*h+a*a)*l,c[11]=(o*(h*h+a*a)-u*(s*h+i*a))*(1-l)+(s*a-i*h)*f,c[12]=0,c[13]=0,c[14]=0,c[15]=1,e}static mirror(t,r=new Or){At(t.normal1),w(Or,r);const[n,e,s]=t.normal1,i=t.w,o=r.m;return o[0]=1-2*n*n,o[1]=-2*e*n,o[2]=-2*s*n,o[3]=2*n*i,o[4]=-2*n*e,o[5]=1-2*e*e,o[6]=-2*s*e,o[7]=2*e*i,o[8]=-2*n*s,o[9]=-2*e*s,o[10]=1-2*s*s,o[11]=2*s*i,o[12]=0,o[13]=0,o[14]=0,o[15]=1,r}static project(t,r=t.normal1,n=new Or){At(r,t.normal1),w(Or,n);const e=t.w,s=n.m,i=t.normal1.dot(r),{x:o,y:h,z:a}=t.normal1,{x:u,y:c,z:l}=r.div(i);return s[0]=1-o*u,s[1]=-h*u,s[2]=-a*u,s[3]=u*e,s[4]=-o*c,s[5]=1-h*c,s[6]=-a*c,s[7]=c*e,s[8]=-o*l,s[9]=-h*l,s[10]=1-a*l,s[11]=l*e,s[12]=0,s[13]=0,s[14]=0,s[15]=1,n}static lineProjection(t,r=new Or){At(t.anchor,t.dir1),w(Or,r);const n=t.anchor.x,e=t.anchor.y,s=t.anchor.z,i=t.dir1.x,o=t.dir1.y,h=t.dir1.z,a=r.m;return a[0]=i*i,a[1]=i*o,a[2]=i*h,a[3]=n,a[4]=o*i,a[5]=o*o,a[6]=o*h,a[7]=e,a[8]=h*i,a[9]=h*o,a[10]=h*h,a[11]=s,a[12]=0,a[13]=0,a[14]=0,a[15]=1,r}static pointInversion(t,r=new Or){At(t),w(Or,r);const n=r.m;return n[0]=-1,n[1]=0,n[2]=0,n[3]=2*t.x,n[4]=0,n[5]=-1,n[6]=0,n[7]=2*t.y,n[8]=0,n[9]=0,n[10]=-1,n[11]=2*t.z,n[12]=0,n[13]=0,n[14]=0,n[15]=1,r}static new(t,r,n){return y(4==t&&4==r),new Or(...n)}get X(){return this.transformVector(Ar.X)}get Y(){return this.transformVector(Ar.Y)}get Z(){return this.transformVector(Ar.Z)}get O(){return this.getTranslation()}isMirror(t=a){const r=this.m,n=Math.sqrt((1-r[0])/2),e=Math.sqrt((1-r[5])/2),s=Math.sqrt((1-r[10])/2);return E(r[1],-2*e*n,t)&&E(r[2],-2*s*n,t)&&E(r[4],-2*n*e,t)&&E(r[6],-2*s*e,t)&&E(r[8],-2*n*s,t)&&E(r[9],-2*e*s,t)&&E(r[12],0,t)&&E(r[13],0,t)&&E(r[14],0,t)&&E(r[15],1,t)&&E(r[3]*e,r[7]*n,t)&&E(r[7]*s,r[11]*e,t)&&E(r[11]*n,r[3]*s,t)}inversed(t){return Or.inverse(this,t)}trace(){return this.m[0]+this.m[5]+this.m[10]+this.m[15]}as3x3(t){const r=(t=Or.copy(this,t)).m;return r[3]=r[7]=r[11]=r[12]=r[13]=r[14]=0,r[15]=1,t}transform(t){return t.times(this)}realEigenValues3(){const t=this.m;y(0==t[12]&&0==t[13]&&0==t[14]);const[r,n,e,,s,i,o,,h,a,u]=t,c=r+i+u,l=-r*i-r*u+n*s+e*h-i*u+o*a,f=r*(i*u-o*a)-n*(s*u-o*h)+e*(s*a-i*h);return console.log(-1,c,l,f),ft(-1,c,l,f)}realEigenVectors3(){const t=this.realEigenValues3(),r=this.times(Or.IDENTITY3);console.log(this.toString()),console.log(r.toString());let n=t.map((t=>Or.IDENTITY3.scale(-t).plus(r)));if(console.log(n.map((t=>t.determinant3()))),console.log(n.map((t=>""+t.toString((t=>""+t)))).join("\\n\\n")),console.log(n.map((t=>""+t.luDecomposition().U.toString((t=>""+t)))).join("\\n\\n")),console.log("mats.map(m=>m.rank())",n.map((t=>t.rank()))),1==t.length)return console.log(n[0].toString()),A((()=>0==n[0].rank())),Ct(3,(t=>new Ar(this.m[t],this.m[4+t],this.m[8+t])));if(2==t.length){1==n[0].rank()&&(n=[n[1],n[0]]),A((()=>2==n[0].rank())),A((()=>1==n[1].rank()));const t=n[0].luDecomposition().U,r=t.row(0).cross(t.row(1)).V3().unit(),e=n[1].luDecomposition().U.row(0).V3(),s=e.getPerpendicular().unit(),i=r.cross(s).rejectedFrom(e);return[r,s,i]}if(3==t.length)return n.forEach(((t,r)=>y(2==t.rank(),r+": "+t.rank()))),n.map((t=>{const r=t.luDecomposition().U;return r.row(0).cross(r.row(1)).V3().unit()}));throw Error("there cannot be more than 3 eigen values")}svd3(){function t(t,r,n,e){const s=Or.identity();return s.setEl(t,t,n),s.setEl(r,r,n),s.setEl(t,r,e),s.setEl(r,t,-e),s}const r=this.as3x3();let n=r.transposed().times(r),e=Or.identity();console.log(n.toString());for(let s=0;s<16;s++){console.log("blahg\\n",e.times(n).times(e.transposed()).toString()),y(e.times(n).times(e.transposed()).likeM4(r.transposed().times(r)),e.times(n).times(e.transposed()).toString(),r.transposed().times(r).toString());let s=0,i=1,o=10;for(;o--;){const t=Math.abs(n.m[o]);o%4!=Math.floor(o/4)&&t>s&&(s=t,i=o)}const h=Math.floor(i/4),a=i%4,u=n.m[5*h],c=n.m[5*a],l=n.m[i],f=u===c?Sr/4:Math.atan(2*l/(u-c))/2;console.log(i,h,a,"phi",f);const w=t(h,a,Math.cos(f),-Math.sin(f));y(w.transposed().times(w).likeIdentity()),console.log(w.toString()),e=e.times(w),n=Or.product(w.transposed(),n,w),console.log(n.toString())}const s=n.map(((t,r)=>r%5==0?Math.sqrt(t):0));return{U:Or.product(r,e,s.map(((t,r)=>r%5==0?1/t:0))),SIGMA:s,VSTAR:e.transposed()}}map(t){return Or.fromFunction4(((r,n,e)=>t(this.m[e],e,this.m)))}likeM4(t){return w(Or,t),this.m.every(((r,n)=>E(r,t.m[n])))}transposed(t){return Or.transpose(this,t)}times(t){return Or.multiply(this,t)}vanishingPoint(t){At(t);const r=this.m,n=t.x,e=t.y,s=t.z,i=n*r[12]+e*r[13]+s*r[14];if(x(i))return;const o=n*r[0]+e*r[1]+s*r[2],h=n*r[4]+e*r[5]+s*r[6],a=n*r[8]+e*r[9]+s*r[10];return new Ar(o/i,h/i,a/i)}transformPoint(t){At(t);const r=this.m,n=t.x,e=t.y,s=t.z,i=n*r[0]+e*r[1]+s*r[2]+r[3],o=n*r[4]+e*r[5]+s*r[6]+r[7],h=n*r[8]+e*r[9]+s*r[10]+r[11],a=n*r[12]+e*r[13]+s*r[14]+r[15];return new Ar(i/a,o/a,h/a)}transformVector(t,r=!0){At(t);const n=this.m,e=t.x*n[12]+t.y*n[13]+t.z*n[14];return r&&y(x(e),(()=>"w === 0 needs to be true for this to make sense (w ="+e+this.toString())),new Ar(n[0]*t.x+n[1]*t.y+n[2]*t.z,n[4]*t.x+n[5]*t.y+n[6]*t.z,n[8]*t.x+n[9]*t.y+n[10]*t.z)}transformVector2(t,r){At(t,r);const n=this.timesVector(kr(r.x,r.y,r.z,1)),e=this.timesVector(kr(t.x,t.y,t.z,0));return e.times(n.w).minus(n.times(e.w)).div(Math.pow(n.w,2)).V3()}transformedPoints(t){return t.map((t=>this.transformPoint(t)))}transformedVectors(t){return t.map((t=>this.transformVector(t)))}new(){return new Or}isRegular(){return!x(this.determinant())}isAxisAligned(){const t=this.m;return 1>=+!x(t[0])+ +!x(t[1])+ +!x(t[2])&&1>=+!x(t[4])+ +!x(t[5])+ +!x(t[6])&&1>=+!x(t[8])+ +!x(t[9])+ +!x(t[10])}isOrthogonal(){return Or.transpose(this,Or.temp0),Or.multiply(this,Or.temp0,Or.temp1),Or.IDENTITY.likeM4(Or.temp1)}isSymmetric(){return Or.transpose(this,Or.temp0),this.likeM4(Or.temp0)}isSkewSymmetric(t){return x(this.m[0],t)&&x(this.m[5],t)&&x(this.m[10],t)&&x(this.m[15],t)&&E(this.m[1],this.m[4],t)&&E(this.m[2],this.m[8],t)&&E(this.m[3],this.m[12],t)&&E(this.m[6],this.m[9],t)&&E(this.m[7],this.m[13],t)&&E(this.m[11],this.m[14],t)}isNormal(){return Or.transpose(this,Or.temp0),Or.multiply(this,Or.temp0,Or.temp1),Or.multiply(Or.temp0,this,Or.temp2),Or.temp1.likeM4(Or.temp2)}determinant(){const t=this.m,r=t[0],n=t[1],e=t[2],s=t[3],i=t[4],o=t[5],h=t[6],a=t[7],u=t[8],c=t[9],l=t[10],f=t[11],w=t[12],M=t[13],d=t[14],m=t[15],y=l*m-f*d,p=c*m-f*M,A=c*d-l*M,g=u*m-f*w,F=u*d-l*w,b=u*M-c*w;return r*(o*y-h*p+a*A)-n*(i*y-h*g+a*F)+e*(i*p-o*g+a*b)-s*(i*A-o*F+h*b)}determinant3(){const[t,r,n,,e,s,i,,o,h,a]=this.m;return t*(s*a-i*h)-r*(e*a-i*o)+n*(e*h-s*o)}isMirroring(){return this.determinant()<0}getTranslation(){const t=this.m,r=t[15];return new Ar(t[3]/r,t[7]/r,t[11]/r)}normalized(){const t=Nr(this.determinant());return 1==t?this:this.divScalar(Math.pow(t,.25))}normalized2(){const t=this.m[15];return 1==t?this:this.divScalar(t)}like3x3(){const t=this.m;return E(1,t[15])&&x(t[12])&&x(t[13])&&x(t[14])&&x(t[3])&&x(t[7])&&x(t[11])}isNoProj(){const t=this.m;return 0==t[12]&&0==t[13]&&0==t[14]&&1==t[15]}likeIdentity(){return this.m.every(((t,r)=>(r/4|0)==r%4?E(1,t):x(t)))}isIdentity(){return this.m.every(((t,r)=>(r/4|0)==r%4?1==t:0==t))}toString(t=(t=>t.toFixed(6).replace(/([0.])(?=0*$)/g," "))){y("string"==typeof t(0),typeof t(0));const r=Array.prototype.slice.call(this.m).map(t),n=[0,1,2,3].map((t=>rr(_t(r,t,0,4).map((t=>t.length)))));return[0,1,2,3].map((t=>r.slice(4*t,4*t+4).map(((t,r)=>" ".repeat(n[r]-t.length)+t)).join(" "))).join("\\n")}isTranslation(){return[1,0,0,2,0,1,0,2,0,0,1,2,0,0,0,1].every(((t,r)=>2==t||t==this.m[r]))}isScaling(){return[2,0,0,0,0,2,0,0,0,0,2,0,0,0,0,1].every(((t,r)=>2==t||t==this.m[r]))}isZRotation(){return[2,2,0,0,2,2,0,0,0,0,1,0,0,0,0,1].every(((t,r)=>2==t||t==this.m[r]))&&E(1,Math.pow(this.m[0],2)+Math.pow(this.m[1],2))&&this.m[0]==this.m[5]&&this.m[1]==-this.m[4]}toSource(){const t=Or.NAMEMAP.get(this);if(t)return t;if(this.isTranslation())return dt("M4.translate",this.O);if(this.isScaling())return dt("M4.scale",this.m[0],this.m[5],this.m[10]);if(this.isNoProj())return this.O.equals(Ar.O)?dt("M4.forSys",this.X,this.Y,this.Z):dt("M4.forSys",this.X,this.Y,this.Z,this.O);if(this.isMirror(0)){const t=this.m,r=Math.sqrt((1-t[0])/2),n=Math.sqrt((1-t[5])/2),e=Math.sqrt((1-t[10])/2),s=t[3]/2/r;return dt("M4.mirror",{normal1:new Ar(r,n,e),w:s})}{const t=this.m;return"new M4(\\n\\t"+t[0]+",\\t"+t[1]+",\\t"+t[2]+",\\t"+t[3]+",\\n\\t"+t[4]+",\\t"+t[5]+",\\t"+t[6]+",\\t"+t[7]+",\\n\\t"+t[8]+",\\t"+t[9]+",\\t"+t[10]+",\\t"+t[11]+",\\n\\t"+t[12]+",\\t"+t[13]+",\\t"+t[14]+",\\t"+t[15]+")"}}xyAreaFactor(){return this.transformVector(Ar.X).cross(this.transformVector(Ar.Y)).length()}}Or.FOO=new Or(0,1,1,2,.3,.4,.8,13,2.1,3.4,5.5,8.9,0,0,0,1),Or.FOO_INV=Or.FOO.inversed(),Or.IDENTITY=Or.identity(),Or.O=new Or(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),Or.YZX=Or.forSys(Ar.Y,Ar.Z,Ar.X),Or.ZXY=Or.forSys(Ar.Z,Ar.X,Ar.Y),Or.IDENTITY3=new Or(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0),Or.temp0=new Or,Or.temp1=new Or,Or.temp2=new Or,Or.NAMEMAP=(new JavaMap).set(Or.IDENTITY3,"M4.IDENTITY3").set(Or.FOO,"M4.FOO").set(Or.O,"M4.O").set(Or.FOO_INV,"M4.FOO_INV").set(Or.IDENTITY,"M4.IDENTITY").set(Or.ZXY,"M4.ZXY").set(Or.YZX,"M4.YZX"),Or.prototype.height=4,Or.prototype.width=4,W(Or.prototype,xr.prototype,"constructor");class jr{constructor(t){this.v=t,w(Float64Array,t)}static fromFunction(t,r){M(t);const n=new Float64Array(t);let e=t;for(;e--;)n[e]=r(e);return new jr(n)}static random(t){return jr.fromFunction(t,(t=>Math.random()))}static from(...t){return y(t[0]instanceof Float64Array||t.every((t=>"number"==typeof t)),\'args[0] instanceof Float64Array || args.every(a => "number" == typeof a)\'),new jr(t[0]instanceof Float64Array?t[0]:Float64Array.from(t))}static Zero(t){M(t);let r=0;const n=new Float64Array(t);for(;r--;)n[r]=0;return new jr(n)}static Unit(t,r){M(t,r);let n=0;const e=new Float64Array(t);for(;n--;)e[n]=+(n==r);return new jr(e)}static pack(t,r,n=0,e=0,s=t.length-n){const i=t[0].dim(),o=r||new Float32Array(i*s);y(o.length-e>=s*i,"dest.length - destStart >= v3count * 3",o.length,e,3*s);let h=s,a=n,u=e;for(;h--;){const r=t[a++];for(let t=0;t<i;t++)o[u++]=r.v[t]}return o}static lerp(t,r,n){y(t.dim()==r.dim());const e=new Float64Array(t.v.length);let s=t.v.length;for(;s--;)e[s]=t.v[s]*(1-n)+r.v[s]*n;return new jr(e)}static add(...t){const r=t[0].v.length,n=new Float64Array(r);let e=t.length;for(;e--;){let s=r;for(;s--;)n[s]+=t[e].v[s]}return new jr(n)}static fromV3AndWeight(t,r){return new jr(new Float64Array([t.x*r,t.y*r,t.z*r,r]))}get x(){return this.v[0]}get y(){return this.v[1]}get z(){return this.v[2]}get w(){return this.v[3]}[Symbol.iterator](){return this.v[Symbol.iterator]()}dim(){return this.v.length}e(t){if(0>t||t>=this.v.length)throw Error("array index out of bounds");return this.v[t]}plus(t){const r=this.v,n=t.v,e=new Float64Array(r.length);let s=r.length;for(;s--;)e[s]=r[s]+n[s];return new jr(e)}minus(t){const r=this.v,n=t.v,e=new Float64Array(r.length);let s=r.length;for(;s--;)e[s]=r[s]-n[s];return new jr(e)}times(t){const r=this.v,n=new Float64Array(r.length);let e=r.length;for(;e--;)n[e]=r[e]*t;return new jr(n)}div(t){const r=this.v,n=new Float64Array(r.length);let e=r.length;for(;e--;)n[e]=r[e]/t;return new jr(n)}dot(t){y(this.dim==t.dim,"passed vector must have the same dim");let r=0;const n=this.v,e=t.v;let s=n.length;for(;s--;)r+=n[s]*e[s];return r}cross(t){w(jr,t);const r=new Float64Array(3);return r[0]=this.v[1]*t.v[2]-this.v[2]*t.v[1],r[1]=this.v[2]*t.v[0]-this.v[0]*t.v[2],r[2]=this.v[0]*t.v[1]-this.v[1]*t.v[0],new jr(r)}schur(t){w(jr,t);const r=this.v,n=t.v,e=new Float64Array(r.length);let s=r.length;for(;s--;)e[s]=r[s]*n[s];return new jr(e)}equals(t){if(t===this)return!0;if(t.constructor!==jr)return!1;if(this.v.length!=t.v.length)return!1;let r=this.v.length;for(;r--;)if(this.v[r]!==t.v[r])return!1;return!0}like(t,r){if(t===this)return!0;if(t.constructor!==jr)return!1;if(this.v.length!=t.v.length)return!1;let n=this.v.length;for(;n--;)if(!E(this.v[n],t.v[n],r))return!1;return!0}map(t){return new jr(this.v.map(t))}toString(t){return t=t||(t=>+t.toFixed(6)),"Vector("+this.v.map(t).join(", ")+")"}toSource(){return dt("VV",...this.v)}angleTo(t){return w(jr,t),y(!this.isZero(),"!this.likeO()"),y(!t.isZero(),"!vector.likeO()"),Math.acos(U(this.dot(t)/this.length()/t.length(),-1,1))}isParallelTo(t){return w(jr,t),y(!this.isZero(),"!this.likeO()"),y(!t.isZero(),"!vector.likeO()"),E(Math.sqrt(this.lengthSquared()*t.lengthSquared()),Math.abs(this.dot(t)))}isPerpendicularTo(t){return w(jr,t),y(!this.isZero(),"!this.likeO()"),y(!t.isZero(),"!vector.likeO()"),x(this.dot(t))}isZero(){return x(this.length())}length(){return Math.hypot.apply(void 0,this.v)}lengthSquared(){let t=0;const r=this.v;let n=r.length;for(;n--;)t+=r[n]*r[n];return t}unit(){const t=this.length();if(x(t))throw Error("cannot normalize zero vector");return this.div(this.length())}normalized(){throw Error("documentation stub. use .unit()")}asRowMatrix(){return new Er(this.v.length,1,this.v)}asColMatrix(){return new Er(1,this.v.length,this.v)}projectedOn(t){return w(jr,t),t.times(this.dot(t)/t.dot(t))}rejectedOn(t){return w(jr,t),this.minus(t.times(this.dot(t)/t.dot(t)))}to(t){return t.minus(this)}hasLength(t){return M(t),E(t,this.length())}V3(){return new Ar(this.v[0],this.v[1],this.v[2])}p3(){y(4==this.v.length);const t=this.v[3];return new Ar(this.v[0]/t,this.v[1]/t,this.v[2]/t)}transposed(){return new Er(this.v.length,1,this.v)}}function kr(...t){return new jr(new Float64Array(t))}function zr(t,r,n){return y(t.length%r==0),new jr(Float64Array.prototype.slice.call(t,n*r,(n+1)*r))}function Br(t,r,n){const e=n.dim();y(t.length%e==0);let s=e;for(;s--;)t[r*e+s]=n.v[s]}class $r extends xr{constructor(t=Ar.INF,r=Ar.INF.negated()){super(),this.min=t,this.max=r,At(t,r)}static forXYZ(t,r,n){return new $r(Ar.O,new Ar(t,r,n))}static forAABBs(t){const r=new $r;for(const n of t)r.addAABB(n);return r}addPoint(t){return At(t),this.min=this.min.min(t),this.max=this.max.max(t),this}addPoints(t){return t.forEach((t=>this.addPoint(t))),this}addAABB(t){return w($r,t),this.addPoint(t.min),this.addPoint(t.max),this}withoutAABB(t){let r,n;w($r,t);const e=this.volume(),s=this.size();let i=-1/0;for(let o=0;o<3;o++){const h=["x","y","z"][o],a=t.min[h]-this.min[h]>this.max[h]-t.max[h],u=a?this.min[h]:Math.max(this.min[h],t.max[h]),c=a?Math.min(this.max[h],t.min[h]):this.max[h],l=(c-u)*e/s[h];l>i&&(i=l,r=this.min.withElement(h,u),n=this.max.withElement(h,c))}return new $r(r,n)}getIntersectionAABB(t){return w($r,t),new $r(this.min.max(t.min),this.max.min(t.max))}touchesAABB(t){return w($r,t),!(this.min.x>t.max.x||this.max.x<t.min.x||this.min.y>t.max.y||this.max.y<t.min.y||this.min.z>t.max.z||this.max.z<t.min.z)}touchesAABBfuzzy(t,r=a){return w($r,t),!(S(t.max.x,this.min.x,r)||S(this.max.x,t.min.x,r)||S(t.max.y,this.min.y,r)||S(this.max.y,t.min.y,r)||S(t.max.z,this.min.z,r)||S(this.max.z,t.min.z,r))}intersectsAABB(t){return w($r,t),!(this.min.x>=t.max.x||this.max.x<=t.min.x||this.min.y>=t.max.y||this.max.y<=t.min.y||this.min.z>=t.max.z||this.max.z<=t.min.z)}intersectsAABB2d(t){return w($r,t),!(this.min.x>=t.max.x||this.max.x<=t.min.x||this.min.y>=t.max.y||this.max.y<=t.min.y)}containsPoint(t){return At(t),this.min.x<=t.x&&this.min.y<=t.y&&this.min.z<=t.z&&this.max.x>=t.x&&this.max.y>=t.y&&this.max.z>=t.z}containsSphere(t,r){return At(t),M(r),this.distanceToPoint(t)>r}intersectsSphere(t,r){return At(t),M(r),this.distanceToPoint(t)<=r}distanceToPoint(t){At(t);const r=t.x,n=t.y,e=t.z,s=this.min,i=this.max;return this.containsPoint(t)?Math.max(s.x-r,r-i.x,s.y-n,n-i.y,s.z-e,e-i.z):t.distanceTo(new Ar(U(r,s.x,i.x),U(n,s.y,i.y),U(e,s.z,i.z)))}containsAABB(t){return w($r,t),this.containsPoint(t.min)&&this.containsPoint(t.max)}likeAABB(t){return w($r,t),this.min.like(t.min)&&this.max.like(t.max)}intersectsLine(t){At(t.anchor,t.dir1);const r=t.dir1.map((t=>t||5e-324)),n=this.min.minus(t.anchor).divv(r),e=this.max.minus(t.anchor).divv(r),s=n.min(e).maxElement(),i=n.max(e).minElement();return s<=i&&!(i<t.tMin||t.tMax<s)}hasVolume(){return this.min.x<=this.max.x&&this.min.y<=this.max.y&&this.min.z<=this.max.z}volume(){if(!this.hasVolume())return-1;const t=this.max.minus(this.min);return t.x*t.y*t.z}size(){return this.max.minus(this.min)}getCenter(){return this.min.plus(this.max).div(2)}transform(t){w(Or,t),y(t.isAxisAligned());const r=new $r;return r.addPoint(t.transformPoint(this.min)),r.addPoint(t.transformPoint(this.max)),r}ofTransformed(t){w(Or,t);const r=new $r;return r.addPoints(t.transformedPoints(this.corners())),r}corners(){const{min:t,max:r}=this;return[t,new Ar(t.x,t.y,r.z),new Ar(t.x,r.y,t.z),new Ar(t.x,r.y,r.z),new Ar(r.x,t.y,t.z),new Ar(r.x,t.y,r.z),new Ar(r.x,r.y,t.z),r]}toString(){return dt("new AABB",this.min,this.max)}toSource(){return this.toString()}getM4(){return Or.translate(this.min).times(Or.scale(this.size()))}}\n\n\n//# sourceURL=webpack://workshop/./node_modules/ts3dutils/lib/index.es.min.js_+_1_modules?')}}]);