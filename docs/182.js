(self.webpackChunkworkshop=self.webpackChunkworkshop||[]).push([[182],{2182:(t,r,e)=>{"use strict";e.d(r,{mN:()=>nt,Co:()=>P,M4:()=>rt,uK:()=>O,wU:()=>u,bE:()=>c,Fw:()=>H,PI:()=>a,gc:()=>l,yu:()=>G,V:()=>$,V3:()=>U,zy:()=>F,Nv:()=>X,hS:()=>Z,qC:()=>j,hu:()=>g,yP:()=>m,nY:()=>N,OD:()=>y,J8:()=>D,uZ:()=>S,en:()=>L,eq:()=>v,p3:()=>M,t7:()=>w,kL:()=>p,zj:()=>q,hO:()=>_,At:()=>b,Tw:()=>C,AW:()=>B});class i{constructor(){this[Symbol.toStringTag]="Map",this._map=new Map,this._size=0}toString(){return"{"+Array.from(this.entries2()).map((({key:t,value:r})=>t+":"+r)).join(", ")+"}"}forEach(t,r){for(const e of this._map.values())for(const{key:i,value:n}of e)t.call(r,n,i,this)}*keys(){for(const t of this._map.values())for(const{key:r}of t)yield r}*values(){for(const t of this._map.values())for(const{value:r}of t)yield r}[Symbol.iterator](){return this.entries()}set(t,r){return this.set2(t,r),this}set2(t,r){const e=t.hashCode(),i=this._map.get(e);if(i){const e=i.findIndex((r=>r.key.equals(t)));if(-1!=e)return i[e].value=r,!1;i.push({key:t,value:r})}else this._map.set(e,[{key:t,value:r}]);return this._size++,!0}has(t){const r=t.hashCode(),e=this._map.get(r);return void 0!==e&&e.some((r=>r.key.equals(t)))}get(t){const r=t.hashCode(),e=this._map.get(r),i=e&&e.find((r=>r.key.equals(t)));return i&&i.value}getLike(t){for(const r of t.hashCodes()){const e=this._map.get(r),i=e&&e.find((r=>r.key.like(t)));if(i)return i}}setLike(t,r){return!this.getLike(t)&&this.set(t,r)}delete(t){const r=t.hashCode(),e=this._map.get(r);if(e){const i=e.findIndex((r=>r.key.equals(t)));if(-1!=i)return 1==e.length?this._map.delete(r):e.splice(i,1),this._size--,!0}return!1}deleteLike(t){for(const r of t.hashCodes()){const e=this._map.get(r);if(e){const i=e.findIndex((r=>r.key.like(t)));if(-1!=i){const t=e[i];return 1==e.length?this._map.delete(r):e.splice(i,1),this._size--,t}}}}*entries2(){for(const t of this._map.values())yield*t}*entries(){for(const t of this._map.values())for(const{key:r,value:e}of t)yield[r,e]}clear(){this._map.clear(),this._size=0}get size(){return this._size}}const n=/^(abstract|boolean|break|byte|case|catch|char|class|const|continue|debugger|default|delete|do|double|else|enum|export|extends|false|final|finally|float|for|function|goto|if|implements|import|in|instanceof|int|interface|long|native|new|null|package|private|protected|public|return|short|static|super|switch|synchronized|this|throw|throws|transient|true|try|typeof|undefined|var|void|volatile|while|with)$/,s=[];function h(t,r=0){switch(typeof t){case"undefined":return"undefined";case"function":return t.toString();case"number":case"boolean":return""+t;case"string":return JSON.stringify(t);case"object":return null==t?"null":t.sce;default:throw Error(typeof t)}}function o(t,r){t.prototype.toSource||Object.defineProperty(t.prototype,"toSource",{value:r,writable:!0,configurable:!0,enumerable:!1})}o(Boolean,Boolean.prototype.toString),o(Function,Function.prototype.toString),o(Number,Number.prototype.toString),o(RegExp,RegExp.prototype.toString),o(Date,(function(){return"new Date("+this.getTime()+")"})),o(String,(function(){return JSON.stringify(this)})),o(Array,(function(){if(s.includes(this))return"CIRCULAR_REFERENCE";s.push(this);let t="[";for(let r=0;r<this.length;r++)t+="\n\t"+h(this[r]).replace(/\r\n|\n|\r/g,"$&\t"),r!==this.length-1&&(t+=",");return t+=0===this.length?"]":"\n]",s.pop(),t})),o(Object,(function(){if(s.includes(this))return"CIRCULAR_REFERENCE";s.push(this);let t="{";const r=Object.keys(this).sort();for(let i=0;i<r.length;i++){const s=r[i];t+="\n\t"+(/^[a-z_$][0-9a-z_$]*$/gi.test(e=s)&&!n.test(e)?s:JSON.stringify(s))+": "+h(this[s]).replace(/\r\n|\n|\r/g,"$&\t"),i!==r.length-1&&(t+=",")}var e;return t+=0===r.length?"}":"\n}",s.pop(),t}));const a=Math.PI,l=2*a,u=!1,c=1/(1<<26);function m(t,...r){var e,i;if(u)for(let n=0;n<r.length;n++)if(!(r[n]instanceof t))throw Error("assertInst objs["+n+"] is not a "+t.prototype.name+". "+(null===(i=null===(e=r[n])||void 0===e?void 0:e.constructor)||void 0===i?void 0:i.name)+r[n]);return!0}function f(...t){if(u)for(let r=0;r<t.length;r++)if("number"!=typeof t[r])throw Error(`assertNumbers arguments[${r}] is not a number. ${typeof t[r]} == typeof ${t[r]}`)}function d(...t){if(u)for(let r=0;r<t.length;r++)if("number"!=typeof t[r]||t[r]%1!=0)throw Error(`assertNumbers arguments[${r}] is not an int. ${typeof t[r]} == typeof ${t[r]}`)}function g(t,...r){if(u&&!t)throw Error("assert failed: "+r.map((t=>"function"==typeof t?t():t||"")).join("\n"));return!0}function y(t,...r){if(u&&!t())throw Error("assertf failed: "+t.toString()+r.map((t=>"function"==typeof t?t():t||"")).join("\n"))}function w(t,r,e){return t*(1-e)+r*e}function p(t,r,e){return(e-t)/(r-t)}const x=Number.prototype.toString;Number.prototype.toString=function(t){return a==this?"PI":x.call(this,t)};const M=(t,r=c)=>Math.abs(t)<=r,v=(t,r,e=c)=>Math.abs(t-r)<=e,z=(t,r,e=c)=>t-r<-e;function A(t,r,e){if(void 0===e||0==+e)return t(r);if(e=+e,isNaN(r=+r)||"number"!=typeof e||e%1!=0)return NaN;let i=r.toString().split("e");return i=(r=t(+(i[0]+"e"+(i[1]?+i[1]-e:-e)))).toString().split("e"),+(i[0]+"e"+(i[1]?+i[1]+e:e))}const b=A.bind(void 0,Math.round);function S(t,r,e){return f(t,r,e),Math.max(r,Math.min(e,t))}function F(t,r,...e){Object.getOwnPropertyNames(r).forEach((i=>{e.includes(i)||(t.hasOwnProperty(i)&&console.warn("target ",t," already has property ",i,t[i]),Object.defineProperty(t,i,Object.getOwnPropertyDescriptor(r,i)))}))}A.bind(void 0,Math.floor),A.bind(void 0,Math.ceil);let k=t=>t;const O=(t,r)=>t-r;function E(t){return~~(t*(1<<28))}const P=.017453292519943295;function I(t,r,e,i){if(M(t))return M(r)?[-i/e]:function(t,r){const e=t*t/4-r;if(e<-c)return[];if(e<=c)return[-t/2];{const r=Math.sqrt(e);return[-t/2-r,-t/2+r]}}(e/r,i/r);const n=t;t=r/n;const s=(3*(r=e/n)-t*t)/3/3,h=s*s*s,o=(2*t*t*t-9*t*r+27*(e=i/n))/27,a=o/2,l=a*a+h;if(l<-c/8){const r=Math.sqrt(-h),e=-o/(2*r),i=Math.acos(e<-1?-1:e>1?1:e),n=2*Math.cbrt(r);return[n*Math.cos(i/3)-t/3,n*Math.cos((i+2*Math.PI)/3)-t/3,n*Math.cos((i+4*Math.PI)/3)-t/3]}if(l<=c/8){if(0==a)return[-t/3];const r=a<0?Math.cbrt(-a):-Math.cbrt(a);return[2*r-t/3,-r-t/3]}{const r=Math.sqrt(l);return[Math.cbrt(-a+r)-Math.cbrt(a+r)-t/3]}}function T(t,...r){return t+"("+r.map(h).join(",")+")"}function N(...t){if(u)for(let t=0;t<arguments.length;t++)if(!(arguments[t]instanceof U||arguments[t]instanceof et))throw Error("assertVectors arguments["+t+"] is not a vector. "+typeof arguments[t]+" == typeof "+arguments[t]);return!0}function q(t,r,e=8,i=1e-8){if("number"==typeof i){let n=r;for(let r=0;r<e;r++){const r=t(n);n-=r/((t(n+i)-r)/i)}return n}return function(t,r,e=4,i){let n=r;for(let r=0;r<e;r++){const r=t(n),e=i(n);(isNaN(r)||isNaN(e))&&console.log(),n-=r/e,isNaN(r)&&console.log()}return n}(t,r,e,i)}function j(t,r,e){const i=t[r];t[r]=t[e],t[e]=i}function V(t,r,e,i,n){for(d(r,i,n),i+=n,n+=r;n-- >r;)e[--i]=t[n];return e}function Y(t,r,e,i,n,s,h){let o=r+h*e,a=n+h*s;for(;o>r;)i[a-=s]=t[o-=e]}function Z(t,r,e=1){f(t,e);const i=Math.ceil((r-t)/e),n=Array(i);for(let r=t,s=0;s<i;r+=e,s++)n[s]=r;return n}function X(t,r){f(t),g("function"==typeof r);const e=Array(t);let i=t;for(;i--;)e[i]=r(i,t);return e}function B(t,r){let e,i=t.length,n=-1/0;for(;i--;){const s=t[i],h=r(s,i,t);h>n&&(n=h,e=s)}return e}function L(t,r){return t[function(t,r){return(t%r+r)%r}(r,t.length)]}function R(t){let r=t.length,e=-1/0;for(;r--;){const i=t[r];e<i&&(e=i)}return e}function C(t){const r=new Set(t);return Array.from(r)}function D(t,r){const e=t[r];return r==t.length-1?t.pop():t[r]=t.pop(),e}function _(t,r){if(r.sort(((t,r)=>t-r)),0===r.length)return t;if(1===r.length)return t.splice(r[0],1),t;let e=r[0],i=r[0],n=0;for(let s=r[0];s<t.length;s++)if(s!==i)t[e++]=t[s];else{if(n++,!(n<r.length))return t.splice(e,s+1-e),t;i=r[n]}throw Error("illegal state")}Object.map=function(t,r,e){const i={};for(const n in t)i[n]=r.call(e,t[n],n,t);return i},String.prototype.capitalizeFirstLetter=function(){return this.charAt(0).toUpperCase()+this.slice(1)},String.prototype.equals=function(t){return this==t},Object.defineProperty(Object.prototype,"sce",{get:function(){return this.toSource()},configurable:!0});class U{constructor(t,r,e){this.x=t,this.y=r,this.z=e,f(t,r,e)}static random(){return new U(Math.random(),Math.random(),Math.random())}static parallel(t,r){return t.dot(r)-t.length()*r.length()}static randomUnit(){const t=2*Math.random()*Math.PI,r=2*Math.random()-1,e=Math.sqrt(1-Math.pow(r,2));return new U(e*Math.cos(t),e*Math.sin(t),r)}static fromAngles(t,r){throw Error()}static fromFunction(t){return new U(t(0),t(1),t(2))}static min(t,r){return new U(Math.min(t.x,r.x),Math.min(t.y,r.y),Math.min(t.z,r.z))}static max(t,r){return new U(Math.max(t.x,r.x),Math.max(t.y,r.y),Math.max(t.z,r.z))}static lerp(t,r,e){return new U(t.x*(1-e)+r.x*e,t.y*(1-e)+r.y*e,t.z*(1-e)+r.z*e)}static fromArray(t){return new U(t[0],t[1],t[2])}static angleBetween(t,r){return t.angleTo(r)}static zip(t,...r){return g(t instanceof Function),new U(t.apply(void 0,r.map((t=>t.x))),t.apply(void 0,r.map((t=>t.y))),t.apply(void 0,r.map((t=>t.z))))}static normalOnPoints(t,r,e){return N(t,r,e),t.to(r).cross(t.to(e))}static add(...t){N(...t);let r=0,e=0,i=0,n=t.length;for(;n--;)r+=t[n].x,e+=t[n].y,i+=t[n].z;return new U(r,e,i)}static sub(...t){N(...t);let r=t[0].x,e=t[0].y,i=t[0].z,n=t.length;for(;n--;)r-=t[n].x,e-=t[n].y,i-=t[n].z;return new U(r,e,i)}static pack(t,r,e=0,i=0,n=t.length-e){const s=r||new Float32Array(3*n);g(s.length-i>=3*n,"dest.length - destStart >= v3count * 3",s.length,i,3*n);let h=n,o=e,a=i;for(;h--;){const r=t[o++];s[a++]=r.x,s[a++]=r.y,s[a++]=r.z}return s}static unpack(t,r,e=0,i=0,n=(t.length-e)/3){g((r=r||Array(n)).length-i>=n,"dest.length - destStart >= v3count");let s=n,h=e,o=i;for(;s--;)r[o++]=new U(t[h++],t[h++],t[h++]);return r}static packXY(t,r,e=0,i=0,n=t.length-e){const s=r||new Float32Array(2*n);g(s.length-i>=n,"dest.length - destStart >= v3count");let h=n,o=e,a=i;for(;h--;){const r=t[o++];s[a++]=r.x,s[a++]=r.y}return s}static unpackXY(t,r,e=0,i=0,n=Math.min(t.length/2,r&&r.length||1/0)-i){g((r=r||Array(n)).length-i>=n,"dest.length - destStart >= v3count"),g(t.length-e>=2*n,"dest.length - destStart >= v3count");let s=n,h=e,o=i;for(;s--;)r[o++]=new U(t[h++],t[h++],0);return r}static perturbed(t,r){return t.perturbed(r)}static polar(t,r,e=0){return new U(t*Math.cos(r),t*Math.sin(r),e)}static sphere(t,r,e=1){return new U(e*Math.cos(r)*Math.cos(t),e*Math.cos(r)*Math.sin(t),e*Math.sin(r))}static inverseLerp(t,r,e){const i=t.to(r);return t.to(e).dot(i)/i.squared()}get 0(){return this.x}get 1(){return this.y}get 2(){return this.z}get u(){return this.x}get v(){return this.y}perturbed(t=.8*c){return this.map((r=>r+(Math.random()-.5)*t))}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}e(t){return g(t>=0&&t<3),0==t?this.x:1==t?this.y:this.z}negated(){return new U(-this.x,-this.y,-this.z)}abs(){return new U(Math.abs(this.x),Math.abs(this.y),Math.abs(this.z))}plus(t){return N(t),new U(this.x+t.x,this.y+t.y,this.z+t.z)}schur(t){return new U(this.x*t.x,this.y*t.y,this.z*t.z)}divv(t){return new U(this.x/t.x,this.y/t.y,this.z/t.z)}minus(t){return N(t),new U(this.x-t.x,this.y-t.y,this.z-t.z)}to(t){return N(t),t.minus(this)}times(t){return f(t),new U(this.x*t,this.y*t,this.z*t)}div(t){return f(t),new U(this.x/t,this.y/t,this.z/t)}dot(t){return m(U,t),this.x*t.x+this.y*t.y+this.z*t.z}lerp(t,r){return N(t),f(r),U.lerp(this,t,r)}squared(){return this.dot(this)}distanceTo(t){return N(t),Math.hypot(this.x-t.x,this.y-t.y,this.z-t.z)}distanceToSquared(t){return N(t),this.minus(t).squared()}toSource(){return U.NAMEMAP.get(this)||this.toString()}nonParallelVector(){const t=this.abs();return t.x<=t.y&&t.x<=t.z?U.X:t.y<=t.x&&t.y<=t.z?U.Y:U.Z}slerp(t,r){N(t),f(r);const e=Math.sin,i=this.angleTo(t);return this.times(e((1-r)*i)/e(i)).plus(t.times(e(r*i)/e(i)))}min(t){return new U(Math.min(this.x,t.x),Math.min(this.y,t.y),Math.min(this.z,t.z))}max(t){return new U(Math.max(this.x,t.x),Math.max(this.y,t.y),Math.max(this.z,t.z))}equals(t){return this==t||this.x==t.x&&this.y==t.y&&this.z==t.z}cross(t){return new U(this.y*t.z-this.z*t.y,this.z*t.x-this.x*t.z,this.x*t.y-this.y*t.x)}minElement(){return Math.min(this.x,this.y,this.z)}maxElement(){return Math.max(this.x,this.y,this.z)}toArray(t=3){return[this.x,this.y,this.z].slice(0,t)}getPerpendicular(){if(M(this.x)&&M(this.y)){if(M(this.z))throw Error("zero vector");return U.Y}return new U(-this.y,this.x,0)}dim(){return 3}els(){return[this.x,this.y,this.z]}angleXY(){return Math.atan2(this.y,this.x)}lengthXY(){return Math.hypot(this.x,this.y)}squaredXY(){return this.x*this.x+this.y*this.y}xy(){return new U(this.x,this.y,0)}map(t){return new U(t(this.x,"x"),t(this.y,"y"),t(this.z,"z"))}toString(t){return t=t||k,U.NAMEMAP.get(this)||"V("+[this.x,this.y,this.z].map(t).join(", ")+")"}angleTo(t){return g(1==arguments.length),N(t),g(!this.likeO()),g(!t.likeO()),Math.acos(Math.min(1,this.dot(t)/this.length()/t.length()))}angleRelativeNormal(t,r){return g(2==arguments.length),N(t,r),y((()=>r.hasLength(1))),Math.atan2(this.cross(t).dot(r),this.dot(t))}isParallelTo(t){N(t),g(!this.likeO()),g(!t.likeO());const r=this.dot(t);return v(this.squared()*t.squared(),r*r)}isPerpendicularTo(t){return N(t),g(!this.likeO(),"!this.likeO()"),g(!t.likeO(),"!vector.likeO()"),M(this.dot(t))}isReverseDirTo(t){N(t),g(!this.likeO()),g(!t.likeO());const r=this.dot(t);return v(Math.sqrt(this.squared()*t.squared()),r)}length(){return Math.hypot(this.x,this.y,this.z)}likeO(){return this.like(U.O)}like(t){return t===this||t instanceof U&&v(this.x,t.x)&&v(this.y,t.y)&&v(this.z,t.z)}likeOrReversed(t){return v(Math.abs(this.dot(t)),Math.sqrt(this.squared()*t.squared()))}unit(){return g(!this.likeO(),"cannot normalize zero vector"),this.div(this.length())}normalized(){throw Error("documentation stub. use .unit()")}toLength(t){return f(t),this.times(t/this.length())}projectedOn(t){return N(t),t.times(this.dot(t)/t.dot(t))}rejectedFrom(t){return N(t),this.minus(t.times(this.dot(t)/t.dot(t)))}rejectedFrom1(t){return N(t),g(t.hasLength(1)),this.minus(t.times(this.dot(t)))}rejectedLength(t){return N(t),Math.sqrt(this.dot(this)-Math.pow(this.dot(t),2)/t.dot(t))}rejected1Length(t){return N(t),g(t.hasLength(1)),Math.sqrt(this.dot(this)-Math.pow(this.dot(t),2))}hasLength(t){return f(t),v(t,this.length())}absSum(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}minAbsElement(){return Math.min(Math.abs(this.x),Math.abs(this.y),Math.min(this.z))}maxAbsElement(){return Math.max(Math.abs(this.x),Math.abs(this.y),Math.abs(this.z))}maxAbsDim(){const t=Math.abs(this.x),r=Math.abs(this.y),e=Math.abs(this.z);return t>=r?t>=e?0:2:r>=e?1:2}minAbsDim(){const t=Math.abs(this.x),r=Math.abs(this.y),e=Math.abs(this.z);return t<r?t<e?0:2:r<e?1:2}withElement(t,r){return g(["x","y","z"].includes(t),""+t),f(r),"x"==t?new U(r,this.y,this.z):"y"==t?new U(this.x,r,this.z):new U(this.x,this.y,r)}hashCode(){function t(t){return~~(t*(1<<28))}return~~(31*(31*t(this.x)+t(this.y))+t(this.z))}hashCodes(){const t=~~(31*(31*~~(this.x*(1<<28)-.5)+~~(this.y*(1<<28)-.5))+~~(this.z*(1<<28)-.5));return[~~t,~~(t+961),~~(t+31),~~(t+31+961),~~(t+1),~~(t+1+961),~~(t+1+31),~~(t+1+31+961)]}compareTo(t){return this.x!=t.x?this.x-t.x:this.y!=t.y?this.y-t.y:this.z-t.z}compareTo2(t,r=c){return v(this.x,t.x,r)?v(this.y,t.y,r)?v(this.z,t.z,r)?0:this.z-t.z:this.y-t.y:this.x-t.x}toAngles(){return{theta:Math.atan2(this.y,this.x),phi:Math.asin(this.z/this.length())}}}function $(t,r,e){if(3==arguments.length)return new U(parseFloat(t),parseFloat(r),parseFloat(e));if(2==arguments.length)return new U(parseFloat(t),parseFloat(r),0);if(1==arguments.length&&"object"==typeof t){if(t instanceof U)return t;if(t instanceof Array||t instanceof Float32Array||t instanceof Float64Array){if(2==t.length)return new U(parseFloat(t[0]),parseFloat(t[1]),0);if(3==t.length)return new U(parseFloat(t[0]),parseFloat(t[1]),parseFloat(t[2]))}else if("x"in t&&"y"in t)return new U(parseFloat(t.x),parseFloat(t.y),"z"in t?parseFloat(t.z):0)}throw Error("invalid arguments"+arguments)}U.O=new U(0,0,0),U.X=new U(1,0,0),U.Y=new U(0,1,0),U.Z=new U(0,0,1),U.XY=new U(1,1,0),U.XYZ=new U(1,1,1),U.INF=new U(1/0,1/0,1/0),U.UNITS=[U.X,U.Y,U.Z],U.NAMEMAP=(new i).set(U.O,"V3.O").set(U.X,"V3.X").set(U.Y,"V3.Y").set(U.Z,"V3.Z").set(U.XYZ,"V3.XYZ").set(U.INF,"V3.INF");const W={normal1:U.X,w:0},H={normal1:U.Y,w:0},J={normal1:U.Z,w:0};class G{mirror(t){return this.transform(rt.mirror(t))}mirroredX(){return this.mirror(W)}mirrorY(){return this.mirror(H)}mirrorZ(){return this.mirror(J)}project(t){return this.transform(rt.project(t))}projectXY(){return this.transform(rt.project(J))}projectYZ(){return this.transform(rt.project(W))}projectZX(){return this.transform(rt.project(H))}translate(...t){return this.transform(rt.translate.apply(void 0,t),T(".translate",...t))}scale(...t){return this.transform(rt.scale.apply(void 0,t),T(".scale",...t))}rotateX(t){return this.transform(rt.rotateX(t),`.rotateX(${t})`)}rotateY(t){return this.transform(rt.rotateY(t),`.rotateY(${t})`)}rotateZ(t){return this.transform(rt.rotateZ(t),`.rotateZ(${t})`)}rotate(t,r,e){return this.transform(rt.rotateLine(t,r,e),T(".rotate",t,r,e))}rotateAB(t,r){return this.transform(rt.rotateAB(t,r),T(".rotateAB",t,r))}eulerZXZ(t,r,e){throw Error()}shearX(t,r){return this.transform(new rt([1,t,r,0,0,1,0,0,0,0,1,0,0,0,0,1]))}foo(){return this.transform(rt.FOO)}fooInv(){return this.transform(rt.FOO_INV)}visit(t,...r){let e=Object.getPrototypeOf(this);for(;!t.hasOwnProperty(e.constructor.name)&&e!==G.prototype;)e=Object.getPrototypeOf(e);if(t.hasOwnProperty(e.constructor.name))return t[e.constructor.name].apply(this,r);throw Error("No implementation for "+this.constructor.name)}}class K{constructor(t,r,e){this.width=t,this.height=r,this.m=e,d(t,r),y((()=>0<t)),y((()=>0<r)),g(t*r==e.length,"width * height == m.length",t,r,e.length)}static random(t,r){return K.fromFunction(t,r,(()=>Math.random()))}static fromFunction(t,r,e){const i=new Float64Array(r*t);let n=r*t;for(;n--;)i[n]=e(Math.floor(n/t),n%t,n);return new K(t,r,i)}static identityN(t){d(t);const r=new Float64Array(t*t);let e=t*(t+1);for(;e;)e-=t+1,r[e]=1;return new K(t,t,r)}static permutation(t,r,e){d(t,r,e),y((()=>0<=r&&r<t)),y((()=>0<=e&&e<t));const i=new Float64Array(t*t);let n=t*(t+1);for(;n;)n-=t+1,i[n]=1;return i[r*t+r]=0,i[e*t+e]=0,i[r*t+e]=1,i[e*t+r]=1,new K(t,t,i)}static fromRowArrays(...t){if(0==t.length)throw Error("cannot have 0 vector");const r=t.length,e=t[0].length,i=new Float64Array(r*e);V(t[0],0,i,0,e);for(let n=1;n<r;n++){if(t[n].length!=e)throw Error("all row arrays must be the same length");V(t[n],0,i,n*e,e)}return this.new(e,r,i)}static fromColVectors(t){return K.fromColArrays(...t.map((t=>t.v)))}static forWidthHeight(t,r){return new K(t,r,new Float64Array(t*r))}static fromColArrays(...t){if(0==t.length)throw Error("cannot have 0 vector");const r=t.length,e=t[0].length,i=new Float64Array(e*r);Y(t[0],0,1,i,0,r,e);for(let n=1;n<r;n++){if(t[n].length!=e)throw Error("all col arrays must be the same length");Y(t[n],0,1,i,n,r,e)}return this.new(r,e,i)}static product(...t){const[r,e]=Array.isArray(t[0])?[t[0],t[1]]:[t,void 0];if(0==r.length)throw Error("Can't guess matrix size.");return 1==r.length?K.copy(r[0],e):K.copy(r.reduce(((t,r)=>t.times(r))),e)}static jacobi(t,r,e=t(r),i=1e-6){const n=K.forWidthHeight(r.length,e.length);for(let s=0;s<r.length;s++){r[s]+=i;const h=t(r);for(let t=0;t<e.length;t++){const r=(h[t]-e[t])/i;n.setEl(t,s,r)}r[s]-=i}return n}static copy(t,r=t.new()){m(K,t,r),g(t.width==r.width),g(t.height==r.height),g(r!=t,"result != src");const e=t.m,i=r.m;let n=e.length;for(;n--;)i[n]=e[n];return r}static new(t,r,e){return new K(t,r,e)}copy(){return K.copy(this)}e(t,r){return d(t,r),g(0<=t&&t<this.height,"rowIndex out of bounds "+t),g(0<=r&&r<this.width,"colIndex out of bounds "+r),this.m[t*this.width+r]}setEl(t,r,e){d(t,r),g(0<=t&&t<this.height,"rowIndex out of bounds "+t),g(0<=r&&r<this.width,"colIndex out of bounds "+r),f(e),this.m[t*this.width+r]=e}plus(t){g(this.width==t.width),g(this.height==t.height);const r=this.new();let e=this.m.length;for(;e--;)r.m[e]=this.m[e]+t.m[e];return r}minus(t){g(this.width==t.width),g(this.height==t.height);const r=this.new();let e=this.m.length;for(;e--;)r.m[e]=this.m[e]-t.m[e];return r}mulScalar(t){f(t);const r=this.new();let e=this.m.length;for(;e--;)r.m[e]=this.m[e]*t;return r}divScalar(t){f(t);const r=this.new();let e=this.m.length;for(;e--;)r.m[e]=this.m[e]/t;return r}new(){return new K(this.width,this.height,new Float64Array(this.width*this.height))}toString(t,r,e){g("string"==typeof(t=t||(t=>t.toFixed(6)))(0),typeof t(0)),g(!r||r.length==this.width),g(!e||e.length==this.height);const i=Array.from(this.m).map(t),n=X(this.height,(t=>i.slice(t*this.width,(t+1)*this.width)));r&&n.unshift(Array.from(r)),e&&n.forEach(((t,i)=>t.unshift(e[i-(r?1:0)]||"")));const s=X(this.width,(t=>R(n.map((r=>r[t].length)))));return n.map(((t,i)=>t.map(((t,n)=>(0==i&&r||0==n&&e?String.prototype.padEnd:String.prototype.padStart).call(t,s[n]))).join("  "))).map((t=>t+"\n")).join("")}row(t){d(t),g(0<=t&&t<this.height,"rowIndex out of bounds "+t);const r=new Float64Array(this.width);return V(this.m,t*this.width,r,0,this.width),new et(r)}col(t){d(t),g(0<=t&&t<this.width,"colIndex out of bounds "+t);const r=new Float64Array(this.height);return Y(this.m,t,this.width,r,0,1,this.height),new et(r)}dim(){return{width:this.width,height:this.height}}dimString(){return this.width+"x"+this.height}equals(t){if(t.constructor!=this.constructor)return!1;if(this.width!=t.width||this.height!=t.height)return!1;let r=this.m.length;for(;r--;)if(this.m[r]!=t.m[r])return!1;return!0}equalsMatrix(t,r=c){if(m(K,t),this.width!=t.width||this.height!=t.height)return!1;let e=this.m.length;for(;e--;)if(Math.abs(this.m[e]-t.m[e])>r)return!1;return!0}hashCode(){let t=0,r=this.m.length;for(;r--;)t=31*t+E(this.m[r]);return t}isZero(){let t=this.m.length;for(;t--;)if(!M(this.m[t]))return!1;return!0}isOrthogonal(){return this.isSquare()&&this.transposed().times(this).equalsMatrix(K.identityN(this.width))}luDecomposition(){const t=this.width,r=this.height,e=this.asRowArrays(Float64Array),i=X(r,(()=>new Float64Array(r))),n=K.identityN(r).asRowArrays(Float64Array);let s=0;for(let h=0;h<t;h++){s=h;let o=0,a=-1,l=0;for(let t=s;t<r;t++){const r=e[t][h];l+=+(0!=r),Math.abs(r)>o&&(o=Math.abs(r),a=t)}if(0!=o&&(g(-1!==a),j(e,s,a),j(i,s,a),j(n,s,a),i[s][h]=1,1<l))for(let n=s+1;n<r;n++){const r=e[n][h]/e[s][h];i[n][h]=r;for(let i=h;i<t;i++)e[n][i]-=r*e[s][i]}}return{L:K.fromRowArrays(...i),U:K.fromRowArrays(...e),P:K.fromRowArrays(...n)}}qrDecompositionGivensRotation(){const t=this.copy();function r(t,r,e,i,n){const s=K.identityN(t);return s.setEl(r,r,i),s.setEl(e,e,i),s.setEl(r,e,n),s.setEl(e,r,-n),s}let e=K.identityN(this.height);for(let i=0;i<this.width;i++)for(let n=i+1;n<this.height;n++){const s=t.e(i,i),h=t.e(n,i);if(0==h)continue;const o=Math.hypot(s,h),a=s/o,l=h/o;for(let r=i;r<this.width;r++){const e=t.e(i,r)*a+t.e(n,r)*l,s=t.e(n,r)*a-t.e(i,r)*l;t.setEl(i,r,e),t.setEl(n,r,s)}e=r(this.height,i,n,a,l).times(e)}return{Q:e.transposed(),R:t}}isPermutation(){return!(!this.isSquare()||this.m.some((t=>!M(t)&&!v(1,t)))||this.asRowArrays(Array).some((t=>1!=t.filter((t=>v(1,t))).length))||this.asColArrays(Array).some((t=>1!=t.filter((t=>v(1,t))).length)))}isDiagonal(t){let r=this.m.length;for(;r--;)if(0!=r%(this.width+1)&&!M(this.m[r],t))return!1;return!0}isIdentity(t){return this.isLowerUnitriangular(t)&&this.isUpperTriangular(t)}isUpperTriangular(t){return this.isSquare()&&this.isUpperTrapezoidal(t)}isUpperTrapezoidal(t=c){for(let r=1;r<this.height;r++)for(let e=0;e<r;e++)if(!M(this.m[r*this.width+e],t))return!1;return!0}isSymmetric(t=c){if(!this.isSquare())return!1;for(let r=0;r<this.height-1;r++)for(let e=r+1;e<this.width;e++){const i=this.m[r*this.width+e],n=this.m[e*this.width+r];if(!v(i,n,t))return!1}return!0}solveLinearSystem(t){m(et,t);const{L:r,U:e,P:i}=this.luDecomposition(),n=r.solveForwards(i.timesVector(t));return e.solveBackwards(n)}isLowerUnitriangular(t=c){if(!this.isSquare())return!1;for(let r=0;r<this.height-1;r++)for(let e=r;e<this.width;e++){const i=this.m[r*this.width+e];if(r==e?!v(1,i,t):!M(i,t))return!1}return!0}isLowerTriangular(t){return this.isSquare()&&this.isLowerTrapezoidal(t)}isLowerTrapezoidal(t=c){for(let r=0;r<this.height-1;r++)for(let e=r+1;e<this.width;e++)if(!M(this.m[r*this.width+e],t))return!1;return!0}solveBackwards(t){N(t),g(this.height==t.dim(),"this.height == x.dim()"),g(this.isUpperTriangular(),"this.isUpperTriangular()\n"+this.toString());const r=new Float64Array(this.width);let e=this.height;for(;e--;){let i=t.v[e];for(let t=e+1;t<this.width;t++)i-=r[t]*this.e(e,t);r[e]=i/this.e(e,e)}return new et(r)}solveBackwardsMatrix(t){const r=Array(t.width);let e=t.width;for(;e--;)r[e]=this.solveBackwards(t.col(e));return K.fromColVectors(r)}solveForwardsMatrix(t){const r=Array(t.width);let e=t.width;for(;e--;)r[e]=this.solveForwards(t.col(e));return K.fromColVectors(r)}solveForwards(t){N(t),g(this.height==t.dim(),"this.height == x.dim()"),y((()=>this.isLowerTriangular()),this.toString());const r=new Float64Array(this.width);for(let e=0;e<this.height;e++){let i=t.v[e];for(let t=0;t<e;t++)i-=r[t]*this.e(e,t);r[e]=i/this.e(e,e)}return new et(r)}rank(){const t=this.luDecomposition().U;let r=this.height,e=this.height;for(;r--;)e-=+t.row(r).isZero();return e}rowsIndependent(){return this.height==this.rank()}colsIndependent(){return this.width==this.rank()}asRowArrays(t=Float64Array){return X(this.height,(r=>this.rowArray(r,t)))}asColArrays(t=Float64Array){return X(this.width,(r=>this.colArray(r,t)))}rowArray(t,r=Float64Array){const e=new r(this.width);return V(this.m,t*this.width,e,0,this.width)}colArray(t,r=Float64Array){const e=new r(this.width);return Y(this.m,t,this.height,e,0,1,this.height),e}subMatrix(t,r,e,i){g(0<t&&0<r&&0<e&&0<i),g(t+r<=this.width&&e+i<=this.height);const n=new Float64Array(r*i);return function(t,r,e,i,n,s,h,o){for(let n=0;n<o;n++)V(t,r+e*n,i,0+s*n,h)}(this.m,t,this.width,n,0,r,i,r),new K(r,i,n)}map(t){return new K(this.width,this.height,this.m.map(t))}dimEquals(t){return m(K,t),this.width==t.width&&this.height==t.height}inversed(){if(this.isSquare()){if(2==this.width)return this.inversed2();if(3==this.width)return this.inversed3();if(4==this.width)return this.inversed4()}const{L:t,U:r,P:e}=this.luDecomposition(),i=t.solveForwardsMatrix(e);return r.solveBackwardsMatrix(i)}inversed2(){y((()=>2==this.width&&2==this.height));const t=K.forWidthHeight(2,2),r=this.m,e=t.m,i=r[0]*r[3]-r[1]*e[2];return e[0]=r[3]/i,e[1]=-r[2]/i,e[2]=-r[1]/i,e[3]=r[0]/i,t}inversed3(t=K.forWidthHeight(3,3)){m(K,t),y((()=>3==this.width&&3==this.height)),y((()=>3==t.width&&3==t.height)),g((()=>this!=t));const r=this.m,e=t.m;e[0]=r[4]*r[8]-r[5]*r[7],e[1]=-r[1]*r[8]+r[2]*r[7],e[2]=r[1]*r[5]-r[2]*r[4],e[3]=-r[3]*r[8]+r[5]*r[6],e[4]=r[0]*r[8]-r[2]*r[6],e[5]=-r[0]*r[5]+r[2]*r[3],e[6]=r[3]*r[7]-r[4]*r[6],e[7]=-r[0]*r[7]+r[1]*r[6],e[8]=r[0]*r[4]-r[1]*r[3];const i=r[0]*e[0]+r[1]*e[3]+r[2]*e[6];let n=9;for(;n--;)e[n]/=i;return t}inversed4(t=K.forWidthHeight(4,4)){m(K,t),y((()=>4==this.width&&4==this.height)),y((()=>4==t.width&&4==t.height)),g((()=>this!=t));const r=this.m,e=t.m;e[0]=r[5]*r[10]*r[15]-r[5]*r[14]*r[11]-r[6]*r[9]*r[15]+r[6]*r[13]*r[11]+r[7]*r[9]*r[14]-r[7]*r[13]*r[10],e[1]=-r[1]*r[10]*r[15]+r[1]*r[14]*r[11]+r[2]*r[9]*r[15]-r[2]*r[13]*r[11]-r[3]*r[9]*r[14]+r[3]*r[13]*r[10],e[2]=r[1]*r[6]*r[15]-r[1]*r[14]*r[7]-r[2]*r[5]*r[15]+r[2]*r[13]*r[7]+r[3]*r[5]*r[14]-r[3]*r[13]*r[6],e[3]=-r[1]*r[6]*r[11]+r[1]*r[10]*r[7]+r[2]*r[5]*r[11]-r[2]*r[9]*r[7]-r[3]*r[5]*r[10]+r[3]*r[9]*r[6],e[4]=-r[4]*r[10]*r[15]+r[4]*r[14]*r[11]+r[6]*r[8]*r[15]-r[6]*r[12]*r[11]-r[7]*r[8]*r[14]+r[7]*r[12]*r[10],e[5]=r[0]*r[10]*r[15]-r[0]*r[14]*r[11]-r[2]*r[8]*r[15]+r[2]*r[12]*r[11]+r[3]*r[8]*r[14]-r[3]*r[12]*r[10],e[6]=-r[0]*r[6]*r[15]+r[0]*r[14]*r[7]+r[2]*r[4]*r[15]-r[2]*r[12]*r[7]-r[3]*r[4]*r[14]+r[3]*r[12]*r[6],e[7]=r[0]*r[6]*r[11]-r[0]*r[10]*r[7]-r[2]*r[4]*r[11]+r[2]*r[8]*r[7]+r[3]*r[4]*r[10]-r[3]*r[8]*r[6],e[8]=r[4]*r[9]*r[15]-r[4]*r[13]*r[11]-r[5]*r[8]*r[15]+r[5]*r[12]*r[11]+r[7]*r[8]*r[13]-r[7]*r[12]*r[9],e[9]=-r[0]*r[9]*r[15]+r[0]*r[13]*r[11]+r[1]*r[8]*r[15]-r[1]*r[12]*r[11]-r[3]*r[8]*r[13]+r[3]*r[12]*r[9],e[10]=r[0]*r[5]*r[15]-r[0]*r[13]*r[7]-r[1]*r[4]*r[15]+r[1]*r[12]*r[7]+r[3]*r[4]*r[13]-r[3]*r[12]*r[5],e[11]=-r[0]*r[5]*r[11]+r[0]*r[9]*r[7]+r[1]*r[4]*r[11]-r[1]*r[8]*r[7]-r[3]*r[4]*r[9]+r[3]*r[8]*r[5],e[12]=-r[4]*r[9]*r[14]+r[4]*r[13]*r[10]+r[5]*r[8]*r[14]-r[5]*r[12]*r[10]-r[6]*r[8]*r[13]+r[6]*r[12]*r[9],e[13]=r[0]*r[9]*r[14]-r[0]*r[13]*r[10]-r[1]*r[8]*r[14]+r[1]*r[12]*r[10]+r[2]*r[8]*r[13]-r[2]*r[12]*r[9],e[14]=-r[0]*r[5]*r[14]+r[0]*r[13]*r[6]+r[1]*r[4]*r[14]-r[1]*r[12]*r[6]-r[2]*r[4]*r[13]+r[2]*r[12]*r[5],e[15]=r[0]*r[5]*r[10]-r[0]*r[9]*r[6]-r[1]*r[4]*r[10]+r[1]*r[8]*r[6]+r[2]*r[4]*r[9]-r[2]*r[8]*r[5];const i=r[0]*e[0]+r[1]*e[4]+r[2]*e[8]+r[3]*e[12];let n=16;for(;n--;)e[n]/=i;return t}canMultiply(t){return m(K,t),this.width==t.height}times(t){m(K,t),g(this.canMultiply(t),`Cannot multiply this ${this.dimString()} by matrix ${t.dimString()}`);const r=t.width,e=this.height,i=this.width,n=new Float64Array(r*e);let s=e;for(;s--;){let e=r;for(;e--;){let h=0,o=i;for(;o--;)h+=this.m[s*i+o]*t.m[o*r+e];n[s*r+e]=h}}return new K(r,e,n)}timesVector(t){N(t),g(this.width==t.dim());const r=this.height,e=this.width,i=new Float64Array(r);let n=r;for(;n--;){let r=0,s=e;for(;s--;)r+=this.m[n*e+s]*t.v[s];i[n]=r}return new et(i)}transposed(){const t=this.height,r=this.width,e=new Float64Array(t*r);let i=r;for(;i--;){let n=t;for(;n--;)e[i*t+n]=this.m[n*r+i]}return new K(t,r,e)}transpose(){const t=this.height,r=this.width,e=this.m;let i=t;for(;i--;){let n=Math.min(i,r);for(;n--;){const s=e[i*r+n];e[i*r+n]=e[n*t+i],e[n*t+i]=s}}this.width=t,this.height=r}isSquare(){return this.height==this.width}diagonal(){if(!this.isSquare())throw Error("!!");const t=new Float64Array(this.width);let r=this.width*(this.width+1),e=this.width;for(;e--;)r-=this.width+1,t[e]=this.m[r];return new et(t)}maxEl(){return R(this.m)}minEl(){return function(t){let r=t.length,e=1/0;for(;r--;){const i=t[r];e>i&&(e=i)}return e}(this.m)}maxAbsColSum(){let t=0,r=this.width;for(;r--;){let e=0,i=this.height;for(;i--;)e+=Math.abs(this.m[i*this.width+r]);t=Math.max(t,e)}return t}maxAbsRowSum(){let t=0,r=this.height;for(;r--;){let e=0,i=this.width;for(;i--;)e+=Math.abs(this.m[r*this.width+i]);t=Math.max(t,e)}return t}getTriangularDeterminant(){g(this.isUpperTriangular()||this.isLowerTriangular(),"not a triangular matrix");let t=1,r=this.width*(this.width+1);for(;r;)r-=this.width+1,t*=this.m[r];return t}getDeterminant(){return this.luDecomposition().U.getTriangularDeterminant()}hasFullRank(){return Math.min(this.width,this.height)==this.rank()}permutationAsIndexMap(){y((()=>this.isPermutation()));const t=Array(this.height);let r=this.height;for(;r--;){const e=r*this.width;let i=e;for(;this.m[i]<.5;)i++;t[r]=i-e}return t}getDependentRowIndexes(t=this.luDecomposition()){const{L:r,U:e,P:i}=t,n=Array(this.height);let s=this.height;for(;s--&&e.row(s).length()<c;)n[s]=!0;let h=this.height;for(;h--;)if(n[h]){let t=Math.min(h,this.width);for(;t--;)0!==r.e(h,t)&&(n[t]=!0)}console.log("m\n",this.toString((t=>""+t))),console.log("L\n",r.toString((t=>""+t))),console.log("U\n",e.toString((t=>""+t))),console.log("P\n",i.toString((t=>""+t)));const o=i.permutationAsIndexMap();return n.map(((t,r)=>t&&o[r])).filter((t=>null!=t))}lerp(t,r,e=this.new()){m(K,t,e),f(r),g(this.width==t.width&&this.height==t.height);const i=1-r;let n=this.m.length;for(;n--;)e.m[n]=i*this.m[n]+r*t.m[n];return e}}const{PI:Q,abs:tt}=Math;class rt extends K{constructor(...t){let r;if(0==t.length)r=new Float64Array(16);else{const e=function(t){return Array.prototype.concat.apply([],t)}(t);g(16==e.length,"flattened.length == 16 "+e.length),r=new Float64Array(e)}super(4,4,r)}static inverse(t,r=new rt){return t.inversed4(r)}static permutation4(t,r,e=new rt){d(t,r),y((()=>0<=t&&t<4)),y((()=>0<=r&&r<4));const i=e.m;return rt.identity(e),i[4*t+t]=0,i[4*r+r]=0,i[4*t+r]=1,i[4*r+t]=1,e}static transpose(t,r=new rt){m(rt,t),m(rt,r),g(t!=r,"matrix != result");const e=t.m,i=r.m;return i[0]=e[0],i[1]=e[4],i[2]=e[8],i[3]=e[12],i[4]=e[1],i[5]=e[5],i[6]=e[9],i[7]=e[13],i[8]=e[2],i[9]=e[6],i[10]=e[10],i[11]=e[14],i[12]=e[3],i[13]=e[7],i[14]=e[11],i[15]=e[15],r}static multiply(t,r,e=new rt){m(rt,t,r),m(rt,e),g(t!=e,"left != result"),g(r!=e,"right != result");const i=t.m,n=r.m,s=e.m;return s[0]=i[0]*n[0]+i[1]*n[4]+(i[2]*n[8]+i[3]*n[12]),s[1]=i[0]*n[1]+i[1]*n[5]+(i[2]*n[9]+i[3]*n[13]),s[2]=i[0]*n[2]+i[1]*n[6]+(i[2]*n[10]+i[3]*n[14]),s[3]=i[0]*n[3]+i[1]*n[7]+(i[2]*n[11]+i[3]*n[15]),s[4]=i[4]*n[0]+i[5]*n[4]+(i[6]*n[8]+i[7]*n[12]),s[5]=i[4]*n[1]+i[5]*n[5]+(i[6]*n[9]+i[7]*n[13]),s[6]=i[4]*n[2]+i[5]*n[6]+(i[6]*n[10]+i[7]*n[14]),s[7]=i[4]*n[3]+i[5]*n[7]+(i[6]*n[11]+i[7]*n[15]),s[8]=i[8]*n[0]+i[9]*n[4]+(i[10]*n[8]+i[11]*n[12]),s[9]=i[8]*n[1]+i[9]*n[5]+(i[10]*n[9]+i[11]*n[13]),s[10]=i[8]*n[2]+i[9]*n[6]+(i[10]*n[10]+i[11]*n[14]),s[11]=i[8]*n[3]+i[9]*n[7]+(i[10]*n[11]+i[11]*n[15]),s[12]=i[12]*n[0]+i[13]*n[4]+(i[14]*n[8]+i[15]*n[12]),s[13]=i[12]*n[1]+i[13]*n[5]+(i[14]*n[9]+i[15]*n[13]),s[14]=i[12]*n[2]+i[13]*n[6]+(i[14]*n[10]+i[15]*n[14]),s[15]=i[12]*n[3]+i[13]*n[7]+(i[14]*n[11]+i[15]*n[15]),e}static product(...t){const[r,e]=Array.isArray(t[0])?[t[0],t[1]]:[t,new rt];if(0==r.length)return rt.identity(e);if(1==r.length)return rt.copy(r[0],e);if(2==r.length)return rt.multiply(r[0],r[1],e);let i=rt.temp0,n=rt.temp1;rt.multiply(r[0],r[1],i);for(let t=2;t<r.length-1;t++)rt.multiply(i,r[t],n),[i,n]=[n,i];return rt.multiply(i,function(t){return t[t.length-1]}(r),e)}static forSys(t,r,e=t.cross(r),i=U.O){return N(t,r,e,i),new rt(t.x,r.x,e.x,i.x,t.y,r.y,e.y,i.y,t.z,r.z,e.z,i.z,0,0,0,1)}static forRows(t,r,e,i=U.O){return N(t,r,e,i),new rt(t.x,t.y,t.z,0,r.x,r.y,r.z,0,e.x,e.y,e.z,0,i.x,i.y,i.z,1)}static identity(t=new rt){m(rt,t);const r=t.m;return r[0]=r[5]=r[10]=r[15]=1,r[1]=r[2]=r[3]=r[4]=r[6]=r[7]=r[8]=r[9]=r[11]=r[12]=r[13]=r[14]=0,t}static fromFunction4(t,r=new rt){g("function"==typeof t),m(rt,r);const e=r.m;let i=16;for(;i--;)e[i]=t(Math.floor(i/4),i%4,i);return r}static perspective(t,r,e,i,n=new rt){return rt.perspectiveRad(t*P,r,e,i,n)}static perspectiveRad(t,r,e,i,n=new rt){m(rt,n),f(t,r,e,i);const s=Math.tan(t/2)*e,h=s*r;return rt.frustum(-h,h,-s,s,e,i,n)}static perspectivePlane(t,r=new rt){m(rt,r);const e=r.m;return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=t.normal1.x,e[13]=t.normal1.y,e[14]=t.normal1.z,e[15]=-t.w,r}static frustum(t,r,e,i,n,s,h=new rt){f(t,r,e,i,n,s),g(0<n,"0 < near"),g(n<s,"near < far"),m(rt,h);const o=h.m;return o[0]=2*n/(r-t),o[1]=0,o[2]=(r+t)/(r-t),o[3]=0,o[4]=0,o[5]=2*n/(i-e),o[6]=(i+e)/(i-e),o[7]=0,o[8]=0,o[9]=0,o[10]=-(s+n)/(s-n),o[11]=-2*s*n/(s-n),o[12]=0,o[13]=0,o[14]=-1,o[15]=0,h}static projectPlanePoint(t,r,e=new rt){N(t,r.normal1),m(rt,e);const i=e.m,n=r.normal1,s=r.w,h=n.dot(t);return i[0]=t.x*n.x+s-h,i[1]=t.x*n.y,i[2]=t.x*n.z,i[3]=-s*t.x,i[4]=t.y*n.x,i[5]=t.y*n.y+s-h,i[6]=t.y*n.z,i[7]=-s*t.y,i[8]=t.z*n.x,i[9]=t.z*n.y,i[10]=t.z*n.z+s-h,i[11]=-s*t.z,i[12]=n.x,i[13]=n.y,i[14]=n.z,i[15]=-h,e}static ortho(t,r,e,i,n,s,h=new rt){f(t,r,e,i,n,s),m(rt,h);const o=h.m;return o[0]=2/(r-t),o[1]=0,o[2]=0,o[3]=-(r+t)/(r-t),o[4]=0,o[5]=2/(i-e),o[6]=0,o[7]=-(i+e)/(i-e),o[8]=0,o[9]=0,o[10]=-2/(s-n),o[11]=-(s+n)/(s-n),o[12]=0,o[13]=0,o[14]=0,o[15]=1,h}static scale(...t){let r,e,i,n;t[0]instanceof U?(g(t.length<=2),({x:r,y:e,z:i}=t[0]),n=t[1]):"number"!=typeof t[1]?(r=e=i=t[0],n=t[1]):(g(t.length<=4),r=t[0],e=t[1],i=null!=t[2]?t[2]:1,n=t[3]),null==n&&(n=new rt),m(rt,n),f(r,e,i);const s=n.m;return s[0]=r,s[1]=0,s[2]=0,s[3]=0,s[4]=0,s[5]=e,s[6]=0,s[7]=0,s[8]=0,s[9]=0,s[10]=i,s[11]=0,s[12]=0,s[13]=0,s[14]=0,s[15]=1,n}static translate(...t){let r,e,i,n;t[0]instanceof U?(g(t.length<=2),({x:r,y:e,z:i}=t[0]),n=t[1]):(g(t.length<=4),r=t[0],e=null!=t[1]?t[1]:0,i=null!=t[2]?t[2]:0,n=t[3]),null==n&&(n=new rt),m(rt,n),f(r,e,i);const s=n.m;return s[0]=1,s[1]=0,s[2]=0,s[3]=r,s[4]=0,s[5]=1,s[6]=0,s[7]=e,s[8]=0,s[9]=0,s[10]=1,s[11]=i,s[12]=0,s[13]=0,s[14]=0,s[15]=1,n}static rotate(t,r,e){null==e&&(e=new rt),m(rt,e);let{x:i,y:n,z:s}=r;g(!new U(i,n,s).likeO(),"!V(x, y, z).likeO()");const h=e.m,o=Math.sqrt(i*i+n*n+s*s);i/=o,n/=o,s/=o;const a=Math.cos(t),l=Math.sin(t),u=1-a;return h[0]=i*i*u+a,h[1]=i*n*u-s*l,h[2]=i*s*u+n*l,h[3]=0,h[4]=n*i*u+s*l,h[5]=n*n*u+a,h[6]=n*s*u-i*l,h[7]=0,h[8]=s*i*u-n*l,h[9]=s*n*u+i*l,h[10]=s*s*u+a,h[11]=0,h[12]=0,h[13]=0,h[14]=0,h[15]=1,e}static lookAt(t,r,e,i=new rt){N(t,r,e),m(rt,i);const n=i.m,s=t.minus(r).unit(),h=e.cross(s).unit(),o=s.cross(h).unit();return n[0]=h.x,n[1]=h.y,n[2]=h.z,n[3]=-h.dot(t),n[4]=o.x,n[5]=o.y,n[6]=o.z,n[7]=-o.dot(t),n[8]=s.x,n[9]=s.y,n[10]=s.z,n[11]=-s.dot(t),n[12]=0,n[13]=0,n[14]=0,n[15]=1,i}static rotateX(t){f(t);const r=Math.sin(t),e=Math.cos(t);return new rt([1,0,0,0,0,e,-r,0,0,r,e,0,0,0,0,1])}static rotateY(t){const r=Math.sin(t),e=Math.cos(t);return new rt([e,0,r,0,0,1,0,0,-r,0,e,0,0,0,0,1])}static rotateZ(t){const r=Math.sin(t),e=Math.cos(t);return new rt([e,-r,0,0,r,e,0,0,0,0,1,0,0,0,0,1])}static rotateAB(t,r,e=new rt){N(t,r),m(rt,e);const i=t.cross(r),n=i.length();if(M(n))return rt.identity(e);const s=Math.atan2(n,t.dot(r));return rt.rotateLine(U.O,i,s,e)}static rotateLine(t,r,e,i=new rt){N(t,r),f(e),m(rt,i),r=r.unit();const n=t.x,s=t.y,h=t.z,o=r.x,a=r.y,l=r.z,u=i.m,c=Math.cos(e),d=Math.sin(e);return u[0]=o*o+(a*a+l*l)*c,u[1]=o*a*(1-c)-l*d,u[2]=o*l*(1-c)+a*d,u[3]=(n*(a*a+l*l)-o*(s*a+h*l))*(1-c)+(s*l-h*a)*d,u[4]=o*a*(1-c)+l*d,u[5]=a*a+(o*o+l*l)*c,u[6]=a*l*(1-c)-o*d,u[7]=(s*(o*o+l*l)-a*(n*o+h*l))*(1-c)+(h*o-n*l)*d,u[8]=o*l*(1-c)-a*d,u[9]=a*l*(1-c)+o*d,u[10]=l*l+(o*o+a*a)*c,u[11]=(h*(o*o+a*a)-l*(n*o+s*a))*(1-c)+(n*a-s*o)*d,u[12]=0,u[13]=0,u[14]=0,u[15]=1,i}static mirror(t,r=new rt){N(t.normal1),m(rt,r);const[e,i,n]=t.normal1,s=t.w,h=r.m;return h[0]=1-2*e*e,h[1]=-2*i*e,h[2]=-2*n*e,h[3]=2*e*s,h[4]=-2*e*i,h[5]=1-2*i*i,h[6]=-2*n*i,h[7]=2*i*s,h[8]=-2*e*n,h[9]=-2*i*n,h[10]=1-2*n*n,h[11]=2*n*s,h[12]=0,h[13]=0,h[14]=0,h[15]=1,r}static project(t,r=t.normal1,e=new rt){N(r,t.normal1),m(rt,e);const i=t.w,n=e.m,s=t.normal1.dot(r),{x:h,y:o,z:a}=t.normal1,{x:l,y:u,z:c}=r.div(s);return n[0]=1-h*l,n[1]=-o*l,n[2]=-a*l,n[3]=l*i,n[4]=-h*u,n[5]=1-o*u,n[6]=-a*u,n[7]=u*i,n[8]=-h*c,n[9]=-o*c,n[10]=1-a*c,n[11]=c*i,n[12]=0,n[13]=0,n[14]=0,n[15]=1,e}static lineProjection(t,r=new rt){N(t.anchor,t.dir1),m(rt,r);const e=t.anchor.x,i=t.anchor.y,n=t.anchor.z,s=t.dir1.x,h=t.dir1.y,o=t.dir1.z,a=r.m;return a[0]=s*s,a[1]=s*h,a[2]=s*o,a[3]=e,a[4]=h*s,a[5]=h*h,a[6]=h*o,a[7]=i,a[8]=o*s,a[9]=o*h,a[10]=o*o,a[11]=n,a[12]=0,a[13]=0,a[14]=0,a[15]=1,r}static pointInversion(t,r=new rt){N(t),m(rt,r);const e=r.m;return e[0]=-1,e[1]=0,e[2]=0,e[3]=2*t.x,e[4]=0,e[5]=-1,e[6]=0,e[7]=2*t.y,e[8]=0,e[9]=0,e[10]=-1,e[11]=2*t.z,e[12]=0,e[13]=0,e[14]=0,e[15]=1,r}static new(t,r,e){return g(4==t&&4==r),new rt(...e)}get X(){return this.transformVector(U.X)}get Y(){return this.transformVector(U.Y)}get Z(){return this.transformVector(U.Z)}get O(){return this.getTranslation()}isMirror(t=c){const r=this.m,e=Math.sqrt((1-r[0])/2),i=Math.sqrt((1-r[5])/2),n=Math.sqrt((1-r[10])/2);return v(r[1],-2*i*e,t)&&v(r[2],-2*n*e,t)&&v(r[4],-2*e*i,t)&&v(r[6],-2*n*i,t)&&v(r[8],-2*e*n,t)&&v(r[9],-2*i*n,t)&&v(r[12],0,t)&&v(r[13],0,t)&&v(r[14],0,t)&&v(r[15],1,t)&&v(r[3]*i,r[7]*e,t)&&v(r[7]*n,r[11]*i,t)&&v(r[11]*e,r[3]*n,t)}inversed(t){return rt.inverse(this,t)}trace(){return this.m[0]+this.m[5]+this.m[10]+this.m[15]}as3x3(t){const r=(t=rt.copy(this,t)).m;return r[3]=r[7]=r[11]=r[12]=r[13]=r[14]=0,r[15]=1,t}transform(t){return t.times(this)}realEigenValues3(){const t=this.m;g(0==t[12]&&0==t[13]&&0==t[14]);const[r,e,i,,n,s,h,,o,a,l]=t,u=r+s+l,c=-r*s-r*l+e*n+i*o-s*l+h*a,m=r*(s*l-h*a)-e*(n*l-h*o)+i*(n*a-s*o);return console.log(-1,u,c,m),I(-1,u,c,m)}realEigenVectors3(){const t=this.realEigenValues3(),r=this.times(rt.IDENTITY3);console.log(this.toString()),console.log(r.toString());let e=t.map((t=>rt.IDENTITY3.scale(-t).plus(r)));if(console.log(e.map((t=>t.determinant3()))),console.log(e.map((t=>""+t.toString((t=>""+t)))).join("\n\n")),console.log(e.map((t=>""+t.luDecomposition().U.toString((t=>""+t)))).join("\n\n")),console.log("mats.map(m=>m.rank())",e.map((t=>t.rank()))),1==t.length)return console.log(e[0].toString()),y((()=>0==e[0].rank())),X(3,(t=>new U(this.m[t],this.m[4+t],this.m[8+t])));if(2==t.length){1==e[0].rank()&&(e=[e[1],e[0]]),y((()=>2==e[0].rank())),y((()=>1==e[1].rank()));const t=e[0].luDecomposition().U,r=t.row(0).cross(t.row(1)).V3().unit(),i=e[1].luDecomposition().U.row(0).V3(),n=i.getPerpendicular().unit(),s=r.cross(n).rejectedFrom(i);return[r,n,s]}if(3==t.length)return e.forEach(((t,r)=>g(2==t.rank(),r+": "+t.rank()))),e.map((t=>{const r=t.luDecomposition().U;return r.row(0).cross(r.row(1)).V3().unit()}));throw Error("there cannot be more than 3 eigen values")}svd3(){function t(t,r,e,i){const n=rt.identity();return n.setEl(t,t,e),n.setEl(r,r,e),n.setEl(t,r,i),n.setEl(r,t,-i),n}const r=this.as3x3();let e=r.transposed().times(r),i=rt.identity();console.log(e.toString());for(let n=0;n<16;n++){console.log("blahg\n",i.times(e).times(i.transposed()).toString()),g(i.times(e).times(i.transposed()).likeM4(r.transposed().times(r)),i.times(e).times(i.transposed()).toString(),r.transposed().times(r).toString());let n=0,s=1,h=10;for(;h--;){const t=Math.abs(e.m[h]);h%4!=Math.floor(h/4)&&t>n&&(n=t,s=h)}const o=Math.floor(s/4),a=s%4,l=e.m[5*o],u=e.m[5*a],c=e.m[s],m=l===u?Q/4:Math.atan(2*c/(l-u))/2;console.log(s,o,a,"phi",m);const f=t(o,a,Math.cos(m),-Math.sin(m));g(f.transposed().times(f).likeIdentity()),console.log(f.toString()),i=i.times(f),e=rt.product(f.transposed(),e,f),console.log(e.toString())}const n=e.map(((t,r)=>r%5==0?Math.sqrt(t):0));return{U:rt.product(r,i,n.map(((t,r)=>r%5==0?1/t:0))),SIGMA:n,VSTAR:i.transposed()}}map(t){return rt.fromFunction4(((r,e,i)=>t(this.m[i],i,this.m)))}likeM4(t){return m(rt,t),this.m.every(((r,e)=>v(r,t.m[e])))}transposed(t){return rt.transpose(this,t)}times(t){return rt.multiply(this,t)}vanishingPoint(t){N(t);const r=this.m,e=t.x,i=t.y,n=t.z,s=e*r[12]+i*r[13]+n*r[14];if(M(s))return;const h=e*r[0]+i*r[1]+n*r[2],o=e*r[4]+i*r[5]+n*r[6],a=e*r[8]+i*r[9]+n*r[10];return new U(h/s,o/s,a/s)}transformPoint(t){N(t);const r=this.m,e=t.x,i=t.y,n=t.z,s=e*r[0]+i*r[1]+n*r[2]+r[3],h=e*r[4]+i*r[5]+n*r[6]+r[7],o=e*r[8]+i*r[9]+n*r[10]+r[11],a=e*r[12]+i*r[13]+n*r[14]+r[15];return new U(s/a,h/a,o/a)}transformVector(t,r=!0){N(t);const e=this.m,i=t.x*e[12]+t.y*e[13]+t.z*e[14];return r&&g(M(i),(()=>"w === 0 needs to be true for this to make sense (w ="+i+this.toString())),new U(e[0]*t.x+e[1]*t.y+e[2]*t.z,e[4]*t.x+e[5]*t.y+e[6]*t.z,e[8]*t.x+e[9]*t.y+e[10]*t.z)}transformVector2(t,r){N(t,r);const e=this.timesVector(it(r.x,r.y,r.z,1)),i=this.timesVector(it(t.x,t.y,t.z,0));return i.times(e.w).minus(e.times(i.w)).div(Math.pow(e.w,2)).V3()}transformedPoints(t){return t.map((t=>this.transformPoint(t)))}transformedVectors(t){return t.map((t=>this.transformVector(t)))}new(){return new rt}isRegular(){return!M(this.determinant())}isAxisAligned(){const t=this.m;return 1>=+!M(t[0])+ +!M(t[1])+ +!M(t[2])&&1>=+!M(t[4])+ +!M(t[5])+ +!M(t[6])&&1>=+!M(t[8])+ +!M(t[9])+ +!M(t[10])}isOrthogonal(){return rt.transpose(this,rt.temp0),rt.multiply(this,rt.temp0,rt.temp1),rt.IDENTITY.likeM4(rt.temp1)}isSymmetric(){return rt.transpose(this,rt.temp0),this.likeM4(rt.temp0)}isSkewSymmetric(t){return M(this.m[0],t)&&M(this.m[5],t)&&M(this.m[10],t)&&M(this.m[15],t)&&v(this.m[1],this.m[4],t)&&v(this.m[2],this.m[8],t)&&v(this.m[3],this.m[12],t)&&v(this.m[6],this.m[9],t)&&v(this.m[7],this.m[13],t)&&v(this.m[11],this.m[14],t)}isNormal(){return rt.transpose(this,rt.temp0),rt.multiply(this,rt.temp0,rt.temp1),rt.multiply(rt.temp0,this,rt.temp2),rt.temp1.likeM4(rt.temp2)}determinant(){const t=this.m,r=t[0],e=t[1],i=t[2],n=t[3],s=t[4],h=t[5],o=t[6],a=t[7],l=t[8],u=t[9],c=t[10],m=t[11],f=t[12],d=t[13],g=t[14],y=t[15],w=c*y-m*g,p=u*y-m*d,x=u*g-c*d,M=l*y-m*f,v=l*g-c*f,z=l*d-u*f;return r*(h*w-o*p+a*x)-e*(s*w-o*M+a*v)+i*(s*p-h*M+a*z)-n*(s*x-h*v+o*z)}determinant3(){const[t,r,e,,i,n,s,,h,o,a]=this.m;return t*(n*a-s*o)-r*(i*a-s*h)+e*(i*o-n*h)}isMirroring(){return this.determinant()<0}getTranslation(){const t=this.m,r=t[15];return new U(t[3]/r,t[7]/r,t[11]/r)}normalized(){const t=tt(this.determinant());return 1==t?this:this.divScalar(Math.pow(t,.25))}normalized2(){const t=this.m[15];return 1==t?this:this.divScalar(t)}like3x3(){const t=this.m;return v(1,t[15])&&M(t[12])&&M(t[13])&&M(t[14])&&M(t[3])&&M(t[7])&&M(t[11])}isNoProj(){const t=this.m;return 0==t[12]&&0==t[13]&&0==t[14]&&1==t[15]}likeIdentity(){return this.m.every(((t,r)=>(r/4|0)==r%4?v(1,t):M(t)))}isIdentity(){return this.m.every(((t,r)=>(r/4|0)==r%4?1==t:0==t))}toString(t=(t=>t.toFixed(6).replace(/([0.])(?=0*$)/g," "))){g("string"==typeof t(0),typeof t(0));const r=Array.prototype.slice.call(this.m).map(t),e=[0,1,2,3].map((t=>R(function(t,r,e,i,n=1){f(r,i),r<0&&(r=t.length+r),e<=0&&(e=t.length+e);const s=Math.ceil((e-r)/i),h=Array(s);let o=0;for(let s=r;s<e;s+=i)for(let r=s;r<Math.min(s+n,e);r++)h[o++]=t[r];return g(s==o),h}(r,t,0,4).map((t=>t.length)))));return[0,1,2,3].map((t=>r.slice(4*t,4*t+4).map(((t,r)=>" ".repeat(e[r]-t.length)+t)).join(" "))).join("\n")}isTranslation(){return[1,0,0,2,0,1,0,2,0,0,1,2,0,0,0,1].every(((t,r)=>2==t||t==this.m[r]))}isScaling(){return[2,0,0,0,0,2,0,0,0,0,2,0,0,0,0,1].every(((t,r)=>2==t||t==this.m[r]))}isZRotation(){return[2,2,0,0,2,2,0,0,0,0,1,0,0,0,0,1].every(((t,r)=>2==t||t==this.m[r]))&&v(1,Math.pow(this.m[0],2)+Math.pow(this.m[1],2))&&this.m[0]==this.m[5]&&this.m[1]==-this.m[4]}toSource(){const t=rt.NAMEMAP.get(this);if(t)return t;if(this.isTranslation())return T("M4.translate",this.O);if(this.isScaling())return T("M4.scale",this.m[0],this.m[5],this.m[10]);if(this.isNoProj())return this.O.equals(U.O)?T("M4.forSys",this.X,this.Y,this.Z):T("M4.forSys",this.X,this.Y,this.Z,this.O);if(this.isMirror(0)){const t=this.m,r=Math.sqrt((1-t[0])/2),e=Math.sqrt((1-t[5])/2),i=Math.sqrt((1-t[10])/2),n=t[3]/2/r;return T("M4.mirror",{normal1:new U(r,e,i),w:n})}{const t=this.m;return"new M4(\n\t"+t[0]+",\t"+t[1]+",\t"+t[2]+",\t"+t[3]+",\n\t"+t[4]+",\t"+t[5]+",\t"+t[6]+",\t"+t[7]+",\n\t"+t[8]+",\t"+t[9]+",\t"+t[10]+",\t"+t[11]+",\n\t"+t[12]+",\t"+t[13]+",\t"+t[14]+",\t"+t[15]+")"}}xyAreaFactor(){return this.transformVector(U.X).cross(this.transformVector(U.Y)).length()}}rt.FOO=new rt(0,1,1,2,.3,.4,.8,13,2.1,3.4,5.5,8.9,0,0,0,1),rt.FOO_INV=rt.FOO.inversed(),rt.IDENTITY=rt.identity(),rt.O=new rt(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),rt.YZX=rt.forSys(U.Y,U.Z,U.X),rt.ZXY=rt.forSys(U.Z,U.X,U.Y),rt.IDENTITY3=new rt(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0),rt.temp0=new rt,rt.temp1=new rt,rt.temp2=new rt,rt.NAMEMAP=(new i).set(rt.IDENTITY3,"M4.IDENTITY3").set(rt.FOO,"M4.FOO").set(rt.O,"M4.O").set(rt.FOO_INV,"M4.FOO_INV").set(rt.IDENTITY,"M4.IDENTITY").set(rt.ZXY,"M4.ZXY").set(rt.YZX,"M4.YZX"),rt.prototype.height=4,rt.prototype.width=4,F(rt.prototype,G.prototype,"constructor");class et{constructor(t){this.v=t,m(Float64Array,t)}static fromFunction(t,r){f(t);const e=new Float64Array(t);let i=t;for(;i--;)e[i]=r(i);return new et(e)}static random(t){return et.fromFunction(t,(t=>Math.random()))}static from(...t){return g(t[0]instanceof Float64Array||t.every((t=>"number"==typeof t)),'args[0] instanceof Float64Array || args.every(a => "number" == typeof a)'),new et(t[0]instanceof Float64Array?t[0]:Float64Array.from(t))}static Zero(t){f(t);let r=0;const e=new Float64Array(t);for(;r--;)e[r]=0;return new et(e)}static Unit(t,r){f(t,r);let e=0;const i=new Float64Array(t);for(;e--;)i[e]=+(e==r);return new et(i)}static pack(t,r,e=0,i=0,n=t.length-e){const s=t[0].dim(),h=r||new Float32Array(s*n);g(h.length-i>=n*s,"dest.length - destStart >= v3count * 3",h.length,i,3*n);let o=n,a=e,l=i;for(;o--;){const r=t[a++];for(let t=0;t<s;t++)h[l++]=r.v[t]}return h}static lerp(t,r,e){g(t.dim()==r.dim());const i=new Float64Array(t.v.length);let n=t.v.length;for(;n--;)i[n]=t.v[n]*(1-e)+r.v[n]*e;return new et(i)}static add(...t){const r=t[0].v.length,e=new Float64Array(r);let i=t.length;for(;i--;){let n=r;for(;n--;)e[n]+=t[i].v[n]}return new et(e)}static fromV3AndWeight(t,r){return new et(new Float64Array([t.x*r,t.y*r,t.z*r,r]))}get x(){return this.v[0]}get y(){return this.v[1]}get z(){return this.v[2]}get w(){return this.v[3]}[Symbol.iterator](){return this.v[Symbol.iterator]()}dim(){return this.v.length}e(t){if(0>t||t>=this.v.length)throw Error("array index out of bounds");return this.v[t]}plus(t){const r=this.v,e=t.v,i=new Float64Array(r.length);let n=r.length;for(;n--;)i[n]=r[n]+e[n];return new et(i)}minus(t){const r=this.v,e=t.v,i=new Float64Array(r.length);let n=r.length;for(;n--;)i[n]=r[n]-e[n];return new et(i)}times(t){const r=this.v,e=new Float64Array(r.length);let i=r.length;for(;i--;)e[i]=r[i]*t;return new et(e)}div(t){const r=this.v,e=new Float64Array(r.length);let i=r.length;for(;i--;)e[i]=r[i]/t;return new et(e)}dot(t){g(this.dim==t.dim,"passed vector must have the same dim");let r=0;const e=this.v,i=t.v;let n=e.length;for(;n--;)r+=e[n]*i[n];return r}cross(t){m(et,t);const r=new Float64Array(3);return r[0]=this.v[1]*t.v[2]-this.v[2]*t.v[1],r[1]=this.v[2]*t.v[0]-this.v[0]*t.v[2],r[2]=this.v[0]*t.v[1]-this.v[1]*t.v[0],new et(r)}schur(t){m(et,t);const r=this.v,e=t.v,i=new Float64Array(r.length);let n=r.length;for(;n--;)i[n]=r[n]*e[n];return new et(i)}equals(t){if(t===this)return!0;if(t.constructor!==et)return!1;if(this.v.length!=t.v.length)return!1;let r=this.v.length;for(;r--;)if(this.v[r]!==t.v[r])return!1;return!0}like(t,r){if(t===this)return!0;if(t.constructor!==et)return!1;if(this.v.length!=t.v.length)return!1;let e=this.v.length;for(;e--;)if(!v(this.v[e],t.v[e],r))return!1;return!0}map(t){return new et(this.v.map(t))}toString(t){return t=t||(t=>+t.toFixed(6)),"Vector("+this.v.map(t).join(", ")+")"}toSource(){return T("VV",...this.v)}angleTo(t){return m(et,t),g(!this.isZero(),"!this.likeO()"),g(!t.isZero(),"!vector.likeO()"),Math.acos(S(this.dot(t)/this.length()/t.length(),-1,1))}isParallelTo(t){return m(et,t),g(!this.isZero(),"!this.likeO()"),g(!t.isZero(),"!vector.likeO()"),v(Math.sqrt(this.lengthSquared()*t.lengthSquared()),Math.abs(this.dot(t)))}isPerpendicularTo(t){return m(et,t),g(!this.isZero(),"!this.likeO()"),g(!t.isZero(),"!vector.likeO()"),M(this.dot(t))}isZero(){return M(this.length())}length(){return Math.hypot.apply(void 0,this.v)}lengthSquared(){let t=0;const r=this.v;let e=r.length;for(;e--;)t+=r[e]*r[e];return t}unit(){const t=this.length();if(M(t))throw Error("cannot normalize zero vector");return this.div(this.length())}normalized(){throw Error("documentation stub. use .unit()")}asRowMatrix(){return new K(this.v.length,1,this.v)}asColMatrix(){return new K(1,this.v.length,this.v)}projectedOn(t){return m(et,t),t.times(this.dot(t)/t.dot(t))}rejectedOn(t){return m(et,t),this.minus(t.times(this.dot(t)/t.dot(t)))}to(t){return t.minus(this)}hasLength(t){return f(t),v(t,this.length())}V3(){return new U(this.v[0],this.v[1],this.v[2])}p3(){g(4==this.v.length);const t=this.v[3];return new U(this.v[0]/t,this.v[1]/t,this.v[2]/t)}transposed(){return new K(this.v.length,1,this.v)}}function it(...t){return new et(new Float64Array(t))}class nt extends G{constructor(t=U.INF,r=U.INF.negated()){super(),this.min=t,this.max=r,N(t,r)}static forXYZ(t,r,e){return new nt(U.O,new U(t,r,e))}static forAABBs(t){const r=new nt;for(const e of t)r.addAABB(e);return r}addPoint(t){return N(t),this.min=this.min.min(t),this.max=this.max.max(t),this}addPoints(t){return t.forEach((t=>this.addPoint(t))),this}addAABB(t){return m(nt,t),this.addPoint(t.min),this.addPoint(t.max),this}withoutAABB(t){let r,e;m(nt,t);const i=this.volume(),n=this.size();let s=-1/0;for(let h=0;h<3;h++){const o=["x","y","z"][h],a=t.min[o]-this.min[o]>this.max[o]-t.max[o],l=a?this.min[o]:Math.max(this.min[o],t.max[o]),u=a?Math.min(this.max[o],t.min[o]):this.max[o],c=(u-l)*i/n[o];c>s&&(s=c,r=this.min.withElement(o,l),e=this.max.withElement(o,u))}return new nt(r,e)}getIntersectionAABB(t){return m(nt,t),new nt(this.min.max(t.min),this.max.min(t.max))}touchesAABB(t){return m(nt,t),!(this.min.x>t.max.x||this.max.x<t.min.x||this.min.y>t.max.y||this.max.y<t.min.y||this.min.z>t.max.z||this.max.z<t.min.z)}touchesAABBfuzzy(t,r=c){return m(nt,t),!(z(t.max.x,this.min.x,r)||z(this.max.x,t.min.x,r)||z(t.max.y,this.min.y,r)||z(this.max.y,t.min.y,r)||z(t.max.z,this.min.z,r)||z(this.max.z,t.min.z,r))}intersectsAABB(t){return m(nt,t),!(this.min.x>=t.max.x||this.max.x<=t.min.x||this.min.y>=t.max.y||this.max.y<=t.min.y||this.min.z>=t.max.z||this.max.z<=t.min.z)}intersectsAABB2d(t){return m(nt,t),!(this.min.x>=t.max.x||this.max.x<=t.min.x||this.min.y>=t.max.y||this.max.y<=t.min.y)}containsPoint(t){return N(t),this.min.x<=t.x&&this.min.y<=t.y&&this.min.z<=t.z&&this.max.x>=t.x&&this.max.y>=t.y&&this.max.z>=t.z}containsSphere(t,r){return N(t),f(r),this.distanceToPoint(t)>r}intersectsSphere(t,r){return N(t),f(r),this.distanceToPoint(t)<=r}distanceToPoint(t){N(t);const r=t.x,e=t.y,i=t.z,n=this.min,s=this.max;return this.containsPoint(t)?Math.max(n.x-r,r-s.x,n.y-e,e-s.y,n.z-i,i-s.z):t.distanceTo(new U(S(r,n.x,s.x),S(e,n.y,s.y),S(i,n.z,s.z)))}containsAABB(t){return m(nt,t),this.containsPoint(t.min)&&this.containsPoint(t.max)}likeAABB(t){return m(nt,t),this.min.like(t.min)&&this.max.like(t.max)}intersectsLine(t){N(t.anchor,t.dir1);const r=t.dir1.map((t=>t||5e-324)),e=this.min.minus(t.anchor).divv(r),i=this.max.minus(t.anchor).divv(r),n=e.min(i).maxElement(),s=e.max(i).minElement();return n<=s&&!(s<t.tMin||t.tMax<n)}hasVolume(){return this.min.x<=this.max.x&&this.min.y<=this.max.y&&this.min.z<=this.max.z}volume(){if(!this.hasVolume())return-1;const t=this.max.minus(this.min);return t.x*t.y*t.z}size(){return this.max.minus(this.min)}getCenter(){return this.min.plus(this.max).div(2)}transform(t){m(rt,t),g(t.isAxisAligned());const r=new nt;return r.addPoint(t.transformPoint(this.min)),r.addPoint(t.transformPoint(this.max)),r}ofTransformed(t){m(rt,t);const r=new nt;return r.addPoints(t.transformedPoints(this.corners())),r}corners(){const{min:t,max:r}=this;return[t,new U(t.x,t.y,r.z),new U(t.x,r.y,t.z),new U(t.x,r.y,r.z),new U(r.x,t.y,t.z),new U(r.x,t.y,r.z),new U(r.x,r.y,t.z),r]}toString(){return T("new AABB",this.min,this.max)}toSource(){return this.toString()}getM4(){return rt.translate(this.min).times(rt.scale(this.size()))}}}}]);