(self.webpackChunkworkshop=self.webpackChunkworkshop||[]).push([[3],{4003:n=>{"use strict";n.exports="#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\n\nfloat banded(float bandCount, float t) {\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\n}\nfloat banded(int bandCount, float t) {\n  return banded(float(bandCount), t);\n}\n\nbool between(float min, float max, float value) {\n    return min <= value && value <= max;\n}\n\nuniform sampler2D gradients;\n\nfloat dotGridGradient(vec2 cell, vec2 pos) {\n    vec2 d = cell - pos;\n\n    vec2 gradient = texelFetch(gradients, ivec2(cell), 0).xy;\n    return dot(gradient, d);\n}\n\nfloat mixx(float a, float b, float t) {\n     return mix(a, b, smoothstep(0.0, 1.0, t));\n//    return mix(a, b, t);\n}\n\n// resulting range is [-0.68, 0.68]. Use unmix to normalize if necessary.\nfloat perlin2D(vec2 xy) {\n    float x0 = floor(xy.x);\n    float x1 = x0 + 1.0;\n    float y0 = floor(xy.y);\n    float y1 = y0 + 1.0;\n\n    // Interpolate between grid point gradients\n    float n00 = dotGridGradient(vec2(x0, y0), xy);\n    float n10 = dotGridGradient(vec2(x1, y0), xy);\n    float ny0 = mixx(n00, n10, xy.x - x0);\n\n    float n01 = dotGridGradient(vec2(x0, y1), xy);\n    float n11 = dotGridGradient(vec2(x1, y1), xy);\n    float ny1 = mixx(n01, n11, xy.x - x0);\n\n    return mixx(ny0, ny1, xy.y - y0);\n}\n\nfloat test(vec2 xy) {\n    vec2 closestGP = round(xy);\n    return float(distance(closestGP, xy) < 0.5)\n    * float(abs(dotGridGradient(closestGP, xy)) < 0.1);\n}\n\nfloat unmix(float a, float b, float value) {\n  return (value - a) / (b - a);\n}\n\nfloat remix(float fromA, float fromB, float toA, float toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\nvec4 remix(float fromA, float fromB, vec4 toA, vec4 toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\nuniform float highResTimeStamp;\n\nfloat waves(vec4 color, vec2 position, vec2 direction) {\n    return sin(dot(position, direction / pow(length(direction), 2.0)) + float(highResTimeStamp) / 200.0);\n}\n\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\n  float isLow = float(t < 0.0);\n  float isHigh = float(t > 1.0);\n  float isMid = 1.0 - isLow - isHigh;\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\n}\n\nvec3 raToHex(vec2 xy) {\n    float hex_t = xy.y / 0.866;\n    float hex_s = xy.x - hex_t / 2.0;\n    return vec3(hex_s, hex_t, -(hex_s + hex_t));\n}\n\nvec2 hex2Ra(vec3 hex) {\n    float y = hex.t * 0.866;\n    float x = hex.s + hex.t / 2.0;\n    return vec2(x, y);\n}\n\nvec3 hexRound(vec3 hex) {\n    vec3 r = floor(hex + 0.5);\n    vec3 diff = abs(r - hex);\n\n    if (diff.x > diff.y && diff.x > diff.z) {\n        r.x = -(r.y + r.z);\n    } else if (diff.y > diff.z) {\n        r.y = -(r.x + r.z);\n    } else {\n        r.z = -(r.x + r.y);\n    }\n\n    return r;\n}\n\nfloat max3(float a, float b, float c) {\n  return max(a, max(b, c));\n}\nfloat max3(vec3 v) {\n  return max(v.x, max(v.y, v.z));\n}\n\nfloat hexSdf(vec3 hex) {\n    return max3(abs(hex.yzx + hex.zxy / 2.0));\n}\n\nuniform sampler2D texture;\nuniform vec4 colorPrimary;\nuniform vec4 colorSecondary;\nuniform vec4 colorBg;\nuniform float a;\nuniform int bandCount;\nin float n;\nin vec2 coord;\nout vec4 fragColor;\n\nconst vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\nconst vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\nconst vec4 blue = vec4(0.0, 0.0, 1.0, 1.0);\nconst vec4 red = vec4(1.0, 0.0, 0.0, 1.0);\n\nvoid main2() {\n    float fraction = (n + 0.5) * 0.5;\n    vec4 waves1 = mix(colorBg, colorPrimary,\n    float(waves(colorPrimary, coord, vec2(0.2, 0.05)) >= 0.7));\n    vec4 waves2 = mix(colorSecondary, colorBg,\n    float(waves(colorPrimary, coord, vec2(0.002, 0.1)) >= 0.7));\n\n    float perl = perlin2D(coord);\n    float perl01 = unmix(-.68, .68, perl);\n    float band = banded(3.0, perl01);\n    float isTop = float(band == 1.0);\n    float isBottom = float(band == 0.0);\n    fragColor = waves2 * isTop\n        + waves2 * isBottom\n        + (1.0 - isTop - isBottom) * mix(colorBg, colorPrimary,\n                banded(float(bandCount), unmix(0.333, 0.666, perl01)));\n//        + vec4(0.0, 0.0, 0.0, 1.0) * float(between(0.0, 0.3, perl));\n    // fragColor = mix(colorBg, colorPrimary, banded(float(bandCount), perl01));\n    // fragColor = visualize(blue, red, perl01);\n\n//    fragColor = mix(colorBg, colorPrimary, unmix(-0.5, 0.5, perl));\n    //fragColor = texelFetch(gradients, ivec2(coord), 0);\n\n}\n\nvoid main() {\n    vec3 hex_pos = raToHex(coord);\n    vec3 hex_center = hexRound(hex_pos);\n    vec2 center = hex2Ra(hex_center);\n    float centerPerl = unmix(-.68, .68, perlin2D(center / 20.0));\n    float isTop = float(centerPerl > a + 0.05);\n    float isBottom = float(centerPerl < a - 0.05);\n    vec4 hexColor = isTop * colorPrimary\n        + isBottom * colorSecondary\n        + (1.0 - isTop - isBottom) * colorBg;\n\n    hexColor = mix(colorBg, colorPrimary, banded(bandCount, centerPerl));\n\n    vec3 hex_d = hex_pos - hex_center;\n    float d = hexSdf(hex_d);\n    float isHex = smoothstep(-0.42, -0.38, -d);\n    fragColor = mix(colorBg, hexColor, isHex);\n}"}}]);