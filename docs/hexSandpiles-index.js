(self.webpackChunkworkshop=self.webpackChunkworkshop||[]).push([[729],{6746:(t,e,r)=>{"use strict";r.r(e),r.d(e,{default:()=>z});var n=r(9392),s=r(7392),i=r(9291),a=r(3376),o=r(1213),l=r(2276),h=r(9526);const c="#version 300 es\r\nin vec4 ts_Vertex;\r\nin vec2 ts_TexCoord;\r\nout vec2 coord;\r\nvoid main() {\r\n    coord = ts_TexCoord.xy;\r\n    gl_Position = ts_Vertex;\r\n}",d=r.p+"9f2a6e398434ad4fb383aa9d00d675e7.ttf",u="C:\\Users\\aval\\tsdev\\workshop\\src\\hexSandpiles\\index.tsx",x=(t,e,r,s)=>{const i=n.Kj.plane({startX:-1,width:2,startY:-1,height:2});return i.coords[0]=[t,e],i.coords[1]=[r,e],i.coords[2]=[t,s],i.coords[3]=[r,s],i.compile(),i},f=async(t,e,r)=>{await r(t+1,e),await r(t-1,e),await r(t,e+1),await r(t,e-1),await r(t+1-2*(1&e),e+1),await r(t+1-2*(1&e),e-1)},v=Math.sqrt(3)/2,p=(t,e)=>{const r=t+.5*(1&e),n=e*v;return(0,a.V)(r,n,0)},y=255;(0,o.assert)(p(0,0).equals((0,a.V)(0,0))),(0,o.assert)(p(1,0).equals((0,a.V)(1,0))),(0,o.assert)(p(0,1).equals((0,a.V)(.5,v)));const m=(t,e,r,n)=>(([t,e,r],[n,s,i])=>(Math.abs(n-t)+Math.abs(s-e)+Math.abs(i-r))/2)(w(t,e),w(r,n)),w=(t,e)=>{const r=t-(e>>1);return[r,e,-r-e]};o.assert.deepEqual(w(0,0),[0,0,-0]),o.assert.deepEqual(w(1,0),[1,0,-1]),o.assert.deepEqual(w(0,1),[0,1,-1]),o.assert.deepEqual(w(0,2),[-1,2,-1]),o.assert.deepEqual(w(-1,0),[-1,0,1]),o.assert.deepEqual(w(0,-1),[1,-1,0]),o.assert.deepEqual(w(-1,-1),[0,-1,1]),o.assert.deepEqual(w(0,-2),[1,-2,1]);class g{constructor(t,e){this.w=t,this.h=e,this.data=new Uint8Array(t*e)}clone(){const t=new g(this.w,this.h);return t.plusHS(this),t}dualize(){for(let t=0;t<this.h*this.w;t++)y!==this.data[t]&&(this.data[t]=5-this.data[t]);console.log("dualized")}plus(t){for(let e=0;e<this.h*this.w;e++)y!==this.data[e]&&(this.data[e]+=t);console.log("plus "+t)}times(t){for(let e=0;e<this.h*this.w;e++)y!==this.data[e]&&(this.data[e]*=t);console.log("times "+t)}setHS(t){for(let e=0;e<this.h*this.w;e++)this.data[e]=t.data[e]}plusHS(t){for(let e=0;e<this.h*this.w;e++)y!==this.data[e]&&(this.data[e]+=t.data[e])}fill(t){for(let e=0;e<this.h*this.w;e++)y!==this.data[e]&&(this.data[e]=t)}fillf(t){for(let e=0;e<this.h*this.w;e++){const r=e%this.w,n=e/this.w|0;y!==this.data[e]&&(this.data[e]=t(r,n,e,this.data[e]))}}getOddr(t,e){return this.data[e*this.w+t]}setOddr(t,e,r){return this.data[e*this.w+t]=r}addOddr(t,e,r){return this.data[e*this.w+t]+=r}isSink(t,e){return this.getOddr(t,e)===y}drawHex(t,e,r){const n=this.w/2|0,s=this.h/2|0;for(let i=0;i<this.h*this.w;i++){const a=i%this.w,o=i/this.w|0;t<=m(n,s,a,o)&&m(n,s,a,o)<=e&&(this.data[i]=r)}}async drawText(t,e,r,n,s){var i;const o=(await(i=d,new Promise(((t,e)=>{(0,l.zD)(i,((r,n)=>r?e(r):t(n)))})))).getPath(r,0,0,n),h=o.getBoundingBox(),c=((0,a.V)(t,e),(0,a.V)(h.x1,h.y1).to((0,a.V)(h.x2,h.y2)));console.log("path",o);const u=document.createElement("canvas");u.width=2*(h.x2-h.x1),u.height=2*(h.y2-h.y1);const x=u.getContext("2d");x.scale(2,2),x.translate(-h.x1,-h.y1),x.fillStyle="black",x.imageSmoothingEnabled=!1,o.draw(x);const f=p(t,e).minus(c.div(2));var v=x.getImageData(0,0,u.width,u.height).data;for(let t=0;t<this.h*this.w;t++){const e=t%this.w,r=t/this.w|0,n=p(e,r).minus(f);0<n.x&&n.x<h.x2-h.x1&&0<n.y&&n.y<h.y2-h.y1&&v[4*((2*n.y|0)*u.width+(2*n.x|0))+3]>127&&(this.data[t]=s)}}drawTriangle(t,e,r){const n=this.w/2|0,s=this.h/2|0;for(let i=0;i<this.h*this.w;i++){const a=i%this.w,o=i/this.w|0,l=Math.max(...w(a-n,o-s));t<=l&&l<=e&&(this.data[i]=r)}}drawCircle(t,e,r){const n=this.w/2|0,s=this.h/2|0,i=p(n,s);for(let n=0;n<this.h*this.w;n++){const s=n%this.w,a=n/this.w|0,o=p(s,a).distanceTo(i);t<=o&&o<=e&&(this.data[n]=r)}}drawRect(t,e,r){for(let n=0;n<this.h*this.w;n++){const s=n%this.w-(this.w/2|0),i=(n/this.w|0)-(this.h/2|0),o=(0,a.V)(...w(s,i));Math.abs(o.x+(o.y>>1))<t/2&&Math.abs(o.y)<e/2&&Math.abs(o.x)<t/2+12&&Math.abs(o.z)<t/2+12&&(this.data[n]=r)}}async asyncStabilizeNoShader(){let t;do{t=0;for(let e=0;e<this.h*this.w;e++){const r=e%this.w,n=e/this.w|0;!this.isSink(r,n)&&this.getOddr(r,n)>=6&&(await f(r,n,(async(t,e)=>!this.isSink(t,e)&&this.addOddr(t,e,1))),this.addOddr(r,n,-6),t++)}await(0,i.Z)(10)}while(0!=t);console.log("stabilized"),await(0,i.Z)(2e3)}createTextures(t,e){return function(t){let e,r=t[0],n=1;for(;n<t.length;){const s=t[n],i=t[n+1];if(n+=2,("optionalAccess"===s||"optionalCall"===s)&&null==r)return;"access"===s||"optionalAccess"===s?(e=r,r=i(r)):"call"!==s&&"optionalCall"!==s||(r=i(((...t)=>r.call(e,...t))),e=void 0)}return r}([this,"access",t=>t.glInfo,"optionalAccess",t=>t.gl])===t&&(this.glInfo=void 0),this.glInfo||(this.glInfo={gl:t,t0:new n.xE(this.w,this.h,{filter:t.NEAREST,internalFormat:t.R8UI,format:t.RED_INTEGER}),t1:new n.xE(this.w,this.h,{filter:t.NEAREST,internalFormat:t.R8UI,format:t.RED_INTEGER}),stepPlane:x(0,0,this.w,this.h),stepShader:e}),this.glInfo.t0}async asyncStabilize(){const t=this.glInfo;for(this.upload();this.countUnstable()>0;){for(let e=0;e<1e3;e++)for(let e=0;e<1;e++)t.t1.drawTo((e=>{t.t0.bind(0),t.stepShader.uniforms({heights:0}).draw(t.stepPlane)})),t.t0.swapWith(t.t1);t.t0.downloadData(this.data)}}*stabilizeInteractive(t=1){const e=this.glInfo;for(this.upload();this.countUnstable()>0;){for(let r=0;r<1e3;r++){for(let r=0;r<t;r++)e.t1.drawTo((t=>{e.t0.bind(0),e.stepShader.uniforms({heights:0}).draw(e.stepPlane)})),e.t0.swapWith(e.t1);yield}e.t0.downloadData(this.data)}}async calcHash(){return Array.from(new Uint8Array(await crypto.subtle.digest("SHA-1",this.data))).map((t=>t.toString(16).padStart(2,"0"))).join("")}countUnstable(){let t=0;for(let e=0;e<this.w*this.h;e++)t+=+(y!==this.data[e]&&this.data[e]>=6);return t}async calcRecurringInverse(){this.plus(10),await this.asyncStabilize(),this.dualize(),this.plus(5),await this.asyncStabilize()}async calcRecurringIdentity(){this.fill(10),await this.asyncStabilize(),this.dualize(),this.plus(5),await this.asyncStabilize()}upload(){this.glInfo.t0.setData(this.data)}getOddrBB(){const t=t=>{for(let e=0;e<this.w;e++)if(this.data[t*this.w+e]!==y)return!1;return!0};let e=0,r=this.h;for(;e<this.h&&t(e);)e++;for(;r>0&&t(r-1);)r--;const n=t=>{for(let n=e;n<r;n++)if(this.data[n*this.w+t]!==y)return!1;return!0};let s=0,i=this.w;for(;s<this.h&&n(s);)s++;for(;i>0&&n(i-1);)i--;return{x0:s,x1:i,y0:e,y1:r}}getBB(){const{x0:t,x1:e,y0:r,y1:n}=this.getOddrBB();return{min:p(t,r),max:p(e,n)}}}const _=s.bA("white","green").mode("rgb").colors(10,"gl"),b=s.$_("F4F4ED").gl();const z=()=>{const t=(0,h.useRef)(null);(0,h.useEffect)((()=>{!async function(t){const e=n.ZG.create({canvas:t});console.log("gl",e),e.addResizeListener(),console.log(e.canvas.width,e.canvas.height);const r=n.ex.create(c,'#version 300 es\r\nprecision mediump float;\r\nprecision mediump usampler2D;\r\n\r\n// this shader defines a virtual texture, which renders\r\n// a hex "(height-)map" saved as ODDR\r\n\r\n// texture coordinate to render\r\nin vec2 coord;\r\n\r\nuniform vec4 colorBg;\r\nuniform vec4[10] colorFg;\r\n\r\nuniform mat4 tt;\r\n\r\nconst int MAX_MARCHING_STEPS = 255;\r\nconst float MIN_DIST = 0.0;\r\nconst float MAX_DIST = 100.0;\r\n\r\nconst uint SINK = 255u;\r\n\r\nout vec4 fragColor;\r\n\r\n// the "map" being rendered. also implicitely defines the\r\n// size of the texture.\r\n// width: x is in [-0.5, heights.width], (0, 0) is the center of the first hex\r\n// height: sqrt(3) / 2 * heights.height\r\nuniform usampler2D heights;\r\n\r\nvec3 raToHex(vec2 xy) {\r\n\tfloat hex_t = xy.y / 0.866;\r\n\tfloat hex_s = xy.x - hex_t / 2.0;\r\n\treturn vec3(hex_s, hex_t, -(hex_s + hex_t));\r\n}\r\n\r\nvec2 hexToRa(vec3 hex) {\r\n\tfloat y = hex.t * 0.866;\r\n\tfloat x = hex.s + hex.t / 2.0;\r\n\treturn vec2(x, y);\r\n}\r\nivec2 cube_to_oddr(ivec3 cube) {\r\n    int col = cube.x + (cube.y - (cube.y&1)) / 2;\r\n    int row = cube.y;\r\n    return ivec2(col, row);\r\n}\r\nivec3 oddr_to_cube(ivec2 hex) {\r\n    int x = hex.x - (hex.y - (hex.y&1)) / 2;\r\n    int y = hex.y;\r\n    int z = -x-y;\r\n    return ivec3(x, y, z);\r\n}\r\n\r\nvec3 hexRound(vec3 hex) {\r\n\tvec3 r = floor(hex + 0.5);\r\n\tvec3 diff = abs(r - hex);\r\n\r\n\tif (diff.x > diff.y && diff.x > diff.z) {\r\n\t\tr.x = -(r.y + r.z);\r\n\t} else if (diff.y > diff.z) {\r\n\t\tr.y = -(r.x + r.z);\r\n\t} else {\r\n\t\tr.z = -(r.x + r.y);\r\n\t}\r\n\r\n\treturn r;\r\n}\r\nfloat max3 (vec3 v) {\r\n  return max (max (v.x, v.y), v.z);\r\n}\r\nfloat min3 (vec3 v) {\r\n  return max (max (v.x, v.y), v.z);\r\n}\r\nfloat hex_sdf(vec3 h) {\r\n\treturn max3(abs(h.yzx + h.zxy/2.0 ) );\r\n\t// return abs(h.x+(h.y/2.0) );\r\n\t// return max3(abs(vec3(h)));\r\n}\r\n\r\nbool between(float min, float max, float x) {\r\n\treturn min <= x && x <= max;\r\n}\r\n\r\nuint heightAt(ivec2 p) {\r\n\tivec2 tex_size = textureSize(heights, 0);\r\n\r\n\tif (p.x < 0 || p.y < 0 || tex_size.x <= p.x || tex_size.y <= p.y) {\r\n\t\t// point is outside source texture, treat as sink\r\n\t\treturn SINK;\r\n\t} else {\r\n\t\treturn texelFetch(heights, p, 0).r;\r\n\t}\r\n}\r\n\r\nvoid main() {\r\n\t// vec2 pos2 = vec4(coord, 0.0, 1.0).xy * 400.0;\r\n\tvec2 pos2 = (tt * vec4(coord, 0.0, 1.0)).xy;\r\n\r\n\t// fragColor = length(pos2 - vec2(100.0, 100.0)) < 50.0\r\n\t// \t? colorFg[0]\r\n\t// \t: colorBg;\r\n\t// return;\r\n\tvec3 hex_pos = raToHex(pos2);\r\n\t// vec2 hex_center = floor(hex_pos + 0.5);\r\n\tvec3 hex_center = hexRound(hex_pos);\r\n\tvec2 center = hexToRa(hex_center);\r\n\tvec2 squarePos = floor(pos2+ 0.5);\r\n\tvec3 hex_d = hex_pos - hex_center;\r\n\t// vec2 d =hex_pos - hex_center;\r\n\t// vec3 zz = vec3(d.xy, (d.y - d.x)/1.41);\r\n\tvec2 local_ra_offset = pos2 - center;\r\n\t// if (abs(zz.x +zz.y+ zz.z) < 0.1) {\r\n\t// if (max(d.x, max(d.y, 0.0)) < 0.45) {\r\n\t// if (length(pos2 - squarePos) < 0.5) {\r\n\tfloat d = hex_sdf(hex_d);\r\n\tif (between(0.0, 0.425, d)\r\n\t\t// || length(pos2 - center) < 0.2\r\n\t) {\r\n\t// if (length (pos2 - center) <0.53){\r\n\t// if (length (hex_pos - hex_center) <0.45){\r\n\t\tivec2 center2 = cube_to_oddr( ivec3(hex_center) );\r\n\t\tuint value = heightAt(center2);\r\n\t\tfragColor = value == 255u ? colorBg : colorFg[value];\r\n\t} else {\r\n\t\tfragColor = colorBg;\r\n\t}\r\n}'),s=n.ex.create(c,"#version 300 es\r\nprecision mediump float;\r\nprecision mediump usampler2D;\r\nin vec2 coord;\r\n\r\nuniform vec2 iResolution;\r\nuniform vec4 colorBg;\r\nuniform vec4[10] colorFg;\r\n\r\nout uvec4 fragColor;\r\n\r\nconst uint SINK = 255u;\r\n\r\nuniform usampler2D heights;\r\n\r\nfloat EPSILON = 0.0001;\r\n\r\nvec3 raToHex(vec2 xy) {\r\n\tfloat hex_t = xy.y / 0.866;\r\n\tfloat hex_s = xy.x - hex_t / 2.0;\r\n\treturn vec3(hex_s, hex_t, -(hex_s + hex_t));\r\n}\r\n\r\nvec2 hexToRa(vec3 hex) {\r\n\tfloat y = hex.t * 0.866;\r\n\tfloat x = hex.s + hex.t / 2.0;\r\n\treturn vec2(x, y);\r\n}\r\nivec2 cube_to_oddr(ivec3 cube) {\r\n    int col = cube.x + (cube.y - (cube.y&1)) / 2;\r\n    int row = cube.y;\r\n    return ivec2(col, row);\r\n}\r\nivec3 oddr_to_cube(ivec2 hex) {\r\n    int x = hex.x - (hex.y - (hex.y&1)) / 2;\r\n    int y = hex.y;\r\n    int z = -x-y;\r\n    return ivec3(x, y, z);\r\n}\r\n\r\nvec3 hexRound(vec3 hex) {\r\n\tvec3 r = floor(hex + 0.5);\r\n\tvec3 diff = abs(r - hex);\r\n\r\n\tif (diff.x > diff.y && diff.x > diff.z) {\r\n\t\tr.x = -(r.y + r.z);\r\n\t} else if (diff.y > diff.z) {\r\n\t\tr.y = -(r.x + r.z);\r\n\t} else {\r\n\t\tr.z = -(r.x + r.y);\r\n\t}\r\n\r\n\treturn r;\r\n}\r\nfloat max3 (vec3 v) {\r\n  return max (max (v.x, v.y), v.z);\r\n}\r\nfloat min3 (vec3 v) {\r\n  return max (max (v.x, v.y), v.z);\r\n}\r\nfloat hex_sdf(vec3 h) {\r\n\treturn max3(abs(h.yzx + h.zxy/2.0 ) );\r\n\t// return abs(h.x+(h.y/2.0) );\r\n\t// return max3(abs(vec3(h)));\r\n}\r\n\r\nbool between(float min, float max, float x) {\r\n\treturn min <= x && x <= max;\r\n}\r\n\r\nuint heightAt(ivec2 p) {\r\n\tivec2 tex_size = textureSize(heights, 0);\r\n\r\n\tif (p.x < 0 || p.y < 0 || tex_size.x <= p.x || tex_size.y <= p.y) {\r\n\t\t// point is outside source texture, treat as sink\r\n\t\treturn SINK;\r\n\t} else {\r\n\t\treturn texelFetch(heights, p, 0).r;\r\n\t}\r\n}\r\n\r\nuint at(ivec2 p) {\r\n\tuint value = heightAt(p);\r\n\tif (SINK == value) {\r\n\t\treturn 0u;\r\n\t} else {\r\n\t\treturn value / 6u;\r\n\t}\r\n}\r\n\r\nuint calc(ivec2 oddr_pos) {\r\n\tuint value = texelFetch(heights, oddr_pos, 0).r;\r\n\r\n\tif (SINK == value) {\r\n\t\treturn SINK;\r\n\t}\r\n\r\n\t// the current pos topples as many times as it can\r\n\tvalue = value % 6u;\r\n\t// all the neighbors topple as often as they can\r\n\tvalue += at(oddr_pos + ivec2(+1, 0));\r\n\tvalue += at(oddr_pos + ivec2(-1, 0));\r\n\r\n\tvalue += at(oddr_pos + ivec2(0, +1));\r\n\tvalue += at(oddr_pos + ivec2(0, -1));\r\n\r\n\tvalue += at(oddr_pos + ivec2(0 != (oddr_pos.y & 1) ? 1 : -1, +1));\r\n\tvalue += at(oddr_pos + ivec2(0 != (oddr_pos.y & 1) ? 1 : -1, -1));\r\n\r\n\treturn value;\r\n}\r\n\r\nvoid main() {\r\n\tfragColor = uvec4(calc(ivec2(coord)), 0u, 0u, 0u);\r\n\t// fragColor = uvec4(2u, 0u, 0u, 0u);\r\n}"),o=new g(256,256),l=o.createTextures(e,s),h=x(-1,-1,1,1),d=e.canvas.width/e.canvas.height;console.log("aspect",d),o.fill(y),o.drawHex(0,80,0);const u=o.getBB(),f=u.min.to(u.max),v=f.x/f.y;console.log("ratios",d,v,""+f,u);const p=a.M4.translate(u.min.plus(u.max).times(-.5)).scale(d<v?1/f.x:1/f.y).scale(.98).scale(2).scale(1,-1,1).scale(1/d,1,1);console.log("mm\n"+p.str);const m=t=>new URL(""+document.location).searchParams.get(t);await o.calcRecurringIdentity(),o.fillf(((t,e,r,n)=>y===n?y:3+n%3));const w=m("t");await o.drawText(128,128,w?atob(w):"Hi!",25,5);const z=o.clone();z.createTextures(e,s),z.fillf((()=>5+6*Math.random()|0)),await z.asyncStabilize(),o.plusHS(z),await o.asyncStabilize(),await z.calcRecurringInverse(),o.plusHS(z),o.upload(),e.animate((()=>{l.bind(0),r.uniforms({iResolution:[800,600],tt:p.inversed(),colorBg:b,"colorFg[0]":_,heights:0}).draw(h)})),await(0,i.Z)(2e3),await(async t=>{for(const e of o.stabilizeInteractive(t))await(0,i.Z)(16)})(+(m("speed")||"2")),o.upload(),console.log("aspect",d)}(t.current)}),[]);const e=32,r={boxSizing:"border-box",position:"relative",content:"",width:e,display:"block",height:e/v/4,borderWidth:`0 16px ${e/v/4}px 16px`,borderStyle:"solid"};return h.createElement("div",{style:{display:"flex",flexDirection:"column",height:"100%"},__self:void 0,__source:{fileName:u,lineNumber:661}},h.createElement("canvas",{ref:t,style:{flexGrow:1},__self:void 0,__source:{fileName:u,lineNumber:662}}),h.createElement("div",{style:{padding:4,display:"flex",backgroundColor:s.gl(b).css()},__self:void 0,__source:{fileName:u,lineNumber:663}},_.map(((t,n)=>h.createElement("div",{className:"hex",style:{display:"flex",flexDirection:"column",margin:4},key:n,__self:void 0,__source:{fileName:u,lineNumber:671}},h.createElement("div",{style:{...r,borderColor:s.gl(t).css()+" transparent",borderWidth:`0 16px ${e/v/4}px 16px`},__self:void 0,__source:{fileName:u,lineNumber:680}}),h.createElement("div",{style:{textAlign:"center",backgroundColor:s.gl(t).css(),height:e/v/2,color:s.gl(t).textColor().css(),display:"flex",alignItems:"center",justifyContent:"center"},__self:void 0,__source:{fileName:u,lineNumber:689}},n),h.createElement("div",{style:{...r,borderColor:s.gl(t).css()+" transparent",borderWidth:e/v/4+"px 16px 0 16px"},__self:void 0,__source:{fileName:u,lineNumber:702}})))),h.createElement("div",{style:{textAlign:"right",padding:10,flexGrow:1},__self:void 0,__source:{fileName:u,lineNumber:717}},h.createElement("a",{href:"http://people.reed.edu/~davidp/grant/",__self:void 0,__source:{fileName:u,lineNumber:718}},"Original (square)")," ","by ",h.createElement("a",{href:"http://people.reed.edu/~davidp/",__self:void 0,__source:{fileName:u,lineNumber:719}},"Prof. David Perkinson"),"."," ",h.createElement("a",{href:"https://www.youtube.com/watch?v=1MtEUErz7Gg",__self:void 0,__source:{fileName:u,lineNumber:721}},"Explanatory video"))))}},2993:()=>{}}]);