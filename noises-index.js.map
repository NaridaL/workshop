{"version":3,"file":"noises-index.js","mappings":"gJACA,2qzBACMA,EAAY,CAAC,QAAU,EAAE,QAAU,CAAC,mEAAmE,6DAA6D,uEAAuE,6DAA6D,4DAA4D,gEAAgE,8DAA8D,4DAA4D,8DAA8D,gEAAgE,8DAA8D,+DAA+D,2DAA2D,2DAA2D,sEAAsE,wEAAwE,2DAA2D,sEAAsE,mEAAmE,qEAAqE,uEAAuE,mEAAmE,oEAAoE,kEAAkE,oEAAoE,gEAAgE,8DAA8D,gEAAgE,8DAA8D,4DAA4D,MAAQ,GAAG,SAAW,g5H,uECEv8D,SAASC,GAAiB,MAC/BC,EAAK,KACLC,EAAI,gBACJC,KACGC,IAMH,OACE,gBAAoB,IAAW,CAC7BC,QAAS,WACTC,KAAM,QACNC,KAAM,SACNC,MAAOP,EAAMC,GACbO,SAAWC,GACTP,EAAgB,CAAE,CAACD,IAAQQ,EAAEC,OAAOH,QAEtCI,MAAOV,KACJE,GAGT,C,iBC3BA,IAAIS,EAAM,CACT,eAAgB,KAChB,eAAgB,KAChB,gBAAiB,KACjB,sBAAuB,IACvB,iBAAkB,KAClB,2BAA4B,KAC5B,cAAe,KACf,eAAgB,KAChB,eAAgB,KAChB,cAAe,MAIhB,SAASC,EAAeC,GACvB,IAAIC,EAAKC,EAAsBF,GAC/B,OAAOG,EAAoBF,EAC5B,CACA,SAASC,EAAsBF,GAC9B,IAAIG,EAAoBC,EAAEN,EAAKE,GAAM,CACpC,IAAIL,EAAI,IAAIU,MAAM,uBAAyBL,EAAM,KAEjD,MADAL,EAAEW,KAAO,mBACHX,CACP,CACA,OAAOG,EAAIE,EACZ,CACAD,EAAeQ,KAAO,WACrB,OAAOC,OAAOD,KAAKT,EACpB,EACAC,EAAeU,QAAUP,EACzBQ,EAAOC,QAAUZ,EACjBA,EAAeE,GAAK,I,mKC1Bb,MAAMW,EAAO,KACPC,EAAUC,IAAW,QAAQA,EAAI,MAAM,GAAK,IAG5CC,EAAsB,CAACC,EAAOC,IACzCA,EAAY,EAAIC,KAAKC,IAAI,KAAMH,EAAQ,GAC5BI,EAAqB,CAACJ,EAAOK,IAC/B,EAATA,EAAaH,KAAKC,IAAI,KAAMH,EAAQ,GACzBM,EAA4B,CACvCN,EACAC,IACGA,EAAY,EAAIC,KAAKK,IAAI,KAAMP,EAAQ,GAC/BQ,EAAyB,CACpCR,EACAS,IACGA,EAAeP,KAAKQ,IAAI,KAAMV,EAAQ,GAC9BW,EAA4B,CACvCX,EACAS,IACkB,EAAfA,EAAmBP,KAAKK,IAAI,KAAMP,EAAQ,GAExC,SAASY,GAAe,MAC7BZ,EAAK,OACLK,EAAM,WACNQ,EAAa,EAAC,WACdC,KACGzC,IAOH,QAAK0C,IAAcD,SAAiBC,IAAcV,GAChD,MAAM,IAAIhB,MAAM,wCAKlB,YAHI0B,IAAcV,IAChBA,EAASN,EAAoBC,EAAOc,IAGpC,gBAAoB,OAAQ,CAC1BE,GAAG,QACD,IAAAC,GAAE,EAAAC,GAAGC,MAAMd,EAAQQ,QAChB,QAAW,EAAGb,GAAOlB,IAAKsC,IAC3B,IAAAC,GAAE,EAAAH,GAAGC,MAAMd,EAAQQ,EAAaO,GAAK,KAAMpB,OAE7C,IAAAsB,SAECjD,GAGT,CAEO,SAASkD,GAAQ,GACtBtC,EAAE,SACFuC,EAAQ,MACRC,EAAK,QACLC,IAOA,OACE,gBAAoB,WAAgB,KAChC,gBAAoB,IAAK,CAAEzC,GAAIA,GAAMuC,IACrC,QAAW,EAAGC,EAAQ,GAAG3C,IAAKsC,GAC9B,gBAAoB,IAAK,CACvBnC,GAAI,GAAGA,KAAMmC,IACbO,IAAK,GAAG1C,KAAMmC,IACdQ,UAAW,WAAWR,EAAI,GAAKM,UAE7BF,IAKZ,CAEO,MAAMK,EAAgBC,IAC3B,MAAMC,EAAYC,OAAOC,KAAKH,EAAK,SAAU,uBACzCC,IAAWA,EAAUG,OAAS,M,+CCtFpC,sL,4ECAA,++lCACMlE,EAAY,CAAC,QAAU,EAAE,QAAU,CAAC,wEAAwE,6DAA6D,gEAAgE,+DAA+D,2DAA2D,gEAAgE,4DAA4D,gEAAgE,8DAA8D,4DAA4D,8DAA8D,gEAAgE,mEAAmE,uEAAuE,6DAA6D,0EAA0E,2EAA2E,uEAAuE,mEAAmE,kEAAkE,mEAAmE,yEAAyE,mEAAmE,oEAAoE,sEAAsE,2EAA2E,MAAQ,GAAG,SAAW,22K,mQCF9vD,SAASmE,EAAeC,GAAO,IAAIC,EAA+B5D,EAAQ2D,EAAI,GAAQhB,EAAI,EAAG,KAAOA,EAAIgB,EAAIE,QAAQ,CAAE,MAAMC,EAAKH,EAAIhB,GAAUoB,EAAKJ,EAAIhB,EAAI,GAAY,GAARA,GAAK,GAAe,mBAAPmB,GAAkC,iBAAPA,IAAmC,MAAT9D,EAAiB,OAA+B,WAAP8D,GAA0B,mBAAPA,GAA2BF,EAAgB5D,EAAOA,EAAQ+D,EAAG/D,IAA0B,SAAP8D,GAAwB,iBAAPA,IAAyB9D,EAAQ+D,EAAG,IAAIC,IAAShE,EAAMiE,KAAKL,KAAkBI,IAAQJ,OAAgBtB,EAAa,CAAE,OAAOtC,CAAO,CAsD5f,SAASkE,GAAY,GAC1BC,EAAE,QACFC,EAAO,MACP3E,EAAK,SACL4E,EAAQ,UACRC,EAAS,YACTC,IASA,MAAMC,GAAe,IAAAC,WACdC,EAAKC,IAAU,IAAAC,UAAS,IACxBC,EAAUC,IAAe,IAAAF,aAEzBG,EAAgBC,IAAqB,IAAAJ,YAEtCK,GAAS,IAAAC,aACbC,MAAOC,IACL,MAAMC,EAAMD,EAAME,cAAcC,QAC7BF,IAAIG,MAAM,KACVnF,IAAKgB,IAAOA,GAEf,GADAyD,OAAYxC,GACRkC,EAAaiB,QACf,IACE,MAAMpC,EAAMqC,IAAIC,sBACRnB,EAAaiB,QAAQG,YAAYP,EAAKL,IAE9CA,OAAkB1C,IAClB,QAAae,EACf,CAAE,MAAOnD,GACP2F,QAAQC,MAAM5F,EAChB,GAGJ,KAEF,IAAA6F,WAAU,KACJxB,IACFA,EAAYkB,QAAUjB,EAAaiB,UAEpC,CAAClB,IAEJ,MAAMyB,GAAW,IAAAd,aACdE,GAAUN,EAAYM,EAAME,eAC7B,KAEKW,EAAiBC,IAAsB,IAAAtB,UAAS,GACjDuB,EAAmB,CACvB,GACA,EACA5C,OAAO6C,iBACP,EACA,EAAI7C,OAAO6C,kBAEPC,GAAY,IAAAnB,aAAY,IAAMJ,OAAYxC,GAAY,IAC5D,OACE,gBAAoBgE,EAAA,EAAM,CAAEnC,GAAI,IAAKA,EAAIoC,SAAU,aAC/C,gBAAoBC,EAAA,EAAM,CAAEhD,OAAQqB,EAAUA,SAAUA,EAAU4B,QAASJ,GACzE,gBAAoBK,EAAA,EAAU,CAAE,WAAY,YAAaC,QAAS1B,GAAU,aAG5E,gBAAoByB,EAAA,EAAU,CAAE,WAAY,YAAaC,QAAS1B,GAAU,aAG5E,gBAAoB2B,EAAA,GAAU,KAC5B,gBAAoBC,EAAA,EAAc,KAAM,cAAiB,IACzD,gBAAoBC,EAAA,EAAQ,CAC5B9G,MAAOiG,EACPhG,SAAWC,IACT4E,OAAYxC,GACZ4D,GAAoBhG,EAAEC,OAAOH,QAE/BF,KAAM,SAEJqG,EAAiB9F,IAAKgB,GACtB,gBAAoBqF,EAAA,EAAU,CAAExD,IAAK7B,EAAGrB,MAAOqB,GAC3CA,OAMV,gBAAoB0F,EAAA,EAAK,CAAE5C,GAAI,CAAEoC,SAAU,WAAYS,OAAQ,EAAGC,MAAO,SACpD3E,IAAnByC,EACA,gBAAoBmC,EAAA,EAAkB,CACpCrH,QAAS,cACTG,MAAwB,IAAjB+E,IAGT,gBAAoBoC,EAAA,EAAK,CAAErH,KAAM,QAAS6G,QAASX,GAC/C,gBAAoBoB,EAAA,EAAc,QAIxC,gBAAoBL,EAAA,EAAK,CAAE5C,GAAI,CAAEoC,SAAU,WAAYS,OAAQ,EAAGK,KAAM,IAAO3C,GAE/E,gBAAoB4C,EAAA,EAAW,CAC/BC,UAAWC,EACXnD,SAAUA,EACVD,QAASA,EACT3E,MAAOA,EACP8E,YAAaC,EACbiD,MAAO9C,EACPsB,gBAAiBA,EACjB3B,UAAWA,EACXH,GAAI,CAAEuD,MAAO,OAAQC,OAAQ,UAIrC,CAEO,MAAMH,EAAgB,EAC3BnD,WACAoD,QACArD,UACA3E,QACA8E,cACAD,aAAY,EACZ2B,sBAUA,MAAM2B,GAAY,IAAAnD,QAAO,MACnBD,GAAe,IAAAC,WAErB,IAAAsB,WAAU,KACR,GAAI6B,EAAUnC,QAAS,CACrB,MAAMoC,EAAY,IAAIxD,EAASuD,EAAUnC,QAAS,CAChDgC,QACAxB,oBAOF,OALAzB,EAAaiB,QAAUoC,EACvBA,EAAUC,QACNvD,IACFA,EAAYkB,QAAUoC,GAEjB,IAAMA,EAAUE,SACzB,GACC,CAAC1D,EAAUoD,EAAOxB,EAAiB1B,IACtC,MAAMyD,GAAQ,EAAAC,EAAA,KAed,OAdA,IAAAlC,WAAU,KACRvB,EAAaiB,SACX1E,OAAOmH,OAAO1D,EAAaiB,QAAQ0C,IAAK,CACtCC,gBAAiB,KAAWJ,EAAMK,QAAQC,WAAWC,SAASC,KAC9DC,aAAc,KAAWT,EAAMK,QAAQK,QAAQC,MAAMH,KACrDI,eAAgB,KAAWZ,EAAMK,QAAQQ,UAAUF,MAAMH,QAE5D,CAAChE,EAAaiB,QAASuC,EAAMK,WAChC,IAAAtC,WAAU,KACJvB,EAAaiB,UAASjB,EAAaiB,QAAQrB,QAAUA,IACxD,CAACI,EAAaiB,QAASrB,KAC1B,IAAA2B,WAAU,KACJvB,EAAaiB,SAAS1E,OAAOmH,OAAO1D,EAAaiB,QAAQ0C,IAAK1I,IACjE,CAAC+E,EAAaiB,QAAShG,IACnB,gBAAoB,SAAU,CAAEqJ,IAAKlB,EAAWmB,MAAO,CAAErB,MAAO,OAAQC,OAAQ,WAElF,MAAMqB,EASV,MAAAC,GAAUC,KAAKC,SAAW,EAAE,GAAI,EAAG,CAGnC,OAAAC,GAAWF,KAAKf,IAAM,CAAC,CAAC,CACxB,OAAAkB,GAAWH,KAAK9E,SAAU,CAAI,CAE9B,OAAAkF,GAAWJ,KAAKK,KAAO,MAAQ,CAGhC,WAAAC,CACIC,EAGAC,GACF,MACEjC,EAAK,gBACLxB,EAAkB1C,OAAO6C,mBAEzB8C,KAAKO,WAAaA,EAAWP,KAAKQ,OAASA,EAAOV,EAAqBW,UAAUV,OAAOhF,KAAKiF,MAAMF,EAAqBW,UAAUP,QAAQnF,KAAKiF,MAAMF,EAAqBW,UAAUN,QAAQpF,KAAKiF,MAAMF,EAAqBW,UAAUL,QAAQrF,KAAKiF,MAAMF,EAAqBW,UAAUC,QAAQ3F,KAAKiF,MACvS,MAWMV,EAAK,KAAYqB,OAAO,CAC5BH,OAAQA,EACRI,OAAO,EACPC,oBAAoB,IAMtB,SAASC,IACPxB,EAAGkB,OAAOhC,MAAQc,EAAGkB,OAAOO,YAAchE,EAC1CuC,EAAGkB,OAAO/B,OAASa,EAAGkB,OAAOQ,aAAejE,EAC5CuC,EAAG2B,SAAS,EAAG,EAAG3B,EAAGkB,OAAOhC,MAAOc,EAAGkB,OAAO/B,OAC/C,CALAuB,KAAKV,GAAKA,EAMV3C,QAAQuE,IAAI,kBAAmBnE,GAC/BiD,KAAKjD,gBAAkBA,EACS,IAA5BiD,KAAKQ,OAAOO,cACdD,IACAxB,EAAGkB,OAAOW,iBAAiB,SAAUL,IAEvCxB,EAAGkB,OAAOW,iBAAiB,aAvBPnK,IAClBgJ,KAAKC,SAAW,EAAE,GAAI,KAuBxBX,EAAGkB,OAAOW,iBAAiB,YAhCRnK,IACjB,MAAMwJ,EAASxJ,EAAEoF,eACX,MAAEoC,EAAK,OAAEC,GAAW+B,EAAOY,wBACjCpB,KAAKC,SAAW,CACdO,EAAOhC,OAASxH,EAAEqK,QAAU7C,GAC5BgC,EAAO/B,QAAU,EAAIzH,EAAEsK,QAAU7C,MA4BrCuB,KAAKuB,UAAY,IAAKC,MAAM,CAAEC,QAAS,EAAGC,QAAS,EAAGlD,MAAO,EAAGC,OAAQ,IAQxEuB,KAAKuB,UAAUI,QAAQrC,GACvBU,KAAK4B,cAAgBrD,GAAS,IAAIsD,EAAA,EAActD,GAChDyB,KAAKV,GAAGwC,cACR9B,KAAK+B,cACP,CAEC,YAAAA,GACC/B,KAAKgC,YAEH,UAEAhC,KAAKO,aAET,CAEC,OAAAG,GAAWV,KAAKgC,YChTZ,SAAqBC,GAC1B,IACIC,EADAC,EAAW,GAEf,OAAO,YAAarH,GAQlB,OANEqH,EAASxH,SAAWG,EAAKH,QACzBwH,EAASC,KAAK,CAACC,EAAG5I,IAAM4I,IAAMvH,EAAKrB,OAEnC0I,EAAWrH,EACXoH,EAAaD,KAAKnH,IAEboH,CACT,CACF,CDmSiCI,CAC7B,CAACC,EAAIC,KACH,IAAInM,EACJ,IACE,IAAIoM,EACc,iBAAPD,EACTC,EAAQD,GAERC,EAAQD,EAAGnD,QACXhJ,EAAYmM,EAAGnM,WAKjBsG,QAAQuE,IAAI,mBAEZlB,KAAK0C,OAAS,KAAO/B,OAAO4B,EAAIE,EAAOzC,KAAKV,GAC9C,CAAE,MAAOtI,GAGP,GAFA2F,QAAQgG,QACRhG,QAAQC,MAAMvG,GACVA,EAAW,CACb,MAAMuM,EAAoB,IAAI,EAAAC,kBAAkBxM,GAC1CyM,EAAa,EAAKC,QAAQC,QAC9B,iBACA,CAACC,EAAOC,KACN,MAAMC,EAAmBP,EAAkBQ,oBAAoB,CAC7DF,MAAOA,EACPG,OAAQ,IAGV,OADA1G,QAAQuE,IAAI,mBAAoBiC,GAE9B,SACAA,EAAiBG,OACjB,IACAH,EAAiBD,KACjB,IACAC,EAAiBE,SAItB,EAAKN,QAAUD,CAClB,CAEA,IAAK9C,KAAK0C,OAAQ,MAAM1L,CAC1B,GAEH,CAED,KAAA4H,GACEoB,KAAKK,KAAOL,KAAKV,GAAGpE,QAAQ8E,KAAKjE,OAAOwH,KAAKvD,MAC/C,CAEA,MAAAjE,CAAOyH,GACL7G,QAAQuE,IAAI,SAAUlB,KAAKjD,iBAC3BiD,KAAKV,GAAGwC,cACR9B,KAAK+B,eACLvH,EAAe,CAACwF,KAAM,SAAUyD,GAAKA,EAAE7B,cAAe,iBAAkB8B,GAAMA,EAAGC,KAAM,OAAQC,GAAMA,EAAGJ,KAEnGxD,KAAK0C,QACV1C,KAAK0C,OACFmB,SAAS,CACRC,YAAa,CAAC9D,KAAKV,GAAGkB,OAAOhC,MAAOwB,KAAKV,GAAGkB,OAAO/B,QACnDsF,OAAQ/D,KAAKC,SACb+D,MAAOhE,KAAK9E,QAAUsI,EAAM,IAAO,IAEpCK,SAAS7D,KAAKf,KACd4E,SAAS7D,KAAK6D,YACdI,KAAKjE,KAAKuB,UACf,CAEA,OAAA1C,GACElC,QAAQuE,IAAI,WACZlB,KAAKK,MAGP,CAEA,iBAAM3D,EAEH8B,EAAOC,GACRyF,GAEA1J,EAAe,CAAC0J,EAAY,eAAgBC,GAAMA,EAAG,WAC/C,OAAM,IACZ,MAAM3D,EAAS4D,SAASC,cAAc,UACtC7D,EAAOhC,MAAQA,EACfgC,EAAO/B,OAASA,EAEhB9B,QAAQuE,IAAIlB,KAAKM,aACjB,MAAMgE,EAAW,IAAItE,KAAKM,YAAYE,EAAQ,CAAEzD,gBAAiB,IACjElF,OAAOmH,OAAOsF,EAASrF,IAAKe,KAAKf,KACjC,MAAMsF,EAAO,IACPjF,EAAKgF,EAAShF,GACpBA,EAAGkF,OAAOlF,EAAGmF,cACb,IAAIC,EAAa,EACjB,IAAK,IAAIvM,EAAI,EAAGA,EAAIqG,EAAOrG,GAAKoM,EAC9B,IAAK,IAAII,EAAI,EAAGA,EAAIlG,EAAQkG,GAAKJ,EAAM,CACrC,MAAMK,EAAerM,KAAKsM,IAAIN,EAAM/F,EAAQrG,GACtC2M,EAAgBvM,KAAKsM,IAAIN,EAAM9F,EAASkG,GAC9CrF,EAAGyF,QAAQ5M,EAAGwM,EAAGC,EAAcE,GAE/BR,EAASvI,OAAO,SAEV,OAAM,GACZ2I,GAAcE,EAAeE,EAC7BtK,EAAe,CAAC0J,EAAY,eAAgBc,GAAMA,EAAGN,GAAclG,EAAQC,KAC7E,CAEF,OAAO,IAAIwG,QAAQ,CAACnN,EAASoN,IAC3B1E,EAAO2E,OACJC,GACCA,EAAOtN,EAAQsN,GAAQF,EAAO,kCAChC,OAGN,CAKC,QAAArB,GACC,MAAO,CAAC,CACV,E,4EE1aF,kvhCACMxN,EAAY,CAAC,QAAU,EAAE,QAAU,CAAC,6DAA6D,6DAA6D,uEAAuE,6DAA6D,8DAA8D,gEAAgE,+DAA+D,2DAA2D,2DAA2D,4DAA4D,gEAAgE,8DAA8D,4DAA4D,sEAAsE,2DAA2D,sEAAsE,mEAAmE,qEAAqE,uEAAuE,mEAAmE,oEAAoE,kEAAkE,oEAAoE,gEAAgE,8DAA8D,iEAAiE,MAAQ,GAAG,SAAW,+zK,4ECDzsD,w0mCACMA,EAAY,CAAC,QAAU,EAAE,QAAU,CAAC,2DAA2D,6DAA6D,gEAAgE,+DAA+D,2DAA2D,gEAAgE,4DAA4D,gEAAgE,8DAA8D,4DAA4D,8DAA8D,gEAAgE,iEAAiE,mEAAmE,uEAAuE,6DAA6D,0EAA0E,2EAA2E,uEAAuE,mEAAmE,kEAAkE,mEAAmE,yEAAyE,mEAAmE,oEAAoE,sEAAsE,2EAA2E,MAAQ,GAAG,SAAW,+5K,2MCFlzD,SAASmE,EAAeC,GAAO,IAAIC,EAA+B5D,EAAQ2D,EAAI,GAAQhB,EAAI,EAAG,KAAOA,EAAIgB,EAAIE,QAAQ,CAAE,MAAMC,EAAKH,EAAIhB,GAAUoB,EAAKJ,EAAIhB,EAAI,GAAY,GAARA,GAAK,GAAe,mBAAPmB,GAAkC,iBAAPA,IAAmC,MAAT9D,EAAiB,OAA+B,WAAP8D,GAA0B,mBAAPA,GAA2BF,EAAgB5D,EAAOA,EAAQ+D,EAAG/D,IAA0B,SAAP8D,GAAwB,iBAAPA,IAAyB9D,EAAQ+D,EAAG,IAAIC,IAAShE,EAAMiE,KAAKL,KAAkBI,IAAQJ,OAAgBtB,EAAa,CAAE,OAAOtC,CAAO,CAE5f,MAAMuO,EACV,MAAAtF,GAAUC,KAAKsF,QAAU,EAAA/L,GAAGgM,CAAC,CAG7B,OAAArF,GAAWF,KAAKwF,YAAc,CAAC,CAAC,CAChC,OAAArF,GAAWH,KAAKyF,UAAW,CAAK,CAChC,KAAAC,GACC,EAAAC,GAAGC,SAAS5F,KAAKzJ,OACjBiE,EAAe,CAACwF,KAAM,SAAUgF,GAAMA,EAAGjO,SAAU,eAAgB8O,GAAMA,EAAG7F,KAAKzJ,QACnF,CAEA,WAAA+J,CACG/J,EACCQ,EACA+O,GACA9F,KAAKzJ,MAAQA,EAAMyJ,KAAKjJ,SAAWA,EAASiJ,KAAK8F,OAASA,EAAOT,EAAc5E,UAAUV,OAAOhF,KAAKiF,MAAMqF,EAAc5E,UAAUP,QAAQnF,KAAKiF,MAAMqF,EAAc5E,UAAUN,QAAQpF,KAAKiF,MAAMqF,EAAc5E,UAAUL,QAAQrF,KAAKiF,MAAMqF,EAAc5E,UAAUC,QAAQ3F,KAAKiF,MAAMqF,EAAc5E,UAAUsF,QAAQhL,KAAKiF,MAAMqF,EAAc5E,UAAUuF,QAAQjL,KAAKiF,MAAMqF,EAAc5E,UAAUwF,QAAQlL,KAAKiF,KAAM,CAE5Z,OAAAI,GAAWJ,KAAKkG,SAAYC,IAC1BA,IAAMnG,KAAKzJ,OAAS,EAAAoP,GAAGS,KAAKD,EAAGnG,KAAKzJ,OACrC,CAED,iBAAA8P,CACEC,EAIAC,EAAkBD,GAQlB,OANA9L,EAAe,CAACwF,KAAM,SAAUwG,GAAMA,EAAGC,WAAY,eAAgBC,GAAMA,MAC3EJ,EAAgBnF,iBAAiB,QAASnB,KAAK2G,OAC/CL,EAAgBnF,iBAAiB,YAAanB,KAAK4G,WACnDL,EAAgBpF,iBAAiB,UAAWnB,KAAK6G,SACjDN,EAAgBpF,iBAAiB,QAASnB,KAAK8G,OAEvC9G,KAAKyG,WAAa,KACxBH,EAAgBS,oBAAoB,QAAS/G,KAAK2G,OAClDL,EAAgBS,oBAAoB,YAAa/G,KAAK4G,WACtDL,EAAgBQ,oBAAoB,UAAW/G,KAAK6G,SACpDN,EAAgBQ,oBAAoB,QAAS/G,KAAK8G,OAEtD,CAEA,mBAAAE,GACExM,EAAe,CAACwF,KAAM,SAAUiH,GAAMA,EAAGR,WAAY,eAAgBS,GAAOA,KAC9E,CACA,mBAAQC,GAAgBnH,KAAKoH,aAAe,CAAC,IAAK,IAAK,IAAK,IAAI,CAEhE,IAAAzD,GACE,MAAM0D,EAAQ,IAAI,EAAA9N,MACbyG,KAAKwF,YAAY8B,KAAOtH,KAAKwF,YAAYnM,KACzC2G,KAAKwF,YAAY+B,KAAOvH,KAAKwF,YAAYgC,EAC5C,GAEGH,EAAMI,UACTzH,KAAKzJ,MAAQyJ,KAAKzJ,MAAMmR,UAAUL,EAAMM,MAAM,KAC9CnN,EAAe,CAACwF,KAAM,SAAU4H,GAAOA,EAAI7Q,SAAU,eAAgB8Q,GAAOA,EAAI7H,KAAKzJ,SAEzF,CACC,OAAAmK,GAAWV,KAAK2G,MAAS3P,IACxB,MAAMwJ,EAASxJ,EAAEoF,eACX,MAAEoC,EAAK,OAAEC,GAAW+B,EAAOY,wBAC3B0G,EAASvP,KAAKwP,IAAI,KAAMxP,KAAKyP,KAAKhR,EAAEiR,SACpCC,EAAI,IAAI,EAAA3O,GACZiH,EAAOhC,OAASxH,EAAEqK,QAAU7C,GAC5BgC,EAAO/B,QAAU,EAAIzH,EAAEsK,QAAU7C,GACjC,GAEFuB,KAAKzJ,MAAQyJ,KAAKzJ,MACfmR,UAAUQ,EAAEC,WACZC,MAAM,EAAA7O,GAAG8O,IAAIV,MAAMG,IACnBJ,UAAUQ,GACb1N,EAAe,CAACwF,KAAM,SAAUsI,GAAOA,EAAIvR,SAAU,eAAgBwR,GAAOA,EAAIvI,KAAKzJ,SACrFS,EAAEwR,iBACFxR,EAAEyR,kBACH,CAEA,OAAA1C,GAAW/F,KAAK4G,UAAa5P,IAC5B,MAAMwJ,EAASxJ,EAAEoF,eACX,MAAEoC,EAAK,OAAEC,GAAW+B,EAAOY,wBAC3BsH,GAAU,IAAAC,GAAE3R,EAAE4R,MAAO5R,EAAE6R,OACvBC,EAAQ9I,KAAKsF,QAAQyD,GAAGL,GACd,EAAZ1R,EAAEgS,UAAgBhJ,KAAKyF,WAEzBzF,KAAKzJ,MAAQyJ,KAAKzJ,MAAMmR,UACtBlH,EAAOhC,OAASsK,EAAM3Q,EAAIqG,GAC1BgC,EAAO/B,SAAWqK,EAAMnE,EAAIlG,GAC5B,GAEFjE,EAAe,CAACwF,KAAM,SAAUiJ,GAAOA,EAAIlS,SAAU,eAAgBmS,GAAOA,EAAIlJ,KAAKzJ,UAEvFyJ,KAAKsF,QAAUoD,EAChB,CAEA,OAAA1C,GAAWhG,KAAK6G,QAAW7P,IACZ,MAAVA,EAAEgD,KACJgG,KAAK0F,QACL1O,EAAEwR,kBACOnD,EAAc+B,aAAa+B,SAASnS,EAAEgD,OAC/CgG,KAAKwF,YAAYxO,EAAEgD,MAAO,EAC1BhD,EAAEwR,kBAEL,CACA,OAAAvC,GAAWjG,KAAK8G,MAAS9P,IACxBgJ,KAAKwF,YAAYxO,EAAEgD,UAAOZ,EAC1BpC,EAAEwR,iBACH,CAED,YAAAY,GACE,OAAOpJ,KAAKzJ,KACd,CAEA,oBAAO8S,CAAc9S,EAAO+S,EAAY,GACtC,MAAMC,EAAQhT,EAAMiT,iBACdpB,EAAQ7R,EAAM4P,EAAE,GACtB,OACE5N,KAAKkR,MAAMF,EAAMpR,EAAImR,GACrB,IACA/Q,KAAKkR,MAAMF,EAAM5E,EAAI2E,GACrB,IACA/Q,KAAKkR,MAAMlR,KAAK2I,IAAIkH,GAAS7P,KAAK2I,IAAI,KAE1C,CAEA,sBAAOwI,CAAgBC,EAAKL,EAAY,GACtC,MAEOM,EAAWC,EAAWC,GAAYH,EAAIrN,MAAM,KACnD,OAAO,EAAAqJ,GAAG+B,UACR,IAAI,EAAAnO,IAAIqQ,EAAYN,GAAYO,EAAYP,EAAW,IACvDlB,MAAM7P,KAAKwP,IAAI,KAAM+B,GACzB,EACAzE,EAAc8B,gBC5FE,QAAkB,IAAK,IACvC,EAAA5N,GAAGC,MAAM,EAA2B,GAAvBjB,KAAKwR,SAAW,IAAWxR,KAAKyR,KAD/C,MAIMC,EAAe,CACnBC,UAAW,EACX5C,EAAG,GACH6C,EAAG,GACHC,EAAG,GACHT,IAAK,SAiHMU,EAAO,CAClBC,EACAC,EACAL,EACApT,KAEA,QACEwT,EACAC,EACAhS,KAAKiS,MAA2C,GAArC,QAAQF,EAAUC,EAAUzT,IAAc,GA+XlD,MAAM2T,UAA8B3K,EAAA,GAGzC,WAAAQ,CACEC,EACAC,EACAkK,GAEAC,MAAMpK,EAAYC,EAAQkK,GAC1BlK,EAAOoK,SAAW,EAClB5K,KAAK6K,cAAgB,IAAIxF,EAAc,EAAAM,GAAGC,WAAY8E,EAAQI,aAC9D9K,KAAK6K,cAAcxE,kBAAkB7F,EACvC,CAEC,QAAAqD,GACC,MAAO,CACLkH,UAAW/K,KAAK6K,cAAczB,eAC9B4B,UAAWhL,KAAK6K,cAAczB,eAAe6B,WAEjD,CACC,MAAAC,CAAO3U,GACNyJ,KAAK6K,cAAc3E,SAAS3P,EAC9B,CAEC,MAAAwF,CAAOyH,GACNxD,KAAK6K,cAAclH,OACnBgH,MAAM5O,OAAOyH,EACf,EAEF,MAAM2H,EAAoB,EACxBC,OACAnQ,KACAC,UACA3E,YASA,MAAM4E,GAAW,IAAAa,aACf,cAAcyO,EAEZ,WAAAnK,CACEE,EACAkK,GAEAC,MAAM,IAAM,QAAQ,KAAOS,EAAO,SAAU5K,EAAQkK,EACtD,GAEF,CAACU,IAGH,OACE,gBAAoB,KAAa,CAAEnQ,GAAIA,EAAIE,SAAUA,EAAUD,QAASA,EAAS3E,MAAOA,KAG5F,OACE,MAAOA,EAAO2P,IAAY,EAAAmF,EAAA,GAAapB,IAChCzO,EAAKC,IAAU,IAAAC,UAAS,GACzBjF,GAAkB,IAAAuF,aACrBvE,GAAMyO,EAAUqB,IAAM,IAAMA,KAAM9P,KACnC,CAACyO,IAUGoF,IARS,IAAAtP,aACb,EAAG2N,UACD,MAAMxD,EAAId,EAAcqE,gBAAgBC,GACxClT,EAAgB,CAAEkT,IAAKtE,EAAcgE,cAAclD,MAErD,CAAC1P,KAGgB,IAAA8E,WAMnB,OALA,IAAAsB,WAAU,KACRtG,EAAMoT,KAvnBT,SAAwBlP,GAAO,IAAIC,EAA+B5D,EAAQ2D,EAAI,GAAQhB,EAAI,EAAG,KAAOA,EAAIgB,EAAIE,QAAQ,CAAE,MAAMC,EAAKH,EAAIhB,GAAUoB,EAAKJ,EAAIhB,EAAI,GAAY,GAARA,GAAK,GAAe,mBAAPmB,GAAkC,iBAAPA,IAAmC,MAAT9D,EAAiB,OAA+B,WAAP8D,GAA0B,mBAAPA,GAA2BF,EAAgB5D,EAAOA,EAAQ+D,EAAG/D,IAA0B,SAAP8D,GAAwB,iBAAPA,IAAyB9D,EAAQ+D,EAAG,IAAIC,IAAShE,EAAMiE,KAAKL,KAAkBI,IAAQJ,OAAgBtB,EAAa,CAAgB,CAwnB7f,CAAe,CAACkS,EAAY,SAAU7H,GAAKA,EAAElH,QAAS,iBAAkBmH,GAAMA,EAAGwH,OAAQ,eAAgBtH,GAAMA,EAAGyB,EAAcqE,gBAAgBnT,EAAMoT,SACvJ,IAGD,gBAAoB4B,EAAA,EAAM,CAAEC,WAAW,EAAM3L,MAAO,CAAEpB,OAAQ,OAASgN,QAAS,EAAGC,QAAS,GACxF,gBAAoBH,EAAA,EAAM,CAAEC,WAAW,EAAMG,MAAM,EAAMC,GAAI,EAAGH,QAAS,GACvE,CACA,QASAtU,IAAI,CAACiU,EAAM3R,IACX,gBAAoB8R,EAAA,EAAM,CAAE3U,KAAM,CAAEiV,GAAI,IAAM7R,IAAKP,GAC/C,gBAAoB0R,EAAmB,CACvClQ,GAAI,CAAEwD,OAAQ,KACdvD,SAAS,EACT3E,MAAOA,EACP6U,KAAMA,EACN/P,YAAaiQ,OAMnB,gBAAoBC,EAAA,EAAM,CAC1B3U,KAAM,CAAEiV,GAAI,GAAIC,GAAI,GACpB7Q,GAAI,CACF8Q,QAAS,OACTC,cAAe,SACfxN,MAAO,OACPyN,WAAY,UAEZC,IAAK,IAGL,gBAAoB9O,EAAA,EAAM,KACxB,gBAAoB+O,EAAA,EAAa,KAAM,kDAIzC,gBAAoB7V,EAAA,EAAkB,CAAOC,QAAOE,kBAAmBD,KAAM,cAC7E,gBAAoB4V,EAAA,GAAQ,CAC5BtV,MAAOP,EAAM+Q,EACbvQ,SAAU,CAACC,EAAGsQ,IAAM7Q,EAAgB,CAAE6Q,MACtCzC,IAAK,EACLwH,IAAK,EACL9H,KAAM,MAEN,gBAAoB6H,EAAA,GAAQ,CAC5BtV,MAAOP,EAAM4T,EACbpT,SAAU,CAACC,EAAGmT,IAAM1T,EAAgB,CAAE0T,MACtCtF,IAAK,EACLwH,IAAK,EACL9H,KAAM,MAEN,gBAAoB6H,EAAA,GAAQ,CAC5BtV,MAAOP,EAAM6T,EACbrT,SAAU,CAACC,EAAGoT,IAAM3T,EAAgB,CAAE2T,MACtCvF,IAAK,EACLwH,IAAK,EACL9H,KAAM,MAENhO,EAAM+Q,EACN,gBAAoB,MAAO,KAAM,QAAU9L,IAIpD,C,4EC/rBD,y2QACMnF,EAAY,CAAC,QAAU,EAAE,QAAU,CAAC,2DAA2D,6DAA6D,8DAA8D,2DAA2D,gEAAgE,6DAA6D,+DAA+D,sEAAsE,4DAA4D,4DAA4D,gEAAgE,gEAAgE,6DAA6D,MAAQ,GAAG,SAAW,6gD,4ECDx2B,sqlBACMA,EAAY,CAAC,QAAU,EAAE,QAAU,CAAC,4DAA4D,6DAA6D,8DAA8D,gEAAgE,4DAA4D,gEAAgE,8DAA8D,4DAA4D,8DAA8D,6DAA6D,2DAA2D,6DAA6D,+DAA+D,4DAA4D,6DAA6D,uEAAuE,gEAAgE,4DAA4D,sEAAsE,MAAQ,GAAG,SAAW,iyF,+CCC1tC,MAAMwL,EACV,MAAA9B,GAAUC,KAAKlG,MAAQ,CAAC,CAExB,OAAAoG,GAAWF,KAAKsM,SAAWC,YAAYC,KAAK,CAC7C,WAAAlM,CACImM,EACApS,EAAS,IACT2F,KAAKyM,OAASA,EAAOzM,KAAK3F,OAASA,EAAOwH,EAAcpB,UAAUV,OAAOhF,KAAKiF,MAAM6B,EAAcpB,UAAUP,QAAQnF,KAAKiF,KAAM,CAEnI,IAAA2D,CAAK+I,EAAOH,YAAYC,OACtB,MAAMnS,EAAS2F,KAAK3F,OAEpB,GADA2F,KAAKlG,OAASkG,KAAKlG,MAAQ,GAAKO,EACb,IAAf2F,KAAKlG,MAAa,CACpB,MAAM0B,EAAMjD,KAAKiS,MAAgB,IAATnQ,GAAkBqS,EAAO1M,KAAKsM,WACtDtM,KAAKyM,OAAOjR,GACZwE,KAAKsM,SAAWI,CAClB,CACF,E,4ECnBF,yphBACMrW,EAAY,CAAC,QAAU,EAAE,QAAU,CAAC,4DAA4D,gEAAgE,4DAA4D,gEAAgE,8DAA8D,+DAA+D,uEAAuE,sEAAsE,8DAA8D,kEAAkE,sEAAsE,8DAA8D,8DAA8D,6DAA6D,4DAA4D,MAAQ,GAAG,SAAW,g3E,6GCQ7/B,MAAMsW,EAAaC,GACTA,EAEJA,EACGC,UAAU,GACVvQ,MAAM,KACNnF,IAAK2V,IACJ,MAAO9S,EAAKlD,GAASgW,EAAKxQ,MAAM,KAChC,MAAO,CAACyQ,mBAAmB/S,GAAM+S,mBAAmBjW,MAErDkW,OACC,CAACC,GAAMjT,EAAKlD,MACVmW,EAAIjT,GAAOlD,EACJmW,GAET,CAAC,GAbL,CAAC,EAgBDC,EAAgBzV,GAElB,IACAI,OAAOsV,QAAQ1V,GACZN,IACC,EAAE6C,EAAKlD,KACLsW,mBAAmBpT,GAAO,IAAMoT,mBAAmBtW,IAEtDuW,KAAK,KAINC,EACJnV,GAEA,IAAUA,EAAG,CAACkK,EAAGrI,KACf,GAAI,cAAgBA,EAOb,MAAI,SAAWqI,GAEX,UAAYA,IAEZ,QAAUA,EACZkL,IACE,cAAgBlL,OACzB,EACS,SAAWA,EACb,KACE,KAAOA,EACT,GACGmL,OAAOnL,GAGVA,GAFCA,GAnBR,IACE,OAAO,QAAoBA,EAC7B,CAAE,MAAOrL,GAEP,OADA2F,QAAQC,MAAM5F,GACP,IACT,IAmBAyW,EAAoBtV,GACxB,IAAUA,EAAG,CAACkK,EAAGrI,IACP,cAARA,GAAsB,QAAkBqI,GAAM,GAAKA,GAGhD,SAASgJ,EACdpB,GACA,YACEyD,EAAcJ,EAAkB,UAChCK,EAAYF,EAAgB,KAC5BG,EAAO,KACL,CAAC,GAEL,MAAMC,GAAqB,IAAA7R,aAAY,KACrC,MAAMzF,EACJ,mBAAsB0T,EAClB,IACAA,EAEA6D,EAAcJ,EAClB7V,OAAOmH,OAAO2O,EAAUpX,GAAQoW,EAAUvI,SAAS2J,SAASnB,QAS9D,OAPAjQ,QAAQuE,IAAI,gBACZ8M,QAAQC,kBACN7U,EACAgL,SAAS8J,MACThB,EAAaS,EAAUG,KAGlBA,GACN,CAACJ,EAAazD,EAAc0D,KACxBpX,EAAO2P,IAAY,IAAAxK,UAASmS,GAC7BM,GAAgB,IAAA5S,UAsBtB,OArBA,IAAAsB,WAAU,IAtGX,SAAwBpC,GAAO,IAAIC,EAA+B5D,EAAQ2D,EAAI,GAAQhB,EAAI,EAAG,KAAOA,EAAIgB,EAAIE,QAAQ,CAAE,MAAMC,EAAKH,EAAIhB,GAAUoB,EAAKJ,EAAIhB,EAAI,GAAY,GAARA,GAAK,GAAe,mBAAPmB,GAAkC,iBAAPA,IAAmC,MAAT9D,EAAiB,OAA+B,WAAP8D,GAA0B,mBAAPA,GAA2BF,EAAgB5D,EAAOA,EAAQ+D,EAAG/D,IAA0B,SAAP8D,GAAwB,iBAAPA,IAAyB9D,EAAQ+D,EAAG,IAAIC,IAAShE,EAAMiE,KAAKL,KAAkBI,IAAQJ,OAAgBtB,EAAa,CAAE,OAAOtC,CAAO,CAsGjf0D,CAAe,CAAC2T,EAAe,SAAU1K,GAAKA,EAAElH,QAAS,eAAgBmH,GAAMA,EAAGnN,KAAU,CAACA,IACxG4X,EAAc5R,UACjBI,QAAQuE,IAAI,aACZiN,EAAc5R,QAAU,IAAS,SAAU6R,GACzCJ,QAAQK,eACNjV,EACAgL,SAAS8J,MACThB,EAAaS,EAAUS,IAE3B,EAAGR,KAGL,IAAA/Q,WAAU,KACR,MAAMyR,EAAe,KACnBpI,EAAS2H,MAGX,OADAxT,OAAO8G,iBAAiB,aAAcmN,GAC/B,KACLjU,OAAO0M,oBAAoB,aAAcuH,KAE1C,CAACT,IACG,CAACtX,EAAO2P,EACjB,C,iKC9GO,SAASqI,EAAEpW,GAChB,MAAO,CAAEtB,KAAM,KAAY2X,cAAeC,UAAU,EAAOtW,EAAGA,EAChE,CAEO,SAASuW,EACdC,EACAC,EACAC,EACAC,EACAC,EACA7G,GAEA,MAAO,CACL8G,SAAUF,EACVG,GAAIN,EACJO,GAAIN,EACJH,UAAU,EACVM,UAAWA,EACXlY,KAAM,KAAYsY,IAClBhX,EAAG+P,EAAE/P,EACLiX,KAAM,EACNzK,EAAGuD,EAAEvD,EAET,CAEO,MAAM0K,EAAI,CACfC,EACAC,EACAC,EACAC,EACAtX,EACAwM,KACG,CACH9N,KAAM,KAAY6Y,SAClBJ,KACAC,KACAC,KACAC,KACAtX,IACAwM,IACA8J,UAAU,IAGC9F,EAAKhE,IAAM,CACtB9N,KAAM,KAAY8Y,aAClBhL,IACA8J,UAAU,IAcL,SAASnV,EAAEsW,EAAIC,GACpB,MAAO1X,EAAGwM,QAAYvL,IAAPyW,EAAmB,CAAC,EAAM1X,EAAG,EAAMwM,GAAK,CAACiL,EAAIC,GAC5D,MAAO,CAAEhZ,KAAM,KAAYiZ,QAAS3X,IAAGwM,IAAG8J,UAAU,EACtD,CAWO,SAAS/U,EAAEkW,EAAIC,GACpB,MAAO1X,EAAGwM,QAAYvL,IAAPyW,EAAmB,CAAC,EAAM1X,EAAG,EAAMwM,GAAK,CAACiL,EAAIC,GAC5D,MAAO,CAAEhZ,KAAM,KAAYkZ,QAAS5X,IAAGwM,IAAG8J,UAAU,EACtD,CAEO,MAAMuB,EAAI,CAAC7X,EAAGwM,KAAM,CACzB9N,KAAM,KAAYkZ,QAClB5X,IACAwM,IACA8J,UAAU,IAGC9U,EAAI,KAAM,CAAG9C,KAAM,KAAYoZ,aAE/BC,EAAS,IAAIC,KACxB,MAAMC,EAAU,GAChB,IAAIC,EAAQ,EACVC,EAAQ,EACV,IAAK,MAAMlG,KAAK+F,EAAM,CACpB,GAAI,mBAAsB/F,EACxB,IAAK,MAAMmG,KAAMnG,EAAEiG,EAAOC,GACxBF,EAAQI,KAAKD,QAGfH,EAAQI,KAAKpG,GAEf,MAAMqG,EAAQ,IAAKL,GACf,MAAOK,IAAOJ,EAAQI,EAAMtY,GAC5B,MAAOsY,IAAOH,EAAQG,EAAM9L,EAClC,CACA,OAAO,IAAI,KAAYyL,GAAS3G,MAAM,GAAGyG,UAIpC,SAASQ,EAAOC,EAAKxY,EAAGwM,GAC7B,MAAO,CAACiM,EAAOC,KACb,MAAMC,GAAO,IAAAnI,GAAGiI,EAAOC,GACjBE,GAAK,IAAApI,GAAGxQ,EAAGwM,GACXqM,EAAOF,EAAK/H,GAAGgI,GAAIE,SAASN,GAC5BO,GAAK,IAAAvI,GAAGoI,EAAG5Y,EAAI6Y,EAAKrM,EAAGoM,EAAGpM,EAAIqM,EAAK7Y,GACzC,MAAO,CAACuB,EAAEqX,EAAGI,MAAMH,IAAQtC,EAAEiC,EAAKA,EAAK,EAAG,EAAG,EAAGO,IAEpD,C,2GC5HO,MAAME,EAAgB,CAC3B,CAAC,IAAK,KAAM,MACZ,CAAC,IAAK,IAAK,MACX,CAAC,IAAK,IAAK,MACX,CAAC,IAAK,IAAK,MACX,CAAC,IAAK,IAAK,MACX,CAAC,IAAK,IAAK,MACX,CAAC,IAAK,IAAK,MACX,CAAC,GAAI,IAAK,MACV,CAAC,GAAI,GAAI,MACT,CAAC,GAAI,GAAI,MACT,CAAC,GAAI,GAAI,QAsBEC,EAAgB,CAC3B,CAAC,IAAK,KAAM,MACZ,CAAC,IAAK,IAAK,MACX,CAAC,IAAK,IAAK,MACX,CAAC,IAAK,IAAK,MACX,CAAC,IAAK,IAAK,MACX,CAAC,IAAK,IAAK,MACX,CAAC,IAAK,IAAK,MACX,CAAC,GAAI,IAAK,MACV,CAAC,GAAI,GAAI,MACT,CAAC,GAAI,GAAI,MACT,CAAC,GAAI,GAAI,QAEEC,EAAc,IACtBF,EACH,CAAC,IAAK,IAAK,gBACX,CAAC,IAAK,IAAK,gBACX,CAAC,GAAI,GAAI,iBACT,CAAC,MAAO,MAAO,UACf,CAAC,MAAO,MAAO,UASV,SAASG,EAAoBC,GAClC,MAAMC,EAASH,EAAYI,KAAK,EAAE,CAAE,CAAEC,KAAUA,IAASH,GACzD,GAAIC,EAAQ,OAAOA,EACnB,MAAOnK,EAAG6C,GAAKqH,EAAIlV,MAAM,KACzB,MAAO,EAAEgL,GAAI6C,EAAG,SAClB,CACO,SAASyH,EAAwBtK,EAAG6C,GAEzC,OADE7C,EAAG6C,GAAK,CAAC7C,EAAG6C,GAAG0H,KAAK,MA1E4B,OAAzBC,EA2EDR,EAAYI,KAAK,EAAEvZ,EAAGwM,KAAOxM,IAAMmP,GAAK3C,IAAMwF,IA3EL2H,EA2ES,KAAM,CAAGxK,EAAG6C,EAAG,UA3EH4H,GAAvF,IAA0BD,CA4E3B,CACO,SAASE,GAAmB1K,EAAG6C,EAAGwH,IACvC,MAAgB,WAATA,EAAyBrK,EAAI,IAAM6C,EAAIwH,CAChD,CAEO,MAAMM,EAAgBb,EAAc,E,4EChF3C,83NACM/a,EAAY,CAAC,QAAU,EAAE,QAAU,CAAC,8DAA8D,6DAA6D,8DAA8D,2DAA2D,gEAAgE,6DAA6D,4DAA4D,4DAA4D,6DAA6D,uEAAuE,gEAAgE,8DAA8D,gEAAgE,6DAA6D,MAAQ,GAAG,SAAW,wuC,4ECDx6B,mpNACMA,EAAY,CAAC,QAAU,EAAE,QAAU,CAAC,4DAA4D,6DAA6D,8DAA8D,sEAAsE,4DAA4D,4DAA4D,gEAAgE,4DAA4D,gEAAgE,2DAA2D,gEAAgE,8DAA8D,MAAQ,GAAG,SAAW,srC,4ECD1yB,2+fACMA,EAAY,CAAC,QAAU,EAAE,QAAU,CAAC,4DAA4D,6DAA6D,8DAA8D,6DAA6D,2DAA2D,gEAAgE,6DAA6D,+DAA+D,sEAAsE,4DAA4D,4DAA4D,gEAAgE,6DAA6D,gEAAgE,6DAA6D,MAAQ,GAAG,SAAW,83E","sources":["/dev/workshop/./src/noises/mengerSlices.frag?","/dev/workshop/./src/common/BoundNumberField.tsx?","/dev/workshop/./src/noises/ sync ^\\.\\/.*\\.frag$?","/dev/workshop/./src/paperBox1/common.tsx?","/dev/workshop/./src/common/raymarch.vert?","/dev/workshop/./src/noises/sphereOpenSimplex.frag?","/dev/workshop/./src/sdfs/SimpleCanvasRenderer.tsx?","/dev/workshop/./src/common/memoizeLast.ts?","/dev/workshop/./src/noises/magic2.frag?","/dev/workshop/./src/noises/tree.frag?","/dev/workshop/./src/noises/PanController.ts?","/dev/workshop/./src/noises/index.tsx?","/dev/workshop/./src/noises/test.frag?","/dev/workshop/./src/noises/julia.frag?","/dev/workshop/./src/common/FPSController.ts?","/dev/workshop/./src/noises/magic.frag?","/dev/workshop/./src/common/useHashState.ts?","/dev/workshop/./src/paperBox1/svg.ts?","/dev/workshop/./src/paperBox1/PaperSize.tsx?","/dev/workshop/./src/noises/simplex.frag?","/dev/workshop/./src/noises/test3.frag?","/dev/workshop/./src/noises/test2.frag?"],"sourcesContent":["\nexport default \"#version 300 es\\n\\nprecision highp float;\\n\\n// START ../common/banded.glsl\\nfloat banded(float bandCount, float t) {\\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\\n}\\nfloat banded(int bandCount, float t) {\\n  return banded(float(bandCount), t);\\n}\\n\\n// #pragma glslify: export(banded)\\n\\n\\n// END ../common/banded.glsl\\n// START ../common/checkerboardGrad.glsl\\n//https://iquilezles.org/articles/checkerfiltering/\\nfloat tri(float x) {\\n  float h = fract(x * 0.5) - 0.5;\\n  return 1.0 - 2.0 * abs(h);\\n}\\nvec2 tri(vec2 x) {\\n  vec2 h = fract(x * 0.5) - 0.5;\\n  return 1.0 - 2.0 * abs(h);\\n}\\n\\nfloat checkerboardGrad(vec2 uv) {\\n  vec2 w = max(abs(dFdx(uv)), abs(dFdy(uv))) + 0.01; // filter kernel\\n  vec2 i = (tri(uv + 0.5 * w) - tri(uv - 0.5 * w)) / w; // analytical integral (box filter)\\n  return 0.5 - 0.5 * i.x * i.y; // xor pattern\\n}\\n\\n// END ../common/checkerboardGrad.glsl\\n// START ../common/colors.glsl\\nconst vec3 INDIAN_RED = vec3(0.804, 0.361, 0.361);\\nconst vec3 LIGHT_CORAL = vec3(0.941, 0.502, 0.502);\\nconst vec3 SALMON = vec3(0.98, 0.502, 0.447);\\nconst vec3 DARK_SALMON = vec3(0.914, 0.588, 0.478);\\nconst vec3 LIGHT_SALMON = vec3(1.0, 0.627, 0.478);\\nconst vec3 CRIMSON = vec3(0.863, 0.078, 0.235);\\nconst vec3 RED = vec3(1.0, 0.0, 0.0);\\nconst vec3 FIRE_BRICK = vec3(0.698, 0.133, 0.133);\\nconst vec3 DARK_RED = vec3(0.545, 0.0, 0.0);\\nconst vec3 PINK = vec3(1.0, 0.753, 0.796);\\nconst vec3 LIGHT_PINK = vec3(1.0, 0.714, 0.757);\\nconst vec3 HOT_PINK = vec3(1.0, 0.412, 0.706);\\nconst vec3 DEEP_PINK = vec3(1.0, 0.078, 0.576);\\nconst vec3 MEDIUM_VIOLET_RED = vec3(0.78, 0.082, 0.522);\\nconst vec3 PALE_VIOLET_RED = vec3(0.859, 0.439, 0.576);\\nconst vec3 CORAL = vec3(1.0, 0.498, 0.314);\\nconst vec3 TOMATO = vec3(1.0, 0.388, 0.278);\\nconst vec3 ORANGE_RED = vec3(1.0, 0.271, 0.0);\\nconst vec3 DARK_ORANGE = vec3(1.0, 0.549, 0.0);\\nconst vec3 ORANGE = vec3(1.0, 0.647, 0.0);\\nconst vec3 GOLD = vec3(1.0, 0.843, 0.0);\\nconst vec3 YELLOW = vec3(1.0, 1.0, 0.0);\\nconst vec3 LIGHT_YELLOW = vec3(1.0, 1.0, 0.878);\\nconst vec3 LEMON_CHION = vec3(1.0, 0.98, 0.804);\\nconst vec3 LIGHT_GOLDENROD_YELLOW = vec3(0.98, 0.98, 0.824);\\nconst vec3 PAPAYA_WHIP = vec3(1.0, 0.937, 0.835);\\nconst vec3 MOCCASIN = vec3(1.0, 0.894, 0.71);\\nconst vec3 PEACH_PU = vec3(1.0, 0.855, 0.725);\\nconst vec3 PALE_GOLDENROD = vec3(0.933, 0.91, 0.667);\\nconst vec3 KHAKI = vec3(0.941, 0.902, 0.549);\\nconst vec3 DARK_KHAKI = vec3(0.741, 0.718, 0.42);\\nconst vec3 LAVENDER = vec3(0.902, 0.902, 0.98);\\nconst vec3 THISTLE = vec3(0.847, 0.749, 0.847);\\nconst vec3 PLUM = vec3(0.867, 0.627, 0.867);\\nconst vec3 VIOLET = vec3(0.933, 0.51, 0.933);\\nconst vec3 ORCHID = vec3(0.855, 0.439, 0.839);\\nconst vec3 FUCHSIA = vec3(1.0, 0.0, 1.0);\\nconst vec3 MAGENTA = vec3(1.0, 0.0, 1.0);\\nconst vec3 MEDIUM_ORCHID = vec3(0.729, 0.333, 0.827);\\nconst vec3 MEDIUM_PURPLE = vec3(0.576, 0.439, 0.859);\\nconst vec3 BLUE_VIOLET = vec3(0.541, 0.169, 0.886);\\nconst vec3 DARK_VIOLET = vec3(0.58, 0.0, 0.827);\\nconst vec3 DARK_ORCHID = vec3(0.6, 0.196, 0.8);\\nconst vec3 DARK_MAGENTA = vec3(0.545, 0.0, 0.545);\\nconst vec3 PURPLE = vec3(0.502, 0.0, 0.502);\\nconst vec3 INDIGO = vec3(0.294, 0.0, 0.51);\\nconst vec3 SLATE_BLUE = vec3(0.416, 0.353, 0.804);\\nconst vec3 DARK_SLATE_BLUE = vec3(0.282, 0.239, 0.545);\\nconst vec3 GREEN_YELLOW = vec3(0.678, 1.0, 0.184);\\nconst vec3 CHARTREUSE = vec3(0.498, 1.0, 0.0);\\nconst vec3 LAWN_GREEN = vec3(0.486, 0.988, 0.0);\\nconst vec3 LIME = vec3(0.0, 1.0, 0.0);\\nconst vec3 LIME_GREEN = vec3(0.196, 0.804, 0.196);\\nconst vec3 PALE_GREEN = vec3(0.596, 0.984, 0.596);\\nconst vec3 LIGHT_GREEN = vec3(0.565, 0.933, 0.565);\\nconst vec3 MEDIUM_SPRING_GREEN = vec3(0.0, 0.98, 0.604);\\nconst vec3 SPRING_GREEN = vec3(0.0, 1.0, 0.498);\\nconst vec3 MEDIUM_SEA_GREEN = vec3(0.235, 0.702, 0.443);\\nconst vec3 SEA_GREEN = vec3(0.18, 0.545, 0.341);\\nconst vec3 FOREST_GREEN = vec3(0.133, 0.545, 0.133);\\nconst vec3 GREEN = vec3(0.0, 0.502, 0.0);\\nconst vec3 DARK_GREEN = vec3(0.0, 0.392, 0.0);\\nconst vec3 YELLOW_GREEN = vec3(0.604, 0.804, 0.196);\\nconst vec3 OLIVE_DRAB = vec3(0.42, 0.557, 0.137);\\nconst vec3 OLIVE = vec3(0.502, 0.502, 0.0);\\nconst vec3 DARK_OLIVE_GREEN = vec3(0.333, 0.42, 0.184);\\nconst vec3 MEDIUM_AQUAMARINE = vec3(0.4, 0.804, 0.667);\\nconst vec3 DARK_SEA_GREEN = vec3(0.561, 0.737, 0.561);\\nconst vec3 LIGHT_SEA_GREEN = vec3(0.125, 0.698, 0.667);\\nconst vec3 DARK_CYAN = vec3(0.0, 0.545, 0.545);\\nconst vec3 TEAL = vec3(0.0, 0.502, 0.502);\\nconst vec3 AQUA = vec3(0.0, 1.0, 1.0);\\nconst vec3 CYAN = vec3(0.0, 1.0, 1.0);\\nconst vec3 LIGHT_CYAN = vec3(0.878, 1.0, 1.0);\\nconst vec3 PALE_TURQUOISE = vec3(0.686, 0.933, 0.933);\\nconst vec3 AQUAMARINE = vec3(0.498, 1.0, 0.831);\\nconst vec3 TURQUOISE = vec3(0.251, 0.878, 0.816);\\nconst vec3 MEDIUM_TURQUOISE = vec3(0.282, 0.82, 0.8);\\nconst vec3 DARK_TURQUOISE = vec3(0.0, 0.808, 0.82);\\nconst vec3 CADET_BLUE = vec3(0.373, 0.62, 0.627);\\nconst vec3 STEEL_BLUE = vec3(0.275, 0.51, 0.706);\\nconst vec3 LIGHT_STEEL_BLUE = vec3(0.69, 0.769, 0.871);\\nconst vec3 POWDER_BLUE = vec3(0.69, 0.878, 0.902);\\nconst vec3 LIGHT_BLUE = vec3(0.678, 0.847, 0.902);\\nconst vec3 SKY_BLUE = vec3(0.529, 0.808, 0.922);\\nconst vec3 LIGHT_SKY_BLUE = vec3(0.529, 0.808, 0.98);\\nconst vec3 DEEP_SKY_BLUE = vec3(0.0, 0.749, 1.0);\\nconst vec3 DODGER_BLUE = vec3(0.118, 0.565, 1.0);\\nconst vec3 CORNLOWER_BLUE = vec3(0.392, 0.584, 0.929);\\nconst vec3 MEDIUM_SLATE_BLUE = vec3(0.482, 0.408, 0.933);\\nconst vec3 ROYAL_BLUE = vec3(0.255, 0.412, 0.882);\\nconst vec3 BLUE = vec3(0.0, 0.0, 1.0);\\nconst vec3 MEDIUM_BLUE = vec3(0.0, 0.0, 0.804);\\nconst vec3 DARK_BLUE = vec3(0.0, 0.0, 0.545);\\nconst vec3 NAVY = vec3(0.0, 0.0, 0.502);\\nconst vec3 MIDNIGHT_BLUE = vec3(0.098, 0.098, 0.439);\\nconst vec3 CORNSILK = vec3(1.0, 0.973, 0.863);\\nconst vec3 BLANCHED_ALMOND = vec3(1.0, 0.922, 0.804);\\nconst vec3 BISQUE = vec3(1.0, 0.894, 0.769);\\nconst vec3 NAVAJO_WHITE = vec3(1.0, 0.871, 0.678);\\nconst vec3 WHEAT = vec3(0.961, 0.871, 0.702);\\nconst vec3 BURLY_WOOD = vec3(0.871, 0.722, 0.529);\\nconst vec3 TAN = vec3(0.824, 0.706, 0.549);\\nconst vec3 ROSY_BROWN = vec3(0.737, 0.561, 0.561);\\nconst vec3 SANDY_BROWN = vec3(0.957, 0.643, 0.376);\\nconst vec3 GOLDENROD = vec3(0.855, 0.647, 0.125);\\nconst vec3 DARK_GOLDENROD = vec3(0.722, 0.525, 0.043);\\nconst vec3 PERU = vec3(0.804, 0.522, 0.247);\\nconst vec3 CHOCOLATE = vec3(0.824, 0.412, 0.118);\\nconst vec3 SADDLE_BROWN = vec3(0.545, 0.271, 0.075);\\nconst vec3 SIENNA = vec3(0.627, 0.322, 0.176);\\nconst vec3 BROWN = vec3(0.647, 0.165, 0.165);\\nconst vec3 MAROON = vec3(0.502, 0.0, 0.0);\\nconst vec3 WHITE = vec3(1.0, 1.0, 1.0);\\nconst vec3 SNOW = vec3(1.0, 0.98, 0.98);\\nconst vec3 HONEYDEW = vec3(0.941, 1.0, 0.941);\\nconst vec3 MINT_CREAM = vec3(0.961, 1.0, 0.98);\\nconst vec3 AZURE = vec3(0.941, 1.0, 1.0);\\nconst vec3 ALICE_BLUE = vec3(0.941, 0.973, 1.0);\\nconst vec3 GHOST_WHITE = vec3(0.973, 0.973, 1.0);\\nconst vec3 WHITE_SMOKE = vec3(0.961, 0.961, 0.961);\\nconst vec3 SEASHELL = vec3(1.0, 0.961, 0.933);\\nconst vec3 BEIGE = vec3(0.961, 0.961, 0.863);\\nconst vec3 OLD_LACE = vec3(0.992, 0.961, 0.902);\\nconst vec3 FLORAL_WHITE = vec3(1.0, 0.98, 0.941);\\nconst vec3 IVORY = vec3(1.0, 1.0, 0.941);\\nconst vec3 ANTIQUE_WHITE = vec3(0.98, 0.922, 0.843);\\nconst vec3 LINEN = vec3(0.98, 0.941, 0.902);\\nconst vec3 LAVENDER_BLUSH = vec3(1.0, 0.941, 0.961);\\nconst vec3 MISTY_ROSE = vec3(1.0, 0.894, 0.882);\\nconst vec3 GAINSBORO = vec3(0.863, 0.863, 0.863);\\nconst vec3 LIGHT_GREY = vec3(0.827, 0.827, 0.827);\\nconst vec3 SILVER = vec3(0.753, 0.753, 0.753);\\nconst vec3 DARK_GRAY = vec3(0.663, 0.663, 0.663);\\nconst vec3 GRAY = vec3(0.502, 0.502, 0.502);\\nconst vec3 DIM_GRAY = vec3(0.412, 0.412, 0.412);\\nconst vec3 LIGHT_SLATE_GRAY = vec3(0.467, 0.533, 0.6);\\nconst vec3 SLATE_GRAY = vec3(0.439, 0.502, 0.565);\\nconst vec3 DARK_SLATE_GRAY = vec3(0.184, 0.31, 0.31);\\nconst vec3 BLACK = vec3(0.0, 0.0, 0.0);\\n\\n// END ../common/colors.glsl\\n// START ../common/complex.glsl\\n// START ./polar.glsl\\n// START ../common/fromPolar.glsl\\n// START ./unmix.glsl\\nfloat unmix(float a, float b, float value) {\\n  return (value - a) / (b - a);\\n}\\n\\n// #pragma glslify: export(unmix)\\n\\n\\n// END ./unmix.glsl\\n\\nvec3 fromPolar(float radius, float phi, float z) {\\n  return vec3(radius * cos(phi), radius * sin(phi), z);\\n}\\n\\nvec2 fromPolar(float radius, float phi) {\\n  return vec2(radius * cos(phi), radius * sin(phi));\\n}\\n\\nvec2 fromPolar(vec2 polar) {\\n  return fromPolar(polar.x, polar.y);\\n}\\n\\n// #pragma glslify: export(fromPolar)\\n\\n\\n// END ../common/fromPolar.glsl\\n// START ../common/toPolar.glsl\\n\\nvec2 toPolar(vec2 xy) {\\n  return vec2(length(xy), atan(xy.y, xy.x));\\n}\\n\\nmat2 toPolarDerivate(vec2 xy) {\\n  return mat2(xy.x * xy.x, xy.y * xy.y, -xy.y, xy.x) / dot(xy, xy);\\n}\\n\\n// #pragma glslify: export(toPolar)\\n\\n\\n// END ../common/toPolar.glsl\\n\\n// END ./polar.glsl\\n\\nvec2 complexConj(vec2 z) {\\n  return vec2(z.x, -z.y);\\n}\\n\\nvec2 complexMul(vec2 a, vec2 b) {\\n  return vec2(a.x * b.x - a.y * b.y, a.y * b.x + a.x * b.y);\\n}\\n\\nvec2 complexDiv(vec2 a, vec2 b) {\\n  vec2 bConj = vec2(b.x, -b.y);\\n  float divisor = complexMul(b, bConj).x;\\n  return complexMul(a, bConj) / divisor;\\n}\\n\\n// return e^z\\nvec2 complexPow(vec2 z) {\\n  // e^(re + i * im)\\n  // = e^re * e^(i * im)\\n  return fromPolar(exp(z.x), z.y);\\n}\\n\\n// return w^z\\nvec2 complexPow(vec2 w, float z) {\\n  // w = r * e ^ (i * phi)\\n  // ln(w) = ln(r) + i * phi\\n  // w^z = e^(z * log(w)) = e^(z * (ln(r) + i * (phi))\\n  vec2 wPolar = toPolar(w);\\n  vec2 eExp = z * vec2(log(wPolar.x), wPolar.y);\\n  return complexPow(eExp);\\n}\\n\\n// END ../common/complex.glsl\\n// START ../common/constants.glsl\\nconst float SQRT1_2 = 0.7071067811865476;\\nconst float SQRT1_3 = 0.57735026919;\\nconst float SQRT2 = 1.4142135623730951;\\nconst float SQRT3 = 1.732050807568877;\\n// sqrt(3)/2 = sin(60*)\\nconst float SQRT3_2 = 0.86602540378;\\nconst float GOLDEN_RATIO = 1.61803398875;\\nconst float PI = 3.141592653589793;\\nconst float TAU = 6.28318530718;\\n/**\\n * One degree in radians. Use like `sin(30 * DEG)`.\\n */\\nconst float DEGREE = 0.017453292519943295;\\n\\n// END ../common/constants.glsl\\n// START ../common/linstep.glsl\\nfloat linstep(float a, float b, float t) {\\n  return clamp((t - a) / (b - a), 0.0, 1.0);\\n}\\nvec2 linstep(vec2 a, vec2 b, float t) {\\n  return clamp((t - a) / (b - a), 0.0, 1.0);\\n}\\nvec3 linstep(vec3 a, vec3 b, float t) {\\n  return clamp((t - a) / (b - a), 0.0, 1.0);\\n}\\nvec4 linstep(vec4 a, vec4 b, float t) {\\n  return clamp((t - a) / (b - a), 0.0, 1.0);\\n}\\n\\n// END ../common/linstep.glsl\\n// START ../common/matrices.glsl\\n\\nmat2 rot2(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat2(c, s, -s, c);\\n}\\nmat3 rotX(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\\n}\\nmat3 rotY(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\\n}\\nmat3 rotZ(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\\n}\\n/**\\n * Returns a matrix that puts the camera at the eye point `ex, ey, ez` looking\\n * toward the center point `cx, cy, cz` with an up direction of `ux, uy, uz`.\\n * This emulates the OpenGL function `gluLookAt()`.\\n */\\nmat4 lookAt(vec3 eye, vec3 focus, vec3 up) {\\n  vec3 f = normalize(eye - focus);\\n  vec3 s = normalize(cross(up, f));\\n  vec3 t = normalize(cross(f, s));\\n\\n  return mat4(\\n    vec4(s.x, t.x, f.x, 0.0),\\n    vec4(s.y, t.y, f.y, 0.0),\\n    vec4(s.z, t.z, f.z, 0.0),\\n    vec4(-dot(s, eye), -dot(t, eye), -dot(f, eye), 1)\\n  );\\n}\\n\\n// the OpenGL function `glFrustum()`.\\nmat4 frustum(\\n  float left,\\n  float right,\\n  float bottom,\\n  float top,\\n  float near,\\n  float far\\n) {\\n  return mat4(\\n    vec4(2.0 * near / (right - left), 0.0, 0.0, 0.0),\\n    vec4(0, 2.0 * near / (top - bottom), 0.0, 0.0),\\n    vec4(\\n      (right + left) / (right - left),\\n      (top + bottom) / (top - bottom),\\n      -(far + near) / (far - near),\\n      -1\\n    ),\\n    vec4(0.0, 0.0, -2.0 * far * near / (far - near), 0.0)\\n  );\\n}\\n\\nmat4 perspective(float fovDegrees, float aspect, float near, float far) {\\n  float y = tan(fovDegrees * DEGREE / 2.0) * near;\\n  float x = y * aspect;\\n  return frustum(-x, x, -y, y, near, far);\\n}\\nmat4 ortho(\\n  float left,\\n  float right,\\n  float bottom,\\n  float top,\\n  float near,\\n  float far\\n) {\\n  return mat4(\\n    vec4(2.0 / (right - left), 0.0, 0.0, 0.0),\\n    vec4(0.0, 2.0 / (top - bottom), 0.0, 0.0),\\n    vec4(0.0, 0.0, -2.0 / (far - near), 0.0),\\n    vec4(\\n      -(right + left) / (right - left),\\n      -(top + bottom) / (top - bottom),\\n      -(far + near) / (far - near),\\n      1.0\\n    )\\n  );\\n}\\n\\n// END ../common/matrices.glsl\\n// START ../common/max3.glsl\\nfloat max3(float a, float b, float c) {\\n  return max(a, max(b, c));\\n}\\nfloat max3(vec3 v) {\\n  return max(v.x, max(v.y, v.z));\\n}\\n\\n// #pragma glslify: export(max3)\\n\\n\\n// END ../common/max3.glsl\\n// START ../common/min3.glsl\\nfloat min3(float a, float b, float c) {\\n  return min(a, min(b, c));\\n}\\nfloat min3(vec3 v) {\\n  return min(v.x, min(v.y, v.z));\\n}\\n\\n// #pragma glslify: export(min3)\\n\\n\\n// END ../common/min3.glsl\\n// START ../common/sdf2d/sdArcRect.glsl\\n\\n/**\\n * 2D signed distance function to an arc with square ends. The opening of the\\n * arc is on the left (negative X direction). The total spanned angle is\\n * `2 * halfAngle`.\\n *\\n * `radius` is the center radius of the arc.\\n *\\n * `width.x` is the thickness of the arc.\\n *\\n * `width.y` is how much the flat end of the arc is extructed. This is a\\n * parameter as is it trivial to add with the current implementation. Set to 0\\n * to just have a flat-ended arc.\\n */\\nfloat sdArcRect(float halfAngle, float radius, vec2 width, vec2 p) {\\n  // Symmetric across x axis; all points on top.\\n  p.y = abs(p.y);\\n  // Rotate so that the end of the arc is at the x axis.\\n  p = rot2(-halfAngle) * p;\\n  if (p.y > 0.0) {\\n    // p is \\\"above the end of the arc\\\"; calculate as for sdRectangle.\\n    p.x = abs(p.x - radius);\\n    p -= 0.5 * width;\\n    return length(max(p, 0.0)) + min(0.0, max(p.x, p.y));\\n  } else {\\n    // Otherwise, the distance is basically just the radial distance to the arc.\\n    // For the inside of the sdf, we have to take the end into account.\\n    return max(abs(length(p) - radius) - 0.5 * width.x, p.y - 0.5 * width.y);\\n  }\\n}\\n\\n// END ../common/sdf2d/sdArcRect.glsl\\n// START ../common/sdf2d/sdRectangle.glsl\\nfloat sdRectangle(vec2 dim, vec2 p) {\\n  vec2 d = abs(p) - 0.5 * dim;\\n  return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\\n}\\n\\nfloat sdRectangle(float width, float height, vec2 p) {\\n  return sdRectangle(vec2(width, height), p);\\n}\\n\\n\\n// END ../common/sdf2d/sdRectangle.glsl\\n// START ../common/sdf2d/sdGear.glsl\\n// START ../dot2.glsl\\nfloat dot2(vec3 x) {\\n  return dot(x, x);\\n}\\nfloat dot2(vec2 x) {\\n  return dot(x, x);\\n}\\n\\n// END ../dot2.glsl\\n// START ./addFillet.glsl\\nfloat addFillet(float r, float a, float b) {\\n  if (a < r && b < r) {\\n    return r - distance(vec2(a, b), vec2(r));\\n  } else {\\n    return min(a, b);\\n  }\\n}\\n\\n// #pragma glslify: export(addFillet)\\n\\n\\n// END ./addFillet.glsl\\n\\n/**\\n * SDF of one side of an invlute gear tooth. It starts at (baseRadius,0)\\n * perpendicular to x-axis and goes right/up.\\n *\\n * Oq and qp are perpendicular.`|q| = 1` Calc |qp| with pythagoras.\\n *\\n * ```\\n * |__\\n * |  \\\\_q\\n * |___|_________\\n * O\\n *         p\\n * ```\\n */\\nfloat sdInvolute(float baseRadius, vec2 p) {\\n  if (p.x < baseRadius) {\\n    return -p.y;\\n  } else {\\n    float qpLength = sqrt(dot2(p) - baseRadius * baseRadius);\\n    float qopAngle = acos(baseRadius / length(p));\\n    float pAngle = atan(p.y, p.x);\\n    float qAngle = qopAngle + pAngle;\\n    float d = qpLength - qAngle * baseRadius;\\n    return d;\\n  }\\n}\\nvec2 opRotSym(float n, vec2 p) {\\n  vec2 polar = toPolar(p);\\n  float f = TAU / n;\\n  polar.y = (fract(polar.y / f + 0.5) - 0.5) * f;\\n  p = fromPolar(polar);\\n  return p;\\n}\\n/**\\n * 2D signed distance function (SDF) of an (external) involute gear. The gear is\\n * centered at origin and has `n` teeth.\\n *\\n * Involute gear primer: The \\\"pitch\\\" circle/radius is where two gears touch each\\n * other. The circular pitch is the distance, along the pitch circle, between\\n * two teeth. `pitchRadius = (float(n) * circularPitch) / TAU`\\n *\\n * For two gears to be compatible they need to have the same pressure angle and\\n * circular pitch.\\n *\\n * The base circle/radius is the circle from which the involute tooth profile is\\n * constructed. `baseRadius = cos(pressureAngle) * pitchRadius`.\\n *\\n * The teeth profiles go from \\\"dedendum circle\\\" (see code) to \\\"addendum circle\\\".\\n * The difference between dedendum circle and base circle is filled by a fillet.\\n *\\n * See also http://faculty.mercer.edu/jenkins_he/documents/Gears2R1.pdf\\n */\\nfloat sdGear(int n, float pressureAngle, float circularPitch, vec2 p) {\\n  float pitchRadius = float(n) * circularPitch / TAU;\\n  float baseRadius = cos(pressureAngle) * pitchRadius;\\n\\n  float addendumRadius = pitchRadius + 1.0 / PI * circularPitch;\\n  float d3 = length(p) - addendumRadius;\\n  if (d3 > 0.1) {\\n    return d3;\\n  }\\n  float dedendumRadius = pitchRadius - 1.25 / PI * circularPitch;\\n  float d2 = length(p) - dedendumRadius;\\n  if (d2 < -0.1) {\\n    return d2;\\n  }\\n  p = opRotSym(float(n), p);\\n  //  float d = distance(vec2(1, 0.1), p) - 0.1;\\n  p.y = abs(p.y);\\n  vec2 polar = toPolar(p);\\n  float f = TAU / float(n);\\n  polar.y = (fract(polar.y / f + 0.5) - 0.5) * f;\\n  polar.y -= 1.3 / float(n);\\n  float d = sdInvolute(baseRadius, fromPolar(polar));\\n\\n  return max(addFillet(baseRadius - dedendumRadius, d, d2), d3);\\n}\\n\\n/**\\n * See sdGear. Not quite `-sdGear`, as the dedendum and addendum radii are\\n * reversed to avoid intersections.\\n */\\nfloat sdGearInternal(int n, float pressureAngle, float circularPitch, vec2 p) {\\n  float pitchRadius = float(n) * circularPitch / TAU;\\n  float baseRadius = cos(pressureAngle) * pitchRadius;\\n\\n  float addendumRadius = pitchRadius - 1.0 / PI * circularPitch;\\n  float d3 = -(length(p) - addendumRadius);\\n  if (d3 > 0.1) {\\n    return d3;\\n  }\\n  float dedendumRadius = pitchRadius + 1.25 / PI * circularPitch;\\n  float d2 = -(length(p) - dedendumRadius);\\n  if (d2 < -0.1) {\\n    return d2;\\n  }\\n  p = opRotSym(float(n), p);\\n  //  float d = distance(vec2(1, 0.1), p) - 0.1;\\n  p.y = abs(p.y);\\n  vec2 polar = toPolar(p);\\n  float f = TAU / float(n);\\n  polar.y = (fract(polar.y / f + 0.5) - 0.5) * f;\\n  polar.y -= 1.0 / 1.3 / float(n);\\n  float d = -sdInvolute(baseRadius, fromPolar(polar));\\n\\n  return max(min(d, d2), d3);\\n}\\n\\n// END ../common/sdf2d/sdGear.glsl\\n// START ../common/sdf3d/opRepLim.glsl\\nvec3 opRepLim(vec3 p, vec3 cellSize, vec3 limit) {\\n  return p - cellSize * clamp(round(p / cellSize), vec3(0.0), limit);\\n}\\nvec2 opRepLim(vec2 p, vec2 cellSize, vec2 limit) {\\n  return p - cellSize * clamp(round(p / cellSize), vec2(0.0), limit);\\n}\\nfloat opRepLim(float p, float cellSize, float limit) {\\n  return p - cellSize * clamp(round(p / cellSize), 0.0, limit);\\n}\\n\\n// #pragma glslify: export(opRepLim)\\n\\n\\n// END ../common/sdf3d/opRepLim.glsl\\n// START ../common/sdf3d/sdArrow.glsl\\n// START ./sdCylinder.glsl\\nfloat sdCylinder(float radius, float z, vec3 p) {\\n  vec2 d = vec2(length(p.xy), abs(p.z)) - vec2(radius, z);\\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\\n}\\n\\n// #pragma glslify: export(sdCylinder)\\n\\n\\n// END ./sdCylinder.glsl\\n// START ./sdCone.glsl\\n\\n/**\\n * Signed distance function (SDF) of a cone. The tip of the cone is at the\\n * origin and points towards +Z. q is a point on the rim of the cone.\\n */\\nfloat sdCone(vec2 c, float h, vec3 p) {\\n  vec2 q = h * vec2(c.x / c.y, -1.0);\\n  vec2 w = vec2(length(p.xz), p.y);\\n  vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);\\n  vec2 b = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0);\\n  float k = sign(q.y);\\n  float d = min(dot(a, a), dot(b, b));\\n  float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));\\n  return sqrt(d) * sign(s);\\n}\\n// #pragma glslify: export(sdBox)\\n\\nfloat sdConeB(vec2 c, float h, vec3 p) {\\n  float q = length(p.xz);\\n  return max(dot(c.xy, vec2(q, p.y)), -h - p.y);\\n}\\n\\n// END ./sdCone.glsl\\nvec3 perpendicularVector(vec3 a) {\\n  return cross(a, abs(a.z) > abs(a.x) ? vec3(0, 0, 1) : vec3(0, 1, 0));\\n}\\n/**\\n * Signed distance function (SDF) of an arrow. The arrow goes along the X axis.\\n * The shaft of the arrow has thickness TODO. The tip of the arrow has 30Â°\\n * angle, length of TODO, with the widest point being.\\n */\\nfloat sdArrow(float length, vec3 p) {\\n  float r = 0.01;\\n  return min(\\n    sdCylinder(\\n      0.02 - r,\\n      0.5 * (length - 0.1) - r,\\n      p.yzx - vec3(0, 0, 0.5 * (length - 0.1))\\n    ) -\\n      r,\\n    sdCone(\\n      vec2(sin(15.0 * DEGREE), cos(15.0 * DEGREE)),\\n      0.15 - r,\\n      p.zxy - vec3(0, length - r, 0)\\n    ) -\\n      r\\n  );\\n}\\nfloat sdArrow(vec3 a, vec3 b, vec3 p) {\\n  vec3 x = normalize(b - a);\\n  vec3 y = normalize(perpendicularVector(x));\\n  vec3 z = cross(x, y);\\n  return sdArrow(length(b - a), inverse(mat3(x, y, z)) * (p - a));\\n}\\n\\n// END ../common/sdf3d/sdArrow.glsl\\n// START ../common/sdf3d/sdBox.glsl\\n\\nfloat sdBox(vec3 r, vec3 p) {\\n  vec3 q = abs(p) - r;\\n  return length(max(q, 0.0)) + min(max3(q), 0.0);\\n}\\n\\nfloat sdBox(vec3 r, float r2, vec3 p) {\\n  return sdBox(r - r2, p) - r2;\\n}\\n\\n// #pragma glslify: export(sdBox)\\n\\n\\n// END ../common/sdf3d/sdBox.glsl\\n// START ../common/sdf3d/sdTorus.glsl\\nfloat sdTorus(float r0, float r1, vec3 p) {\\n  vec3 closestCenter = vec3(normalize(p.xy) * r0, 0.0);\\n  return distance(closestCenter, p) - r1;\\n}\\n\\n// #pragma glslify: export(sdTorus)\\n\\n\\n// END ../common/sdf3d/sdTorus.glsl\\n// START ../common/transform.glsl\\nvec3 transform(mat4 pm, vec3 p) {\\n  vec4 pStar = pm * vec4(p, 1);\\n  return pStar.xyz / pStar.w;\\n}\\n\\nvec2 transform(mat4 pm, vec2 p) {\\n  vec4 pStar = pm * vec4(p, 0, 1);\\n  return pStar.xy / pStar.w;\\n}\\n\\n// END ../common/transform.glsl\\n// START ../common/ungamma.glsl\\nvec3 ungamma(vec4 col) {\\n  return pow(col.rgb, vec3(2.2));\\n}\\nvec3 ungamma(vec3 col) {\\n  return pow(col, vec3(2.2));\\n}\\n\\n// END ../common/ungamma.glsl\\n// START ../common/visualize.glsl\\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\\n  float isLow = float(t < 0.0);\\n  float isHigh = float(t > 1.0);\\n  float isMid = 1.0 - isLow - isHigh;\\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\\n}\\n\\nvec4 visualize(float t) {\\n  const vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\\n  const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\\n  return visualize(BLUE, RED, t);\\n}\\n\\n// #pragma glslify: export(visualize)\\n\\n\\n// END ../common/visualize.glsl\\n// START ../sdfs2d/vizz.glsl\\n// START ../common/between.glsl\\nbool between(float min, float max, float value) {\\n  return min <= value && value <= max;\\n}\\n\\n// #pragma glslify: export(between)\\n\\n\\n// END ../common/between.glsl\\n\\nuniform vec4 colorPrimary;\\nuniform vec4 colorSecondary;\\nuniform vec4 colorBackground;\\nuniform vec2 iMouse;\\n\\n// show with square wave\\nvec3 vizz(float val) {\\n  vec3 color0 = ungamma(colorBackground);\\n  vec3 color1 = ungamma(colorPrimary);\\n  vec3 color2 = ungamma(colorSecondary);\\n  vec3 cc = val >= 0.0 ? color1 : color2;\\n  float v = abs(mod(abs(val) - 0.5, 2.0) - 1.0);\\n  const float k = 0.5 * 0.1;\\n  if (between(-0.5, 0.5, val)) {\\n    return mix(color2, color1, smoothstep(-k, +k, val));\\n  }\\n  return mix(cc, color0, smoothstep(-0.5 - k, -0.5 + k, -v));\\n}\\n// #pragma glslify: export(vizz)\\nvec3 vizz(float val, float mouseVal, vec2 fragCoord, vec2 mouse, vec2 iMouse) {\\n  vec3 color = vizz(val);\\n\\n  if (-1.0 != iMouse.x) {\\n    color = mix(\\n      color,\\n      ungamma(BLUE),\\n      smoothstep(-0.2, -0.0, -abs(distance(mouse, fragCoord) - abs(mouseVal)))\\n    );\\n  }\\n\\n  return color;\\n}\\n\\n#define VIZZ(SDF)                                                              \\\\\\n  (vizz(                                                                       \\\\\\n    SDF((coord - 0.5) * iResolution * 0.1),                                    \\\\\\n    SDF((iMouse - 0.5 * iResolution) * 0.1),                                   \\\\\\n    coord * iResolution * 0.1,                                                 \\\\\\n    iMouse * 0.1,                                                              \\\\\\n    iMouse                                                                     \\\\\\n  ))\\n\\n// show with one line at 0\\nvec3 vizz2(float val) {\\n  vec3 color0 = ungamma(colorBackground);\\n  vec3 color1 = ungamma(colorPrimary);\\n  vec3 color2 = ungamma(colorSecondary);\\n  vec3 cc = val >= 0.0 ? color1 : color2;\\n  const float k = 0.1;\\n  vec2 dVal = vec2(dFdx(val), dFdy(val));\\n  return mix(\\n    color0,\\n    color1,\\n    smoothstep(-k, +k, -abs(val / length(dVal)) + 0.8)\\n  );\\n}\\n\\n// END ../sdfs2d/vizz.glsl\\n\\nin float n;\\nin vec2 coord;\\nout vec4 fragColor;\\nuniform float a;\\nuniform float b;\\nuniform float c;\\nuniform float d;\\nuniform float iTime;\\nuniform int bandCount;\\nuniform mat4 viewModel;\\nuniform sampler2D texture;\\nuniform vec2 iResolution;\\n\\nfloat sdf(vec2 p) {\\n  p *= 0.1;\\n  p = complexMul(p, fromPolar(1.0, 20.0 * DEGREE * length(p) * a));\\n\\n  // center rectangle\\n  float d = sdRectangle(vec2(1.0), p);\\n  float scale = 1.0;\\n  for (int i = 0; i < 4; i++) {\\n    p = abs(p);\\n    p = opRepLim(p, vec2(1.0), vec2(1));\\n    p *= 3.0;\\n    scale *= 1.0 / 3.0;\\n    float id = length(p) - 0.5;\\n    //    float id = sdRectangle(vec2(1.0), p);\\n    d = min(d, id * scale);\\n  }\\n  return d * 10.0;\\n}\\n\\nvoid main() {\\n  vec2 fragCoord = transform(viewModel, coord * iResolution);\\n  vec2 tp = (fragCoord - 0.5 * iResolution) * 0.1;\\n  vec3 color = vizz(\\n    sdf(transform(viewModel, (coord - 0.5) * iResolution)),\\n    sdf(transform(viewModel, (iMouse - 0.5) * iResolution)),\\n    transform(viewModel, coord * iResolution),\\n    transform(viewModel, iMouse),\\n    iMouse\\n  );\\n  color = vizz2(sdf(tp));\\n  color = pow(color, vec3(1.0 / 2.2)); // gamma correction\\n  fragColor = vec4(color, 1);\\n}\\n\"\nconst sourceMap = {\"version\":3,\"sources\":[\"/home/runner/work/workshop/workshop/src/noises/mengerSlices.frag\",\"/home/runner/work/workshop/workshop/src/common/banded.glsl\",\"/home/runner/work/workshop/workshop/src/common/checkerboardGrad.glsl\",\"/home/runner/work/workshop/workshop/src/common/colors.glsl\",\"/home/runner/work/workshop/workshop/src/common/unmix.glsl\",\"/home/runner/work/workshop/workshop/src/common/fromPolar.glsl\",\"/home/runner/work/workshop/workshop/src/common/toPolar.glsl\",\"/home/runner/work/workshop/workshop/src/common/polar.glsl\",\"/home/runner/work/workshop/workshop/src/common/complex.glsl\",\"/home/runner/work/workshop/workshop/src/common/constants.glsl\",\"/home/runner/work/workshop/workshop/src/common/linstep.glsl\",\"/home/runner/work/workshop/workshop/src/common/matrices.glsl\",\"/home/runner/work/workshop/workshop/src/common/max3.glsl\",\"/home/runner/work/workshop/workshop/src/common/min3.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf2d/sdArcRect.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf2d/sdRectangle.glsl\",\"/home/runner/work/workshop/workshop/src/common/dot2.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf2d/addFillet.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf2d/sdGear.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/opRepLim.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdCylinder.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdCone.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdArrow.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdBox.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdTorus.glsl\",\"/home/runner/work/workshop/workshop/src/common/transform.glsl\",\"/home/runner/work/workshop/workshop/src/common/ungamma.glsl\",\"/home/runner/work/workshop/workshop/src/common/visualize.glsl\",\"/home/runner/work/workshop/workshop/src/common/between.glsl\",\"/home/runner/work/workshop/workshop/src/sdfs2d/vizz.glsl\"],\"names\":[],\"mappings\":\"AAAA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AC5IA;AACA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AChHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A7BlCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA\"}\nexport { sourceMap };\n","import TextField, { } from \"@mui/material/TextField\"\nimport * as React from \"react\"\n\n\nexport function BoundNumberField({\n  state,\n  prop,\n  setStatePartial,\n  ...props\n}\n\n\n\n) {\n  return (\n    React.createElement(TextField, {\n      variant: \"outlined\",\n      size: \"small\",\n      type: \"number\",\n      value: state[prop],\n      onChange: (e) =>\n        setStatePartial({ [prop]: +e.target.value } )\n      ,\n      label: prop,\n      ...props,}\n    )\n  )\n}\n","var map = {\n\t\"./julia.frag\": 7527,\n\t\"./magic.frag\": 7993,\n\t\"./magic2.frag\": 4169,\n\t\"./mengerSlices.frag\": 939,\n\t\"./simplex.frag\": 9132,\n\t\"./sphereOpenSimplex.frag\": 3039,\n\t\"./test.frag\": 6794,\n\t\"./test2.frag\": 9808,\n\t\"./test3.frag\": 9779,\n\t\"./tree.frag\": 4358\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 1530;","import * as React from \"react\"\n\nimport { arrayRange, DEG, round10, TAU, V3 } from \"ts3dutils\"\nimport { encode, L, M, Z } from \"./svg\"\n\nexport const INCH = 25.4\nexport const fmtdeg = (x) => \"\" + round10(x / DEG, -1) + \"Â°\"\n \n\nexport const radiusFromSideWidth = (sides, sideWidth) =>\n  sideWidth / 2 / Math.sin(TAU / sides / 2)\nexport const sideWithFromRadius = (sides, radius) =>\n  radius * 2 * Math.sin(TAU / sides / 2)\nexport const centerToSideFromSideWidth = (\n  sides,\n  sideWidth,\n) => sideWidth / 2 / Math.tan(TAU / sides / 2)\nexport const radiusFromCenterToSide = (\n  sides,\n  centerToSide,\n) => centerToSide / Math.cos(TAU / sides / 2)\nexport const sideWidthFromCenterToSide = (\n  sides,\n  centerToSide,\n) => centerToSide * 2 * Math.tan(TAU / sides / 2)\n\nexport function RegularPolygon({\n  sides,\n  radius,\n  startAngle = 0,\n  sideLength = undefined,\n  ...props\n}\n\n\n\n\n) {\n  if ((undefined !== sideLength) === (undefined !== radius)) {\n    throw new Error(\"must set either sideLength or radius\")\n  }\n  if (undefined === radius) {\n    radius = radiusFromSideWidth(sides, sideLength)\n  }\n  return (\n    React.createElement('path', {\n      d: encode(\n        M(V3.polar(radius, startAngle)),\n        ...arrayRange(0, sides).map((i) =>\n          L(V3.polar(radius, startAngle + i * (TAU / sides))),\n        ),\n        Z(),\n      ),\n      ...props,}\n    )\n  )\n}\n\nexport function RotStep({\n  id,\n  children,\n  count,\n  stepDeg,\n}\n\n\n\n\n) {\n  return (\n    React.createElement(React.Fragment, null\n      , React.createElement('g', { id: id,}, children)\n      , arrayRange(0, count - 1).map((i) => (\n        React.createElement('g', {\n          id: `${id}-${i}`,\n          key: `${id}-${i}`,\n          transform: `rotate(${(i + 1) * stepDeg} 0 0)`,}\n\n          , children\n        )\n      ))\n    )\n  )\n}\n\nexport const openInNewTab = (url) => {\n  const newWindow = window.open(url, \"_blank\", \"noopener,noreferrer\")\n  if (newWindow) newWindow.opener = null\n}\n","\nexport default \"#version 300 es\\nprecision highp float;\\n\\nin vec4 ts_Vertex;\\nin vec2 ts_TexCoord;\\nout vec2 coord;\\nvoid main() {\\n  gl_Position = ts_Vertex;\\n  coord = ts_TexCoord;\\n}\\n\"\nconst sourceMap = {\"version\":3,\"sources\":[\"/home/runner/work/workshop/workshop/src/common/raymarch.vert\"],\"names\":[],\"mappings\":\"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA\"}\nexport { sourceMap };\n","\nexport default \"#version 300 es\\n\\nprecision highp float;\\n\\n// START ../common/banded.glsl\\nfloat banded(float bandCount, float t) {\\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\\n}\\nfloat banded(int bandCount, float t) {\\n  return banded(float(bandCount), t);\\n}\\n\\n// #pragma glslify: export(banded)\\n\\n\\n// END ../common/banded.glsl\\n// START ../common/matrices.glsl\\n// START ./constants.glsl\\nconst float SQRT1_2 = 0.7071067811865476;\\nconst float SQRT1_3 = 0.57735026919;\\nconst float SQRT2 = 1.4142135623730951;\\nconst float SQRT3 = 1.732050807568877;\\n// sqrt(3)/2 = sin(60*)\\nconst float SQRT3_2 = 0.86602540378;\\nconst float GOLDEN_RATIO = 1.61803398875;\\nconst float PI = 3.141592653589793;\\nconst float TAU = 6.28318530718;\\n/**\\n * One degree in radians. Use like `sin(30 * DEG)`.\\n */\\nconst float DEGREE = 0.017453292519943295;\\n\\n// END ./constants.glsl\\n\\nmat2 rot2(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat2(c, s, -s, c);\\n}\\nmat3 rotX(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\\n}\\nmat3 rotY(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\\n}\\nmat3 rotZ(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\\n}\\n/**\\n * Returns a matrix that puts the camera at the eye point `ex, ey, ez` looking\\n * toward the center point `cx, cy, cz` with an up direction of `ux, uy, uz`.\\n * This emulates the OpenGL function `gluLookAt()`.\\n */\\nmat4 lookAt(vec3 eye, vec3 focus, vec3 up) {\\n  vec3 f = normalize(eye - focus);\\n  vec3 s = normalize(cross(up, f));\\n  vec3 t = normalize(cross(f, s));\\n\\n  return mat4(\\n    vec4(s.x, t.x, f.x, 0.0),\\n    vec4(s.y, t.y, f.y, 0.0),\\n    vec4(s.z, t.z, f.z, 0.0),\\n    vec4(-dot(s, eye), -dot(t, eye), -dot(f, eye), 1)\\n  );\\n}\\n\\n// the OpenGL function `glFrustum()`.\\nmat4 frustum(\\n  float left,\\n  float right,\\n  float bottom,\\n  float top,\\n  float near,\\n  float far\\n) {\\n  return mat4(\\n    vec4(2.0 * near / (right - left), 0.0, 0.0, 0.0),\\n    vec4(0, 2.0 * near / (top - bottom), 0.0, 0.0),\\n    vec4(\\n      (right + left) / (right - left),\\n      (top + bottom) / (top - bottom),\\n      -(far + near) / (far - near),\\n      -1\\n    ),\\n    vec4(0.0, 0.0, -2.0 * far * near / (far - near), 0.0)\\n  );\\n}\\n\\nmat4 perspective(float fovDegrees, float aspect, float near, float far) {\\n  float y = tan(fovDegrees * DEGREE / 2.0) * near;\\n  float x = y * aspect;\\n  return frustum(-x, x, -y, y, near, far);\\n}\\nmat4 ortho(\\n  float left,\\n  float right,\\n  float bottom,\\n  float top,\\n  float near,\\n  float far\\n) {\\n  return mat4(\\n    vec4(2.0 / (right - left), 0.0, 0.0, 0.0),\\n    vec4(0.0, 2.0 / (top - bottom), 0.0, 0.0),\\n    vec4(0.0, 0.0, -2.0 / (far - near), 0.0),\\n    vec4(\\n      -(right + left) / (right - left),\\n      -(top + bottom) / (top - bottom),\\n      -(far + near) / (far - near),\\n      1.0\\n    )\\n  );\\n}\\n\\n// END ../common/matrices.glsl\\n// START ../common/max3.glsl\\nfloat max3(float a, float b, float c) {\\n  return max(a, max(b, c));\\n}\\nfloat max3(vec3 v) {\\n  return max(v.x, max(v.y, v.z));\\n}\\n\\n// #pragma glslify: export(max3)\\n\\n\\n// END ../common/max3.glsl\\n// START ../common/visualize.glsl\\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\\n  float isLow = float(t < 0.0);\\n  float isHigh = float(t > 1.0);\\n  float isMid = 1.0 - isLow - isHigh;\\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\\n}\\n\\nvec4 visualize(float t) {\\n  const vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\\n  const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\\n  return visualize(BLUE, RED, t);\\n}\\n\\n// #pragma glslify: export(visualize)\\n\\n\\n// END ../common/visualize.glsl\\n// START ../common/polar.glsl\\n// START ../common/fromPolar.glsl\\n// START ./unmix.glsl\\nfloat unmix(float a, float b, float value) {\\n  return (value - a) / (b - a);\\n}\\n\\n// #pragma glslify: export(unmix)\\n\\n\\n// END ./unmix.glsl\\n\\nvec3 fromPolar(float radius, float phi, float z) {\\n  return vec3(radius * cos(phi), radius * sin(phi), z);\\n}\\n\\nvec2 fromPolar(float radius, float phi) {\\n  return vec2(radius * cos(phi), radius * sin(phi));\\n}\\n\\nvec2 fromPolar(vec2 polar) {\\n  return fromPolar(polar.x, polar.y);\\n}\\n\\n// #pragma glslify: export(fromPolar)\\n\\n\\n// END ../common/fromPolar.glsl\\n// START ../common/toPolar.glsl\\n\\nvec2 toPolar(vec2 xy) {\\n  return vec2(length(xy), atan(xy.y, xy.x));\\n}\\n\\nmat2 toPolarDerivate(vec2 xy) {\\n  return mat2(xy.x * xy.x, xy.y * xy.y, -xy.y, xy.x) / dot(xy, xy);\\n}\\n\\n// #pragma glslify: export(toPolar)\\n\\n\\n// END ../common/toPolar.glsl\\n\\n// END ../common/polar.glsl\\n// START ../common/ungamma.glsl\\nvec3 ungamma(vec4 col) {\\n  return pow(col.rgb, vec3(2.2));\\n}\\nvec3 ungamma(vec3 col) {\\n  return pow(col, vec3(2.2));\\n}\\n\\n// END ../common/ungamma.glsl\\n// START ../common/transform.glsl\\nvec3 transform(mat4 pm, vec3 p) {\\n  vec4 pStar = pm * vec4(p, 1);\\n  return pStar.xyz / pStar.w;\\n}\\n\\nvec2 transform(mat4 pm, vec2 p) {\\n  vec4 pStar = pm * vec4(p, 0, 1);\\n  return pStar.xy / pStar.w;\\n}\\n\\n// END ../common/transform.glsl\\n// START ../common/OpenSimplex2.glsl\\n//////////////// K.jpg's Re-oriented 4-Point BCC Noise (OpenSimplex2) ////////////////\\n////////////////////// Output: vec4(dF/dx, dF/dy, dF/dz, value) //////////////////////\\n\\n// Inspired by Stefan Gustavson's noise\\nvec4 permute(vec4 t) {\\n  return t * (t * 34.0 + 133.0);\\n}\\n\\n// Gradient set is a normalized expanded rhombic dodecahedron\\nvec3 grad(float hash) {\\n  // Random vertex of a cube, +/- 1 each\\n  vec3 cube = mod(floor(hash / vec3(1.0, 2.0, 4.0)), 2.0) * 2.0 - 1.0;\\n\\n  // Random edge of the three edges connected to that vertex\\n  // Also a cuboctahedral vertex\\n  // And corresponds to the face of its dual, the rhombic dodecahedron\\n  vec3 cuboct = cube;\\n  cuboct[int(hash / 16.0)] = 0.0;\\n\\n  // In a funky way, pick one of the four points on the rhombic face\\n  float type = mod(floor(hash / 8.0), 2.0);\\n  vec3 rhomb = (1.0 - type) * cube + type * (cuboct + cross(cube, cuboct));\\n\\n  // Expand it so that the new edges are the same length\\n  // as the existing ones\\n  vec3 grad = cuboct * 1.22474487139 + rhomb;\\n\\n  // To make all gradients the same length, we only need to shorten the\\n  // second type of vector. We also put in the whole noise scale constant.\\n  // The compiler should reduce it into the existing floats. I think.\\n  grad *= (1.0 - 0.042942436724648037 * type) * 32.80201376986577;\\n\\n  return grad;\\n}\\n\\n// BCC lattice split up into 2 cube lattices\\nvec4 openSimplex2Base(vec3 X) {\\n  // First half-lattice, closest edge\\n  vec3 v1 = round(X);\\n  vec3 d1 = X - v1;\\n  vec3 score1 = abs(d1);\\n  vec3 dir1 = step(max(score1.yzx, score1.zxy), score1);\\n  vec3 v2 = v1 + dir1 * sign(d1);\\n  vec3 d2 = X - v2;\\n\\n  // Second half-lattice, closest edge\\n  vec3 X2 = X + 144.5;\\n  vec3 v3 = round(X2);\\n  vec3 d3 = X2 - v3;\\n  vec3 score2 = abs(d3);\\n  vec3 dir2 = step(max(score2.yzx, score2.zxy), score2);\\n  vec3 v4 = v3 + dir2 * sign(d3);\\n  vec3 d4 = X2 - v4;\\n\\n  // Gradient hashes for the four points, two from each half-lattice\\n  vec4 hashes = permute(mod(vec4(v1.x, v2.x, v3.x, v4.x), 289.0));\\n  hashes = permute(mod(hashes + vec4(v1.y, v2.y, v3.y, v4.y), 289.0));\\n  hashes = mod(\\n    permute(mod(hashes + vec4(v1.z, v2.z, v3.z, v4.z), 289.0)),\\n    48.0\\n  );\\n\\n  // Gradient extrapolations & kernel function\\n  vec4 a = max(\\n    0.5 - vec4(dot(d1, d1), dot(d2, d2), dot(d3, d3), dot(d4, d4)),\\n    0.0\\n  );\\n  vec4 aa = a * a;\\n  vec4 aaaa = aa * aa;\\n  vec3 g1 = grad(hashes.x);\\n  vec3 g2 = grad(hashes.y);\\n  vec3 g3 = grad(hashes.z);\\n  vec3 g4 = grad(hashes.w);\\n  vec4 extrapolations = vec4(\\n    dot(d1, g1),\\n    dot(d2, g2),\\n    dot(d3, g3),\\n    dot(d4, g4)\\n  );\\n\\n  // Derivatives of the noise\\n  vec3 derivative =\\n    -8.0 * mat4x3(d1, d2, d3, d4) * (aa * a * extrapolations) +\\n    mat4x3(g1, g2, g3, g4) * aaaa;\\n\\n  // Return it all as a vec4\\n  return vec4(derivative, dot(aaaa, extrapolations));\\n}\\n\\n// Use this if you don't want Z to look different from X and Y\\nvec4 openSimplex2_Conventional(vec3 X) {\\n  // Rotate around the main diagonal. Not a skew transform.\\n  vec4 result = openSimplex2Base(dot(X, vec3(2.0 / 3.0)) - X);\\n  return vec4(dot(result.xyz, vec3(2.0 / 3.0)) - result.xyz, result.w);\\n}\\n\\n// Use this if you want to show X and Y in a plane, then use Z for time, vertical, etc.\\nvec4 openSimplex2_ImproveXY(vec3 X) {\\n  // Rotate so Z points down the main diagonal. Not a skew transform.\\n  mat3 orthonormalMap = mat3(\\n    vec3(0.788675134594813, -0.211324865405187, -0.577350269189626),\\n    vec3(-0.211324865405187, 0.788675134594813, -0.577350269189626),\\n    vec3(0.577350269189626, 0.577350269189626, 0.577350269189626)\\n  );\\n\\n  vec4 result = openSimplex2Base(orthonormalMap * X);\\n  return vec4(result.xyz * orthonormalMap, result.w);\\n}\\n\\n//////////////////////////////// End noise code ////////////////////////////////\\n\\n\\n// END ../common/OpenSimplex2.glsl\\n// START ../common/checkerboardGrad.glsl\\n//https://iquilezles.org/articles/checkerfiltering/\\nfloat tri(float x) {\\n  float h = fract(x * 0.5) - 0.5;\\n  return 1.0 - 2.0 * abs(h);\\n}\\nvec2 tri(vec2 x) {\\n  vec2 h = fract(x * 0.5) - 0.5;\\n  return 1.0 - 2.0 * abs(h);\\n}\\n\\nfloat checkerboardGrad(vec2 uv) {\\n  vec2 w = max(abs(dFdx(uv)), abs(dFdy(uv))) + 0.01; // filter kernel\\n  vec2 i = (tri(uv + 0.5 * w) - tri(uv - 0.5 * w)) / w; // analytical integral (box filter)\\n  return 0.5 - 0.5 * i.x * i.y; // xor pattern\\n}\\n\\n// END ../common/checkerboardGrad.glsl\\n// START ../common/colors.glsl\\nconst vec3 INDIAN_RED = vec3(0.804, 0.361, 0.361);\\nconst vec3 LIGHT_CORAL = vec3(0.941, 0.502, 0.502);\\nconst vec3 SALMON = vec3(0.98, 0.502, 0.447);\\nconst vec3 DARK_SALMON = vec3(0.914, 0.588, 0.478);\\nconst vec3 LIGHT_SALMON = vec3(1.0, 0.627, 0.478);\\nconst vec3 CRIMSON = vec3(0.863, 0.078, 0.235);\\nconst vec3 RED = vec3(1.0, 0.0, 0.0);\\nconst vec3 FIRE_BRICK = vec3(0.698, 0.133, 0.133);\\nconst vec3 DARK_RED = vec3(0.545, 0.0, 0.0);\\nconst vec3 PINK = vec3(1.0, 0.753, 0.796);\\nconst vec3 LIGHT_PINK = vec3(1.0, 0.714, 0.757);\\nconst vec3 HOT_PINK = vec3(1.0, 0.412, 0.706);\\nconst vec3 DEEP_PINK = vec3(1.0, 0.078, 0.576);\\nconst vec3 MEDIUM_VIOLET_RED = vec3(0.78, 0.082, 0.522);\\nconst vec3 PALE_VIOLET_RED = vec3(0.859, 0.439, 0.576);\\nconst vec3 CORAL = vec3(1.0, 0.498, 0.314);\\nconst vec3 TOMATO = vec3(1.0, 0.388, 0.278);\\nconst vec3 ORANGE_RED = vec3(1.0, 0.271, 0.0);\\nconst vec3 DARK_ORANGE = vec3(1.0, 0.549, 0.0);\\nconst vec3 ORANGE = vec3(1.0, 0.647, 0.0);\\nconst vec3 GOLD = vec3(1.0, 0.843, 0.0);\\nconst vec3 YELLOW = vec3(1.0, 1.0, 0.0);\\nconst vec3 LIGHT_YELLOW = vec3(1.0, 1.0, 0.878);\\nconst vec3 LEMON_CHION = vec3(1.0, 0.98, 0.804);\\nconst vec3 LIGHT_GOLDENROD_YELLOW = vec3(0.98, 0.98, 0.824);\\nconst vec3 PAPAYA_WHIP = vec3(1.0, 0.937, 0.835);\\nconst vec3 MOCCASIN = vec3(1.0, 0.894, 0.71);\\nconst vec3 PEACH_PU = vec3(1.0, 0.855, 0.725);\\nconst vec3 PALE_GOLDENROD = vec3(0.933, 0.91, 0.667);\\nconst vec3 KHAKI = vec3(0.941, 0.902, 0.549);\\nconst vec3 DARK_KHAKI = vec3(0.741, 0.718, 0.42);\\nconst vec3 LAVENDER = vec3(0.902, 0.902, 0.98);\\nconst vec3 THISTLE = vec3(0.847, 0.749, 0.847);\\nconst vec3 PLUM = vec3(0.867, 0.627, 0.867);\\nconst vec3 VIOLET = vec3(0.933, 0.51, 0.933);\\nconst vec3 ORCHID = vec3(0.855, 0.439, 0.839);\\nconst vec3 FUCHSIA = vec3(1.0, 0.0, 1.0);\\nconst vec3 MAGENTA = vec3(1.0, 0.0, 1.0);\\nconst vec3 MEDIUM_ORCHID = vec3(0.729, 0.333, 0.827);\\nconst vec3 MEDIUM_PURPLE = vec3(0.576, 0.439, 0.859);\\nconst vec3 BLUE_VIOLET = vec3(0.541, 0.169, 0.886);\\nconst vec3 DARK_VIOLET = vec3(0.58, 0.0, 0.827);\\nconst vec3 DARK_ORCHID = vec3(0.6, 0.196, 0.8);\\nconst vec3 DARK_MAGENTA = vec3(0.545, 0.0, 0.545);\\nconst vec3 PURPLE = vec3(0.502, 0.0, 0.502);\\nconst vec3 INDIGO = vec3(0.294, 0.0, 0.51);\\nconst vec3 SLATE_BLUE = vec3(0.416, 0.353, 0.804);\\nconst vec3 DARK_SLATE_BLUE = vec3(0.282, 0.239, 0.545);\\nconst vec3 GREEN_YELLOW = vec3(0.678, 1.0, 0.184);\\nconst vec3 CHARTREUSE = vec3(0.498, 1.0, 0.0);\\nconst vec3 LAWN_GREEN = vec3(0.486, 0.988, 0.0);\\nconst vec3 LIME = vec3(0.0, 1.0, 0.0);\\nconst vec3 LIME_GREEN = vec3(0.196, 0.804, 0.196);\\nconst vec3 PALE_GREEN = vec3(0.596, 0.984, 0.596);\\nconst vec3 LIGHT_GREEN = vec3(0.565, 0.933, 0.565);\\nconst vec3 MEDIUM_SPRING_GREEN = vec3(0.0, 0.98, 0.604);\\nconst vec3 SPRING_GREEN = vec3(0.0, 1.0, 0.498);\\nconst vec3 MEDIUM_SEA_GREEN = vec3(0.235, 0.702, 0.443);\\nconst vec3 SEA_GREEN = vec3(0.18, 0.545, 0.341);\\nconst vec3 FOREST_GREEN = vec3(0.133, 0.545, 0.133);\\nconst vec3 GREEN = vec3(0.0, 0.502, 0.0);\\nconst vec3 DARK_GREEN = vec3(0.0, 0.392, 0.0);\\nconst vec3 YELLOW_GREEN = vec3(0.604, 0.804, 0.196);\\nconst vec3 OLIVE_DRAB = vec3(0.42, 0.557, 0.137);\\nconst vec3 OLIVE = vec3(0.502, 0.502, 0.0);\\nconst vec3 DARK_OLIVE_GREEN = vec3(0.333, 0.42, 0.184);\\nconst vec3 MEDIUM_AQUAMARINE = vec3(0.4, 0.804, 0.667);\\nconst vec3 DARK_SEA_GREEN = vec3(0.561, 0.737, 0.561);\\nconst vec3 LIGHT_SEA_GREEN = vec3(0.125, 0.698, 0.667);\\nconst vec3 DARK_CYAN = vec3(0.0, 0.545, 0.545);\\nconst vec3 TEAL = vec3(0.0, 0.502, 0.502);\\nconst vec3 AQUA = vec3(0.0, 1.0, 1.0);\\nconst vec3 CYAN = vec3(0.0, 1.0, 1.0);\\nconst vec3 LIGHT_CYAN = vec3(0.878, 1.0, 1.0);\\nconst vec3 PALE_TURQUOISE = vec3(0.686, 0.933, 0.933);\\nconst vec3 AQUAMARINE = vec3(0.498, 1.0, 0.831);\\nconst vec3 TURQUOISE = vec3(0.251, 0.878, 0.816);\\nconst vec3 MEDIUM_TURQUOISE = vec3(0.282, 0.82, 0.8);\\nconst vec3 DARK_TURQUOISE = vec3(0.0, 0.808, 0.82);\\nconst vec3 CADET_BLUE = vec3(0.373, 0.62, 0.627);\\nconst vec3 STEEL_BLUE = vec3(0.275, 0.51, 0.706);\\nconst vec3 LIGHT_STEEL_BLUE = vec3(0.69, 0.769, 0.871);\\nconst vec3 POWDER_BLUE = vec3(0.69, 0.878, 0.902);\\nconst vec3 LIGHT_BLUE = vec3(0.678, 0.847, 0.902);\\nconst vec3 SKY_BLUE = vec3(0.529, 0.808, 0.922);\\nconst vec3 LIGHT_SKY_BLUE = vec3(0.529, 0.808, 0.98);\\nconst vec3 DEEP_SKY_BLUE = vec3(0.0, 0.749, 1.0);\\nconst vec3 DODGER_BLUE = vec3(0.118, 0.565, 1.0);\\nconst vec3 CORNLOWER_BLUE = vec3(0.392, 0.584, 0.929);\\nconst vec3 MEDIUM_SLATE_BLUE = vec3(0.482, 0.408, 0.933);\\nconst vec3 ROYAL_BLUE = vec3(0.255, 0.412, 0.882);\\nconst vec3 BLUE = vec3(0.0, 0.0, 1.0);\\nconst vec3 MEDIUM_BLUE = vec3(0.0, 0.0, 0.804);\\nconst vec3 DARK_BLUE = vec3(0.0, 0.0, 0.545);\\nconst vec3 NAVY = vec3(0.0, 0.0, 0.502);\\nconst vec3 MIDNIGHT_BLUE = vec3(0.098, 0.098, 0.439);\\nconst vec3 CORNSILK = vec3(1.0, 0.973, 0.863);\\nconst vec3 BLANCHED_ALMOND = vec3(1.0, 0.922, 0.804);\\nconst vec3 BISQUE = vec3(1.0, 0.894, 0.769);\\nconst vec3 NAVAJO_WHITE = vec3(1.0, 0.871, 0.678);\\nconst vec3 WHEAT = vec3(0.961, 0.871, 0.702);\\nconst vec3 BURLY_WOOD = vec3(0.871, 0.722, 0.529);\\nconst vec3 TAN = vec3(0.824, 0.706, 0.549);\\nconst vec3 ROSY_BROWN = vec3(0.737, 0.561, 0.561);\\nconst vec3 SANDY_BROWN = vec3(0.957, 0.643, 0.376);\\nconst vec3 GOLDENROD = vec3(0.855, 0.647, 0.125);\\nconst vec3 DARK_GOLDENROD = vec3(0.722, 0.525, 0.043);\\nconst vec3 PERU = vec3(0.804, 0.522, 0.247);\\nconst vec3 CHOCOLATE = vec3(0.824, 0.412, 0.118);\\nconst vec3 SADDLE_BROWN = vec3(0.545, 0.271, 0.075);\\nconst vec3 SIENNA = vec3(0.627, 0.322, 0.176);\\nconst vec3 BROWN = vec3(0.647, 0.165, 0.165);\\nconst vec3 MAROON = vec3(0.502, 0.0, 0.0);\\nconst vec3 WHITE = vec3(1.0, 1.0, 1.0);\\nconst vec3 SNOW = vec3(1.0, 0.98, 0.98);\\nconst vec3 HONEYDEW = vec3(0.941, 1.0, 0.941);\\nconst vec3 MINT_CREAM = vec3(0.961, 1.0, 0.98);\\nconst vec3 AZURE = vec3(0.941, 1.0, 1.0);\\nconst vec3 ALICE_BLUE = vec3(0.941, 0.973, 1.0);\\nconst vec3 GHOST_WHITE = vec3(0.973, 0.973, 1.0);\\nconst vec3 WHITE_SMOKE = vec3(0.961, 0.961, 0.961);\\nconst vec3 SEASHELL = vec3(1.0, 0.961, 0.933);\\nconst vec3 BEIGE = vec3(0.961, 0.961, 0.863);\\nconst vec3 OLD_LACE = vec3(0.992, 0.961, 0.902);\\nconst vec3 FLORAL_WHITE = vec3(1.0, 0.98, 0.941);\\nconst vec3 IVORY = vec3(1.0, 1.0, 0.941);\\nconst vec3 ANTIQUE_WHITE = vec3(0.98, 0.922, 0.843);\\nconst vec3 LINEN = vec3(0.98, 0.941, 0.902);\\nconst vec3 LAVENDER_BLUSH = vec3(1.0, 0.941, 0.961);\\nconst vec3 MISTY_ROSE = vec3(1.0, 0.894, 0.882);\\nconst vec3 GAINSBORO = vec3(0.863, 0.863, 0.863);\\nconst vec3 LIGHT_GREY = vec3(0.827, 0.827, 0.827);\\nconst vec3 SILVER = vec3(0.753, 0.753, 0.753);\\nconst vec3 DARK_GRAY = vec3(0.663, 0.663, 0.663);\\nconst vec3 GRAY = vec3(0.502, 0.502, 0.502);\\nconst vec3 DIM_GRAY = vec3(0.412, 0.412, 0.412);\\nconst vec3 LIGHT_SLATE_GRAY = vec3(0.467, 0.533, 0.6);\\nconst vec3 SLATE_GRAY = vec3(0.439, 0.502, 0.565);\\nconst vec3 DARK_SLATE_GRAY = vec3(0.184, 0.31, 0.31);\\nconst vec3 BLACK = vec3(0.0, 0.0, 0.0);\\n\\n// END ../common/colors.glsl\\n// START ../common/sdf3d/sdIcosahedron.glsl\\n\\n// signed distance function for icosahedron\\n// cf. https://en.wikipedia.org/wiki/Regular_icosahedron\\n// s: edge length\\n// p: point to evaluate function for\\nfloat sdIcosahedron(float s, vec3 p) {\\n  // NN = 1/GOLDEN_RATIO = GOLDEN_RATIO - 1\\n  const float K = GOLDEN_RATIO * 0.5;\\n  // the three vertices of the icosahedron triangle which\\n  // is fully inside the +++ octant. (edge length = 1)\\n  const vec3 a = vec3(0.5, K, 0.0);\\n  const vec3 b = vec3(0.0, 0.5, K);\\n  const vec3 c = vec3(K, 0.0, 0.5);\\n  const vec3 ab1 = b - a; // values chosen so edge length is 1\\n  const vec3 n1 = normalize(cross(a, b));\\n  const vec3 n2 = normalize(cross(b, c));\\n  const vec3 n3 = normalize(cross(c, a));\\n  const vec3 xyz1 = normalize(vec3(1.0));\\n  // for edge-length 1\\n  const float INSCRIBED_SPHERE_RADIUS = 0.7557613141;\\n\\n  // we use a rotation where the icosahedron is symmetric\\n  // in all three coordinate planes, and reduce the problem\\n  // to the +++ octant\\n  p = abs(p);\\n\\n  // there is one complete triangle in the +++ octant\\n  // mirror on planes which go through origin and the\\n  // complete triangles sides.\\n  if (dot(p, n1) < 0.0) {\\n    p += -2.0 * dot(p, n1) * n1;\\n  }\\n  if (dot(p, n2) < 0.0) {\\n    p += -2.0 * dot(p, n2) * n2;\\n  }\\n  if (dot(p, n3) < 0.0) {\\n    p += -2.0 * dot(p, n3) * n3;\\n  }\\n\\n  // rotate space around (1,1,1) vector so that all sides of the triangle\\n  // end up mapped on the ab side.\\n  vec3 dirs = vec3(-dot(n1, p), -dot(n2, p), -dot(n3, p));\\n  if (dirs.y > dirs.x && dirs.y > dirs.z) {\\n    p = p.yzx;\\n  } else if (dirs.z > dirs.x && dirs.z > dirs.y) {\\n    p = p.zxy;\\n  }\\n\\n  // check if the point is directly (perpendicular) above the triangle.\\n  // as we have rotated the space, we only need to check if it is\\n  // inside one edge.\\n  vec3 midAB = (a + b) / 2.0;\\n  vec3 pn = normalize(c - midAB);\\n  float w = dot(midAB, pn);\\n  if (dot(p, pn) > w * s) {\\n    // if not, return the distance to the plane the triangle is in\\n    return dot(xyz1, p) - INSCRIBED_SPHERE_RADIUS * s;\\n  }\\n\\n  // project the point onto segment ab, and return the distance to it\\n  float d3 = dot(ab1, p);\\n  d3 = clamp(d3, -0.5 * s, 0.5 * s);\\n  vec3 closestp = midAB * s + d3 * ab1;\\n  return distance(closestp, p);\\n}\\n// #pragma glslify: export(sdIcosahedron)\\n\\n// END ../common/sdf3d/sdIcosahedron.glsl\\n// START ../common/sdf3d/sdDodecahedron.glsl\\n\\nfloat sdDodecahedron(float s, vec3 p, out vec3 color) {\\n  const float PHI = GOLDEN_RATIO;\\n  color = vec3(0.2);\\n  if (p != abs(p)) {\\n    p = abs(p);\\n    if (color == vec3(0.2)) color = RED;\\n  }\\n  p = abs(p);\\n  const vec3 fv =\\n    vec3(1.0 / PHI, 0, PHI) + 2.0 * vec3(1, 0, 1) + 2.0 * vec3(PHI, 0, 0);\\n  const vec3 fv2 =\\n    vec3(PHI, 1.0 / PHI, 0) + 2.0 * vec3(1, 1, 0) + 2.0 * vec3(0, PHI, 0);\\n  const vec3 fv3 =\\n    vec3(0, PHI, 1.0 / PHI) + 2.0 * vec3(0, 1, 1) + 2.0 * vec3(0, 0, PHI);\\n  return max3(\\n    dot(normalize(fv), p),\\n    dot(normalize(fv2), p),\\n    dot(normalize(fv3), p)\\n  ) -\\n  s;\\n  //  float m = p.x + p.y + p.z - s;\\n  //  vec3 q;\\n  //  if (3.0 * p.x < m) q = p.xyz;\\n  //  else if (3.0 * p.y < m) q = p.yzx;\\n  //  else if (3.0 * p.z < m) q = p.zxy;\\n  //  else return m * 0.57735027;\\n  //\\n  //  float k = clamp(0.5 * (q.z - q.y + s), 0.0, s);\\n  //  return length(vec3(q.x, q.y - s + k, q.z - k));\\n}\\nfloat sdDodecahedron(float s, vec3 p) {\\n  vec3 c;\\n  return sdDodecahedron(s, p, c);\\n}\\n\\n// END ../common/sdf3d/sdDodecahedron.glsl\\n// START ../common/sdf3d/sdLego.glsl\\n// START ./sdCylinder.glsl\\nfloat sdCylinder(float radius, float z, vec3 p) {\\n  vec2 d = vec2(length(p.xy), abs(p.z)) - vec2(radius, z);\\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\\n}\\n\\n// #pragma glslify: export(sdCylinder)\\n\\n\\n// END ./sdCylinder.glsl\\n// START ./sdTube.glsl\\nfloat sdTube(float radius, float r2, float z, vec3 p) {\\n  vec2 d = vec2(length(p.xy), abs(p.z)) - vec2(radius, z);\\n  d.x = abs(d.x) - r2;\\n  vec2 closest = vec2(abs(d.x - radius) - r2, clamp(d.y, 0.0, z));\\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\\n}\\n\\n// END ./sdTube.glsl\\n// START ./sdBox.glsl\\n\\nfloat sdBox(vec3 r, vec3 p) {\\n  vec3 q = abs(p) - r;\\n  return length(max(q, 0.0)) + min(max3(q), 0.0);\\n}\\n\\nfloat sdBox(vec3 r, float r2, vec3 p) {\\n  return sdBox(r - r2, p) - r2;\\n}\\n\\n// #pragma glslify: export(sdBox)\\n\\n\\n// END ./sdBox.glsl\\n\\nfloat sdLego(vec3 p) {\\n  const float IWALLT = 0.04;\\n  p.xy = abs(p.xy);\\n  vec2 c = vec2(4.0, 2.0);\\n  //    p.xy = mod(p.xy + c * 0.5, c) - c * 0.5;\\n  p -= vec3(0.0, 0.0, 0.6);\\n  float d;\\n  const float cr = 0.02;\\n  d = sdBox(vec3(2.0, 1.0, 0.6), cr, p);\\n  if (d > 0.5) {\\n    return d;\\n  }\\n  //    top studs\\n  vec3 p8 = vec3(abs(p.xy - vec2(1.0, 0.0)), p.z) - vec3(0.5, 0.5, 0.6);\\n  float dStuds = sdCylinder(0.35 - 0.04, 0.2, p8) - 0.04;\\n  d = min(d, dStuds);\\n  // little holes in bottom of studs\\n  float dStudHoles = sdCylinder(0.2 - 0.04, 0.3, p8 - vec3(0, 0, -0.4)) - 0.04;\\n  d = max(d, -dStudHoles);\\n  // TODO use sdf texture to add LEGO or custom logo to studs\\n\\n  // hole in the bottom\\n  const float WALLT = 4.0 * IWALLT;\\n  float dBottom = sdBox(\\n    vec3(2.0 - WALLT, 1.0 - WALLT, 0.6),\\n    p - vec3(0, 0, -WALLT)\\n  );\\n  d = max(d, -dBottom);\\n\\n  // 12 indentations on inside.\\n  vec3 pa = p;\\n  // 3. move by 1 in X dir\\n  pa.x -= 1.0;\\n  // 2. mirror across XY axis\\n  if (pa.x > pa.y) pa.xy = pa.yx;\\n  // 1. mirror across Y axis\\n  pa.x = abs(pa.x);\\n  float k = sdBox(vec3(0.5 * IWALLT, 0.05, 0.6), pa - vec3(0.5, 0.8, 0));\\n  d = min(d, k);\\n\\n  // center bar\\n  p = vec3(abs(p.xy), p.z);\\n  d = min(d, sdBox(vec3(0.5 * IWALLT, 0.3, 0.5), p - vec3(0, 0.65, 0.1)));\\n\\n  // 3 tubes\\n  vec3 pTube = p;\\n  if (pTube.x > 0.5) pTube.x -= 1.0;\\n  pTube.x = abs(pTube.x);\\n  d = min(d, sdTube(0.35 + 0.5 * IWALLT, 0.5 * IWALLT, 0.6, pTube));\\n  return d;\\n}\\n\\n// END ../common/sdf3d/sdLego.glsl\\n// START ../common/sdf3d/sdOctahedron.glsl\\nfloat sdOctahedron(float s, vec3 p) {\\n  p = abs(p);\\n  float m = p.x + p.y + p.z - s;\\n  vec3 q;\\n  if (3.0 * p.x < m) q = p.xyz;\\n  else if (3.0 * p.y < m) q = p.yzx;\\n  else if (3.0 * p.z < m) q = p.zxy;\\n  else return m * 0.57735027;\\n\\n  float k = clamp(0.5 * (q.z - q.y + s), 0.0, s);\\n  return length(vec3(q.x, q.y - s + k, q.z - k));\\n}\\n// #pragma glslify: export(sdOctahedron)\\n\\nfloat sdOctahedron(vec3 p, float s) {\\n  p = abs(p);\\n\\n  float m = p.x + p.y + p.z - s;\\n  //find point on octohedron surf nearest to p\\n  vec3 projPoint = p - vec3(0.333333 * m); //project onto surface plane\\n  //now push projected point, if outside triangle edge, perpendicular to edge, to edge\\n  vec3 toMove = min(projPoint, 0.0); //if projpoint.x<0 move along (1.0,-0.5,-0.5) , etc\\n  float toMoveSum = dot(toMove, vec3(1.0)); //which is basically along (1.5,0,0) then vec3(-0.5)\\n\\n  vec3 movedPoint = projPoint + toMove * vec3(-1.5) + toMoveSum * vec3(0.5); //better to multiply toMove by a matrix (1s diagonal, 0.5 other)?\\n\\n  movedPoint = max(movedPoint, 0.0); //cap x,y,z to 0 then\\n  movedPoint *= s / dot(movedPoint, vec3(1.0)); //scale about 0,0,0\\n\\n  return length(p - movedPoint);\\n}\\n\\n// END ../common/sdf3d/sdOctahedron.glsl\\n// START ../common/sdf3d/sdArrow.glsl\\n// START ./sdCone.glsl\\n\\n/**\\n * Signed distance function (SDF) of a cone. The tip of the cone is at the\\n * origin and points towards +Z. q is a point on the rim of the cone.\\n */\\nfloat sdCone(vec2 c, float h, vec3 p) {\\n  vec2 q = h * vec2(c.x / c.y, -1.0);\\n  vec2 w = vec2(length(p.xz), p.y);\\n  vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);\\n  vec2 b = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0);\\n  float k = sign(q.y);\\n  float d = min(dot(a, a), dot(b, b));\\n  float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));\\n  return sqrt(d) * sign(s);\\n}\\n// #pragma glslify: export(sdBox)\\n\\nfloat sdConeB(vec2 c, float h, vec3 p) {\\n  float q = length(p.xz);\\n  return max(dot(c.xy, vec2(q, p.y)), -h - p.y);\\n}\\n\\n// END ./sdCone.glsl\\nvec3 perpendicularVector(vec3 a) {\\n  return cross(a, abs(a.z) > abs(a.x) ? vec3(0, 0, 1) : vec3(0, 1, 0));\\n}\\n/**\\n * Signed distance function (SDF) of an arrow. The arrow goes along the X axis.\\n * The shaft of the arrow has thickness TODO. The tip of the arrow has 30Â°\\n * angle, length of TODO, with the widest point being.\\n */\\nfloat sdArrow(float length, vec3 p) {\\n  float r = 0.01;\\n  return min(\\n    sdCylinder(\\n      0.02 - r,\\n      0.5 * (length - 0.1) - r,\\n      p.yzx - vec3(0, 0, 0.5 * (length - 0.1))\\n    ) -\\n      r,\\n    sdCone(\\n      vec2(sin(15.0 * DEGREE), cos(15.0 * DEGREE)),\\n      0.15 - r,\\n      p.zxy - vec3(0, length - r, 0)\\n    ) -\\n      r\\n  );\\n}\\nfloat sdArrow(vec3 a, vec3 b, vec3 p) {\\n  vec3 x = normalize(b - a);\\n  vec3 y = normalize(perpendicularVector(x));\\n  vec3 z = cross(x, y);\\n  return sdArrow(length(b - a), inverse(mat3(x, y, z)) * (p - a));\\n}\\n\\n// END ../common/sdf3d/sdArrow.glsl\\n// START ../common/sdf3d/sdTetrahedron.glsl\\n// START ./sdCapsule.glsl\\nfloat sdCapsule(vec3 a, vec3 b, float r, vec3 p) {\\n  vec3 pa = p - a;\\n  vec3 ba = b - a;\\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\\n  return length(pa - ba * h) - r;\\n}\\n// #pragma glslify: export(sdCapsule)\\n\\n// END ./sdCapsule.glsl\\n\\n/**\\n * Signed distance function (SDF) of a tetrahedron centered at the origin with\\n * side length `2s`.\\n *\\n * The corners are at `a/b = (+-1,0,sqrt(1/2))` and `c/d = (0,+-1,-sqrt(1/2))`.\\n *\\n * The side length is `||`\\n *\\n * The outscribed sphere has a radius of `sqrt(3/2)`.\\n *\\n * The inscribed sphere has a radius of `sqrt(1/6)`. This is calculated using\\n * the fact that the triangle defined by `mid(a,b) = (0,0,sqrt(1/2))`, `c` and\\n * `mid(c,d) = (0,0,-sqrt(1/2))` is similar to the triangle `mid(a,b)`, `q`, and\\n * `O`.\\n *\\n * For rounded edges, use TODO.\\n *\\n * ```\\n *           ^ Z\\n *           |(+-1, sqrt(1/2))\\n *          /\\\\_\\n *        /    \\\\.q = closest point to center on face\\n *      /    .   \\\\__> Y\\n *    /            \\\\_\\n *  /________________\\\\_(0,-1,sqrt(1/2))\\n * (0,-1,-sqrt(1/2))\\n * ```\\n */\\nfloat sdTetrahedron(float s, vec3 p) {\\n  const vec3 a = vec3(1, 0, SQRT1_2);\\n  const vec3 b = vec3(-1, 0, SQRT1_2);\\n  const vec3 c = vec3(0, 1, -SQRT1_2);\\n  const vec3 d = vec3(0, -1, -SQRT1_2);\\n  const vec3 midBC = 0.5 * (b + c);\\n  const vec3 mirror = normalize(cross(midBC - d, midBC - a));\\n\\n  // Tetra is symmetric in X and Y axes. RED surface in image.\\n  p.xy = abs(p.xy);\\n  // The part z < 0 is symmetric if we rotate it by 90Â°. BLUE surface in image.\\n  if (p.z < 0.0) {\\n    p = vec3(p.y, p.x, -p.z);\\n  }\\n  // Points below the plane through a, d and mid(b,c) are mirrored through it.\\n  // GREEN surface in image.\\n  p -= 2.0 * mirror * min(dot(p, mirror), 0.0);\\n  // After mirror some points are negative, abs again:\\n  p.xy = abs(p.xy);\\n\\n  // Points are now either above the white surface, or above the positive ab segment.\\n  // We shift the coordinate system so that a is now at the origin.\\n  p -= vec3(1, 0, SQRT1_2) * s;\\n  // Finally, we move points which are directely above the face parallel along\\n  // it to a/origin. We can then calculate the sdf as length(p).\\n  p.x = max(p.x, 0.0);\\n  vec3 midABToC1 = normalize(vec3(0, 1, -SQRT2));\\n\\n  p -= max(dot(midABToC1, p), 0.0) * midABToC1;\\n  return sign(p.z) * length(p);\\n}\\n\\n// Same function but also outputs color for explanation image:\\n//float sdTetrahedron(float s, vec3 p, out vec3 color) {\\n//  //  return distance(vec3(1), p) - 0.2;\\n//  const vec3 a = vec3(0, -1, -SQRT1_2);\\n//  const vec3 b = vec3(0, 1, -SQRT1_2);\\n//  const vec3 c = vec3(1, 0, SQRT1_2);\\n//  const vec3 d = vec3(-1, 0, SQRT1_2);\\n//  const vec3 x = 0.5 * (b + d);\\n//  const vec3 mirror = normalize(cross(x - a, x - c));\\n//\\n//  color = WHITE;\\n//  if (p.xy != abs(p.xy)) {\\n//    p.xy = abs(p.xy);\\n//    if (color == WHITE) color = RED;\\n//  }\\n//  if (p.z < 0.0) {\\n//    p = vec3(p.y, p.x, -p.z);\\n//    if (color == WHITE) color = BLUE;\\n//  }\\n//  if (dot(p, mirror) < 0.0) {\\n//    if (color == WHITE) color = GREEN;\\n//    p -= 2.0 * mirror * min(dot(p, mirror), 0.0);\\n//  }\\n//  p.xy = abs(p.xy);\\n//  p -= vec3(1, 0, SQRT1_2);\\n//  p.x = max(p.x, 0.0);\\n//  vec3 fgh = normalize(vec3(0, 1, -SQRT2));\\n//\\n//  p -= max(dot(fgh, p), 0.0) * fgh;\\n//  return sign(p.z) * length(p);\\n//}\\n\\n\\n// END ../common/sdf3d/sdTetrahedron.glsl\\n\\nuniform sampler2D texture;\\nuniform float iTime;\\nuniform vec4 colorPrimary;\\nuniform vec4 colorSecondary;\\nuniform vec4 colorBackground;\\nuniform float a;\\nuniform float b;\\nuniform float c;\\nuniform float d;\\nuniform int bandCount;\\nuniform vec2 iResolution;\\nuniform vec2 iMouse;\\nin float n;\\nin vec2 coord;\\nout vec4 fragColor;\\n\\n\\nstruct Hit {\\n  float distance;\\n  vec4 color;\\n};\\nHit mixa(Hit a, Hit b, float t) {\\n  return Hit(mix(a.distance, b.distance, t), mix(a.color, b.color, t));\\n}\\nfloat skybox(vec3 p) {\\n  return 32.0 - max3(abs(p));\\n}\\n\\nHit add(Hit a, Hit b) {\\n  //    return a.distance < b.distance\\n  //        ? Hit(a.distance, a.color)\\n  //        : Hit(b.distance, b.color);\\n  return mixa(a, b, float(b.distance < a.distance));\\n}\\n\\nHit addFillet(float r, Hit a, Hit b) {\\n  if (a.distance < r && b.distance < r) {\\n    return Hit(\\n      r - distance(vec2(a.distance, b.distance), vec2(r)),\\n      mix(a.color, b.color, (a.distance - b.distance) / r * 0.5 + 0.5)\\n    );\\n  } else {\\n    return add(a, b);\\n  }\\n}\\n\\nHit addFillet(float r, Hit a, Hit b, vec4 tilletColor) {\\n  if (a.distance < r && b.distance < r) {\\n    return Hit(\\n      r - distance(vec2(a.distance, b.distance), vec2(r)),\\n      tilletColor\\n    );\\n  } else {\\n    return add(a, b);\\n  }\\n}\\nHit addFillet2(float r, Hit a, Hit b) {\\n  float h = smoothstep(-r, r, a.distance - b.distance);\\n  return Hit(\\n    mix(a.distance, b.distance, h) - r * h * (1.0 - h),\\n    mix(a.color, b.color, h)\\n  );\\n}\\n\\nHit neg(Hit a) {\\n  return Hit(-a.distance, a.color);\\n}\\nHit sub(Hit from, Hit what) {\\n  Hit whatNeg = neg(what);\\n  return mixa(from, whatNeg, float(whatNeg.distance > from.distance));\\n}\\n\\nvec3 modv(vec3 v, vec3 dir1, float y) {\\n  float t = dot(v, dir1);\\n  return v - floor(t / y) * y * dir1;\\n}\\nvec3 modRotZ(vec3 p, float count) {\\n  vec2 polarXY = toPolar(p.xy);\\n  return fromPolar(polarXY.x, mod(polarXY.y, TAU / count), p.z);\\n}\\n\\nfloat sin01(float x) {\\n  return 0.5 + 0.5 * sin(x);\\n}\\nfloat cos01(float x) {\\n  return 0.5 + 0.5 * cos(x);\\n}\\n\\nfloat smoothmin(float r, float a, float b) {\\n  float h = smoothstep(-r, r, a - b);\\n  return mix(a, b, h) - r * h * (1.0 - h);\\n}\\n\\nvec2 project(vec2 a, vec2 onto1) {\\n  return onto1 * (dot(a, onto1) / dot(onto1, onto1));\\n}\\n\\nvec3 reject(vec3 a, vec3 b1) {\\n  return a - b1 * dot(a, b1);\\n}\\nHit sdf(vec3 p) {\\n  float f =\\n    0.5 * openSimplex2_Conventional(2.0 * (p - vec3(0.1 * iTime, 0, 1))).w +\\n    0.5;\\n  float scale = 2.0;\\n  float ds = distance(p, vec3(0, 0, 1)) - 1.0 - 0.2 * f;\\n  if (ds > 1.0) {\\n    //    ds *= 0.1;\\n  }\\n  float dg = p.z;\\n  if (ds < dg) {\\n    vec3 color = mix(\\n      ungamma(colorBackground),\\n      ungamma(colorPrimary),\\n      banded(bandCount, unmix(-1.0, 1.0, f))\\n    );\\n    color = ungamma(colorPrimary);\\n    //    vec3 color = vec3(f);\\n\\n    return Hit(ds, vec4(color, 1));\\n  } else {\\n    float f = checkerboardGrad(p.xy);\\n\\n    vec3 color = mix(ungamma(colorBackground), ungamma(colorSecondary), f);\\n    return Hit(dg, vec4(color, 1));\\n  }\\n}\\nfloat sdff(vec3 p) {\\n  return sdf(p).distance;\\n}\\nfloat ambientOcclusion(vec3 pWC, vec3 n1WC) {\\n  float k = 1.0;\\n  float distance = sdff(pWC + n1WC * k);\\n  return clamp(distance / k, 0.0, 1.0);\\n}\\n\\nstruct RMResult {\\n  float distance;\\n  vec3 pos;\\n  vec4 color;\\n};\\nRMResult raymarching2(vec3 start, vec3 dir1) {\\n  vec3 pos = start;\\n  Hit hit;\\n  for (int i = 0; i < 200; i++) {\\n    hit = sdf(pos);\\n    if (hit.distance < 0.0001 * hit.distance) break;\\n    pos = pos + dir1 * hit.distance;\\n  }\\n  return RMResult(hit.distance, pos, hit.color);\\n}\\n\\nfloat softshadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {\\n  float res = 1.0;\\n  float t = 0.1;\\n  for (int i = 0; i < 1000 && t < maxt; i++) {\\n    float h = sdff(ro + rd * t);\\n    if (h < 0.001) return 0.0;\\n    res = min(res, k * h / t);\\n    t += h;\\n  }\\n  return res;\\n}\\n\\nconst float eps = 1e-4;\\nvec3 sdfNormal1(vec3 p, float d) {\\n  return normalize(\\n    vec3(\\n      sdff(p + vec3(eps, 0.0, 0.0)),\\n      sdff(p + vec3(0.0, eps, 0.0)),\\n      sdff(p + vec3(0.0, 0.0, eps))\\n    ) -\\n      vec3(sdff(p))\\n  );\\n}\\n\\n//layout (depth_greater) out float gl_FragDepth;\\nvoid main() {\\n  vec3 camPos =\\n    vec3(20, 0, 10) +\\n    (-1.0 == iMouse.x\\n      ? vec3(0)\\n      : vec3(0, (iMouse / iResolution * 2.0 - 1.0) * 10.0));\\n  mat4 modelView =\\n    perspective(10.0, iResolution.x / iResolution.y, 0.1, 20.0) *\\n    lookAt(camPos, vec3(0, 0, 1), vec3(0, 0, 1));\\n  mat4 modelViewInverse = inverse(modelView);\\n\\n  vec3 light = normalize(vec3(-1.0, -2.0, -2));\\n\\n  vec3 a = vec3(coord * 2.0 - 1.0, -1.0);\\n  vec3 b = vec3(coord * 2.0 - 1.0, 1.0);\\n  vec3 aWC = transform(modelViewInverse, a);\\n  vec3 bWC = transform(modelViewInverse, b);\\n  vec3 lookDir1 = normalize(bWC - aWC);\\n\\n  RMResult hitWC = raymarching2(aWC, lookDir1);\\n  vec3 hitn1 = sdfNormal1(hitWC.pos, hitWC.distance);\\n  float dWC = distance(aWC, hitWC.pos);\\n  vec3 hitNDC = transform(modelView, hitWC.pos);\\n  vec3 p = hitWC.pos;\\n  float inSun = softshadow(\\n    hitWC.pos + hitn1 * 0.05,\\n    -light,\\n    0.0001,\\n    300.0,\\n    8.0\\n  );\\n  //    float inSun=1.;\\n\\n  vec3 material = hitWC.color.xyz;\\n  if (dWC > 100.0) {\\n    material = vec3(0.0, 0.0, 0.0);\\n    //    } else if (p.z >= 0.001) {\\n    //        material = vec3(0.2, 0.0, 0.0);\\n    //    } else {\\n    //        vec2 c = vec2(4.0, 2.0);\\n    //        vec2 id = floor(((p.xy - c * 0.5) / c) );\\n    //        material += .15 * cos(vec3(id.x, id.y + 2., id.x + id.y + 4.));\\n  }\\n\\n  const vec3 sunlightColor = vec3(3.0);\\n\\n  float aOcc = ambientOcclusion(hitWC.pos, hitn1);\\n\\n  vec3 reflectionDirection = reflect(light, hitn1);\\n\\n  vec3 color = vec3(0.0);\\n  color += material * aOcc;\\n  color += inSun * sunlightColor * material * max(0.0, dot(-light, hitn1));\\n  //    color = (hitn1);\\n\\n  vec3 eyeDirection = -lookDir1;\\n  float uMaterialShininess = 256.0;\\n  float specularLightWeighting = pow(\\n    max(dot(reflectionDirection, eyeDirection), 0.0),\\n    uMaterialShininess\\n  );\\n  color += specularLightWeighting;\\n  //    float lightIntensity = 0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.);\\n  //    float lightIntensity =\\n  //        0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.) + 0.3*specularLightWeighting;\\n  //    fragColor = visualize(blue, red, mix(0.5, 1.0, inSun) * lightIntensity);\\n  //    fragColor = mix(hitWC.color, colorBackground, mix(0.5, 1.0, inSun) * clamp(lightIntensity, 0., 1.));\\n  color = pow(color, vec3(1.0 / 2.2)); // gamma correction\\n  fragColor = vec4(color, 1.0);\\n}\\n\"\nconst sourceMap = {\"version\":3,\"sources\":[\"/home/runner/work/workshop/workshop/src/noises/sphereOpenSimplex.frag\",\"/home/runner/work/workshop/workshop/src/common/banded.glsl\",\"/home/runner/work/workshop/workshop/src/common/constants.glsl\",\"/home/runner/work/workshop/workshop/src/common/matrices.glsl\",\"/home/runner/work/workshop/workshop/src/common/max3.glsl\",\"/home/runner/work/workshop/workshop/src/common/visualize.glsl\",\"/home/runner/work/workshop/workshop/src/common/unmix.glsl\",\"/home/runner/work/workshop/workshop/src/common/fromPolar.glsl\",\"/home/runner/work/workshop/workshop/src/common/toPolar.glsl\",\"/home/runner/work/workshop/workshop/src/common/polar.glsl\",\"/home/runner/work/workshop/workshop/src/common/ungamma.glsl\",\"/home/runner/work/workshop/workshop/src/common/transform.glsl\",\"/home/runner/work/workshop/workshop/src/common/OpenSimplex2.glsl\",\"/home/runner/work/workshop/workshop/src/common/checkerboardGrad.glsl\",\"/home/runner/work/workshop/workshop/src/common/colors.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdIcosahedron.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdDodecahedron.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdCylinder.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdTube.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdBox.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdLego.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdOctahedron.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdCone.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdArrow.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdCapsule.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdTetrahedron.glsl\"],\"names\":[],\"mappings\":\"AAAA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC/GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC3IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AzB3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA\"}\nexport { sourceMap };\n"," function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }import MoreVertIcon from \"@mui/icons-material/MoreVert\"\nimport Box from \"@mui/material/Box\"\nimport Card from \"@mui/material/Card\"\nimport CardMedia from \"@mui/material/CardMedia\"\nimport CircularProgress from \"@mui/material/CircularProgress\"\nimport Fab from \"@mui/material/Fab\"\nimport ListItem from \"@mui/material/ListItem\"\nimport ListItemText from \"@mui/material/ListItemText\"\nimport Menu from \"@mui/material/Menu\"\nimport MenuItem from \"@mui/material/MenuItem\"\nimport Select from \"@mui/material/Select\"\nimport { useTheme } from \"@mui/material/styles\"\n\nimport * as chroma from \"chroma.ts\"\nimport * as React from \"react\"\nimport {\n\n\n  useCallback,\n  useEffect,\n  useRef,\n  useState,\n} from \"react\"\nimport sleep from \"sleep-promise\"\nimport { SourceMapConsumer } from \"source-map-js\"\nimport { Mesh, Shader, TSGLContext } from \"tsgl\"\n\nimport { FPSController } from \"../common/FPSController\"\nimport { memoizeLast } from \"../common/memoizeLast\"\nimport { openInNewTab } from \"../paperBox1/common\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nexport function GenericDemo({\n  sx,\n  animate,\n  state,\n  Renderer,\n  focusable,\n  rendererRef,\n}\n\n\n\n\n\n\n) {\n  const rendererRef2 = useRef()\n  const [fps, setFps] = useState(0)\n  const [anchorEl, setAnchorEl] = useState()\n\n  const [renderProgress, setRenderProgress] = useState()\n\n  const render = useCallback(\n    async (event) => {\n      const dim = event.currentTarget.dataset\n        .dim.split(\"x\")\n        .map((x) => +x) \n      setAnchorEl(undefined)\n      if (rendererRef2.current) {\n        try {\n          const url = URL.createObjectURL(\n            await rendererRef2.current.renderImage(dim, setRenderProgress),\n          )\n          setRenderProgress(undefined)\n          openInNewTab(url)\n        } catch (e) {\n          console.error(e)\n        }\n      }\n    },\n    [],\n  )\n  useEffect(() => {\n    if (rendererRef) {\n      rendererRef.current = rendererRef2.current\n    }\n  }, [rendererRef])\n\n  const openMenu = useCallback(\n    (event) => setAnchorEl(event.currentTarget),\n    [],\n  )\n  const [resolutionScale, setResolutionScale] = useState(1)\n  const resolutionScales = [\n    0.5,\n    1,\n    window.devicePixelRatio,\n    2,\n    4 * window.devicePixelRatio,\n  ]\n  const closeMenu = useCallback(() => setAnchorEl(undefined), [])\n  return (\n    React.createElement(Card, { sx: { ...sx, position: \"relative\" },}\n      , React.createElement(Menu, { open: !!anchorEl, anchorEl: anchorEl, onClose: closeMenu,}\n        , React.createElement(MenuItem, { 'data-dim': \"1920x1080\", onClick: render,}, \"Render HD\"\n\n        )\n        , React.createElement(MenuItem, { 'data-dim': \"3840x2160\", onClick: render,}, \"Render 4K\"\n\n        )\n        , React.createElement(ListItem, null\n          , React.createElement(ListItemText, null, \"Res Scale \"  ), \" \"\n          , React.createElement(Select, {\n            value: resolutionScale,\n            onChange: (e) => {\n              setAnchorEl(undefined)\n              setResolutionScale(+e.target.value)\n            },\n            size: \"small\",}\n\n            , resolutionScales.map((x) => (\n              React.createElement(MenuItem, { key: x, value: x,}\n                , x\n              )\n            ))\n          )\n        )\n      )\n      , React.createElement(Box, { sx: { position: \"absolute\", margin: 1, right: 0 },}\n        , renderProgress !== undefined ? (\n          React.createElement(CircularProgress, {\n            variant: \"determinate\",\n            value: renderProgress * 100,}\n          )\n        ) : (\n          React.createElement(Fab, { size: \"small\", onClick: openMenu,}\n            , React.createElement(MoreVertIcon, null )\n          )\n        )\n      )\n      , React.createElement(Box, { sx: { position: \"absolute\", margin: 1, left: 0 },}, fps)\n\n      , React.createElement(CardMedia, {\n        component: ReactGlCanvas,\n        Renderer: Renderer,\n        animate: animate,\n        state: state,\n        rendererRef: rendererRef2,\n        onFps: setFps,\n        resolutionScale: resolutionScale,\n        focusable: focusable,\n        sx: { width: \"100%\", height: \"100%\" },}\n      )\n    )\n  )\n}\n\nexport const ReactGlCanvas = ({\n  Renderer,\n  onFps,\n  animate,\n  state,\n  rendererRef,\n  focusable = false,\n  resolutionScale,\n}\n\n\n\n\n\n\n\n) => {\n  const canvasRef = useRef(null)\n  const rendererRef2 = useRef()\n\n  useEffect(() => {\n    if (canvasRef.current) {\n      const renderer1 = new Renderer(canvasRef.current, {\n        onFps,\n        resolutionScale,\n      })\n      rendererRef2.current = renderer1\n      renderer1.start()\n      if (rendererRef) {\n        rendererRef.current = renderer1\n      }\n      return () => renderer1.destroy()\n    }\n  }, [Renderer, onFps, resolutionScale, rendererRef])\n  const theme = useTheme()\n  useEffect(() => {\n    rendererRef2.current &&\n      Object.assign(rendererRef2.current.dyn, {\n        colorBackground: chroma.css(theme.palette.background.default).gl(),\n        colorPrimary: chroma.css(theme.palette.primary.main).gl(),\n        colorSecondary: chroma.css(theme.palette.secondary.main).gl(),\n      })\n  }, [rendererRef2.current, theme.palette])\n  useEffect(() => {\n    if (rendererRef2.current) rendererRef2.current.animate = animate\n  }, [rendererRef2.current, animate])\n  useEffect(() => {\n    if (rendererRef2.current) Object.assign(rendererRef2.current.dyn, state)\n  }, [rendererRef2.current, state])\n  return React.createElement('canvas', { ref: canvasRef, style: { width: \"100%\", height: \"100%\" },} )\n}\nexport class SimpleCanvasRenderer {\n  \n\n\n\n\n\n  \n\n   __init() {this.mousePos = [-1, -1] }\n\n  \n   __init2() {this.dyn = {}}\n   __init3() {this.animate = true}\n  \n   __init4() {this.stop = () => {}}\n  \n\n  constructor(\n      fragShader\n\n,\n      canvas,\n    {\n      onFps,\n      resolutionScale = window.devicePixelRatio,\n    },\n  ) {;this.fragShader = fragShader;this.canvas = canvas;SimpleCanvasRenderer.prototype.__init.call(this);SimpleCanvasRenderer.prototype.__init2.call(this);SimpleCanvasRenderer.prototype.__init3.call(this);SimpleCanvasRenderer.prototype.__init4.call(this);SimpleCanvasRenderer.prototype.__init5.call(this);\n    const mousemove = (e) => {\n      const canvas = e.currentTarget \n      const { width, height } = canvas.getBoundingClientRect()\n      this.mousePos = [\n        canvas.width * (e.offsetX / width),\n        canvas.height * (1 - e.offsetY / height),\n      ]\n    }\n    const mouseleave = (e) => {\n      this.mousePos = [-1, -1]\n    }\n    const gl = TSGLContext.create({\n      canvas: canvas,\n      alpha: true,\n      premultipliedAlpha: true,\n      // antialias: true,\n      // don't enable by default: bad for perf\n      // throwOnError: true,\n    }) \n    this.gl = gl\n    function fixCanvasRes() {\n      gl.canvas.width = gl.canvas.clientWidth * resolutionScale\n      gl.canvas.height = gl.canvas.clientHeight * resolutionScale\n      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height)\n    }\n    console.log(\"resolutionScale\", resolutionScale)\n    this.resolutionScale = resolutionScale\n    if (this.canvas.clientWidth !== 0) {\n      fixCanvasRes()\n      gl.canvas.addEventListener(\"resize\", fixCanvasRes)\n    }\n    gl.canvas.addEventListener(\"mouseleave\", mouseleave)\n    gl.canvas.addEventListener(\"mousemove\", mousemove)\n    this.planeMesh = Mesh.plane({ startX: -1, startY: -1, width: 2, height: 2 })\n    // Mesh.plane generates tex coords [0,1] and we want [-1, 1] for rendering.\n    // this.planeMesh.coords = [\n    //   [-1, -1],\n    //   [1, -1],\n    //   [-1, 1],\n    //   [1, 1],\n    // ]\n    this.planeMesh.compile(gl)\n    this.fpsController = onFps && new FPSController(onFps)\n    this.gl.makeCurrent()\n    this.updateShader()\n  }\n\n   updateShader() {\n    this.buildShader(\n      // eslint-disable-next-line @typescript-eslint/no-var-requires\n      require(\"../common/raymarch.vert\").default,\n      // eslint-disable-next-line @typescript-eslint/no-var-requires\n      this.fragShader(),\n    )\n  }\n\n   __init5() {this.buildShader = memoizeLast(\n    (vs, fs) => {\n      let sourceMap\n      try {\n        let fsSrc\n        if (typeof fs === \"string\") {\n          fsSrc = fs\n        } else {\n          fsSrc = fs.default\n          sourceMap = fs.sourceMap\n        }\n        // if (this.shader) {\n        //   this.gl.deleteProgram(this.shader.program)\n        // }\n        console.log(\"building shader\")\n\n        this.shader = Shader.create(vs, fsSrc, this.gl)\n      } catch (e) {\n        console.clear()\n        console.error(sourceMap)\n        if (sourceMap) {\n          const sourceMapConsumer = new SourceMapConsumer(sourceMap)\n          const newMessage = (e ).message.replace(\n            /ERROR: 0:(\\d+)/,\n            (match, line) => {\n              const originalPosition = sourceMapConsumer.originalPositionFor({\n                line: +line,\n                column: 0,\n              })\n              console.log(\"originalPosition\", originalPosition)\n              return (\n                \"ERROR \" +\n                originalPosition.source +\n                \":\" +\n                originalPosition.line +\n                \":\" +\n                originalPosition.column\n              )\n            },\n          )\n          ;(e ).message = newMessage\n        }\n\n        if (!this.shader) throw e\n      }\n    },\n  )}\n\n  start() {\n    this.stop = this.gl.animate(this.render.bind(this))\n  }\n\n  render(abs) {\n    console.log(\"render\", this.resolutionScale)\n    this.gl.makeCurrent()\n    this.updateShader()\n    _optionalChain([this, 'access', _ => _.fpsController, 'optionalAccess', _2 => _2.tick, 'call', _3 => _3(abs)])\n    // this.cam.tick(abs)\n    if (!this.shader) return\n    this.shader\n      .uniforms({\n        iResolution: [this.gl.canvas.width, this.gl.canvas.height],\n        iMouse: this.mousePos,\n        iTime: this.animate ? abs / 1000 : 0,\n      })\n      .uniforms(this.dyn)\n      .uniforms(this.uniforms())\n      .draw(this.planeMesh)\n  }\n\n  destroy() {\n    console.log(\"destroy\")\n    this.stop()\n    // this.planeMesh.destroy()\n    // this.shader.destroy()\n  }\n\n  async renderImage(\n    \n    [width, height],\n    onProgress,\n  ) {\n    _optionalChain([onProgress, 'optionalCall', _4 => _4(0)])\n    await sleep(10)\n    const canvas = document.createElement(\"canvas\")\n    canvas.width = width\n    canvas.height = height\n\n    console.log(this.constructor)\n    const renderer = new this.constructor(canvas, { resolutionScale: 4 })\n    Object.assign(renderer.dyn, this.dyn)\n    const step = 256\n    const gl = renderer.gl\n    gl.enable(gl.SCISSOR_TEST)\n    let donePixels = 0\n    for (let x = 0; x < width; x += step) {\n      for (let y = 0; y < height; y += step) {\n        const scissorWidth = Math.min(step, width - x)\n        const scissorHeight = Math.min(step, height - y)\n        gl.scissor(x, y, scissorWidth, scissorHeight)\n        // console.time(\"render block\")\n        renderer.render(0)\n        // console.timeEnd(\"render block\")\n        await sleep(0)\n        donePixels += scissorWidth * scissorHeight\n        _optionalChain([onProgress, 'optionalCall', _5 => _5(donePixels / (width * height))])\n      }\n    }\n    return new Promise((resolve, reject) =>\n      canvas.toBlob(\n        (blob) =>\n          blob ? resolve(blob) : reject(\"error creating png from canvas\"),\n        \"png\",\n      ),\n    )\n  }\n\n  /**\n   * Override this method to add additional uniforms to the simple renderer shader.\n   */\n   uniforms() {\n    return {}\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nexport function memoizeLast(f) {\n  let lastArgs = []\n  let lastResult\n  return function (...args) {\n    if (\n      lastArgs.length !== args.length ||\n      lastArgs.some((v, i) => v !== args[i])\n    ) {\n      lastArgs = args\n      lastResult = f(...args)\n    }\n    return lastResult\n  } \n}\n","\nexport default \"#version 300 es\\n\\nprecision highp float;\\n\\n// START ../common/banded.glsl\\nfloat banded(float bandCount, float t) {\\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\\n}\\nfloat banded(int bandCount, float t) {\\n  return banded(float(bandCount), t);\\n}\\n\\n// #pragma glslify: export(banded)\\n\\n\\n// END ../common/banded.glsl\\n// START ../common/checkerboardGrad.glsl\\n//https://iquilezles.org/articles/checkerfiltering/\\nfloat tri(float x) {\\n  float h = fract(x * 0.5) - 0.5;\\n  return 1.0 - 2.0 * abs(h);\\n}\\nvec2 tri(vec2 x) {\\n  vec2 h = fract(x * 0.5) - 0.5;\\n  return 1.0 - 2.0 * abs(h);\\n}\\n\\nfloat checkerboardGrad(vec2 uv) {\\n  vec2 w = max(abs(dFdx(uv)), abs(dFdy(uv))) + 0.01; // filter kernel\\n  vec2 i = (tri(uv + 0.5 * w) - tri(uv - 0.5 * w)) / w; // analytical integral (box filter)\\n  return 0.5 - 0.5 * i.x * i.y; // xor pattern\\n}\\n\\n// END ../common/checkerboardGrad.glsl\\n// START ../common/colors.glsl\\nconst vec3 INDIAN_RED = vec3(0.804, 0.361, 0.361);\\nconst vec3 LIGHT_CORAL = vec3(0.941, 0.502, 0.502);\\nconst vec3 SALMON = vec3(0.98, 0.502, 0.447);\\nconst vec3 DARK_SALMON = vec3(0.914, 0.588, 0.478);\\nconst vec3 LIGHT_SALMON = vec3(1.0, 0.627, 0.478);\\nconst vec3 CRIMSON = vec3(0.863, 0.078, 0.235);\\nconst vec3 RED = vec3(1.0, 0.0, 0.0);\\nconst vec3 FIRE_BRICK = vec3(0.698, 0.133, 0.133);\\nconst vec3 DARK_RED = vec3(0.545, 0.0, 0.0);\\nconst vec3 PINK = vec3(1.0, 0.753, 0.796);\\nconst vec3 LIGHT_PINK = vec3(1.0, 0.714, 0.757);\\nconst vec3 HOT_PINK = vec3(1.0, 0.412, 0.706);\\nconst vec3 DEEP_PINK = vec3(1.0, 0.078, 0.576);\\nconst vec3 MEDIUM_VIOLET_RED = vec3(0.78, 0.082, 0.522);\\nconst vec3 PALE_VIOLET_RED = vec3(0.859, 0.439, 0.576);\\nconst vec3 CORAL = vec3(1.0, 0.498, 0.314);\\nconst vec3 TOMATO = vec3(1.0, 0.388, 0.278);\\nconst vec3 ORANGE_RED = vec3(1.0, 0.271, 0.0);\\nconst vec3 DARK_ORANGE = vec3(1.0, 0.549, 0.0);\\nconst vec3 ORANGE = vec3(1.0, 0.647, 0.0);\\nconst vec3 GOLD = vec3(1.0, 0.843, 0.0);\\nconst vec3 YELLOW = vec3(1.0, 1.0, 0.0);\\nconst vec3 LIGHT_YELLOW = vec3(1.0, 1.0, 0.878);\\nconst vec3 LEMON_CHION = vec3(1.0, 0.98, 0.804);\\nconst vec3 LIGHT_GOLDENROD_YELLOW = vec3(0.98, 0.98, 0.824);\\nconst vec3 PAPAYA_WHIP = vec3(1.0, 0.937, 0.835);\\nconst vec3 MOCCASIN = vec3(1.0, 0.894, 0.71);\\nconst vec3 PEACH_PU = vec3(1.0, 0.855, 0.725);\\nconst vec3 PALE_GOLDENROD = vec3(0.933, 0.91, 0.667);\\nconst vec3 KHAKI = vec3(0.941, 0.902, 0.549);\\nconst vec3 DARK_KHAKI = vec3(0.741, 0.718, 0.42);\\nconst vec3 LAVENDER = vec3(0.902, 0.902, 0.98);\\nconst vec3 THISTLE = vec3(0.847, 0.749, 0.847);\\nconst vec3 PLUM = vec3(0.867, 0.627, 0.867);\\nconst vec3 VIOLET = vec3(0.933, 0.51, 0.933);\\nconst vec3 ORCHID = vec3(0.855, 0.439, 0.839);\\nconst vec3 FUCHSIA = vec3(1.0, 0.0, 1.0);\\nconst vec3 MAGENTA = vec3(1.0, 0.0, 1.0);\\nconst vec3 MEDIUM_ORCHID = vec3(0.729, 0.333, 0.827);\\nconst vec3 MEDIUM_PURPLE = vec3(0.576, 0.439, 0.859);\\nconst vec3 BLUE_VIOLET = vec3(0.541, 0.169, 0.886);\\nconst vec3 DARK_VIOLET = vec3(0.58, 0.0, 0.827);\\nconst vec3 DARK_ORCHID = vec3(0.6, 0.196, 0.8);\\nconst vec3 DARK_MAGENTA = vec3(0.545, 0.0, 0.545);\\nconst vec3 PURPLE = vec3(0.502, 0.0, 0.502);\\nconst vec3 INDIGO = vec3(0.294, 0.0, 0.51);\\nconst vec3 SLATE_BLUE = vec3(0.416, 0.353, 0.804);\\nconst vec3 DARK_SLATE_BLUE = vec3(0.282, 0.239, 0.545);\\nconst vec3 GREEN_YELLOW = vec3(0.678, 1.0, 0.184);\\nconst vec3 CHARTREUSE = vec3(0.498, 1.0, 0.0);\\nconst vec3 LAWN_GREEN = vec3(0.486, 0.988, 0.0);\\nconst vec3 LIME = vec3(0.0, 1.0, 0.0);\\nconst vec3 LIME_GREEN = vec3(0.196, 0.804, 0.196);\\nconst vec3 PALE_GREEN = vec3(0.596, 0.984, 0.596);\\nconst vec3 LIGHT_GREEN = vec3(0.565, 0.933, 0.565);\\nconst vec3 MEDIUM_SPRING_GREEN = vec3(0.0, 0.98, 0.604);\\nconst vec3 SPRING_GREEN = vec3(0.0, 1.0, 0.498);\\nconst vec3 MEDIUM_SEA_GREEN = vec3(0.235, 0.702, 0.443);\\nconst vec3 SEA_GREEN = vec3(0.18, 0.545, 0.341);\\nconst vec3 FOREST_GREEN = vec3(0.133, 0.545, 0.133);\\nconst vec3 GREEN = vec3(0.0, 0.502, 0.0);\\nconst vec3 DARK_GREEN = vec3(0.0, 0.392, 0.0);\\nconst vec3 YELLOW_GREEN = vec3(0.604, 0.804, 0.196);\\nconst vec3 OLIVE_DRAB = vec3(0.42, 0.557, 0.137);\\nconst vec3 OLIVE = vec3(0.502, 0.502, 0.0);\\nconst vec3 DARK_OLIVE_GREEN = vec3(0.333, 0.42, 0.184);\\nconst vec3 MEDIUM_AQUAMARINE = vec3(0.4, 0.804, 0.667);\\nconst vec3 DARK_SEA_GREEN = vec3(0.561, 0.737, 0.561);\\nconst vec3 LIGHT_SEA_GREEN = vec3(0.125, 0.698, 0.667);\\nconst vec3 DARK_CYAN = vec3(0.0, 0.545, 0.545);\\nconst vec3 TEAL = vec3(0.0, 0.502, 0.502);\\nconst vec3 AQUA = vec3(0.0, 1.0, 1.0);\\nconst vec3 CYAN = vec3(0.0, 1.0, 1.0);\\nconst vec3 LIGHT_CYAN = vec3(0.878, 1.0, 1.0);\\nconst vec3 PALE_TURQUOISE = vec3(0.686, 0.933, 0.933);\\nconst vec3 AQUAMARINE = vec3(0.498, 1.0, 0.831);\\nconst vec3 TURQUOISE = vec3(0.251, 0.878, 0.816);\\nconst vec3 MEDIUM_TURQUOISE = vec3(0.282, 0.82, 0.8);\\nconst vec3 DARK_TURQUOISE = vec3(0.0, 0.808, 0.82);\\nconst vec3 CADET_BLUE = vec3(0.373, 0.62, 0.627);\\nconst vec3 STEEL_BLUE = vec3(0.275, 0.51, 0.706);\\nconst vec3 LIGHT_STEEL_BLUE = vec3(0.69, 0.769, 0.871);\\nconst vec3 POWDER_BLUE = vec3(0.69, 0.878, 0.902);\\nconst vec3 LIGHT_BLUE = vec3(0.678, 0.847, 0.902);\\nconst vec3 SKY_BLUE = vec3(0.529, 0.808, 0.922);\\nconst vec3 LIGHT_SKY_BLUE = vec3(0.529, 0.808, 0.98);\\nconst vec3 DEEP_SKY_BLUE = vec3(0.0, 0.749, 1.0);\\nconst vec3 DODGER_BLUE = vec3(0.118, 0.565, 1.0);\\nconst vec3 CORNLOWER_BLUE = vec3(0.392, 0.584, 0.929);\\nconst vec3 MEDIUM_SLATE_BLUE = vec3(0.482, 0.408, 0.933);\\nconst vec3 ROYAL_BLUE = vec3(0.255, 0.412, 0.882);\\nconst vec3 BLUE = vec3(0.0, 0.0, 1.0);\\nconst vec3 MEDIUM_BLUE = vec3(0.0, 0.0, 0.804);\\nconst vec3 DARK_BLUE = vec3(0.0, 0.0, 0.545);\\nconst vec3 NAVY = vec3(0.0, 0.0, 0.502);\\nconst vec3 MIDNIGHT_BLUE = vec3(0.098, 0.098, 0.439);\\nconst vec3 CORNSILK = vec3(1.0, 0.973, 0.863);\\nconst vec3 BLANCHED_ALMOND = vec3(1.0, 0.922, 0.804);\\nconst vec3 BISQUE = vec3(1.0, 0.894, 0.769);\\nconst vec3 NAVAJO_WHITE = vec3(1.0, 0.871, 0.678);\\nconst vec3 WHEAT = vec3(0.961, 0.871, 0.702);\\nconst vec3 BURLY_WOOD = vec3(0.871, 0.722, 0.529);\\nconst vec3 TAN = vec3(0.824, 0.706, 0.549);\\nconst vec3 ROSY_BROWN = vec3(0.737, 0.561, 0.561);\\nconst vec3 SANDY_BROWN = vec3(0.957, 0.643, 0.376);\\nconst vec3 GOLDENROD = vec3(0.855, 0.647, 0.125);\\nconst vec3 DARK_GOLDENROD = vec3(0.722, 0.525, 0.043);\\nconst vec3 PERU = vec3(0.804, 0.522, 0.247);\\nconst vec3 CHOCOLATE = vec3(0.824, 0.412, 0.118);\\nconst vec3 SADDLE_BROWN = vec3(0.545, 0.271, 0.075);\\nconst vec3 SIENNA = vec3(0.627, 0.322, 0.176);\\nconst vec3 BROWN = vec3(0.647, 0.165, 0.165);\\nconst vec3 MAROON = vec3(0.502, 0.0, 0.0);\\nconst vec3 WHITE = vec3(1.0, 1.0, 1.0);\\nconst vec3 SNOW = vec3(1.0, 0.98, 0.98);\\nconst vec3 HONEYDEW = vec3(0.941, 1.0, 0.941);\\nconst vec3 MINT_CREAM = vec3(0.961, 1.0, 0.98);\\nconst vec3 AZURE = vec3(0.941, 1.0, 1.0);\\nconst vec3 ALICE_BLUE = vec3(0.941, 0.973, 1.0);\\nconst vec3 GHOST_WHITE = vec3(0.973, 0.973, 1.0);\\nconst vec3 WHITE_SMOKE = vec3(0.961, 0.961, 0.961);\\nconst vec3 SEASHELL = vec3(1.0, 0.961, 0.933);\\nconst vec3 BEIGE = vec3(0.961, 0.961, 0.863);\\nconst vec3 OLD_LACE = vec3(0.992, 0.961, 0.902);\\nconst vec3 FLORAL_WHITE = vec3(1.0, 0.98, 0.941);\\nconst vec3 IVORY = vec3(1.0, 1.0, 0.941);\\nconst vec3 ANTIQUE_WHITE = vec3(0.98, 0.922, 0.843);\\nconst vec3 LINEN = vec3(0.98, 0.941, 0.902);\\nconst vec3 LAVENDER_BLUSH = vec3(1.0, 0.941, 0.961);\\nconst vec3 MISTY_ROSE = vec3(1.0, 0.894, 0.882);\\nconst vec3 GAINSBORO = vec3(0.863, 0.863, 0.863);\\nconst vec3 LIGHT_GREY = vec3(0.827, 0.827, 0.827);\\nconst vec3 SILVER = vec3(0.753, 0.753, 0.753);\\nconst vec3 DARK_GRAY = vec3(0.663, 0.663, 0.663);\\nconst vec3 GRAY = vec3(0.502, 0.502, 0.502);\\nconst vec3 DIM_GRAY = vec3(0.412, 0.412, 0.412);\\nconst vec3 LIGHT_SLATE_GRAY = vec3(0.467, 0.533, 0.6);\\nconst vec3 SLATE_GRAY = vec3(0.439, 0.502, 0.565);\\nconst vec3 DARK_SLATE_GRAY = vec3(0.184, 0.31, 0.31);\\nconst vec3 BLACK = vec3(0.0, 0.0, 0.0);\\n\\n// END ../common/colors.glsl\\n// START ../common/linstep.glsl\\nfloat linstep(float a, float b, float t) {\\n  return clamp((t - a) / (b - a), 0.0, 1.0);\\n}\\nvec2 linstep(vec2 a, vec2 b, float t) {\\n  return clamp((t - a) / (b - a), 0.0, 1.0);\\n}\\nvec3 linstep(vec3 a, vec3 b, float t) {\\n  return clamp((t - a) / (b - a), 0.0, 1.0);\\n}\\nvec4 linstep(vec4 a, vec4 b, float t) {\\n  return clamp((t - a) / (b - a), 0.0, 1.0);\\n}\\n\\n// END ../common/linstep.glsl\\n// START ../common/matrices.glsl\\n// START ./constants.glsl\\nconst float SQRT1_2 = 0.7071067811865476;\\nconst float SQRT1_3 = 0.57735026919;\\nconst float SQRT2 = 1.4142135623730951;\\nconst float SQRT3 = 1.732050807568877;\\n// sqrt(3)/2 = sin(60*)\\nconst float SQRT3_2 = 0.86602540378;\\nconst float GOLDEN_RATIO = 1.61803398875;\\nconst float PI = 3.141592653589793;\\nconst float TAU = 6.28318530718;\\n/**\\n * One degree in radians. Use like `sin(30 * DEG)`.\\n */\\nconst float DEGREE = 0.017453292519943295;\\n\\n// END ./constants.glsl\\n\\nmat2 rot2(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat2(c, s, -s, c);\\n}\\nmat3 rotX(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\\n}\\nmat3 rotY(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\\n}\\nmat3 rotZ(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\\n}\\n/**\\n * Returns a matrix that puts the camera at the eye point `ex, ey, ez` looking\\n * toward the center point `cx, cy, cz` with an up direction of `ux, uy, uz`.\\n * This emulates the OpenGL function `gluLookAt()`.\\n */\\nmat4 lookAt(vec3 eye, vec3 focus, vec3 up) {\\n  vec3 f = normalize(eye - focus);\\n  vec3 s = normalize(cross(up, f));\\n  vec3 t = normalize(cross(f, s));\\n\\n  return mat4(\\n    vec4(s.x, t.x, f.x, 0.0),\\n    vec4(s.y, t.y, f.y, 0.0),\\n    vec4(s.z, t.z, f.z, 0.0),\\n    vec4(-dot(s, eye), -dot(t, eye), -dot(f, eye), 1)\\n  );\\n}\\n\\n// the OpenGL function `glFrustum()`.\\nmat4 frustum(\\n  float left,\\n  float right,\\n  float bottom,\\n  float top,\\n  float near,\\n  float far\\n) {\\n  return mat4(\\n    vec4(2.0 * near / (right - left), 0.0, 0.0, 0.0),\\n    vec4(0, 2.0 * near / (top - bottom), 0.0, 0.0),\\n    vec4(\\n      (right + left) / (right - left),\\n      (top + bottom) / (top - bottom),\\n      -(far + near) / (far - near),\\n      -1\\n    ),\\n    vec4(0.0, 0.0, -2.0 * far * near / (far - near), 0.0)\\n  );\\n}\\n\\nmat4 perspective(float fovDegrees, float aspect, float near, float far) {\\n  float y = tan(fovDegrees * DEGREE / 2.0) * near;\\n  float x = y * aspect;\\n  return frustum(-x, x, -y, y, near, far);\\n}\\nmat4 ortho(\\n  float left,\\n  float right,\\n  float bottom,\\n  float top,\\n  float near,\\n  float far\\n) {\\n  return mat4(\\n    vec4(2.0 / (right - left), 0.0, 0.0, 0.0),\\n    vec4(0.0, 2.0 / (top - bottom), 0.0, 0.0),\\n    vec4(0.0, 0.0, -2.0 / (far - near), 0.0),\\n    vec4(\\n      -(right + left) / (right - left),\\n      -(top + bottom) / (top - bottom),\\n      -(far + near) / (far - near),\\n      1.0\\n    )\\n  );\\n}\\n\\n// END ../common/matrices.glsl\\n// START ../common/max3.glsl\\nfloat max3(float a, float b, float c) {\\n  return max(a, max(b, c));\\n}\\nfloat max3(vec3 v) {\\n  return max(v.x, max(v.y, v.z));\\n}\\n\\n// #pragma glslify: export(max3)\\n\\n\\n// END ../common/max3.glsl\\n// START ../common/min3.glsl\\nfloat min3(float a, float b, float c) {\\n  return min(a, min(b, c));\\n}\\nfloat min3(vec3 v) {\\n  return min(v.x, min(v.y, v.z));\\n}\\n\\n// #pragma glslify: export(min3)\\n\\n\\n// END ../common/min3.glsl\\n// START ../common/polar.glsl\\n// START ../common/fromPolar.glsl\\n// START ./unmix.glsl\\nfloat unmix(float a, float b, float value) {\\n  return (value - a) / (b - a);\\n}\\n\\n// #pragma glslify: export(unmix)\\n\\n\\n// END ./unmix.glsl\\n\\nvec3 fromPolar(float radius, float phi, float z) {\\n  return vec3(radius * cos(phi), radius * sin(phi), z);\\n}\\n\\nvec2 fromPolar(float radius, float phi) {\\n  return vec2(radius * cos(phi), radius * sin(phi));\\n}\\n\\nvec2 fromPolar(vec2 polar) {\\n  return fromPolar(polar.x, polar.y);\\n}\\n\\n// #pragma glslify: export(fromPolar)\\n\\n\\n// END ../common/fromPolar.glsl\\n// START ../common/toPolar.glsl\\n\\nvec2 toPolar(vec2 xy) {\\n  return vec2(length(xy), atan(xy.y, xy.x));\\n}\\n\\nmat2 toPolarDerivate(vec2 xy) {\\n  return mat2(xy.x * xy.x, xy.y * xy.y, -xy.y, xy.x) / dot(xy, xy);\\n}\\n\\n// #pragma glslify: export(toPolar)\\n\\n\\n// END ../common/toPolar.glsl\\n\\n// END ../common/polar.glsl\\n// START ../common/sdf2d/sdArcRect.glsl\\n\\n/**\\n * 2D signed distance function to an arc with square ends. The opening of the\\n * arc is on the left (negative X direction). The total spanned angle is\\n * `2 * halfAngle`.\\n *\\n * `radius` is the center radius of the arc.\\n *\\n * `width.x` is the thickness of the arc.\\n *\\n * `width.y` is how much the flat end of the arc is extructed. This is a\\n * parameter as is it trivial to add with the current implementation. Set to 0\\n * to just have a flat-ended arc.\\n */\\nfloat sdArcRect(float halfAngle, float radius, vec2 width, vec2 p) {\\n  // Symmetric across x axis; all points on top.\\n  p.y = abs(p.y);\\n  // Rotate so that the end of the arc is at the x axis.\\n  p = rot2(-halfAngle) * p;\\n  if (p.y > 0.0) {\\n    // p is \\\"above the end of the arc\\\"; calculate as for sdRectangle.\\n    p.x = abs(p.x - radius);\\n    p -= 0.5 * width;\\n    return length(max(p, 0.0)) + min(0.0, max(p.x, p.y));\\n  } else {\\n    // Otherwise, the distance is basically just the radial distance to the arc.\\n    // For the inside of the sdf, we have to take the end into account.\\n    return max(abs(length(p) - radius) - 0.5 * width.x, p.y - 0.5 * width.y);\\n  }\\n}\\n\\n// END ../common/sdf2d/sdArcRect.glsl\\n// START ../common/sdf2d/sdGear.glsl\\n// START ../dot2.glsl\\nfloat dot2(vec3 x) {\\n  return dot(x, x);\\n}\\nfloat dot2(vec2 x) {\\n  return dot(x, x);\\n}\\n\\n// END ../dot2.glsl\\n// START ./addFillet.glsl\\nfloat addFillet(float r, float a, float b) {\\n  if (a < r && b < r) {\\n    return r - distance(vec2(a, b), vec2(r));\\n  } else {\\n    return min(a, b);\\n  }\\n}\\n\\n// #pragma glslify: export(addFillet)\\n\\n\\n// END ./addFillet.glsl\\n\\n/**\\n * SDF of one side of an invlute gear tooth. It starts at (baseRadius,0)\\n * perpendicular to x-axis and goes right/up.\\n *\\n * Oq and qp are perpendicular.`|q| = 1` Calc |qp| with pythagoras.\\n *\\n * ```\\n * |__\\n * |  \\\\_q\\n * |___|_________\\n * O\\n *         p\\n * ```\\n */\\nfloat sdInvolute(float baseRadius, vec2 p) {\\n  if (p.x < baseRadius) {\\n    return -p.y;\\n  } else {\\n    float qpLength = sqrt(dot2(p) - baseRadius * baseRadius);\\n    float qopAngle = acos(baseRadius / length(p));\\n    float pAngle = atan(p.y, p.x);\\n    float qAngle = qopAngle + pAngle;\\n    float d = qpLength - qAngle * baseRadius;\\n    return d;\\n  }\\n}\\nvec2 opRotSym(float n, vec2 p) {\\n  vec2 polar = toPolar(p);\\n  float f = TAU / n;\\n  polar.y = (fract(polar.y / f + 0.5) - 0.5) * f;\\n  p = fromPolar(polar);\\n  return p;\\n}\\n/**\\n * 2D signed distance function (SDF) of an (external) involute gear. The gear is\\n * centered at origin and has `n` teeth.\\n *\\n * Involute gear primer: The \\\"pitch\\\" circle/radius is where two gears touch each\\n * other. The circular pitch is the distance, along the pitch circle, between\\n * two teeth. `pitchRadius = (float(n) * circularPitch) / TAU`\\n *\\n * For two gears to be compatible they need to have the same pressure angle and\\n * circular pitch.\\n *\\n * The base circle/radius is the circle from which the involute tooth profile is\\n * constructed. `baseRadius = cos(pressureAngle) * pitchRadius`.\\n *\\n * The teeth profiles go from \\\"dedendum circle\\\" (see code) to \\\"addendum circle\\\".\\n * The difference between dedendum circle and base circle is filled by a fillet.\\n *\\n * See also http://faculty.mercer.edu/jenkins_he/documents/Gears2R1.pdf\\n */\\nfloat sdGear(int n, float pressureAngle, float circularPitch, vec2 p) {\\n  float pitchRadius = float(n) * circularPitch / TAU;\\n  float baseRadius = cos(pressureAngle) * pitchRadius;\\n\\n  float addendumRadius = pitchRadius + 1.0 / PI * circularPitch;\\n  float d3 = length(p) - addendumRadius;\\n  if (d3 > 0.1) {\\n    return d3;\\n  }\\n  float dedendumRadius = pitchRadius - 1.25 / PI * circularPitch;\\n  float d2 = length(p) - dedendumRadius;\\n  if (d2 < -0.1) {\\n    return d2;\\n  }\\n  p = opRotSym(float(n), p);\\n  //  float d = distance(vec2(1, 0.1), p) - 0.1;\\n  p.y = abs(p.y);\\n  vec2 polar = toPolar(p);\\n  float f = TAU / float(n);\\n  polar.y = (fract(polar.y / f + 0.5) - 0.5) * f;\\n  polar.y -= 1.3 / float(n);\\n  float d = sdInvolute(baseRadius, fromPolar(polar));\\n\\n  return max(addFillet(baseRadius - dedendumRadius, d, d2), d3);\\n}\\n\\n/**\\n * See sdGear. Not quite `-sdGear`, as the dedendum and addendum radii are\\n * reversed to avoid intersections.\\n */\\nfloat sdGearInternal(int n, float pressureAngle, float circularPitch, vec2 p) {\\n  float pitchRadius = float(n) * circularPitch / TAU;\\n  float baseRadius = cos(pressureAngle) * pitchRadius;\\n\\n  float addendumRadius = pitchRadius - 1.0 / PI * circularPitch;\\n  float d3 = -(length(p) - addendumRadius);\\n  if (d3 > 0.1) {\\n    return d3;\\n  }\\n  float dedendumRadius = pitchRadius + 1.25 / PI * circularPitch;\\n  float d2 = -(length(p) - dedendumRadius);\\n  if (d2 < -0.1) {\\n    return d2;\\n  }\\n  p = opRotSym(float(n), p);\\n  //  float d = distance(vec2(1, 0.1), p) - 0.1;\\n  p.y = abs(p.y);\\n  vec2 polar = toPolar(p);\\n  float f = TAU / float(n);\\n  polar.y = (fract(polar.y / f + 0.5) - 0.5) * f;\\n  polar.y -= 1.0 / 1.3 / float(n);\\n  float d = -sdInvolute(baseRadius, fromPolar(polar));\\n\\n  return max(min(d, d2), d3);\\n}\\n\\n// END ../common/sdf2d/sdGear.glsl\\n// START ../common/sdf3d/opRepLim.glsl\\nvec3 opRepLim(vec3 p, vec3 cellSize, vec3 limit) {\\n  return p - cellSize * clamp(round(p / cellSize), vec3(0.0), limit);\\n}\\nvec2 opRepLim(vec2 p, vec2 cellSize, vec2 limit) {\\n  return p - cellSize * clamp(round(p / cellSize), vec2(0.0), limit);\\n}\\nfloat opRepLim(float p, float cellSize, float limit) {\\n  return p - cellSize * clamp(round(p / cellSize), 0.0, limit);\\n}\\n\\n// #pragma glslify: export(opRepLim)\\n\\n\\n// END ../common/sdf3d/opRepLim.glsl\\n// START ../common/sdf3d/sdArrow.glsl\\n// START ./sdCylinder.glsl\\nfloat sdCylinder(float radius, float z, vec3 p) {\\n  vec2 d = vec2(length(p.xy), abs(p.z)) - vec2(radius, z);\\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\\n}\\n\\n// #pragma glslify: export(sdCylinder)\\n\\n\\n// END ./sdCylinder.glsl\\n// START ./sdCone.glsl\\n\\n/**\\n * Signed distance function (SDF) of a cone. The tip of the cone is at the\\n * origin and points towards +Z. q is a point on the rim of the cone.\\n */\\nfloat sdCone(vec2 c, float h, vec3 p) {\\n  vec2 q = h * vec2(c.x / c.y, -1.0);\\n  vec2 w = vec2(length(p.xz), p.y);\\n  vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);\\n  vec2 b = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0);\\n  float k = sign(q.y);\\n  float d = min(dot(a, a), dot(b, b));\\n  float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));\\n  return sqrt(d) * sign(s);\\n}\\n// #pragma glslify: export(sdBox)\\n\\nfloat sdConeB(vec2 c, float h, vec3 p) {\\n  float q = length(p.xz);\\n  return max(dot(c.xy, vec2(q, p.y)), -h - p.y);\\n}\\n\\n// END ./sdCone.glsl\\nvec3 perpendicularVector(vec3 a) {\\n  return cross(a, abs(a.z) > abs(a.x) ? vec3(0, 0, 1) : vec3(0, 1, 0));\\n}\\n/**\\n * Signed distance function (SDF) of an arrow. The arrow goes along the X axis.\\n * The shaft of the arrow has thickness TODO. The tip of the arrow has 30Â°\\n * angle, length of TODO, with the widest point being.\\n */\\nfloat sdArrow(float length, vec3 p) {\\n  float r = 0.01;\\n  return min(\\n    sdCylinder(\\n      0.02 - r,\\n      0.5 * (length - 0.1) - r,\\n      p.yzx - vec3(0, 0, 0.5 * (length - 0.1))\\n    ) -\\n      r,\\n    sdCone(\\n      vec2(sin(15.0 * DEGREE), cos(15.0 * DEGREE)),\\n      0.15 - r,\\n      p.zxy - vec3(0, length - r, 0)\\n    ) -\\n      r\\n  );\\n}\\nfloat sdArrow(vec3 a, vec3 b, vec3 p) {\\n  vec3 x = normalize(b - a);\\n  vec3 y = normalize(perpendicularVector(x));\\n  vec3 z = cross(x, y);\\n  return sdArrow(length(b - a), inverse(mat3(x, y, z)) * (p - a));\\n}\\n\\n// END ../common/sdf3d/sdArrow.glsl\\n// START ../common/sdf3d/sdBox.glsl\\n\\nfloat sdBox(vec3 r, vec3 p) {\\n  vec3 q = abs(p) - r;\\n  return length(max(q, 0.0)) + min(max3(q), 0.0);\\n}\\n\\nfloat sdBox(vec3 r, float r2, vec3 p) {\\n  return sdBox(r - r2, p) - r2;\\n}\\n\\n// #pragma glslify: export(sdBox)\\n\\n\\n// END ../common/sdf3d/sdBox.glsl\\n// START ../common/sdf3d/sdTorus.glsl\\nfloat sdTorus(float r0, float r1, vec3 p) {\\n  vec3 closestCenter = vec3(normalize(p.xy) * r0, 0.0);\\n  return distance(closestCenter, p) - r1;\\n}\\n\\n// #pragma glslify: export(sdTorus)\\n\\n\\n// END ../common/sdf3d/sdTorus.glsl\\n// START ../common/transform.glsl\\nvec3 transform(mat4 pm, vec3 p) {\\n  vec4 pStar = pm * vec4(p, 1);\\n  return pStar.xyz / pStar.w;\\n}\\n\\nvec2 transform(mat4 pm, vec2 p) {\\n  vec4 pStar = pm * vec4(p, 0, 1);\\n  return pStar.xy / pStar.w;\\n}\\n\\n// END ../common/transform.glsl\\n// START ../common/ungamma.glsl\\nvec3 ungamma(vec4 col) {\\n  return pow(col.rgb, vec3(2.2));\\n}\\nvec3 ungamma(vec3 col) {\\n  return pow(col, vec3(2.2));\\n}\\n\\n// END ../common/ungamma.glsl\\n// START ../common/visualize.glsl\\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\\n  float isLow = float(t < 0.0);\\n  float isHigh = float(t > 1.0);\\n  float isMid = 1.0 - isLow - isHigh;\\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\\n}\\n\\nvec4 visualize(float t) {\\n  const vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\\n  const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\\n  return visualize(BLUE, RED, t);\\n}\\n\\n// #pragma glslify: export(visualize)\\n\\n\\n// END ../common/visualize.glsl\\n\\nuniform sampler2D texture;\\nuniform float iTime;\\nuniform vec4 colorPrimary;\\nuniform vec4 colorSecondary;\\nuniform vec4 colorBackground;\\nuniform float a;\\nuniform float b;\\nuniform float c;\\nuniform float d;\\nuniform int bandCount;\\nuniform vec2 iResolution;\\nuniform vec2 iMouse;\\nin float n;\\nin vec2 coord;\\nout vec4 fragColor;\\n\\n\\nstruct Hit {\\n  float distance;\\n  vec4 color;\\n};\\nHit mixa(Hit a, Hit b, float t) {\\n  return Hit(mix(a.distance, b.distance, t), mix(a.color, b.color, t));\\n}\\nfloat skybox(vec3 p) {\\n  return 32.0 - max3(abs(p));\\n}\\n\\nHit add(Hit a, Hit b) {\\n  //    return a.distance < b.distance\\n  //        ? Hit(a.distance, a.color)\\n  //        : Hit(b.distance, b.color);\\n  return mixa(a, b, float(b.distance < a.distance));\\n}\\n\\nHit addFillet(float r, Hit a, Hit b) {\\n  if (a.distance < r && b.distance < r) {\\n    return Hit(\\n      r - distance(vec2(a.distance, b.distance), vec2(r)),\\n      mix(a.color, b.color, (a.distance - b.distance) / r * 0.5 + 0.5)\\n    );\\n  } else {\\n    return add(a, b);\\n  }\\n}\\n\\nHit addFillet(float r, Hit a, Hit b, vec4 tilletColor) {\\n  if (a.distance < r && b.distance < r) {\\n    return Hit(\\n      r - distance(vec2(a.distance, b.distance), vec2(r)),\\n      tilletColor\\n    );\\n  } else {\\n    return add(a, b);\\n  }\\n}\\nHit addFillet2(float r, Hit a, Hit b) {\\n  float h = smoothstep(-r, r, a.distance - b.distance);\\n  return Hit(\\n    mix(a.distance, b.distance, h) - r * h * (1.0 - h),\\n    mix(a.color, b.color, h)\\n  );\\n}\\n\\nHit neg(Hit a) {\\n  return Hit(-a.distance, a.color);\\n}\\nHit sub(Hit from, Hit what) {\\n  Hit whatNeg = neg(what);\\n  return mixa(from, whatNeg, float(whatNeg.distance > from.distance));\\n}\\n\\nvec3 modv(vec3 v, vec3 dir1, float y) {\\n  float t = dot(v, dir1);\\n  return v - floor(t / y) * y * dir1;\\n}\\nvec3 modRotZ(vec3 p, float count) {\\n  vec2 polarXY = toPolar(p.xy);\\n  return fromPolar(polarXY.x, mod(polarXY.y, TAU / count), p.z);\\n}\\n\\nfloat sin01(float x) {\\n  return 0.5 + 0.5 * sin(x);\\n}\\nfloat cos01(float x) {\\n  return 0.5 + 0.5 * cos(x);\\n}\\n\\nfloat smoothmin(float r, float a, float b) {\\n  float h = smoothstep(-r, r, a - b);\\n  return mix(a, b, h) - r * h * (1.0 - h);\\n}\\n\\nvec2 project(vec2 a, vec2 onto1) {\\n  return onto1 * (dot(a, onto1) / dot(onto1, onto1));\\n}\\n\\nvec3 reject(vec3 a, vec3 b1) {\\n  return a - b1 * dot(a, b1);\\n}\\nHit gizmo(vec3 p) {\\n  vec3 absp = abs(p);\\n\\n  Hit res = Hit(sdArrow(1.0, p), vec4(RED, 1));\\n  res = add(res, Hit(sdArrow(1.0, p.yzx), vec4(GREEN, 1)));\\n  res = add(res, Hit(sdArrow(1.0, p.zxy), vec4(BLUE, 1)));\\n  res = add(res, Hit(length(p) - 0.05, vec4(BLACK, 1)));\\n  return res;\\n}\\n/**\\n * Simple rubiks cube. Not actually 3x3x3 cubes but one static 3x3x2 block and\\n * one rotating 3x3x1. Axes are switched at the beginning so it looks like\\n * different moves are being made.\\n */\\nfloat rubiks(vec3 p) {\\n  const float turnTimeInv = 1.0 / 0.5;\\n  int turnNo = int(iTime * turnTimeInv) % 4;\\n  if (turnNo == 0) {\\n    p.x = -p.x;\\n  } else if (turnNo == 1) {\\n    p = vec3(p.y, p.z, -p.x);\\n  } else if (turnNo == 2) {\\n    p = p;\\n  } else {\\n    p = p.yzx;\\n  }\\n  p += 1.0;\\n  vec3 p1 = opRepLim(p, vec3(1), vec3(2, 1, 2));\\n  float d1 = sdBox(vec3(0.45), 0.05, p1);\\n\\n  vec3 p2 = p;\\n  p2 -= vec3(1, 0, 1);\\n  p2 = rotY(smoothstep(0.0, 1.0, fract(iTime * turnTimeInv)) * 0.5 * PI) * p2;\\n  p2 = opRepLim(p2 - vec3(-1, 2, -1), vec3(1), vec3(2, 0, 2));\\n  float d2 = sdBox(vec3(0.45), 0.05, p2);\\n\\n  return min(d1, d2);\\n}\\nfloat rots(vec3 p) {\\n  p.y -= -6.0;\\n  float turnTimeInv = 2.0 * pow(1.1, floor(p.y - 0.5));\\n  int turnNo = int(iTime * turnTimeInv) % 4;\\n  p.y = opRepLim(p.y - 2.0, 1.0, 7.0);\\n  float d2 = sdBox(\\n    vec3(0.4, 0.45, 0.8),\\n    0.05,\\n    rotY(iTime * turnTimeInv * 0.5 * PI) * p\\n  );\\n\\n  return d2;\\n}\\n\\nfloat sdOpExtrude(float thickness, float cornerRadius, float xyDist, float z) {\\n  xyDist += cornerRadius;\\n  z += cornerRadius;\\n  float zDist = abs(z) - 0.5 * thickness;\\n  return length(max(vec2(xyDist, zDist), 0.0)) +\\n  min(max(xyDist, zDist), 0.0) -\\n  cornerRadius;\\n}\\nfloat sdOpExtrude(float thickness, float xyDist, float z) {\\n  return sdOpExtrude(thickness, 0.0, xyDist, z);\\n}\\n#define MIN3(A, B, C) (min(min(A, B), C))\\n/**\\n * - S = sun gear teeth\\n * - P = planet gear teeth\\n * - R = ring gear teeth\\n *\\n * R+S must divide evenly by number of planets for teeth to mesh properly.\\n * (Specifically because the gears are evenly spaced.)\\n *\\n * cf https://woodgears.ca/gear/planetary.html\\n */\\nfloat gears(int S, vec2 p) {\\n  int P = 11,\\n    R = S + 2 * P;\\n  float t = 0.9 * iTime;\\n  p.xy = rot2(-t * -float(S) / float(R)) * p;\\n  float circularPitch = a;\\n  float gearDist = float(S + P) * circularPitch / TAU;\\n  float dRingBorder = length(p) - 5.0;\\n  if (dRingBorder > 0.0) {\\n    return dRingBorder;\\n  }\\n\\n  // sun gear\\n  vec2 p1 = p;\\n  p1 = rot2(t) * p1;\\n  float d1 = max(\\n    sdGear(S, 20.0 * DEGREE, circularPitch, p1),\\n    -(length(p1) - 0.2)\\n  );\\n\\n  // planet gear\\n  vec2 p2 = p;\\n  //  p2 = rot2(t * float(S) / float(S + R)) * p2;\\n  float angleSegment = floor(toPolar(p2).y / (TAU / 3.0) + 0.5);\\n  p2 = opRotSym(3.0, p2);\\n  p2 -= vec2(gearDist, 0);\\n  //  p2 = rot2(t * -float(S) / float(S + R)) * p2;\\n  p2 = rot2((-t + angleSegment * TAU / 3.0) * (float(S) / float(P))) * p2;\\n  float d2 = max(\\n    sdGear(P, 20.0 * DEGREE, circularPitch, p2),\\n    -(length(p2) - 0.2)\\n  );\\n\\n  // ring gear\\n  vec2 p3 = p;\\n  p3 = rot2(t * -float(S) / float(R)) * p3;\\n  float d3 = max(\\n    sdGearInternal(R, 20.0 * DEGREE, circularPitch, p3),\\n    dRingBorder\\n  );\\n  return min3(d1, d2, d3);\\n}\\nfloat gears(vec3 p) {\\n  p -= vec3(0, 0, 1);\\n  p = p.yzx;\\n  float d = sdOpExtrude(4.0, 0.02, gears(22, p.xy), p.z);\\n  return d;\\n}\\nfloat boxes(vec3 p) {\\n  float d1 = p.y - 2.0;\\n  float d2 = p.z - 1.2;\\n  float d3 = sdBox(vec3(4), p);\\n  return max(d1, d2);\\n}\\nconst float RR = 0.2;\\nfloat loader(vec2 p) {\\n  float d = 10000.0;\\n  float t = iTime * 6.0;\\n  for (int i = 0; i < 9; i++) {\\n    float fi = float(i);\\n    // same thing as 0 but offset in time by i:\\n    float ti = t + fi;\\n    float tt = floor(ti / 9.0) + linstep(8.0, 9.0, fract(ti / 9.0) * 9.0);\\n    // same thing as 0 but offset by i:\\n    tt += fi;\\n    vec2 p2 = rot2(tt * 40.0 * DEGREE) * p - vec2(RR / sin(20.0 * DEGREE), 0);\\n    float d2 = sdArcRect(20.0 * DEGREE, 10.0, vec2(6.0, 0.0), p2);\\n    d = min(d, d2);\\n  }\\n  return d - RR;\\n  //  return sdArc(b * PI, 10.0, 5.0, p);\\n}\\nfloat loader(vec3 p) {\\n  p -= vec3(0, 0, 1);\\n  p = p.yzx;\\n  float d = sdOpExtrude(4.0, RR, loader(p.xy), p.z);\\n  return d;\\n}\\nfloat spinring(vec3 p) {\\n  float l = abs(length(p) - 15.0);\\n  if (l > 2.0) {\\n    return l;\\n  }\\n  p.xy = rot2(p.z * a) * p.xy;\\n  return sdTorus(15.0, 0.3, p.zyx) * 0.1;\\n}\\nHit sdf(vec3 p) {\\n  vec3 p2 = p;\\n\\n  float ds;\\n  {\\n    float scale = 0.1;\\n    vec3 p2 = p - vec3(0.5, -0.5, 0.0);\\n    ds = rubiks(p2 / scale) * scale;\\n  }\\n  {\\n    vec3 p3 = p2;\\n    p3 -= vec3(-0.5, 0.5, 0);\\n    p3 = p3.zxy;\\n    ds = min(ds, gears(p3 * 15.0) / 15.0);\\n  }\\n  {\\n    vec3 p3 = p2;\\n    p3 -= vec3(0.5, 0.5, 0);\\n    ds = min(ds, loader(p3 * 100.0) * 00.01);\\n  }\\n  float dg = p.z;\\n  Hit hit;\\n  hit = Hit(ds, vec4(ungamma(colorPrimary), 1));\\n  return hit;\\n\\n  if (ds < dg) {\\n    hit = Hit(ds, vec4(ungamma(colorPrimary), 1));\\n  } else {\\n    float f = checkerboardGrad(p.xy);\\n\\n    vec3 color = mix(ungamma(colorBackground), ungamma(colorSecondary), f);\\n    hit = Hit(dg, vec4(color, 1));\\n  }\\n  hit = add(hit, gizmo(p2));\\n  return hit;\\n}\\nfloat sdff(vec3 p) {\\n  return sdf(p).distance;\\n}\\nfloat ambientOcclusion(vec3 pWC, vec3 n1WC) {\\n  float k = 1.0;\\n  float distance = sdff(pWC + n1WC * k);\\n  return clamp(distance / k, 0.0, 1.0);\\n}\\n\\nstruct RMResult {\\n  float distance;\\n  vec3 pos;\\n  vec4 color;\\n};\\nRMResult raymarching2(vec3 start, vec3 dir1) {\\n  vec3 pos = start;\\n  Hit hit;\\n  for (int i = 0; i < 500; i++) {\\n    hit = sdf(pos);\\n    if (hit.distance < 0.001 || hit.distance > 100.0) break;\\n    pos = pos + dir1 * hit.distance;\\n  }\\n  return RMResult(hit.distance, pos, hit.color);\\n}\\n\\nfloat softshadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {\\n  float res = 1.0;\\n  float t = 0.1;\\n  for (int i = 0; i < 100 && t < maxt; i++) {\\n    float h = sdff(ro + rd * t);\\n    if (h < 0.001) return 0.0;\\n    res = min(res, k * h / t);\\n    t += h;\\n  }\\n  return res;\\n}\\n\\nvec3 sdfNormal1(vec3 p, float d) {\\n  const float EPS = 1e-4;\\n  return normalize(\\n    vec3(\\n      sdff(p + vec3(EPS, 0.0, 0.0)),\\n      sdff(p + vec3(0.0, EPS, 0.0)),\\n      sdff(p + vec3(0.0, 0.0, EPS))\\n    ) -\\n      vec3(sdff(p))\\n  );\\n}\\n\\n//layout (depth_greater) out float gl_FragDepth;\\nvoid main() {\\n  vec3 camPos =\\n    vec3(5, 5, 5) +\\n    (-1.0 == iMouse.x\\n      ? vec3(0)\\n      : vec3(0, (iMouse / iResolution * 2.0 - 1.0) * 10.0));\\n  float aspectRatio = iResolution.x / iResolution.y;\\n  float width = 3.0;\\n  float height = width / aspectRatio;\\n  mat4 modelView =\\n    //    perspective(1.0, iResolution.x / iResolution.y, 0.1, 20.0) *\\n    ortho(-0.5 * width, 0.5 * width, -0.5 * height, 0.5 * height, 0.1, 20.0) *\\n    lookAt(camPos, vec3(0, 0, 0.0), vec3(0, 0, 1));\\n  mat4 modelViewInverse = inverse(modelView);\\n\\n  vec3 light = normalize(vec3(-0.1, -1, -5));\\n\\n  vec3 a = vec3(coord * 2.0 - 1.0, -1.0);\\n  vec3 b = vec3(coord * 2.0 - 1.0, 1.0);\\n  vec3 aWC = transform(modelViewInverse, a);\\n  vec3 bWC = transform(modelViewInverse, b);\\n  vec3 lookDir1 = normalize(bWC - aWC);\\n\\n  RMResult hitWC = raymarching2(aWC, lookDir1);\\n  vec3 hitn1 = sdfNormal1(hitWC.pos, hitWC.distance);\\n  float dWC = distance(aWC, hitWC.pos);\\n  vec3 hitNDC = transform(modelView, hitWC.pos);\\n  vec3 p = hitWC.pos;\\n  //  float inSun = softshadow(\\n  //    hitWC.pos + hitn1 * 0.05,\\n  //    -light,\\n  //    0.0001,\\n  //    300.0,\\n  //    8.0\\n  //  );\\n  float inSun = 1.0;\\n  //    float inSun=1.;\\n\\n  vec3 color;\\n  vec3 material = hitWC.color.xyz;\\n  if (hitWC.distance > 20.0) {\\n    color = ungamma(colorBackground);\\n  } else {\\n    color = vec3(0.0);\\n    const vec3 sunlightColor = vec3(3.0);\\n\\n    //  float aOcc = ambientOcclusion(hitWC.pos, hitn1);\\n    float aOcc = 1.0;\\n\\n    vec3 reflectionDirection = reflect(light, hitn1);\\n\\n    //  color += material * aOcc;\\n    color += inSun * sunlightColor * material * max(0.0, dot(-light, hitn1));\\n    //    color = (hitn1);\\n    vec3 eyeDirection = -lookDir1;\\n    float uMaterialShininess = 256.0;\\n    float specularLightWeighting = pow(\\n      max(dot(reflectionDirection, eyeDirection), 0.0),\\n      uMaterialShininess\\n    );\\n    //  color += specularLightWeighting;\\n    //    float lightIntensity = 0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.);\\n    //    float lightIntensity =\\n    //        0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.) + 0.3*specularLightWeighting;\\n    //    fragColor = visualize(blue, red, mix(0.5, 1.0, inSun) * lightIntensity);\\n    //    fragColor = mix(hitWC.color, colorBackground, mix(0.5, 1.0, inSun) * clamp(lightIntensity, 0., 1.));\\n    color = pow(color, vec3(1.0 / 2.2)); // gamma correction\\n  }\\n\\n  fragColor = vec4(color, 1.0);\\n}\\n\\nvoid mainImage(out vec4 c, vec2 w) {\\n  vec4 p = vec4(w, 0.0, 1.0);\\n\\n  float v = 0.0,\\n    f,\\n    r[17];\\n  vec4 s = vec4(2, 2, 1, 0);\\n\\n  for (int i = 0; i < 17; i++) r[i] = 0.0;\\n\\n  r[0] = p.x + p.y;\\n  r[1] = p.y;\\n\\n  for (int i = 0; i < 17; i++) {\\n    f = -2.0 * floor(r[i] / 2.0) / s[0];\\n    for (int j = 0; j < 3; j++) {\\n      r[i + j] += f * s[j];\\n    }\\n\\n  }\\n\\n  for (int i = 0; i < 17; i++) {\\n    v += mod(r[i], 2.0) * exp2(float(i));\\n  }\\n  v /= exp2(17.0);\\n\\n  c = vec4(v);\\n}\\n\"\nconst sourceMap = {\"version\":3,\"sources\":[\"/home/runner/work/workshop/workshop/src/noises/magic2.frag\",\"/home/runner/work/workshop/workshop/src/common/banded.glsl\",\"/home/runner/work/workshop/workshop/src/common/checkerboardGrad.glsl\",\"/home/runner/work/workshop/workshop/src/common/colors.glsl\",\"/home/runner/work/workshop/workshop/src/common/linstep.glsl\",\"/home/runner/work/workshop/workshop/src/common/constants.glsl\",\"/home/runner/work/workshop/workshop/src/common/matrices.glsl\",\"/home/runner/work/workshop/workshop/src/common/max3.glsl\",\"/home/runner/work/workshop/workshop/src/common/min3.glsl\",\"/home/runner/work/workshop/workshop/src/common/unmix.glsl\",\"/home/runner/work/workshop/workshop/src/common/fromPolar.glsl\",\"/home/runner/work/workshop/workshop/src/common/toPolar.glsl\",\"/home/runner/work/workshop/workshop/src/common/polar.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf2d/sdArcRect.glsl\",\"/home/runner/work/workshop/workshop/src/common/dot2.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf2d/addFillet.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf2d/sdGear.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/opRepLim.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdCylinder.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdCone.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdArrow.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdBox.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdTorus.glsl\",\"/home/runner/work/workshop/workshop/src/common/transform.glsl\",\"/home/runner/work/workshop/workshop/src/common/ungamma.glsl\",\"/home/runner/work/workshop/workshop/src/common/visualize.glsl\"],\"names\":[],\"mappings\":\"AAAA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC5IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AChHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AzBOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA\"}\nexport { sourceMap };\n","\nexport default \"#version 300 es\\n\\nprecision highp float;\\n\\n// START ../common/banded.glsl\\nfloat banded(float bandCount, float t) {\\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\\n}\\nfloat banded(int bandCount, float t) {\\n  return banded(float(bandCount), t);\\n}\\n\\n// #pragma glslify: export(banded)\\n\\n\\n// END ../common/banded.glsl\\n// START ../common/matrices.glsl\\n// START ./constants.glsl\\nconst float SQRT1_2 = 0.7071067811865476;\\nconst float SQRT1_3 = 0.57735026919;\\nconst float SQRT2 = 1.4142135623730951;\\nconst float SQRT3 = 1.732050807568877;\\n// sqrt(3)/2 = sin(60*)\\nconst float SQRT3_2 = 0.86602540378;\\nconst float GOLDEN_RATIO = 1.61803398875;\\nconst float PI = 3.141592653589793;\\nconst float TAU = 6.28318530718;\\n/**\\n * One degree in radians. Use like `sin(30 * DEG)`.\\n */\\nconst float DEGREE = 0.017453292519943295;\\n\\n// END ./constants.glsl\\n\\nmat2 rot2(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat2(c, s, -s, c);\\n}\\nmat3 rotX(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\\n}\\nmat3 rotY(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\\n}\\nmat3 rotZ(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\\n}\\n/**\\n * Returns a matrix that puts the camera at the eye point `ex, ey, ez` looking\\n * toward the center point `cx, cy, cz` with an up direction of `ux, uy, uz`.\\n * This emulates the OpenGL function `gluLookAt()`.\\n */\\nmat4 lookAt(vec3 eye, vec3 focus, vec3 up) {\\n  vec3 f = normalize(eye - focus);\\n  vec3 s = normalize(cross(up, f));\\n  vec3 t = normalize(cross(f, s));\\n\\n  return mat4(\\n    vec4(s.x, t.x, f.x, 0.0),\\n    vec4(s.y, t.y, f.y, 0.0),\\n    vec4(s.z, t.z, f.z, 0.0),\\n    vec4(-dot(s, eye), -dot(t, eye), -dot(f, eye), 1)\\n  );\\n}\\n\\n// the OpenGL function `glFrustum()`.\\nmat4 frustum(\\n  float left,\\n  float right,\\n  float bottom,\\n  float top,\\n  float near,\\n  float far\\n) {\\n  return mat4(\\n    vec4(2.0 * near / (right - left), 0.0, 0.0, 0.0),\\n    vec4(0, 2.0 * near / (top - bottom), 0.0, 0.0),\\n    vec4(\\n      (right + left) / (right - left),\\n      (top + bottom) / (top - bottom),\\n      -(far + near) / (far - near),\\n      -1\\n    ),\\n    vec4(0.0, 0.0, -2.0 * far * near / (far - near), 0.0)\\n  );\\n}\\n\\nmat4 perspective(float fovDegrees, float aspect, float near, float far) {\\n  float y = tan(fovDegrees * DEGREE / 2.0) * near;\\n  float x = y * aspect;\\n  return frustum(-x, x, -y, y, near, far);\\n}\\nmat4 ortho(\\n  float left,\\n  float right,\\n  float bottom,\\n  float top,\\n  float near,\\n  float far\\n) {\\n  return mat4(\\n    vec4(2.0 / (right - left), 0.0, 0.0, 0.0),\\n    vec4(0.0, 2.0 / (top - bottom), 0.0, 0.0),\\n    vec4(0.0, 0.0, -2.0 / (far - near), 0.0),\\n    vec4(\\n      -(right + left) / (right - left),\\n      -(top + bottom) / (top - bottom),\\n      -(far + near) / (far - near),\\n      1.0\\n    )\\n  );\\n}\\n\\n// END ../common/matrices.glsl\\n// START ../common/max3.glsl\\nfloat max3(float a, float b, float c) {\\n  return max(a, max(b, c));\\n}\\nfloat max3(vec3 v) {\\n  return max(v.x, max(v.y, v.z));\\n}\\n\\n// #pragma glslify: export(max3)\\n\\n\\n// END ../common/max3.glsl\\n// START ../common/visualize.glsl\\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\\n  float isLow = float(t < 0.0);\\n  float isHigh = float(t > 1.0);\\n  float isMid = 1.0 - isLow - isHigh;\\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\\n}\\n\\nvec4 visualize(float t) {\\n  const vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\\n  const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\\n  return visualize(BLUE, RED, t);\\n}\\n\\n// #pragma glslify: export(visualize)\\n\\n\\n// END ../common/visualize.glsl\\n// START ../common/polar.glsl\\n// START ../common/fromPolar.glsl\\n// START ./unmix.glsl\\nfloat unmix(float a, float b, float value) {\\n  return (value - a) / (b - a);\\n}\\n\\n// #pragma glslify: export(unmix)\\n\\n\\n// END ./unmix.glsl\\n\\nvec3 fromPolar(float radius, float phi, float z) {\\n  return vec3(radius * cos(phi), radius * sin(phi), z);\\n}\\n\\nvec2 fromPolar(float radius, float phi) {\\n  return vec2(radius * cos(phi), radius * sin(phi));\\n}\\n\\nvec2 fromPolar(vec2 polar) {\\n  return fromPolar(polar.x, polar.y);\\n}\\n\\n// #pragma glslify: export(fromPolar)\\n\\n\\n// END ../common/fromPolar.glsl\\n// START ../common/toPolar.glsl\\n\\nvec2 toPolar(vec2 xy) {\\n  return vec2(length(xy), atan(xy.y, xy.x));\\n}\\n\\nmat2 toPolarDerivate(vec2 xy) {\\n  return mat2(xy.x * xy.x, xy.y * xy.y, -xy.y, xy.x) / dot(xy, xy);\\n}\\n\\n// #pragma glslify: export(toPolar)\\n\\n\\n// END ../common/toPolar.glsl\\n\\n// END ../common/polar.glsl\\n// START ../common/ungamma.glsl\\nvec3 ungamma(vec4 col) {\\n  return pow(col.rgb, vec3(2.2));\\n}\\nvec3 ungamma(vec3 col) {\\n  return pow(col, vec3(2.2));\\n}\\n\\n// END ../common/ungamma.glsl\\n// START ../common/transform.glsl\\nvec3 transform(mat4 pm, vec3 p) {\\n  vec4 pStar = pm * vec4(p, 1);\\n  return pStar.xyz / pStar.w;\\n}\\n\\nvec2 transform(mat4 pm, vec2 p) {\\n  vec4 pStar = pm * vec4(p, 0, 1);\\n  return pStar.xy / pStar.w;\\n}\\n\\n// END ../common/transform.glsl\\n// START ../common/squareWave.glsl\\nfloat squareWave(float x) {\\n  return floor(2.0 * fract(0.5 * x));\\n}\\n\\n// END ../common/squareWave.glsl\\n// START ../common/OpenSimplex2.glsl\\n//////////////// K.jpg's Re-oriented 4-Point BCC Noise (OpenSimplex2) ////////////////\\n////////////////////// Output: vec4(dF/dx, dF/dy, dF/dz, value) //////////////////////\\n\\n// Inspired by Stefan Gustavson's noise\\nvec4 permute(vec4 t) {\\n  return t * (t * 34.0 + 133.0);\\n}\\n\\n// Gradient set is a normalized expanded rhombic dodecahedron\\nvec3 grad(float hash) {\\n  // Random vertex of a cube, +/- 1 each\\n  vec3 cube = mod(floor(hash / vec3(1.0, 2.0, 4.0)), 2.0) * 2.0 - 1.0;\\n\\n  // Random edge of the three edges connected to that vertex\\n  // Also a cuboctahedral vertex\\n  // And corresponds to the face of its dual, the rhombic dodecahedron\\n  vec3 cuboct = cube;\\n  cuboct[int(hash / 16.0)] = 0.0;\\n\\n  // In a funky way, pick one of the four points on the rhombic face\\n  float type = mod(floor(hash / 8.0), 2.0);\\n  vec3 rhomb = (1.0 - type) * cube + type * (cuboct + cross(cube, cuboct));\\n\\n  // Expand it so that the new edges are the same length\\n  // as the existing ones\\n  vec3 grad = cuboct * 1.22474487139 + rhomb;\\n\\n  // To make all gradients the same length, we only need to shorten the\\n  // second type of vector. We also put in the whole noise scale constant.\\n  // The compiler should reduce it into the existing floats. I think.\\n  grad *= (1.0 - 0.042942436724648037 * type) * 32.80201376986577;\\n\\n  return grad;\\n}\\n\\n// BCC lattice split up into 2 cube lattices\\nvec4 openSimplex2Base(vec3 X) {\\n  // First half-lattice, closest edge\\n  vec3 v1 = round(X);\\n  vec3 d1 = X - v1;\\n  vec3 score1 = abs(d1);\\n  vec3 dir1 = step(max(score1.yzx, score1.zxy), score1);\\n  vec3 v2 = v1 + dir1 * sign(d1);\\n  vec3 d2 = X - v2;\\n\\n  // Second half-lattice, closest edge\\n  vec3 X2 = X + 144.5;\\n  vec3 v3 = round(X2);\\n  vec3 d3 = X2 - v3;\\n  vec3 score2 = abs(d3);\\n  vec3 dir2 = step(max(score2.yzx, score2.zxy), score2);\\n  vec3 v4 = v3 + dir2 * sign(d3);\\n  vec3 d4 = X2 - v4;\\n\\n  // Gradient hashes for the four points, two from each half-lattice\\n  vec4 hashes = permute(mod(vec4(v1.x, v2.x, v3.x, v4.x), 289.0));\\n  hashes = permute(mod(hashes + vec4(v1.y, v2.y, v3.y, v4.y), 289.0));\\n  hashes = mod(\\n    permute(mod(hashes + vec4(v1.z, v2.z, v3.z, v4.z), 289.0)),\\n    48.0\\n  );\\n\\n  // Gradient extrapolations & kernel function\\n  vec4 a = max(\\n    0.5 - vec4(dot(d1, d1), dot(d2, d2), dot(d3, d3), dot(d4, d4)),\\n    0.0\\n  );\\n  vec4 aa = a * a;\\n  vec4 aaaa = aa * aa;\\n  vec3 g1 = grad(hashes.x);\\n  vec3 g2 = grad(hashes.y);\\n  vec3 g3 = grad(hashes.z);\\n  vec3 g4 = grad(hashes.w);\\n  vec4 extrapolations = vec4(\\n    dot(d1, g1),\\n    dot(d2, g2),\\n    dot(d3, g3),\\n    dot(d4, g4)\\n  );\\n\\n  // Derivatives of the noise\\n  vec3 derivative =\\n    -8.0 * mat4x3(d1, d2, d3, d4) * (aa * a * extrapolations) +\\n    mat4x3(g1, g2, g3, g4) * aaaa;\\n\\n  // Return it all as a vec4\\n  return vec4(derivative, dot(aaaa, extrapolations));\\n}\\n\\n// Use this if you don't want Z to look different from X and Y\\nvec4 openSimplex2_Conventional(vec3 X) {\\n  // Rotate around the main diagonal. Not a skew transform.\\n  vec4 result = openSimplex2Base(dot(X, vec3(2.0 / 3.0)) - X);\\n  return vec4(dot(result.xyz, vec3(2.0 / 3.0)) - result.xyz, result.w);\\n}\\n\\n// Use this if you want to show X and Y in a plane, then use Z for time, vertical, etc.\\nvec4 openSimplex2_ImproveXY(vec3 X) {\\n  // Rotate so Z points down the main diagonal. Not a skew transform.\\n  mat3 orthonormalMap = mat3(\\n    vec3(0.788675134594813, -0.211324865405187, -0.577350269189626),\\n    vec3(-0.211324865405187, 0.788675134594813, -0.577350269189626),\\n    vec3(0.577350269189626, 0.577350269189626, 0.577350269189626)\\n  );\\n\\n  vec4 result = openSimplex2Base(orthonormalMap * X);\\n  return vec4(result.xyz * orthonormalMap, result.w);\\n}\\n\\n//////////////////////////////// End noise code ////////////////////////////////\\n\\n\\n// END ../common/OpenSimplex2.glsl\\n// START ../common/checkerboardGrad.glsl\\n//https://iquilezles.org/articles/checkerfiltering/\\nfloat tri(float x) {\\n  float h = fract(x * 0.5) - 0.5;\\n  return 1.0 - 2.0 * abs(h);\\n}\\nvec2 tri(vec2 x) {\\n  vec2 h = fract(x * 0.5) - 0.5;\\n  return 1.0 - 2.0 * abs(h);\\n}\\n\\nfloat checkerboardGrad(vec2 uv) {\\n  vec2 w = max(abs(dFdx(uv)), abs(dFdy(uv))) + 0.01; // filter kernel\\n  vec2 i = (tri(uv + 0.5 * w) - tri(uv - 0.5 * w)) / w; // analytical integral (box filter)\\n  return 0.5 - 0.5 * i.x * i.y; // xor pattern\\n}\\n\\n// END ../common/checkerboardGrad.glsl\\n// START ../common/colors.glsl\\nconst vec3 INDIAN_RED = vec3(0.804, 0.361, 0.361);\\nconst vec3 LIGHT_CORAL = vec3(0.941, 0.502, 0.502);\\nconst vec3 SALMON = vec3(0.98, 0.502, 0.447);\\nconst vec3 DARK_SALMON = vec3(0.914, 0.588, 0.478);\\nconst vec3 LIGHT_SALMON = vec3(1.0, 0.627, 0.478);\\nconst vec3 CRIMSON = vec3(0.863, 0.078, 0.235);\\nconst vec3 RED = vec3(1.0, 0.0, 0.0);\\nconst vec3 FIRE_BRICK = vec3(0.698, 0.133, 0.133);\\nconst vec3 DARK_RED = vec3(0.545, 0.0, 0.0);\\nconst vec3 PINK = vec3(1.0, 0.753, 0.796);\\nconst vec3 LIGHT_PINK = vec3(1.0, 0.714, 0.757);\\nconst vec3 HOT_PINK = vec3(1.0, 0.412, 0.706);\\nconst vec3 DEEP_PINK = vec3(1.0, 0.078, 0.576);\\nconst vec3 MEDIUM_VIOLET_RED = vec3(0.78, 0.082, 0.522);\\nconst vec3 PALE_VIOLET_RED = vec3(0.859, 0.439, 0.576);\\nconst vec3 CORAL = vec3(1.0, 0.498, 0.314);\\nconst vec3 TOMATO = vec3(1.0, 0.388, 0.278);\\nconst vec3 ORANGE_RED = vec3(1.0, 0.271, 0.0);\\nconst vec3 DARK_ORANGE = vec3(1.0, 0.549, 0.0);\\nconst vec3 ORANGE = vec3(1.0, 0.647, 0.0);\\nconst vec3 GOLD = vec3(1.0, 0.843, 0.0);\\nconst vec3 YELLOW = vec3(1.0, 1.0, 0.0);\\nconst vec3 LIGHT_YELLOW = vec3(1.0, 1.0, 0.878);\\nconst vec3 LEMON_CHION = vec3(1.0, 0.98, 0.804);\\nconst vec3 LIGHT_GOLDENROD_YELLOW = vec3(0.98, 0.98, 0.824);\\nconst vec3 PAPAYA_WHIP = vec3(1.0, 0.937, 0.835);\\nconst vec3 MOCCASIN = vec3(1.0, 0.894, 0.71);\\nconst vec3 PEACH_PU = vec3(1.0, 0.855, 0.725);\\nconst vec3 PALE_GOLDENROD = vec3(0.933, 0.91, 0.667);\\nconst vec3 KHAKI = vec3(0.941, 0.902, 0.549);\\nconst vec3 DARK_KHAKI = vec3(0.741, 0.718, 0.42);\\nconst vec3 LAVENDER = vec3(0.902, 0.902, 0.98);\\nconst vec3 THISTLE = vec3(0.847, 0.749, 0.847);\\nconst vec3 PLUM = vec3(0.867, 0.627, 0.867);\\nconst vec3 VIOLET = vec3(0.933, 0.51, 0.933);\\nconst vec3 ORCHID = vec3(0.855, 0.439, 0.839);\\nconst vec3 FUCHSIA = vec3(1.0, 0.0, 1.0);\\nconst vec3 MAGENTA = vec3(1.0, 0.0, 1.0);\\nconst vec3 MEDIUM_ORCHID = vec3(0.729, 0.333, 0.827);\\nconst vec3 MEDIUM_PURPLE = vec3(0.576, 0.439, 0.859);\\nconst vec3 BLUE_VIOLET = vec3(0.541, 0.169, 0.886);\\nconst vec3 DARK_VIOLET = vec3(0.58, 0.0, 0.827);\\nconst vec3 DARK_ORCHID = vec3(0.6, 0.196, 0.8);\\nconst vec3 DARK_MAGENTA = vec3(0.545, 0.0, 0.545);\\nconst vec3 PURPLE = vec3(0.502, 0.0, 0.502);\\nconst vec3 INDIGO = vec3(0.294, 0.0, 0.51);\\nconst vec3 SLATE_BLUE = vec3(0.416, 0.353, 0.804);\\nconst vec3 DARK_SLATE_BLUE = vec3(0.282, 0.239, 0.545);\\nconst vec3 GREEN_YELLOW = vec3(0.678, 1.0, 0.184);\\nconst vec3 CHARTREUSE = vec3(0.498, 1.0, 0.0);\\nconst vec3 LAWN_GREEN = vec3(0.486, 0.988, 0.0);\\nconst vec3 LIME = vec3(0.0, 1.0, 0.0);\\nconst vec3 LIME_GREEN = vec3(0.196, 0.804, 0.196);\\nconst vec3 PALE_GREEN = vec3(0.596, 0.984, 0.596);\\nconst vec3 LIGHT_GREEN = vec3(0.565, 0.933, 0.565);\\nconst vec3 MEDIUM_SPRING_GREEN = vec3(0.0, 0.98, 0.604);\\nconst vec3 SPRING_GREEN = vec3(0.0, 1.0, 0.498);\\nconst vec3 MEDIUM_SEA_GREEN = vec3(0.235, 0.702, 0.443);\\nconst vec3 SEA_GREEN = vec3(0.18, 0.545, 0.341);\\nconst vec3 FOREST_GREEN = vec3(0.133, 0.545, 0.133);\\nconst vec3 GREEN = vec3(0.0, 0.502, 0.0);\\nconst vec3 DARK_GREEN = vec3(0.0, 0.392, 0.0);\\nconst vec3 YELLOW_GREEN = vec3(0.604, 0.804, 0.196);\\nconst vec3 OLIVE_DRAB = vec3(0.42, 0.557, 0.137);\\nconst vec3 OLIVE = vec3(0.502, 0.502, 0.0);\\nconst vec3 DARK_OLIVE_GREEN = vec3(0.333, 0.42, 0.184);\\nconst vec3 MEDIUM_AQUAMARINE = vec3(0.4, 0.804, 0.667);\\nconst vec3 DARK_SEA_GREEN = vec3(0.561, 0.737, 0.561);\\nconst vec3 LIGHT_SEA_GREEN = vec3(0.125, 0.698, 0.667);\\nconst vec3 DARK_CYAN = vec3(0.0, 0.545, 0.545);\\nconst vec3 TEAL = vec3(0.0, 0.502, 0.502);\\nconst vec3 AQUA = vec3(0.0, 1.0, 1.0);\\nconst vec3 CYAN = vec3(0.0, 1.0, 1.0);\\nconst vec3 LIGHT_CYAN = vec3(0.878, 1.0, 1.0);\\nconst vec3 PALE_TURQUOISE = vec3(0.686, 0.933, 0.933);\\nconst vec3 AQUAMARINE = vec3(0.498, 1.0, 0.831);\\nconst vec3 TURQUOISE = vec3(0.251, 0.878, 0.816);\\nconst vec3 MEDIUM_TURQUOISE = vec3(0.282, 0.82, 0.8);\\nconst vec3 DARK_TURQUOISE = vec3(0.0, 0.808, 0.82);\\nconst vec3 CADET_BLUE = vec3(0.373, 0.62, 0.627);\\nconst vec3 STEEL_BLUE = vec3(0.275, 0.51, 0.706);\\nconst vec3 LIGHT_STEEL_BLUE = vec3(0.69, 0.769, 0.871);\\nconst vec3 POWDER_BLUE = vec3(0.69, 0.878, 0.902);\\nconst vec3 LIGHT_BLUE = vec3(0.678, 0.847, 0.902);\\nconst vec3 SKY_BLUE = vec3(0.529, 0.808, 0.922);\\nconst vec3 LIGHT_SKY_BLUE = vec3(0.529, 0.808, 0.98);\\nconst vec3 DEEP_SKY_BLUE = vec3(0.0, 0.749, 1.0);\\nconst vec3 DODGER_BLUE = vec3(0.118, 0.565, 1.0);\\nconst vec3 CORNLOWER_BLUE = vec3(0.392, 0.584, 0.929);\\nconst vec3 MEDIUM_SLATE_BLUE = vec3(0.482, 0.408, 0.933);\\nconst vec3 ROYAL_BLUE = vec3(0.255, 0.412, 0.882);\\nconst vec3 BLUE = vec3(0.0, 0.0, 1.0);\\nconst vec3 MEDIUM_BLUE = vec3(0.0, 0.0, 0.804);\\nconst vec3 DARK_BLUE = vec3(0.0, 0.0, 0.545);\\nconst vec3 NAVY = vec3(0.0, 0.0, 0.502);\\nconst vec3 MIDNIGHT_BLUE = vec3(0.098, 0.098, 0.439);\\nconst vec3 CORNSILK = vec3(1.0, 0.973, 0.863);\\nconst vec3 BLANCHED_ALMOND = vec3(1.0, 0.922, 0.804);\\nconst vec3 BISQUE = vec3(1.0, 0.894, 0.769);\\nconst vec3 NAVAJO_WHITE = vec3(1.0, 0.871, 0.678);\\nconst vec3 WHEAT = vec3(0.961, 0.871, 0.702);\\nconst vec3 BURLY_WOOD = vec3(0.871, 0.722, 0.529);\\nconst vec3 TAN = vec3(0.824, 0.706, 0.549);\\nconst vec3 ROSY_BROWN = vec3(0.737, 0.561, 0.561);\\nconst vec3 SANDY_BROWN = vec3(0.957, 0.643, 0.376);\\nconst vec3 GOLDENROD = vec3(0.855, 0.647, 0.125);\\nconst vec3 DARK_GOLDENROD = vec3(0.722, 0.525, 0.043);\\nconst vec3 PERU = vec3(0.804, 0.522, 0.247);\\nconst vec3 CHOCOLATE = vec3(0.824, 0.412, 0.118);\\nconst vec3 SADDLE_BROWN = vec3(0.545, 0.271, 0.075);\\nconst vec3 SIENNA = vec3(0.627, 0.322, 0.176);\\nconst vec3 BROWN = vec3(0.647, 0.165, 0.165);\\nconst vec3 MAROON = vec3(0.502, 0.0, 0.0);\\nconst vec3 WHITE = vec3(1.0, 1.0, 1.0);\\nconst vec3 SNOW = vec3(1.0, 0.98, 0.98);\\nconst vec3 HONEYDEW = vec3(0.941, 1.0, 0.941);\\nconst vec3 MINT_CREAM = vec3(0.961, 1.0, 0.98);\\nconst vec3 AZURE = vec3(0.941, 1.0, 1.0);\\nconst vec3 ALICE_BLUE = vec3(0.941, 0.973, 1.0);\\nconst vec3 GHOST_WHITE = vec3(0.973, 0.973, 1.0);\\nconst vec3 WHITE_SMOKE = vec3(0.961, 0.961, 0.961);\\nconst vec3 SEASHELL = vec3(1.0, 0.961, 0.933);\\nconst vec3 BEIGE = vec3(0.961, 0.961, 0.863);\\nconst vec3 OLD_LACE = vec3(0.992, 0.961, 0.902);\\nconst vec3 FLORAL_WHITE = vec3(1.0, 0.98, 0.941);\\nconst vec3 IVORY = vec3(1.0, 1.0, 0.941);\\nconst vec3 ANTIQUE_WHITE = vec3(0.98, 0.922, 0.843);\\nconst vec3 LINEN = vec3(0.98, 0.941, 0.902);\\nconst vec3 LAVENDER_BLUSH = vec3(1.0, 0.941, 0.961);\\nconst vec3 MISTY_ROSE = vec3(1.0, 0.894, 0.882);\\nconst vec3 GAINSBORO = vec3(0.863, 0.863, 0.863);\\nconst vec3 LIGHT_GREY = vec3(0.827, 0.827, 0.827);\\nconst vec3 SILVER = vec3(0.753, 0.753, 0.753);\\nconst vec3 DARK_GRAY = vec3(0.663, 0.663, 0.663);\\nconst vec3 GRAY = vec3(0.502, 0.502, 0.502);\\nconst vec3 DIM_GRAY = vec3(0.412, 0.412, 0.412);\\nconst vec3 LIGHT_SLATE_GRAY = vec3(0.467, 0.533, 0.6);\\nconst vec3 SLATE_GRAY = vec3(0.439, 0.502, 0.565);\\nconst vec3 DARK_SLATE_GRAY = vec3(0.184, 0.31, 0.31);\\nconst vec3 BLACK = vec3(0.0, 0.0, 0.0);\\n\\n// END ../common/colors.glsl\\n// START ../common/sdf3d/sdIcosahedron.glsl\\n\\n// signed distance function for icosahedron\\n// cf. https://en.wikipedia.org/wiki/Regular_icosahedron\\n// s: edge length\\n// p: point to evaluate function for\\nfloat sdIcosahedron(float s, vec3 p) {\\n  // NN = 1/GOLDEN_RATIO = GOLDEN_RATIO - 1\\n  const float K = GOLDEN_RATIO * 0.5;\\n  // the three vertices of the icosahedron triangle which\\n  // is fully inside the +++ octant. (edge length = 1)\\n  const vec3 a = vec3(0.5, K, 0.0);\\n  const vec3 b = vec3(0.0, 0.5, K);\\n  const vec3 c = vec3(K, 0.0, 0.5);\\n  const vec3 ab1 = b - a; // values chosen so edge length is 1\\n  const vec3 n1 = normalize(cross(a, b));\\n  const vec3 n2 = normalize(cross(b, c));\\n  const vec3 n3 = normalize(cross(c, a));\\n  const vec3 xyz1 = normalize(vec3(1.0));\\n  // for edge-length 1\\n  const float INSCRIBED_SPHERE_RADIUS = 0.7557613141;\\n\\n  // we use a rotation where the icosahedron is symmetric\\n  // in all three coordinate planes, and reduce the problem\\n  // to the +++ octant\\n  p = abs(p);\\n\\n  // there is one complete triangle in the +++ octant\\n  // mirror on planes which go through origin and the\\n  // complete triangles sides.\\n  if (dot(p, n1) < 0.0) {\\n    p += -2.0 * dot(p, n1) * n1;\\n  }\\n  if (dot(p, n2) < 0.0) {\\n    p += -2.0 * dot(p, n2) * n2;\\n  }\\n  if (dot(p, n3) < 0.0) {\\n    p += -2.0 * dot(p, n3) * n3;\\n  }\\n\\n  // rotate space around (1,1,1) vector so that all sides of the triangle\\n  // end up mapped on the ab side.\\n  vec3 dirs = vec3(-dot(n1, p), -dot(n2, p), -dot(n3, p));\\n  if (dirs.y > dirs.x && dirs.y > dirs.z) {\\n    p = p.yzx;\\n  } else if (dirs.z > dirs.x && dirs.z > dirs.y) {\\n    p = p.zxy;\\n  }\\n\\n  // check if the point is directly (perpendicular) above the triangle.\\n  // as we have rotated the space, we only need to check if it is\\n  // inside one edge.\\n  vec3 midAB = (a + b) / 2.0;\\n  vec3 pn = normalize(c - midAB);\\n  float w = dot(midAB, pn);\\n  if (dot(p, pn) > w * s) {\\n    // if not, return the distance to the plane the triangle is in\\n    return dot(xyz1, p) - INSCRIBED_SPHERE_RADIUS * s;\\n  }\\n\\n  // project the point onto segment ab, and return the distance to it\\n  float d3 = dot(ab1, p);\\n  d3 = clamp(d3, -0.5 * s, 0.5 * s);\\n  vec3 closestp = midAB * s + d3 * ab1;\\n  return distance(closestp, p);\\n}\\n// #pragma glslify: export(sdIcosahedron)\\n\\n// END ../common/sdf3d/sdIcosahedron.glsl\\n// START ../common/sdf3d/sdDodecahedron.glsl\\n\\nfloat sdDodecahedron(float s, vec3 p, out vec3 color) {\\n  const float PHI = GOLDEN_RATIO;\\n  color = vec3(0.2);\\n  if (p != abs(p)) {\\n    p = abs(p);\\n    if (color == vec3(0.2)) color = RED;\\n  }\\n  p = abs(p);\\n  const vec3 fv =\\n    vec3(1.0 / PHI, 0, PHI) + 2.0 * vec3(1, 0, 1) + 2.0 * vec3(PHI, 0, 0);\\n  const vec3 fv2 =\\n    vec3(PHI, 1.0 / PHI, 0) + 2.0 * vec3(1, 1, 0) + 2.0 * vec3(0, PHI, 0);\\n  const vec3 fv3 =\\n    vec3(0, PHI, 1.0 / PHI) + 2.0 * vec3(0, 1, 1) + 2.0 * vec3(0, 0, PHI);\\n  return max3(\\n    dot(normalize(fv), p),\\n    dot(normalize(fv2), p),\\n    dot(normalize(fv3), p)\\n  ) -\\n  s;\\n  //  float m = p.x + p.y + p.z - s;\\n  //  vec3 q;\\n  //  if (3.0 * p.x < m) q = p.xyz;\\n  //  else if (3.0 * p.y < m) q = p.yzx;\\n  //  else if (3.0 * p.z < m) q = p.zxy;\\n  //  else return m * 0.57735027;\\n  //\\n  //  float k = clamp(0.5 * (q.z - q.y + s), 0.0, s);\\n  //  return length(vec3(q.x, q.y - s + k, q.z - k));\\n}\\nfloat sdDodecahedron(float s, vec3 p) {\\n  vec3 c;\\n  return sdDodecahedron(s, p, c);\\n}\\n\\n// END ../common/sdf3d/sdDodecahedron.glsl\\n// START ../common/sdf3d/sdCylinder.glsl\\nfloat sdCylinder(float radius, float z, vec3 p) {\\n  vec2 d = vec2(length(p.xy), abs(p.z)) - vec2(radius, z);\\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\\n}\\n\\n// #pragma glslify: export(sdCylinder)\\n\\n\\n// END ../common/sdf3d/sdCylinder.glsl\\n// START ../common/sdf3d/sdLego.glsl\\n// START ./sdTube.glsl\\nfloat sdTube(float radius, float r2, float z, vec3 p) {\\n  vec2 d = vec2(length(p.xy), abs(p.z)) - vec2(radius, z);\\n  d.x = abs(d.x) - r2;\\n  vec2 closest = vec2(abs(d.x - radius) - r2, clamp(d.y, 0.0, z));\\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\\n}\\n\\n// END ./sdTube.glsl\\n// START ./sdBox.glsl\\n\\nfloat sdBox(vec3 r, vec3 p) {\\n  vec3 q = abs(p) - r;\\n  return length(max(q, 0.0)) + min(max3(q), 0.0);\\n}\\n\\nfloat sdBox(vec3 r, float r2, vec3 p) {\\n  return sdBox(r - r2, p) - r2;\\n}\\n\\n// #pragma glslify: export(sdBox)\\n\\n\\n// END ./sdBox.glsl\\n\\nfloat sdLego(vec3 p) {\\n  const float IWALLT = 0.04;\\n  p.xy = abs(p.xy);\\n  vec2 c = vec2(4.0, 2.0);\\n  //    p.xy = mod(p.xy + c * 0.5, c) - c * 0.5;\\n  p -= vec3(0.0, 0.0, 0.6);\\n  float d;\\n  const float cr = 0.02;\\n  d = sdBox(vec3(2.0, 1.0, 0.6), cr, p);\\n  if (d > 0.5) {\\n    return d;\\n  }\\n  //    top studs\\n  vec3 p8 = vec3(abs(p.xy - vec2(1.0, 0.0)), p.z) - vec3(0.5, 0.5, 0.6);\\n  float dStuds = sdCylinder(0.35 - 0.04, 0.2, p8) - 0.04;\\n  d = min(d, dStuds);\\n  // little holes in bottom of studs\\n  float dStudHoles = sdCylinder(0.2 - 0.04, 0.3, p8 - vec3(0, 0, -0.4)) - 0.04;\\n  d = max(d, -dStudHoles);\\n  // TODO use sdf texture to add LEGO or custom logo to studs\\n\\n  // hole in the bottom\\n  const float WALLT = 4.0 * IWALLT;\\n  float dBottom = sdBox(\\n    vec3(2.0 - WALLT, 1.0 - WALLT, 0.6),\\n    p - vec3(0, 0, -WALLT)\\n  );\\n  d = max(d, -dBottom);\\n\\n  // 12 indentations on inside.\\n  vec3 pa = p;\\n  // 3. move by 1 in X dir\\n  pa.x -= 1.0;\\n  // 2. mirror across XY axis\\n  if (pa.x > pa.y) pa.xy = pa.yx;\\n  // 1. mirror across Y axis\\n  pa.x = abs(pa.x);\\n  float k = sdBox(vec3(0.5 * IWALLT, 0.05, 0.6), pa - vec3(0.5, 0.8, 0));\\n  d = min(d, k);\\n\\n  // center bar\\n  p = vec3(abs(p.xy), p.z);\\n  d = min(d, sdBox(vec3(0.5 * IWALLT, 0.3, 0.5), p - vec3(0, 0.65, 0.1)));\\n\\n  // 3 tubes\\n  vec3 pTube = p;\\n  if (pTube.x > 0.5) pTube.x -= 1.0;\\n  pTube.x = abs(pTube.x);\\n  d = min(d, sdTube(0.35 + 0.5 * IWALLT, 0.5 * IWALLT, 0.6, pTube));\\n  return d;\\n}\\n\\n// END ../common/sdf3d/sdLego.glsl\\n// START ../common/sdf3d/sdOctahedron.glsl\\nfloat sdOctahedron(float s, vec3 p) {\\n  p = abs(p);\\n  float m = p.x + p.y + p.z - s;\\n  vec3 q;\\n  if (3.0 * p.x < m) q = p.xyz;\\n  else if (3.0 * p.y < m) q = p.yzx;\\n  else if (3.0 * p.z < m) q = p.zxy;\\n  else return m * 0.57735027;\\n\\n  float k = clamp(0.5 * (q.z - q.y + s), 0.0, s);\\n  return length(vec3(q.x, q.y - s + k, q.z - k));\\n}\\n// #pragma glslify: export(sdOctahedron)\\n\\nfloat sdOctahedron(vec3 p, float s) {\\n  p = abs(p);\\n\\n  float m = p.x + p.y + p.z - s;\\n  //find point on octohedron surf nearest to p\\n  vec3 projPoint = p - vec3(0.333333 * m); //project onto surface plane\\n  //now push projected point, if outside triangle edge, perpendicular to edge, to edge\\n  vec3 toMove = min(projPoint, 0.0); //if projpoint.x<0 move along (1.0,-0.5,-0.5) , etc\\n  float toMoveSum = dot(toMove, vec3(1.0)); //which is basically along (1.5,0,0) then vec3(-0.5)\\n\\n  vec3 movedPoint = projPoint + toMove * vec3(-1.5) + toMoveSum * vec3(0.5); //better to multiply toMove by a matrix (1s diagonal, 0.5 other)?\\n\\n  movedPoint = max(movedPoint, 0.0); //cap x,y,z to 0 then\\n  movedPoint *= s / dot(movedPoint, vec3(1.0)); //scale about 0,0,0\\n\\n  return length(p - movedPoint);\\n}\\n\\n// END ../common/sdf3d/sdOctahedron.glsl\\n// START ../common/sdf3d/sdArrow.glsl\\n// START ./sdCone.glsl\\n\\n/**\\n * Signed distance function (SDF) of a cone. The tip of the cone is at the\\n * origin and points towards +Z. q is a point on the rim of the cone.\\n */\\nfloat sdCone(vec2 c, float h, vec3 p) {\\n  vec2 q = h * vec2(c.x / c.y, -1.0);\\n  vec2 w = vec2(length(p.xz), p.y);\\n  vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);\\n  vec2 b = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0);\\n  float k = sign(q.y);\\n  float d = min(dot(a, a), dot(b, b));\\n  float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));\\n  return sqrt(d) * sign(s);\\n}\\n// #pragma glslify: export(sdBox)\\n\\nfloat sdConeB(vec2 c, float h, vec3 p) {\\n  float q = length(p.xz);\\n  return max(dot(c.xy, vec2(q, p.y)), -h - p.y);\\n}\\n\\n// END ./sdCone.glsl\\nvec3 perpendicularVector(vec3 a) {\\n  return cross(a, abs(a.z) > abs(a.x) ? vec3(0, 0, 1) : vec3(0, 1, 0));\\n}\\n/**\\n * Signed distance function (SDF) of an arrow. The arrow goes along the X axis.\\n * The shaft of the arrow has thickness TODO. The tip of the arrow has 30Â°\\n * angle, length of TODO, with the widest point being.\\n */\\nfloat sdArrow(float length, vec3 p) {\\n  float r = 0.01;\\n  return min(\\n    sdCylinder(\\n      0.02 - r,\\n      0.5 * (length - 0.1) - r,\\n      p.yzx - vec3(0, 0, 0.5 * (length - 0.1))\\n    ) -\\n      r,\\n    sdCone(\\n      vec2(sin(15.0 * DEGREE), cos(15.0 * DEGREE)),\\n      0.15 - r,\\n      p.zxy - vec3(0, length - r, 0)\\n    ) -\\n      r\\n  );\\n}\\nfloat sdArrow(vec3 a, vec3 b, vec3 p) {\\n  vec3 x = normalize(b - a);\\n  vec3 y = normalize(perpendicularVector(x));\\n  vec3 z = cross(x, y);\\n  return sdArrow(length(b - a), inverse(mat3(x, y, z)) * (p - a));\\n}\\n\\n// END ../common/sdf3d/sdArrow.glsl\\n// START ../common/sdf3d/sdTetrahedron.glsl\\n// START ./sdCapsule.glsl\\nfloat sdCapsule(vec3 a, vec3 b, float r, vec3 p) {\\n  vec3 pa = p - a;\\n  vec3 ba = b - a;\\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\\n  return length(pa - ba * h) - r;\\n}\\n// #pragma glslify: export(sdCapsule)\\n\\n// END ./sdCapsule.glsl\\n\\n/**\\n * Signed distance function (SDF) of a tetrahedron centered at the origin with\\n * side length `2s`.\\n *\\n * The corners are at `a/b = (+-1,0,sqrt(1/2))` and `c/d = (0,+-1,-sqrt(1/2))`.\\n *\\n * The side length is `||`\\n *\\n * The outscribed sphere has a radius of `sqrt(3/2)`.\\n *\\n * The inscribed sphere has a radius of `sqrt(1/6)`. This is calculated using\\n * the fact that the triangle defined by `mid(a,b) = (0,0,sqrt(1/2))`, `c` and\\n * `mid(c,d) = (0,0,-sqrt(1/2))` is similar to the triangle `mid(a,b)`, `q`, and\\n * `O`.\\n *\\n * For rounded edges, use TODO.\\n *\\n * ```\\n *           ^ Z\\n *           |(+-1, sqrt(1/2))\\n *          /\\\\_\\n *        /    \\\\.q = closest point to center on face\\n *      /    .   \\\\__> Y\\n *    /            \\\\_\\n *  /________________\\\\_(0,-1,sqrt(1/2))\\n * (0,-1,-sqrt(1/2))\\n * ```\\n */\\nfloat sdTetrahedron(float s, vec3 p) {\\n  const vec3 a = vec3(1, 0, SQRT1_2);\\n  const vec3 b = vec3(-1, 0, SQRT1_2);\\n  const vec3 c = vec3(0, 1, -SQRT1_2);\\n  const vec3 d = vec3(0, -1, -SQRT1_2);\\n  const vec3 midBC = 0.5 * (b + c);\\n  const vec3 mirror = normalize(cross(midBC - d, midBC - a));\\n\\n  // Tetra is symmetric in X and Y axes. RED surface in image.\\n  p.xy = abs(p.xy);\\n  // The part z < 0 is symmetric if we rotate it by 90Â°. BLUE surface in image.\\n  if (p.z < 0.0) {\\n    p = vec3(p.y, p.x, -p.z);\\n  }\\n  // Points below the plane through a, d and mid(b,c) are mirrored through it.\\n  // GREEN surface in image.\\n  p -= 2.0 * mirror * min(dot(p, mirror), 0.0);\\n  // After mirror some points are negative, abs again:\\n  p.xy = abs(p.xy);\\n\\n  // Points are now either above the white surface, or above the positive ab segment.\\n  // We shift the coordinate system so that a is now at the origin.\\n  p -= vec3(1, 0, SQRT1_2) * s;\\n  // Finally, we move points which are directely above the face parallel along\\n  // it to a/origin. We can then calculate the sdf as length(p).\\n  p.x = max(p.x, 0.0);\\n  vec3 midABToC1 = normalize(vec3(0, 1, -SQRT2));\\n\\n  p -= max(dot(midABToC1, p), 0.0) * midABToC1;\\n  return sign(p.z) * length(p);\\n}\\n\\n// Same function but also outputs color for explanation image:\\n//float sdTetrahedron(float s, vec3 p, out vec3 color) {\\n//  //  return distance(vec3(1), p) - 0.2;\\n//  const vec3 a = vec3(0, -1, -SQRT1_2);\\n//  const vec3 b = vec3(0, 1, -SQRT1_2);\\n//  const vec3 c = vec3(1, 0, SQRT1_2);\\n//  const vec3 d = vec3(-1, 0, SQRT1_2);\\n//  const vec3 x = 0.5 * (b + d);\\n//  const vec3 mirror = normalize(cross(x - a, x - c));\\n//\\n//  color = WHITE;\\n//  if (p.xy != abs(p.xy)) {\\n//    p.xy = abs(p.xy);\\n//    if (color == WHITE) color = RED;\\n//  }\\n//  if (p.z < 0.0) {\\n//    p = vec3(p.y, p.x, -p.z);\\n//    if (color == WHITE) color = BLUE;\\n//  }\\n//  if (dot(p, mirror) < 0.0) {\\n//    if (color == WHITE) color = GREEN;\\n//    p -= 2.0 * mirror * min(dot(p, mirror), 0.0);\\n//  }\\n//  p.xy = abs(p.xy);\\n//  p -= vec3(1, 0, SQRT1_2);\\n//  p.x = max(p.x, 0.0);\\n//  vec3 fgh = normalize(vec3(0, 1, -SQRT2));\\n//\\n//  p -= max(dot(fgh, p), 0.0) * fgh;\\n//  return sign(p.z) * length(p);\\n//}\\n\\n\\n// END ../common/sdf3d/sdTetrahedron.glsl\\n\\nuniform sampler2D texture;\\nuniform float iTime;\\nuniform vec4 colorPrimary;\\nuniform vec4 colorSecondary;\\nuniform vec4 colorBackground;\\nuniform float a;\\nuniform float b;\\nuniform float c;\\nuniform float d;\\nuniform int bandCount;\\nuniform vec2 iResolution;\\nuniform vec2 iMouse;\\nin float n;\\nin vec2 coord;\\nout vec4 fragColor;\\n\\n\\nstruct Hit {\\n  float distance;\\n  vec4 color;\\n};\\nHit mixa(Hit a, Hit b, float t) {\\n  return Hit(mix(a.distance, b.distance, t), mix(a.color, b.color, t));\\n}\\nfloat skybox(vec3 p) {\\n  return 32.0 - max3(abs(p));\\n}\\n\\nHit add(Hit a, Hit b) {\\n  //    return a.distance < b.distance\\n  //        ? Hit(a.distance, a.color)\\n  //        : Hit(b.distance, b.color);\\n  return mixa(a, b, float(b.distance < a.distance));\\n}\\n\\nHit addFillet(float r, Hit a, Hit b) {\\n  if (a.distance < r && b.distance < r) {\\n    return Hit(\\n      r - distance(vec2(a.distance, b.distance), vec2(r)),\\n      mix(a.color, b.color, (a.distance - b.distance) / r * 0.5 + 0.5)\\n    );\\n  } else {\\n    return add(a, b);\\n  }\\n}\\n\\nHit addFillet(float r, Hit a, Hit b, vec4 tilletColor) {\\n  if (a.distance < r && b.distance < r) {\\n    return Hit(\\n      r - distance(vec2(a.distance, b.distance), vec2(r)),\\n      tilletColor\\n    );\\n  } else {\\n    return add(a, b);\\n  }\\n}\\nHit addFillet2(float r, Hit a, Hit b) {\\n  float h = smoothstep(-r, r, a.distance - b.distance);\\n  return Hit(\\n    mix(a.distance, b.distance, h) - r * h * (1.0 - h),\\n    mix(a.color, b.color, h)\\n  );\\n}\\n\\nHit neg(Hit a) {\\n  return Hit(-a.distance, a.color);\\n}\\nHit sub(Hit from, Hit what) {\\n  Hit whatNeg = neg(what);\\n  return mixa(from, whatNeg, float(whatNeg.distance > from.distance));\\n}\\n\\nvec3 modv(vec3 v, vec3 dir1, float y) {\\n  float t = dot(v, dir1);\\n  return v - floor(t / y) * y * dir1;\\n}\\nvec3 modRotZ(vec3 p, float count) {\\n  vec2 polarXY = toPolar(p.xy);\\n  return fromPolar(polarXY.x, mod(polarXY.y, TAU / count), p.z);\\n}\\n\\nfloat sin01(float x) {\\n  return 0.5 + 0.5 * sin(x);\\n}\\nfloat cos01(float x) {\\n  return 0.5 + 0.5 * cos(x);\\n}\\n\\nfloat smoothmin(float r, float a, float b) {\\n  float h = smoothstep(-r, r, a - b);\\n  return mix(a, b, h) - r * h * (1.0 - h);\\n}\\n\\nvec2 project(vec2 a, vec2 onto1) {\\n  return onto1 * (dot(a, onto1) / dot(onto1, onto1));\\n}\\n\\nvec3 reject(vec3 a, vec3 b1) {\\n  return a - b1 * dot(a, b1);\\n}\\nfloat wavy(float x) {\\n  return fract(x);\\n}\\nfloat wood(vec3 p) {\\n  return distance(p.xy, vec3(0).xy) +\\n  // narrower near top:\\n  0.01 * p.z +\\n  0.05 * openSimplex2_Conventional(p).w +\\n  0.01 * openSimplex2_Conventional(2.0 * p).w;\\n}\\nHit sdf(vec3 p) {\\n  float scale = 2.0;\\n  float ds = sdCylinder(1.0, 1.0, p - vec3(0, -1.2, 1));\\n  ds = min(ds, sdBox(vec3(1.0), p - vec3(0, 1.2, 1)));\\n  if (ds > 1.0) {\\n    //    ds *= 0.1;\\n  }\\n  float dg = p.z;\\n  if (ds < dg) {\\n    float k = wood(p - vec3(0, -1.2, 0));\\n\\n    vec3 color = mix(ungamma(SANDY_BROWN), ungamma(BROWN), wavy(k * 10.0));\\n    //    color = ungamma(colorPrimary);\\n    //        vec3 color = vec3(f);\\n\\n    return Hit(ds, vec4(color, 1));\\n  } else {\\n    float f = checkerboardGrad(p.xy);\\n\\n    vec3 color = mix(ungamma(colorBackground), ungamma(colorSecondary), f);\\n    return Hit(dg, vec4(color, 1));\\n  }\\n}\\nfloat sdff(vec3 p) {\\n  return sdf(p).distance;\\n}\\nfloat ambientOcclusion(vec3 pWC, vec3 n1WC) {\\n  float k = 1.0;\\n  float distance = sdff(pWC + n1WC * k);\\n  return clamp(distance / k, 0.0, 1.0);\\n}\\n\\nstruct RMResult {\\n  float distance;\\n  vec3 pos;\\n  vec4 color;\\n};\\nRMResult raymarching2(vec3 start, vec3 dir1) {\\n  vec3 pos = start;\\n  Hit hit;\\n  for (int i = 0; i < 100; i++) {\\n    hit = sdf(pos);\\n    if (hit.distance < 0.0001) break;\\n    pos = pos + dir1 * hit.distance;\\n  }\\n  return RMResult(hit.distance, pos, hit.color);\\n}\\n\\nfloat softshadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {\\n  float res = 1.0;\\n  float t = 0.1;\\n  for (int i = 0; i < 1000 && t < maxt; i++) {\\n    float h = sdff(ro + rd * t);\\n    if (h < 0.001) return 0.0;\\n    res = min(res, k * h / t);\\n    t += h;\\n  }\\n  return res;\\n}\\n\\nconst float eps = 1e-4;\\nvec3 sdfNormal1(vec3 p, float d) {\\n  return normalize(\\n    vec3(\\n      sdff(p + vec3(eps, 0.0, 0.0)),\\n      sdff(p + vec3(0.0, eps, 0.0)),\\n      sdff(p + vec3(0.0, 0.0, eps))\\n    ) -\\n      vec3(sdff(p))\\n  );\\n}\\n\\n//layout (depth_greater) out float gl_FragDepth;\\nvoid main() {\\n  vec3 camPos =\\n    vec3(20, 0, 10) +\\n    (-1.0 == iMouse.x\\n      ? vec3(0)\\n      : vec3(0, (iMouse / iResolution * 2.0 - 1.0) * 10.0));\\n  mat4 modelView =\\n    perspective(10.0, iResolution.x / iResolution.y, 0.1, 20.0) *\\n    lookAt(camPos, vec3(0, 0, 1), vec3(0, 0, 1));\\n  mat4 modelViewInverse = inverse(modelView);\\n\\n  vec3 light = normalize(vec3(-1.0, -2.0, -2));\\n\\n  vec3 a = vec3(coord * 2.0 - 1.0, -1.0);\\n  vec3 b = vec3(coord * 2.0 - 1.0, 1.0);\\n  vec3 aWC = transform(modelViewInverse, a);\\n  vec3 bWC = transform(modelViewInverse, b);\\n  vec3 lookDir1 = normalize(bWC - aWC);\\n\\n  RMResult hitWC = raymarching2(aWC, lookDir1);\\n  vec3 hitn1 = sdfNormal1(hitWC.pos, hitWC.distance);\\n  float dWC = distance(aWC, hitWC.pos);\\n  vec3 hitNDC = transform(modelView, hitWC.pos);\\n  vec3 p = hitWC.pos;\\n  float inSun = softshadow(\\n    hitWC.pos + hitn1 * 0.05,\\n    -light,\\n    0.0001,\\n    300.0,\\n    8.0\\n  );\\n  //    float inSun=1.;\\n\\n  vec3 material = hitWC.color.xyz;\\n  if (dWC > 100.0) {\\n    material = vec3(0.0, 0.0, 0.0);\\n    //    } else if (p.z >= 0.001) {\\n    //        material = vec3(0.2, 0.0, 0.0);\\n    //    } else {\\n    //        vec2 c = vec2(4.0, 2.0);\\n    //        vec2 id = floor(((p.xy - c * 0.5) / c) );\\n    //        material += .15 * cos(vec3(id.x, id.y + 2., id.x + id.y + 4.));\\n  }\\n\\n  const vec3 sunlightColor = vec3(3.0);\\n\\n  float aOcc = ambientOcclusion(hitWC.pos, hitn1);\\n\\n  vec3 reflectionDirection = reflect(light, hitn1);\\n\\n  vec3 color = vec3(0.0);\\n  color += material * aOcc;\\n  color += inSun * sunlightColor * material * max(0.0, dot(-light, hitn1));\\n  //    color = (hitn1);\\n\\n  vec3 eyeDirection = -lookDir1;\\n  float uMaterialShininess = 256.0;\\n  float specularLightWeighting = pow(\\n    max(dot(reflectionDirection, eyeDirection), 0.0),\\n    uMaterialShininess\\n  );\\n  color += specularLightWeighting;\\n  //    float lightIntensity = 0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.);\\n  //    float lightIntensity =\\n  //        0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.) + 0.3*specularLightWeighting;\\n  //    fragColor = visualize(blue, red, mix(0.5, 1.0, inSun) * lightIntensity);\\n  //    fragColor = mix(hitWC.color, colorBackground, mix(0.5, 1.0, inSun) * clamp(lightIntensity, 0., 1.));\\n  color = pow(color, vec3(1.0 / 2.2)); // gamma correction\\n  fragColor = vec4(color, 1.0);\\n}\\n\"\nconst sourceMap = {\"version\":3,\"sources\":[\"/home/runner/work/workshop/workshop/src/noises/tree.frag\",\"/home/runner/work/workshop/workshop/src/common/banded.glsl\",\"/home/runner/work/workshop/workshop/src/common/constants.glsl\",\"/home/runner/work/workshop/workshop/src/common/matrices.glsl\",\"/home/runner/work/workshop/workshop/src/common/max3.glsl\",\"/home/runner/work/workshop/workshop/src/common/visualize.glsl\",\"/home/runner/work/workshop/workshop/src/common/unmix.glsl\",\"/home/runner/work/workshop/workshop/src/common/fromPolar.glsl\",\"/home/runner/work/workshop/workshop/src/common/toPolar.glsl\",\"/home/runner/work/workshop/workshop/src/common/polar.glsl\",\"/home/runner/work/workshop/workshop/src/common/ungamma.glsl\",\"/home/runner/work/workshop/workshop/src/common/transform.glsl\",\"/home/runner/work/workshop/workshop/src/common/squareWave.glsl\",\"/home/runner/work/workshop/workshop/src/common/OpenSimplex2.glsl\",\"/home/runner/work/workshop/workshop/src/common/checkerboardGrad.glsl\",\"/home/runner/work/workshop/workshop/src/common/colors.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdIcosahedron.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdDodecahedron.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdCylinder.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdTube.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdBox.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdLego.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdOctahedron.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdCone.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdArrow.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdCapsule.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdTetrahedron.glsl\"],\"names\":[],\"mappings\":\"AAAA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC/GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC3IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A1BzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA\"}\nexport { sourceMap };\n"," function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }import { M4, V, V3 } from \"ts3dutils\"\n\nexport class PanController {\n   __init() {this.lastPos = V3.O}\n  \n\n   __init2() {this.pressedKeys = {}}\n   __init3() {this.pauseCam = false}\n   reset() {\n    M4.identity(this.state)\n    _optionalChain([this, 'access', _5 => _5.onChange, 'optionalCall', _6 => _6(this.state)])\n  }\n\n  constructor(\n     state,\n      onChange,\n      lockUp,\n  ) {;this.state = state;this.onChange = onChange;this.lockUp = lockUp;PanController.prototype.__init.call(this);PanController.prototype.__init2.call(this);PanController.prototype.__init3.call(this);PanController.prototype.__init4.call(this);PanController.prototype.__init5.call(this);PanController.prototype.__init6.call(this);PanController.prototype.__init7.call(this);PanController.prototype.__init8.call(this);}\n\n  __init4() {this.setState = (m) => {\n    m !== this.state && M4.copy(m, this.state)\n  }}\n\n  registerListeners(\n    mouseMoveTarget\n\n\n,\n    keyUpDownTarget = mouseMoveTarget,\n  ) {\n    _optionalChain([this, 'access', _7 => _7.unregister, 'optionalCall', _8 => _8()])\n    mouseMoveTarget.addEventListener(\"wheel\", this.wheel)\n    mouseMoveTarget.addEventListener(\"mousemove\", this.mousemove)\n    keyUpDownTarget.addEventListener(\"keydown\", this.keydown)\n    keyUpDownTarget.addEventListener(\"keyup\", this.keyup)\n\n    return (this.unregister = () => {\n      mouseMoveTarget.removeEventListener(\"wheel\", this.wheel)\n      mouseMoveTarget.removeEventListener(\"mousemove\", this.mousemove)\n      keyUpDownTarget.removeEventListener(\"keydown\", this.keydown)\n      keyUpDownTarget.removeEventListener(\"keyup\", this.keyup)\n    })\n  }\n\n  unregisterListeners() {\n    _optionalChain([this, 'access', _9 => _9.unregister, 'optionalCall', _10 => _10()])\n  }\n  static  __initStatic() {this.TRACKED_KEYS = [\"a\", \"d\", \"s\", \"w\"]}\n\n  tick() {\n    const speed = new V3(\n      +!!this.pressedKeys.a - +!!this.pressedKeys.d,\n      +!!this.pressedKeys.s - +!!this.pressedKeys.w,\n      0,\n    )\n    if (!speed.likeO()) {\n      this.state = this.state.translate(speed.times(10))\n      _optionalChain([this, 'access', _11 => _11.onChange, 'optionalCall', _12 => _12(this.state)])\n    }\n  }\n   __init5() {this.wheel = (e) => {\n    const canvas = e.currentTarget \n    const { width, height } = canvas.getBoundingClientRect()\n    const factor = Math.pow(1.1, -Math.sign(e.deltaY))\n    const p = new V3(\n      canvas.width * (e.offsetX / width),\n      canvas.height * (1 - e.offsetY / height),\n      0,\n    )\n    this.state = this.state\n      .translate(p.negated())\n      .scale(V3.XYZ.times(factor))\n      .translate(p)\n    _optionalChain([this, 'access', _13 => _13.onChange, 'optionalCall', _14 => _14(this.state)])\n    e.preventDefault()\n    e.stopPropagation()\n  }}\n\n   __init6() {this.mousemove = (e) => {\n    const canvas = e.currentTarget \n    const { width, height } = canvas.getBoundingClientRect()\n    const pagePos = V(e.pageX, e.pageY)\n    const delta = this.lastPos.to(pagePos)\n    if (e.buttons & 1 && !this.pauseCam) {\n      // zRot -= delta.x * 0.25 * DEG\n      this.state = this.state.translate(\n        canvas.width * (delta.x / width),\n        canvas.height * (-delta.y / height),\n        0,\n      )\n      _optionalChain([this, 'access', _15 => _15.onChange, 'optionalCall', _16 => _16(this.state)])\n    }\n    this.lastPos = pagePos\n  }}\n\n   __init7() {this.keydown = (e) => {\n    if (e.key === \"r\") {\n      this.reset()\n      e.preventDefault()\n    } else if (PanController.TRACKED_KEYS.includes(e.key)) {\n      this.pressedKeys[e.key] = true\n      e.preventDefault()\n    }\n  }}\n   __init8() {this.keyup = (e) => {\n    this.pressedKeys[e.key] = undefined\n    e.preventDefault()\n  }}\n\n  getTransform() {\n    return this.state\n  }\n\n  static toShortString(state, posFactor = 1) {\n    const trans = state.getTranslation()\n    const scale = state.m[0]\n    return (\n      Math.round(trans.x * posFactor) +\n      \"~\" +\n      Math.round(trans.y * posFactor) +\n      \"~\" +\n      Math.round(Math.log(scale) / Math.log(1.1))\n    )\n  }\n\n  static fromShortString(cam, posFactor = 1) {\n    const coord = (s, f) =>\n      V(s.split(\".\").map((sp) => +sp / f) )\n    const [transXStr, transYStr, scaleStr] = cam.split(\"~\")\n    return M4.translate(\n      new V3(+transXStr / posFactor, +transYStr / posFactor, 0),\n    ).scale(Math.pow(1.1, +scaleStr))\n  }\n} PanController.__initStatic();\n"," function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }\nimport Card from \"@mui/material/Card\"\nimport CardContent from \"@mui/material/CardContent\"\n\nimport Grid from \"@mui/material/Grid\"\nimport Slider from \"@mui/material/Slider\"\n\n\n\n\nimport * as React from \"react\"\nimport { useCallback, useEffect, useRef, useState } from \"react\"\nimport {\n  arrayFromFunction,\n  clamp,\n  DEG,\n  emod,\n\n  lerp,\n  lerpInv,\n  M4,\n  PI,\n  V,\n  V3,\n} from \"ts3dutils\"\nimport { Mesh, Shader, Texture, } from \"tsgl\"\nimport { BoundNumberField } from \"../common/BoundNumberField\"\n\nimport { useHashState } from \"../common/useHashState\"\n\n\nimport {\n  GenericDemo,\n\n\n\n\n  SimpleCanvasRenderer,\n} from \"../sdfs/SimpleCanvasRenderer\"\nimport { PanController } from \"./PanController\"\n\nconst gradients = arrayFromFunction(512, () =>\n  V3.polar(1, (Math.random() - 0.5) * 2 * Math.PI),\n)\n\nconst initialState = {\n  bandCount: 8,\n  a: 0.5,\n  b: 0.5,\n  c: 0.5,\n  cam: \"0~0~0\",\n}\n\n\nconst perlin = (x, y, o1) => {\n  const x0 = x | 0\n  const x1 = x0 + 1\n  const y0 = y | 0\n  const y1 = y0 + 1\n\n  const smoothstep = (x) => x * x * (3 - 2 * x)\n\n  const dotGridGradient = (ix, iy, x, y) => {\n    // Compute the distance vector\n    const dx = x - ix\n    const dy = y - iy\n\n    const gradient = emod(gradients, ix * 59 + iy)\n    //console.log(dx, dy, gradient)\n    // Compute the dot-product\n    return gradient.dot(new V3(dx, dy, 0))\n  }\n  // Interpolate between grid point gradients\n\n  const n00 = dotGridGradient(x0, y0, x, y)\n  const n10 = dotGridGradient(x1, y0, x, y)\n  const ny0 = lerp(n00, n10, o1 ? smoothstep(x - x0) : x - x0)\n\n  const n01 = dotGridGradient(x0, y1, x, y)\n  const n11 = dotGridGradient(x1, y1, x, y)\n  const ny1 = lerp(n01, n11, o1 ? smoothstep(x - x0) : x - x0)\n\n  return lerp(ny0, ny1, o1 ? smoothstep(y - y0) : y - y0)\n}\n\nfunction makeCubicGridMesh(cylinderMesh) {\n  const cylMeshes = []\n  for (let x = -5; x < 5; x++) {\n    for (let y = -5; y < 5; y++) {\n      for (let z = -5; z < 5; z++) {\n        cylMeshes.push(\n          cylinderMesh.transform(M4.scale(1, 0.01, 0.01).translate(x, y, z)),\n          cylinderMesh.transform(\n            M4.scale(1, 0.01, 0.01)\n              .rotateY(Math.PI / 2)\n              .translate(x, y, z),\n          ),\n          cylinderMesh.transform(\n            M4.scale(1, 0.01, 0.01)\n              .rotateZ(Math.PI / 2)\n              .translate(x, y, z),\n          ),\n        )\n      }\n    }\n  }\n  const [first, ...rest] = cylMeshes\n  return first.concat(...rest)\n}\n\nfunction makeTetrahedralGridMesh(cylinderMesh) {\n  const cylMeshes = []\n\n  const SIN60 = Math.sqrt(3) / 2\n  const COS60 = Math.cos(Math.PI / 3)\n  // when a regular tetrahedron is viewed projectively so that two faces are\n  // perpendicular to the viewer, they make an isosceles triangle with sides\n  // 1, sin 60Â°, sin 60Â°. gamma is the angle between the two short sides.\n  const gamma = 2 * Math.asin(1 / Math.sqrt(3))\n  for (let x = -0; x < 2; x++) {\n    for (let y = -0; y < 2; y++) {\n      for (let z = -0; z < 1; z++) {\n        const dx = x + (y % 2 === 0 ? 0 : COS60)\n        cylMeshes.push(\n          cylinderMesh.transform(\n            M4.scale(1, 0.01, 0.01).translate(dx, y * SIN60, z * SIN60),\n          ),\n          cylinderMesh.transform(\n            M4.scale(1, 0.01, 0.01)\n              .rotateZ(Math.PI / 3)\n              .translate(dx, y * SIN60, z * SIN60),\n          ),\n          cylinderMesh.transform(\n            M4.scale(1, 0.01, 0.01)\n              .rotateZ((Math.PI / 3) * 2)\n              .translate(dx, y * SIN60, z * SIN60),\n          ),\n          cylinderMesh.transform(\n            M4.scale(1, 0.01, 0.01)\n              .rotateZ(Math.PI / 2)\n              .rotateX((Math.PI - gamma) / 2)\n              .translate(dx, y * SIN60, z * SIN60),\n          ),\n          cylinderMesh.transform(\n            M4.scale(1, 0.01, 0.01)\n              .rotateY(-(Math.PI / 3) * 2)\n              .rotateX(Math.PI / 2 - gamma)\n              .translate(dx, y * SIN60, z * SIN60),\n          ),\n          cylinderMesh.transform(\n            M4.scale(1, 0.01, 0.01)\n              .rotateY(-(Math.PI / 3))\n              .rotateX(Math.PI / 2 - gamma)\n              .translate(dx, y * SIN60, z * SIN60),\n          ),\n        )\n      }\n    }\n  }\n  const [first, ...rest] = cylMeshes\n  return first.concat(...rest)\n}\n\nexport const band = (\n  minValue,\n  maxValue,\n  bandCount,\n  value,\n) =>\n  lerp(\n    minValue,\n    maxValue,\n    Math.floor(lerpInv(minValue, maxValue, value) * 4) / (4 - 1),\n  )\n\nfunction noises(\n  gl,\n  colors,\n  dynamicState,\n) {\n  let o1 = true\n  const w = 512,\n    h = 512\n  const data = new Uint8Array(w * h)\n  const tex = new Texture(w, h, {\n    format: gl.RED,\n    type: gl.UNSIGNED_BYTE,\n    internalFormat: gl.R8,\n    // filter: gl.NEAREST,\n  })\n  const gradientsTex = new Texture(256, 256, {\n    format: gl.RG,\n    type: gl.FLOAT,\n    internalFormat: gl.RG32F,\n    data: V3.packXY(\n      arrayFromFunction(256 * 256, () =>\n        V3.polar(1, (Math.random() - 0.5) * 2 * Math.PI),\n      ),\n    ),\n  })\n  const redoTex = () => {\n    let min = Infinity,\n      max = -Infinity\n    for (let y = 0; y < h; y++) {\n      for (let x = 0; x < w; x++) {\n        //data[y * w + x] = ((x + y) / (w + h - 2)) * 255\n        const perl = clamp(\n          (perlin(\n            dynamicState.xOffset + x / dynamicState.xScale,\n            dynamicState.yOffset + y / dynamicState.yScale,\n            o1,\n          ) +\n            0.5) *\n            0.8,\n          0,\n          1,\n        )\n        const v = Math.random()\n        data[y * w + x] = (Math.floor(perl * 4) / (4 - 1)) * 255\n        max = Math.max(max, v)\n        min = Math.min(min, v)\n      }\n    }\n    data[0] = 0\n    tex.setData(data)\n  }\n\n  // const lll = M4.lookAt(V(2, -10, 5), V3.O, V3.Z).times(\n  //     M4.perspective(70, 1, 0.1, 100)\n  // )\n  // console.log(\"\" + llli)\n  // console.log(llli.transformPoint(V(-1, -1, 1)))\n  // redoTex()\n  const planeMesh = Mesh.plane({ detail: 128 })\n  const sphereMesh = Mesh.sphere(0)\n    .computeWireframeFromFlatTrianglesClosedMesh()\n    .compile()\n  const cylinderMesh = Mesh.rotation(\n    [V3.Y, V3.XY],\n    { anchor: V3.O, dir1: V3.X },\n    2 * Math.PI,\n    3,\n    true,\n  )\n  const cubicGridMesh = makeTetrahedralGridMesh(cylinderMesh)\n  console.log(sphereMesh)\n  // const cubeMesh = Mesh.cube()\n  const shader = Shader.create(\n    `\n      uniform mat4 ts_ModelViewProjectionMatrix;\n      attribute vec4 ts_Vertex;\n      uniform float pointSize;\n      varying vec4 foo;\n      void main() {\n        foo = vec4(1.0, 1.0, 1.0, 1.0);\n        gl_Position = ts_ModelViewProjectionMatrix * ts_Vertex;\n        gl_PointSize = pointSize;\n      }\n    `,\n    `\n      precision highp float;\n      uniform vec4 color;\n      varying vec4 bar;\n      void main() {\n        gl_FragColor = color;\n        if (length(gl_PointCoord - vec2(0.5, 0.5)) > 0.5) {\n          discard;\n        }\n      }\n    `,\n  )\n\n  const perlinShader2 = Shader.create\n\n\n\n\n\n\n\n(\n    `#version 300 es\n      precision highp float;\n      \n      uniform mat4 ts_ModelViewProjectionMatrix;\n      in vec4 ts_Vertex;\n      uniform float pointSize;\n      uniform vec2 scale;\n      uniform vec2 offset;\n      in vec3 ts_TexCoordUVQ;\n      in vec2 ts_TexCoord;\n      out vec3 coordUVQ;\n      out float n;\n      out vec2 coord;\n      void main() {\n        vec2 texCoordAdjusted = offset + ts_TexCoord * scale;\n        n = 0.0;  \n        gl_Position = ts_ModelViewProjectionMatrix * \n          (ts_Vertex + vec4(0.0, 0.0, n, 0.0));\n        gl_PointSize = pointSize;\n        coordUVQ = ts_TexCoordUVQ;\n        coord = texCoordAdjusted;\n      }\n  `,\n    `#version 300 es\n      precision highp float;\n      \n      uniform sampler2D texture;\n      uniform vec4 colorPrimary;\n      uniform vec4 colorBackground;\n      uniform int bandCount;\n      in float n;\n      in vec2 coord;\n      out vec4 fragColor;\n      void main() {\n        float fraction = (n + 0.5) * 0.5;\n        fragColor = mix(colorBackground, colorPrimary, fraction);\n        \n        if (length(gl_PointCoord - vec2(0.5, 0.5)) > 0.5) {\n          discard;\n        }\n      }\n    `,\n  )\n  const texShader = Shader.create\n\n\n\n\n\n\n\n(\n    `\n      uniform mat4 ts_ModelViewProjectionMatrix;\n      attribute vec4 ts_Vertex;\n      uniform float pointSize;\n      attribute vec3 ts_TexCoordUVQ;\n      attribute vec2 ts_TexCoord;\n      varying vec4 foo;\n      varying vec3 coordUVQ;\n      varying vec2 coord;\n      void main() {\n        foo = vec4(1.0, 1.0, 1.0, 1.0);\n        gl_Position = ts_ModelViewProjectionMatrix * ts_Vertex;\n        gl_PointSize = pointSize;\n        coordUVQ = ts_TexCoordUVQ;\n        coord = ts_TexCoord;\n      }\n    `,\n    `\n      precision highp float;\n      uniform sampler2D texture;\n      uniform vec4 colorPrimary;\n      uniform vec4 colorBackground;\n      varying vec4 bar;\n      varying vec3 coordUVQ;\n      varying vec2 coord;\n      void main() {\n        float fraction = texture2D(texture, coord).r;\n        gl_FragColor = mix(colorBackground, colorPrimary, fraction);\n        \n        if (length(gl_PointCoord - vec2(0.5, 0.5)) > 0.5) {\n          discard;\n        }\n      }\n    `,\n  )\n\n  const viewState = {\n    pos: V(0.75, 0, 1),\n    lookDir: V(0, 0, -1),\n  }\n  const saveViewState = () => {\n    localStorage.setItem(\n      \"viewState\",\n      JSON.stringify({\n        pos: viewState.pos.toArray(),\n        lookDir: viewState.lookDir.toArray(),\n      }),\n    )\n  }\n  const loadViewState = () => {\n    if (null !== localStorage.getItem(\"viewState\")) {\n      const json = JSON.parse(localStorage.getItem(\"viewState\"))\n      viewState.pos = V3.fromArray(json.pos)\n      viewState.lookDir = V3.fromArray(json.lookDir)\n    }\n  }\n  loadViewState()\n\n  gl.clearColor(...colors.background)\n  gl.cullFace(gl.BACK)\n\n  // setup camera\n  const cam1 = () => {\n    gl.matrixMode(gl.PROJECTION)\n    gl.loadIdentity()\n    gl.perspective(70, gl.canvas.width / gl.canvas.height, 0.1, 1000)\n    gl.lookAt(V(0, 0.5, 2.2), V3.O, V3.Y)\n    gl.matrixMode(gl.MODELVIEW)\n  }\n  const cam2 = () => {\n    gl.matrixMode(gl.PROJECTION)\n    gl.loadIdentity()\n    gl.perspective(70, gl.canvas.width / gl.canvas.height, 0.1, 1000)\n    gl.lookAt(V(0.75, 0, 1), V(0.75, 0, 0), V3.Y)\n    gl.matrixMode(gl.MODELVIEW)\n  }\n  cam2()\n  gl.pointSize(10)\n\n  //gl.enable(gl.CULL_FACE)\n  gl.disable(gl.CULL_FACE)\n  gl.enable(gl.DEPTH_TEST)\n  gl.enable(gl.BLEND)\n  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)\n  const pressedKeys = {}\n  console.log(gl.canvas)\n  gl.canvas.contentEditable = \"true\" // make canvas focusable\n  gl.canvas.focus()\n  gl.canvas.onkeydown = function (e) {\n    pressedKeys[e.key] = true\n\n    if (\"o\" === e.key) {\n      o1 = !o1\n      redoTex()\n    }\n    if (\"2\" === e.key) {\n      cam2()\n    }\n    if (\"1\" === e.key) {\n      cam1()\n    }\n  }\n  gl.canvas.onkeypress = function (e) {\n    const dir = new V3(0, 0, 0)\n  }\n  gl.canvas.onkeyup = function (e) {\n    pressedKeys[e.key] = false\n  }\n  let lastPos = V3.O\n  let rot = M4.IDENTITY\n  const zRot = 0\n  const yRot = 0\n  gl.canvas.onmousemove2 = function (e) {\n    const pagePos = V(e.pageX, e.pageY)\n    const delta = lastPos.to(pagePos)\n    if (e.buttons & 1) {\n      // zRot -= delta.x * 0.25 * DEG\n      rot = rot.rotateZ(delta.x * 0.25 * DEG)\n      rot = rot.rotateX(delta.y * 0.25 * DEG)\n      // rot = rot.rotate(V3.O, rot.X, delta.y * 0.25 * DEG)\n      // yRot = clamp(yRot - delta.y * 0.25 * DEG, -85 * DEG, 85 * DEG)\n    }\n    lastPos = pagePos\n  }\n  gl.canvas.onmousemove = function (e) {\n    const pagePos = V(e.pageX, e.pageY)\n    const delta = lastPos.to(pagePos)\n    if (e.buttons & 1) {\n      // zRot -= delta.x * 0.25 * DEG\n      const rot = M4.rotateY(-delta.x * 0.25 * DEG).rotateX(\n        -delta.y * 0.25 * DEG,\n      )\n      viewState.lookDir = rot.transformVector(viewState.lookDir).unit()\n      // rot = rot.rotate(V3.O, rot.X, delta.y * 0.25 * DEG)\n      // yRot = clamp(yRot - delta.y * 0.25 * DEG, -85 * DEG, 85 * DEG)\n    }\n    lastPos = pagePos\n  }\n  let outputllll = false\n  return Object.assign(\n    gl.animate(function (abs, _diff) {\n      const speed = new V3(\n        +!!pressedKeys.w - +!!pressedKeys.s,\n        +!!pressedKeys.a - +!!pressedKeys.d,\n        +!!pressedKeys.e - +!!pressedKeys.q + +!!pressedKeys[\" \"],\n      ).times(0.05)\n      if (!speed.likeO()) {\n        const lookDirZ = viewState.lookDir\n\n        viewState.pos = viewState.pos.plus(\n          M4.forSys(lookDirZ, V3.Y.cross(lookDirZ).unit()).transformVector(\n            speed,\n          ),\n        )\n        saveViewState()\n      }\n      gl.matrixMode(gl.PROJECTION)\n      gl.loadIdentity()\n      gl.perspective(70, gl.canvas.width / gl.canvas.height, 0.1, 1000)\n      gl.lookAt(viewState.pos, viewState.pos.plus(viewState.lookDir), V3.Y)\n      gl.matrixMode(gl.MODELVIEW)\n\n      // const angleDeg = (abs / 1000) * 10\n      // const angleDeg = 0\n      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)\n      gl.loadIdentity()\n      // gl.rotate(yRot / DEG, 0, 1, 0)\n      // gl.rotate(-zRot / DEG, 0, 0, 1)\n      //gl.multMatrix(rot)\n\n      gl.pushMatrix()\n\n      gl.translate(0.25, -0.5, 0)\n      // shader\n      //   .uniforms({ color: colors.primary, pointSize: 12 })\n      //   .draw(planeMesh, gl.LINES)\n      tex.bind(0)\n      gradientsTex.bind(1)\n\n      const f = (abs / 1000 / 40) % 1\n      //        vec3 spherepos = fromPolar(mix(-6., 6., f), abs(mix(-10., 10., f)) + PI / 2., 0.);\n      const campos = (f) =>\n        V3.polar(lerp(-6, 6, f), Math.abs(lerp(-10, 10, f)) + PI / 2, 0.5)\n\n      const lll = M4.product(\n        M4.perspective(70, 1, 0.1, 50),\n        M4.lookAt(\n          campos(f),\n          campos(f + 0.005)\n            .unit()\n            .plus(V(0, 0, 0.2)),\n          V3.Z,\n        ),\n        // M4.lookAt(V(10, 0, 10), V3.O, V3.Z),\n        // M4.rotateZ(abs / 10_000),\n      )\n      const llli = lll.inversed()\n      if (!outputllll) {\n        console.log(\"\" + lll)\n        console.log(lll.transformPoint(V3.XYZ.negated()))\n        console.log(lll.transformPoint(V3.XYZ))\n        outputllll = true\n      }\n\n      // shader.uniforms({ color: colors.secondary }).draw(cubicGridMesh)\n\n      //shader\n      // .uniforms({\n      //  color: chroma.css(\"grey\").gl(),\n      // pointSize: 10,\n      // })\n      //.drawBuffers(pointMesh.vertexBuffers, undefined, gl.POINTS)\n      //shader.uniforms({ color: [1, 1, 0, 1] }).draw(pointMesh, gl.LINES)\n      //shader.uniforms({ color: [0, 0, 0, 0.5] }).draw(pointMesh,\n      // gl.TRIANGLES) gl.pushMatrix() gl.translate(30, 0, 0)\n    }),\n    {\n      redoTex,\n    },\n  )\n}\n\nexport class PanningCanvasRenderer extends SimpleCanvasRenderer {\n  \n\n  constructor(\n    fragShader,\n    canvas,\n    options,\n  ) {\n    super(fragShader, canvas, options)\n    canvas.tabIndex = 0\n    this.panController = new PanController(M4.identity(), options.onCamChange)\n    this.panController.registerListeners(canvas)\n  }\n\n   uniforms() {\n    return {\n      modelView: this.panController.getTransform(),\n      viewModel: this.panController.getTransform().inversed(),\n    }\n  }\n   setCam(state) {\n    this.panController.setState(state)\n  }\n\n   render(abs) {\n    this.panController.tick()\n    super.render(abs)\n  }\n}\nconst ShadertoyLikeDemo = ({\n  frag,\n  sx,\n  animate,\n  state,\n}\n\n\n\n\n\n) => {\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  const Renderer = useCallback(\n    class extends PanningCanvasRenderer  {\n      \n      constructor(\n        canvas,\n        options,\n      ) {\n        super(() => require(\"./\" + frag + \".frag\"), canvas, options)\n      }\n    },\n    [frag],\n  )\n\n  return (\n    React.createElement(GenericDemo, { sx: sx, Renderer: Renderer, animate: animate, state: state,} )\n  )\n}\nexport default () => {\n  const [state, setState] = useHashState(initialState)\n  const [fps, setFps] = useState(0)\n  const setStatePartial = useCallback(\n    (o) => setState((s) => ({ ...s, ...o })),\n    [setState],\n  )\n  const setCam = useCallback(\n    ({ cam }) => {\n      const m = PanController.fromShortString(cam)\n      setStatePartial({ cam: PanController.toShortString(m) })\n    },\n    [setStatePartial],\n  )\n\n  const simplexRef = useRef()\n  useEffect(() => {\n    state.cam &&\n      _optionalChain([simplexRef, 'access', _ => _.current, 'optionalAccess', _2 => _2.setCam, 'optionalCall', _3 => _3(PanController.fromShortString(state.cam))])\n  }, [])\n\n  return (\n    React.createElement(Grid, { container: true, style: { height: \"99%\" }, spacing: 2, padding: 2,}\n      , React.createElement(Grid, { container: true, item: true, sm: 9, spacing: 2,}\n        , [\n          \"tree\",\n          // \"mengerSlices\",\n          // \"magic\",\n          // sphereOpenSimplex,\n          // \"simplex\",\n          // \"test3\",\n          // \"test\",\n          // \"julias\",\n          // \"test2\",\n        ].map((frag, i) => (\n          React.createElement(Grid, { size: { xs: 12 }, key: i,}\n            , React.createElement(ShadertoyLikeDemo, {\n              sx: { height: 400 },\n              animate: true,\n              state: state,\n              frag: frag,\n              rendererRef: simplexRef,}\n            )\n          )\n        ))\n      )\n\n      , React.createElement(Grid, {\n        size: { xs: 12, md: 3 },\n        sx: {\n          display: \"flex\",\n          flexDirection: \"column\",\n          width: \"100%\",\n          alignItems: \"stretch\",\n          // \"& > *\": { margin: 1 },\n          gap: 2,\n        },}\n\n        , React.createElement(Card, null\n          , React.createElement(CardContent, null, \"Test with various noise generation functions.\"\n\n          )\n        )\n        , React.createElement(BoundNumberField, { ...{ state, setStatePartial }, prop: \"bandCount\",} )\n        , React.createElement(Slider, {\n          value: state.a,\n          onChange: (e, a) => setStatePartial({ a }),\n          min: 0,\n          max: 1,\n          step: 0.01,}\n        )\n        , React.createElement(Slider, {\n          value: state.b,\n          onChange: (e, b) => setStatePartial({ b }),\n          min: 0,\n          max: 1,\n          step: 0.01,}\n        )\n        , React.createElement(Slider, {\n          value: state.c,\n          onChange: (e, c) => setStatePartial({ c }),\n          min: 0,\n          max: 1,\n          step: 0.01,}\n        )\n        , state.a\n        , React.createElement('div', null, \"fps: \" , fps)\n      )\n    )\n  )\n}\n","\nexport default \"#version 300 es\\nprecision mediump float;\\n\\n// START ../common/banded.glsl\\nfloat banded(float bandCount, float t) {\\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\\n}\\nfloat banded(int bandCount, float t) {\\n  return banded(float(bandCount), t);\\n}\\n\\n// #pragma glslify: export(banded)\\n\\n\\n// END ../common/banded.glsl\\n// START ../common/between.glsl\\nbool between(float min, float max, float value) {\\n  return min <= value && value <= max;\\n}\\n\\n// #pragma glslify: export(between)\\n\\n\\n// END ../common/between.glsl\\n// START ../common/hexFns.glsl\\n// START ./max3.glsl\\nfloat max3(float a, float b, float c) {\\n  return max(a, max(b, c));\\n}\\nfloat max3(vec3 v) {\\n  return max(v.x, max(v.y, v.z));\\n}\\n\\n// #pragma glslify: export(max3)\\n\\n\\n// END ./max3.glsl\\n// START ./constants.glsl\\nconst float SQRT1_2 = 0.7071067811865476;\\nconst float SQRT1_3 = 0.57735026919;\\nconst float SQRT2 = 1.4142135623730951;\\nconst float SQRT3 = 1.732050807568877;\\n// sqrt(3)/2 = sin(60*)\\nconst float SQRT3_2 = 0.86602540378;\\nconst float GOLDEN_RATIO = 1.61803398875;\\nconst float PI = 3.141592653589793;\\nconst float TAU = 6.28318530718;\\n/**\\n * One degree in radians. Use like `sin(30 * DEG)`.\\n */\\nconst float DEGREE = 0.017453292519943295;\\n\\n// END ./constants.glsl\\n\\nvec3 hexRound(vec3 hex) {\\n  vec3 r = floor(hex + 0.5);\\n  vec3 diff = abs(r - hex);\\n\\n  if (diff.x > diff.y && diff.x > diff.z) {\\n    r.x = -(r.y + r.z);\\n  } else if (diff.y > diff.z) {\\n    r.y = -(r.x + r.z);\\n  } else {\\n    r.z = -(r.x + r.y);\\n  }\\n\\n  return r;\\n}\\nvec2 hex2Ra(vec3 hex) {\\n  float y = hex.t * SQRT3_2;\\n  float x = hex.s + hex.t / 2.0;\\n  return vec2(x, y);\\n}\\n\\nfloat hexSdf(vec3 hex) {\\n  return max3(abs(hex.yzx + hex.zxy / 2.0));\\n}\\nvec3 ra2Hex(vec2 xy) {\\n  float hex_t = xy.y / SQRT3_2;\\n  float hex_s = xy.x - hex_t / 2.0;\\n  return vec3(hex_s, hex_t, -(hex_s + hex_t));\\n}\\n\\n// END ../common/hexFns.glsl\\n// START ../common/matrices.glsl\\n\\nmat2 rot2(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat2(c, s, -s, c);\\n}\\nmat3 rotX(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\\n}\\nmat3 rotY(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\\n}\\nmat3 rotZ(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\\n}\\n/**\\n * Returns a matrix that puts the camera at the eye point `ex, ey, ez` looking\\n * toward the center point `cx, cy, cz` with an up direction of `ux, uy, uz`.\\n * This emulates the OpenGL function `gluLookAt()`.\\n */\\nmat4 lookAt(vec3 eye, vec3 focus, vec3 up) {\\n  vec3 f = normalize(eye - focus);\\n  vec3 s = normalize(cross(up, f));\\n  vec3 t = normalize(cross(f, s));\\n\\n  return mat4(\\n    vec4(s.x, t.x, f.x, 0.0),\\n    vec4(s.y, t.y, f.y, 0.0),\\n    vec4(s.z, t.z, f.z, 0.0),\\n    vec4(-dot(s, eye), -dot(t, eye), -dot(f, eye), 1)\\n  );\\n}\\n\\n// the OpenGL function `glFrustum()`.\\nmat4 frustum(\\n  float left,\\n  float right,\\n  float bottom,\\n  float top,\\n  float near,\\n  float far\\n) {\\n  return mat4(\\n    vec4(2.0 * near / (right - left), 0.0, 0.0, 0.0),\\n    vec4(0, 2.0 * near / (top - bottom), 0.0, 0.0),\\n    vec4(\\n      (right + left) / (right - left),\\n      (top + bottom) / (top - bottom),\\n      -(far + near) / (far - near),\\n      -1\\n    ),\\n    vec4(0.0, 0.0, -2.0 * far * near / (far - near), 0.0)\\n  );\\n}\\n\\nmat4 perspective(float fovDegrees, float aspect, float near, float far) {\\n  float y = tan(fovDegrees * DEGREE / 2.0) * near;\\n  float x = y * aspect;\\n  return frustum(-x, x, -y, y, near, far);\\n}\\nmat4 ortho(\\n  float left,\\n  float right,\\n  float bottom,\\n  float top,\\n  float near,\\n  float far\\n) {\\n  return mat4(\\n    vec4(2.0 / (right - left), 0.0, 0.0, 0.0),\\n    vec4(0.0, 2.0 / (top - bottom), 0.0, 0.0),\\n    vec4(0.0, 0.0, -2.0 / (far - near), 0.0),\\n    vec4(\\n      -(right + left) / (right - left),\\n      -(top + bottom) / (top - bottom),\\n      -(far + near) / (far - near),\\n      1.0\\n    )\\n  );\\n}\\n\\n// END ../common/matrices.glsl\\n// START ../common/perlin2DTexture.glsl\\nuniform sampler2D gradients;\\n/* Create random direction vector\\n */\\nvec2 randomGradient(vec2 i) {\\n  // Random float. No precomputed gradients mean this works for any number of grid coordinates\\n  float random =\\n    2920.0 *\\n    sin(float(i.x) * 2.1942 + float(i.y) * 1.71324 + 8.912) *\\n    cos(float(i.x) * 2.3157 * float(i.y) * 2.17832 + 9.758);\\n  //    random = (i.x + 1667.) * (i.x + 2083.) * (i.y + 2659.) * (i.y * 50.77 + .3769);\\n  //    random = sin(SQRT2 * i.x) + cos(GOLDEN_RATIO * i.y) + tan((i.x + i.y) * SQRT3);\\n  return vec2(cos(random), sin(random));\\n}\\nfloat dotGridGradient(vec2 cell, vec2 pos) {\\n  vec2 d = cell - pos;\\n\\n  //  vec2 gradient = texelFetch(gradients, ivec2(cell), 0).xy;\\n  vec2 gradient = randomGradient(vec2(cell));\\n\\n  return dot(gradient, d);\\n}\\n\\nfloat mixx(float a, float b, float t) {\\n  return mix(a, b, smoothstep(0.0, 1.0, t));\\n  //    return mix(a, b, t);\\n}\\n\\n// resulting range is [-0.68, 0.68]. Use unmix to normalize if necessary.\\nfloat perlin2D(vec2 xy) {\\n  float x0 = floor(xy.x);\\n  float x1 = x0 + 1.0;\\n  float y0 = floor(xy.y);\\n  float y1 = y0 + 1.0;\\n\\n  // Interpolate between grid point gradients\\n  float n00 = dotGridGradient(vec2(x0, y0), xy);\\n  float n10 = dotGridGradient(vec2(x1, y0), xy);\\n  float ny0 = mixx(n00, n10, xy.x - x0);\\n\\n  float n01 = dotGridGradient(vec2(x0, y1), xy);\\n  float n11 = dotGridGradient(vec2(x1, y1), xy);\\n  float ny1 = mixx(n01, n11, xy.x - x0);\\n\\n  return mixx(ny0, ny1, xy.y - y0);\\n}\\n\\n// #pragma glslify: export(perlin2D)\\n\\n\\n// END ../common/perlin2DTexture.glsl\\n// START ../common/remix.glsl\\n// START ./unmix.glsl\\nfloat unmix(float a, float b, float value) {\\n  return (value - a) / (b - a);\\n}\\n\\n// #pragma glslify: export(unmix)\\n\\n\\n// END ./unmix.glsl\\n\\nfloat remix(float fromA, float fromB, float toA, float toB, float value) {\\n  return mix(toA, toB, unmix(fromA, fromB, value));\\n}\\n\\nvec4 remix(float fromA, float fromB, vec4 toA, vec4 toB, float value) {\\n  return mix(toA, toB, unmix(fromA, fromB, value));\\n}\\n\\n// #pragma glslify: export(remix)\\n\\n\\n// END ../common/remix.glsl\\n// START ../common/transform.glsl\\nvec3 transform(mat4 pm, vec3 p) {\\n  vec4 pStar = pm * vec4(p, 1);\\n  return pStar.xyz / pStar.w;\\n}\\n\\nvec2 transform(mat4 pm, vec2 p) {\\n  vec4 pStar = pm * vec4(p, 0, 1);\\n  return pStar.xy / pStar.w;\\n}\\n\\n// END ../common/transform.glsl\\n// START ../common/visualize.glsl\\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\\n  float isLow = float(t < 0.0);\\n  float isHigh = float(t > 1.0);\\n  float isMid = 1.0 - isLow - isHigh;\\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\\n}\\n\\nvec4 visualize(float t) {\\n  const vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\\n  const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\\n  return visualize(BLUE, RED, t);\\n}\\n\\n// #pragma glslify: export(visualize)\\n\\n\\n// END ../common/visualize.glsl\\n// START ../common/waves.glsl\\nfloat waves(vec4 color, vec2 position, vec2 direction, float highResTimeStamp) {\\n  return sin(\\n    dot(position, direction / pow(length(direction), 2.0)) +\\n      float(highResTimeStamp) / 200.0\\n  );\\n}\\n\\n// #pragma glslify: export(waves)\\n\\n\\n// END ../common/waves.glsl\\n\\nin float n;\\nin vec2 coord;\\nout vec4 fragColor;\\nuniform float a;\\nuniform int bandCount;\\nuniform mat4 viewModel;\\nuniform sampler2D texture;\\nuniform vec2 iResolution;\\nuniform vec4 colorBackground;\\nuniform vec4 colorPrimary;\\nuniform vec4 colorSecondary;\\n\\nfloat perlin01(vec2 pos) {\\n  return unmix(-0.68, 0.68, perlin2D(pos));\\n}\\n\\nvoid main() {\\n  vec2 fragCoord = transform(viewModel, coord * iResolution);\\n  fragCoord *= 0.01;\\n  vec3 hex_pos = ra2Hex(fragCoord);\\n  vec3 hex_center = hexRound(hex_pos);\\n  vec2 center = hex2Ra(hex_center);\\n  float centerPerl = unmix(-0.68, 0.68, perlin2D(center / 20.0));\\n  float isTop = float(centerPerl > a + 0.05);\\n  float isBottom = float(centerPerl < a - 0.05);\\n  vec4 hexColor =\\n    isTop * colorPrimary +\\n    isBottom * colorSecondary +\\n    (1.0 - isTop - isBottom) * colorBackground;\\n\\n  hexColor = mix(colorBackground, colorPrimary, banded(bandCount, centerPerl));\\n\\n  vec3 hex_d = hex_pos - hex_center;\\n  float d = hexSdf(hex_d);\\n  float isHex = smoothstep(-0.42, -0.38, -d);\\n  fragColor = mix(colorBackground, hexColor, isHex);\\n}\\n\"\nconst sourceMap = {\"version\":3,\"sources\":[\"/home/runner/work/workshop/workshop/src/noises/test.frag\",\"/home/runner/work/workshop/workshop/src/common/banded.glsl\",\"/home/runner/work/workshop/workshop/src/common/between.glsl\",\"/home/runner/work/workshop/workshop/src/common/max3.glsl\",\"/home/runner/work/workshop/workshop/src/common/constants.glsl\",\"/home/runner/work/workshop/workshop/src/common/hexFns.glsl\",\"/home/runner/work/workshop/workshop/src/common/matrices.glsl\",\"/home/runner/work/workshop/workshop/src/common/perlin2DTexture.glsl\",\"/home/runner/work/workshop/workshop/src/common/unmix.glsl\",\"/home/runner/work/workshop/workshop/src/common/remix.glsl\",\"/home/runner/work/workshop/workshop/src/common/transform.glsl\",\"/home/runner/work/workshop/workshop/src/common/visualize.glsl\",\"/home/runner/work/workshop/workshop/src/common/waves.glsl\"],\"names\":[],\"mappings\":\"AAAA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AZIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA\"}\nexport { sourceMap };\n","\nexport default \"#version 300 es\\nprecision highp float;\\n\\n// START ../common/banded.glsl\\nfloat banded(float bandCount, float t) {\\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\\n}\\nfloat banded(int bandCount, float t) {\\n  return banded(float(bandCount), t);\\n}\\n\\n// #pragma glslify: export(banded)\\n\\n\\n// END ../common/banded.glsl\\n// START ../common/between.glsl\\nbool between(float min, float max, float value) {\\n  return min <= value && value <= max;\\n}\\n\\n// #pragma glslify: export(between)\\n\\n\\n// END ../common/between.glsl\\n// START ../common/constants.glsl\\nconst float SQRT1_2 = 0.7071067811865476;\\nconst float SQRT1_3 = 0.57735026919;\\nconst float SQRT2 = 1.4142135623730951;\\nconst float SQRT3 = 1.732050807568877;\\n// sqrt(3)/2 = sin(60*)\\nconst float SQRT3_2 = 0.86602540378;\\nconst float GOLDEN_RATIO = 1.61803398875;\\nconst float PI = 3.141592653589793;\\nconst float TAU = 6.28318530718;\\n/**\\n * One degree in radians. Use like `sin(30 * DEG)`.\\n */\\nconst float DEGREE = 0.017453292519943295;\\n\\n// END ../common/constants.glsl\\n// START ../common/complex.glsl\\n// START ./polar.glsl\\n// START ../common/fromPolar.glsl\\n// START ./unmix.glsl\\nfloat unmix(float a, float b, float value) {\\n  return (value - a) / (b - a);\\n}\\n\\n// #pragma glslify: export(unmix)\\n\\n\\n// END ./unmix.glsl\\n\\nvec3 fromPolar(float radius, float phi, float z) {\\n  return vec3(radius * cos(phi), radius * sin(phi), z);\\n}\\n\\nvec2 fromPolar(float radius, float phi) {\\n  return vec2(radius * cos(phi), radius * sin(phi));\\n}\\n\\nvec2 fromPolar(vec2 polar) {\\n  return fromPolar(polar.x, polar.y);\\n}\\n\\n// #pragma glslify: export(fromPolar)\\n\\n\\n// END ../common/fromPolar.glsl\\n// START ../common/toPolar.glsl\\n\\nvec2 toPolar(vec2 xy) {\\n  return vec2(length(xy), atan(xy.y, xy.x));\\n}\\n\\nmat2 toPolarDerivate(vec2 xy) {\\n  return mat2(xy.x * xy.x, xy.y * xy.y, -xy.y, xy.x) / dot(xy, xy);\\n}\\n\\n// #pragma glslify: export(toPolar)\\n\\n\\n// END ../common/toPolar.glsl\\n\\n// END ./polar.glsl\\n\\nvec2 complexConj(vec2 z) {\\n  return vec2(z.x, -z.y);\\n}\\n\\nvec2 complexMul(vec2 a, vec2 b) {\\n  return vec2(a.x * b.x - a.y * b.y, a.y * b.x + a.x * b.y);\\n}\\n\\nvec2 complexDiv(vec2 a, vec2 b) {\\n  vec2 bConj = vec2(b.x, -b.y);\\n  float divisor = complexMul(b, bConj).x;\\n  return complexMul(a, bConj) / divisor;\\n}\\n\\n// return e^z\\nvec2 complexPow(vec2 z) {\\n  // e^(re + i * im)\\n  // = e^re * e^(i * im)\\n  return fromPolar(exp(z.x), z.y);\\n}\\n\\n// return w^z\\nvec2 complexPow(vec2 w, float z) {\\n  // w = r * e ^ (i * phi)\\n  // ln(w) = ln(r) + i * phi\\n  // w^z = e^(z * log(w)) = e^(z * (ln(r) + i * (phi))\\n  vec2 wPolar = toPolar(w);\\n  vec2 eExp = z * vec2(log(wPolar.x), wPolar.y);\\n  return complexPow(eExp);\\n}\\n\\n// END ../common/complex.glsl\\n// START ../common/colors.glsl\\nconst vec3 INDIAN_RED = vec3(0.804, 0.361, 0.361);\\nconst vec3 LIGHT_CORAL = vec3(0.941, 0.502, 0.502);\\nconst vec3 SALMON = vec3(0.98, 0.502, 0.447);\\nconst vec3 DARK_SALMON = vec3(0.914, 0.588, 0.478);\\nconst vec3 LIGHT_SALMON = vec3(1.0, 0.627, 0.478);\\nconst vec3 CRIMSON = vec3(0.863, 0.078, 0.235);\\nconst vec3 RED = vec3(1.0, 0.0, 0.0);\\nconst vec3 FIRE_BRICK = vec3(0.698, 0.133, 0.133);\\nconst vec3 DARK_RED = vec3(0.545, 0.0, 0.0);\\nconst vec3 PINK = vec3(1.0, 0.753, 0.796);\\nconst vec3 LIGHT_PINK = vec3(1.0, 0.714, 0.757);\\nconst vec3 HOT_PINK = vec3(1.0, 0.412, 0.706);\\nconst vec3 DEEP_PINK = vec3(1.0, 0.078, 0.576);\\nconst vec3 MEDIUM_VIOLET_RED = vec3(0.78, 0.082, 0.522);\\nconst vec3 PALE_VIOLET_RED = vec3(0.859, 0.439, 0.576);\\nconst vec3 CORAL = vec3(1.0, 0.498, 0.314);\\nconst vec3 TOMATO = vec3(1.0, 0.388, 0.278);\\nconst vec3 ORANGE_RED = vec3(1.0, 0.271, 0.0);\\nconst vec3 DARK_ORANGE = vec3(1.0, 0.549, 0.0);\\nconst vec3 ORANGE = vec3(1.0, 0.647, 0.0);\\nconst vec3 GOLD = vec3(1.0, 0.843, 0.0);\\nconst vec3 YELLOW = vec3(1.0, 1.0, 0.0);\\nconst vec3 LIGHT_YELLOW = vec3(1.0, 1.0, 0.878);\\nconst vec3 LEMON_CHION = vec3(1.0, 0.98, 0.804);\\nconst vec3 LIGHT_GOLDENROD_YELLOW = vec3(0.98, 0.98, 0.824);\\nconst vec3 PAPAYA_WHIP = vec3(1.0, 0.937, 0.835);\\nconst vec3 MOCCASIN = vec3(1.0, 0.894, 0.71);\\nconst vec3 PEACH_PU = vec3(1.0, 0.855, 0.725);\\nconst vec3 PALE_GOLDENROD = vec3(0.933, 0.91, 0.667);\\nconst vec3 KHAKI = vec3(0.941, 0.902, 0.549);\\nconst vec3 DARK_KHAKI = vec3(0.741, 0.718, 0.42);\\nconst vec3 LAVENDER = vec3(0.902, 0.902, 0.98);\\nconst vec3 THISTLE = vec3(0.847, 0.749, 0.847);\\nconst vec3 PLUM = vec3(0.867, 0.627, 0.867);\\nconst vec3 VIOLET = vec3(0.933, 0.51, 0.933);\\nconst vec3 ORCHID = vec3(0.855, 0.439, 0.839);\\nconst vec3 FUCHSIA = vec3(1.0, 0.0, 1.0);\\nconst vec3 MAGENTA = vec3(1.0, 0.0, 1.0);\\nconst vec3 MEDIUM_ORCHID = vec3(0.729, 0.333, 0.827);\\nconst vec3 MEDIUM_PURPLE = vec3(0.576, 0.439, 0.859);\\nconst vec3 BLUE_VIOLET = vec3(0.541, 0.169, 0.886);\\nconst vec3 DARK_VIOLET = vec3(0.58, 0.0, 0.827);\\nconst vec3 DARK_ORCHID = vec3(0.6, 0.196, 0.8);\\nconst vec3 DARK_MAGENTA = vec3(0.545, 0.0, 0.545);\\nconst vec3 PURPLE = vec3(0.502, 0.0, 0.502);\\nconst vec3 INDIGO = vec3(0.294, 0.0, 0.51);\\nconst vec3 SLATE_BLUE = vec3(0.416, 0.353, 0.804);\\nconst vec3 DARK_SLATE_BLUE = vec3(0.282, 0.239, 0.545);\\nconst vec3 GREEN_YELLOW = vec3(0.678, 1.0, 0.184);\\nconst vec3 CHARTREUSE = vec3(0.498, 1.0, 0.0);\\nconst vec3 LAWN_GREEN = vec3(0.486, 0.988, 0.0);\\nconst vec3 LIME = vec3(0.0, 1.0, 0.0);\\nconst vec3 LIME_GREEN = vec3(0.196, 0.804, 0.196);\\nconst vec3 PALE_GREEN = vec3(0.596, 0.984, 0.596);\\nconst vec3 LIGHT_GREEN = vec3(0.565, 0.933, 0.565);\\nconst vec3 MEDIUM_SPRING_GREEN = vec3(0.0, 0.98, 0.604);\\nconst vec3 SPRING_GREEN = vec3(0.0, 1.0, 0.498);\\nconst vec3 MEDIUM_SEA_GREEN = vec3(0.235, 0.702, 0.443);\\nconst vec3 SEA_GREEN = vec3(0.18, 0.545, 0.341);\\nconst vec3 FOREST_GREEN = vec3(0.133, 0.545, 0.133);\\nconst vec3 GREEN = vec3(0.0, 0.502, 0.0);\\nconst vec3 DARK_GREEN = vec3(0.0, 0.392, 0.0);\\nconst vec3 YELLOW_GREEN = vec3(0.604, 0.804, 0.196);\\nconst vec3 OLIVE_DRAB = vec3(0.42, 0.557, 0.137);\\nconst vec3 OLIVE = vec3(0.502, 0.502, 0.0);\\nconst vec3 DARK_OLIVE_GREEN = vec3(0.333, 0.42, 0.184);\\nconst vec3 MEDIUM_AQUAMARINE = vec3(0.4, 0.804, 0.667);\\nconst vec3 DARK_SEA_GREEN = vec3(0.561, 0.737, 0.561);\\nconst vec3 LIGHT_SEA_GREEN = vec3(0.125, 0.698, 0.667);\\nconst vec3 DARK_CYAN = vec3(0.0, 0.545, 0.545);\\nconst vec3 TEAL = vec3(0.0, 0.502, 0.502);\\nconst vec3 AQUA = vec3(0.0, 1.0, 1.0);\\nconst vec3 CYAN = vec3(0.0, 1.0, 1.0);\\nconst vec3 LIGHT_CYAN = vec3(0.878, 1.0, 1.0);\\nconst vec3 PALE_TURQUOISE = vec3(0.686, 0.933, 0.933);\\nconst vec3 AQUAMARINE = vec3(0.498, 1.0, 0.831);\\nconst vec3 TURQUOISE = vec3(0.251, 0.878, 0.816);\\nconst vec3 MEDIUM_TURQUOISE = vec3(0.282, 0.82, 0.8);\\nconst vec3 DARK_TURQUOISE = vec3(0.0, 0.808, 0.82);\\nconst vec3 CADET_BLUE = vec3(0.373, 0.62, 0.627);\\nconst vec3 STEEL_BLUE = vec3(0.275, 0.51, 0.706);\\nconst vec3 LIGHT_STEEL_BLUE = vec3(0.69, 0.769, 0.871);\\nconst vec3 POWDER_BLUE = vec3(0.69, 0.878, 0.902);\\nconst vec3 LIGHT_BLUE = vec3(0.678, 0.847, 0.902);\\nconst vec3 SKY_BLUE = vec3(0.529, 0.808, 0.922);\\nconst vec3 LIGHT_SKY_BLUE = vec3(0.529, 0.808, 0.98);\\nconst vec3 DEEP_SKY_BLUE = vec3(0.0, 0.749, 1.0);\\nconst vec3 DODGER_BLUE = vec3(0.118, 0.565, 1.0);\\nconst vec3 CORNLOWER_BLUE = vec3(0.392, 0.584, 0.929);\\nconst vec3 MEDIUM_SLATE_BLUE = vec3(0.482, 0.408, 0.933);\\nconst vec3 ROYAL_BLUE = vec3(0.255, 0.412, 0.882);\\nconst vec3 BLUE = vec3(0.0, 0.0, 1.0);\\nconst vec3 MEDIUM_BLUE = vec3(0.0, 0.0, 0.804);\\nconst vec3 DARK_BLUE = vec3(0.0, 0.0, 0.545);\\nconst vec3 NAVY = vec3(0.0, 0.0, 0.502);\\nconst vec3 MIDNIGHT_BLUE = vec3(0.098, 0.098, 0.439);\\nconst vec3 CORNSILK = vec3(1.0, 0.973, 0.863);\\nconst vec3 BLANCHED_ALMOND = vec3(1.0, 0.922, 0.804);\\nconst vec3 BISQUE = vec3(1.0, 0.894, 0.769);\\nconst vec3 NAVAJO_WHITE = vec3(1.0, 0.871, 0.678);\\nconst vec3 WHEAT = vec3(0.961, 0.871, 0.702);\\nconst vec3 BURLY_WOOD = vec3(0.871, 0.722, 0.529);\\nconst vec3 TAN = vec3(0.824, 0.706, 0.549);\\nconst vec3 ROSY_BROWN = vec3(0.737, 0.561, 0.561);\\nconst vec3 SANDY_BROWN = vec3(0.957, 0.643, 0.376);\\nconst vec3 GOLDENROD = vec3(0.855, 0.647, 0.125);\\nconst vec3 DARK_GOLDENROD = vec3(0.722, 0.525, 0.043);\\nconst vec3 PERU = vec3(0.804, 0.522, 0.247);\\nconst vec3 CHOCOLATE = vec3(0.824, 0.412, 0.118);\\nconst vec3 SADDLE_BROWN = vec3(0.545, 0.271, 0.075);\\nconst vec3 SIENNA = vec3(0.627, 0.322, 0.176);\\nconst vec3 BROWN = vec3(0.647, 0.165, 0.165);\\nconst vec3 MAROON = vec3(0.502, 0.0, 0.0);\\nconst vec3 WHITE = vec3(1.0, 1.0, 1.0);\\nconst vec3 SNOW = vec3(1.0, 0.98, 0.98);\\nconst vec3 HONEYDEW = vec3(0.941, 1.0, 0.941);\\nconst vec3 MINT_CREAM = vec3(0.961, 1.0, 0.98);\\nconst vec3 AZURE = vec3(0.941, 1.0, 1.0);\\nconst vec3 ALICE_BLUE = vec3(0.941, 0.973, 1.0);\\nconst vec3 GHOST_WHITE = vec3(0.973, 0.973, 1.0);\\nconst vec3 WHITE_SMOKE = vec3(0.961, 0.961, 0.961);\\nconst vec3 SEASHELL = vec3(1.0, 0.961, 0.933);\\nconst vec3 BEIGE = vec3(0.961, 0.961, 0.863);\\nconst vec3 OLD_LACE = vec3(0.992, 0.961, 0.902);\\nconst vec3 FLORAL_WHITE = vec3(1.0, 0.98, 0.941);\\nconst vec3 IVORY = vec3(1.0, 1.0, 0.941);\\nconst vec3 ANTIQUE_WHITE = vec3(0.98, 0.922, 0.843);\\nconst vec3 LINEN = vec3(0.98, 0.941, 0.902);\\nconst vec3 LAVENDER_BLUSH = vec3(1.0, 0.941, 0.961);\\nconst vec3 MISTY_ROSE = vec3(1.0, 0.894, 0.882);\\nconst vec3 GAINSBORO = vec3(0.863, 0.863, 0.863);\\nconst vec3 LIGHT_GREY = vec3(0.827, 0.827, 0.827);\\nconst vec3 SILVER = vec3(0.753, 0.753, 0.753);\\nconst vec3 DARK_GRAY = vec3(0.663, 0.663, 0.663);\\nconst vec3 GRAY = vec3(0.502, 0.502, 0.502);\\nconst vec3 DIM_GRAY = vec3(0.412, 0.412, 0.412);\\nconst vec3 LIGHT_SLATE_GRAY = vec3(0.467, 0.533, 0.6);\\nconst vec3 SLATE_GRAY = vec3(0.439, 0.502, 0.565);\\nconst vec3 DARK_SLATE_GRAY = vec3(0.184, 0.31, 0.31);\\nconst vec3 BLACK = vec3(0.0, 0.0, 0.0);\\n\\n// END ../common/colors.glsl\\n// START ../common/hexFns.glsl\\n// START ./max3.glsl\\nfloat max3(float a, float b, float c) {\\n  return max(a, max(b, c));\\n}\\nfloat max3(vec3 v) {\\n  return max(v.x, max(v.y, v.z));\\n}\\n\\n// #pragma glslify: export(max3)\\n\\n\\n// END ./max3.glsl\\n\\nvec3 hexRound(vec3 hex) {\\n  vec3 r = floor(hex + 0.5);\\n  vec3 diff = abs(r - hex);\\n\\n  if (diff.x > diff.y && diff.x > diff.z) {\\n    r.x = -(r.y + r.z);\\n  } else if (diff.y > diff.z) {\\n    r.y = -(r.x + r.z);\\n  } else {\\n    r.z = -(r.x + r.y);\\n  }\\n\\n  return r;\\n}\\nvec2 hex2Ra(vec3 hex) {\\n  float y = hex.t * SQRT3_2;\\n  float x = hex.s + hex.t / 2.0;\\n  return vec2(x, y);\\n}\\n\\nfloat hexSdf(vec3 hex) {\\n  return max3(abs(hex.yzx + hex.zxy / 2.0));\\n}\\nvec3 ra2Hex(vec2 xy) {\\n  float hex_t = xy.y / SQRT3_2;\\n  float hex_s = xy.x - hex_t / 2.0;\\n  return vec3(hex_s, hex_t, -(hex_s + hex_t));\\n}\\n\\n// END ../common/hexFns.glsl\\n// START ../common/matrices.glsl\\n\\nmat2 rot2(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat2(c, s, -s, c);\\n}\\nmat3 rotX(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\\n}\\nmat3 rotY(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\\n}\\nmat3 rotZ(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\\n}\\n/**\\n * Returns a matrix that puts the camera at the eye point `ex, ey, ez` looking\\n * toward the center point `cx, cy, cz` with an up direction of `ux, uy, uz`.\\n * This emulates the OpenGL function `gluLookAt()`.\\n */\\nmat4 lookAt(vec3 eye, vec3 focus, vec3 up) {\\n  vec3 f = normalize(eye - focus);\\n  vec3 s = normalize(cross(up, f));\\n  vec3 t = normalize(cross(f, s));\\n\\n  return mat4(\\n    vec4(s.x, t.x, f.x, 0.0),\\n    vec4(s.y, t.y, f.y, 0.0),\\n    vec4(s.z, t.z, f.z, 0.0),\\n    vec4(-dot(s, eye), -dot(t, eye), -dot(f, eye), 1)\\n  );\\n}\\n\\n// the OpenGL function `glFrustum()`.\\nmat4 frustum(\\n  float left,\\n  float right,\\n  float bottom,\\n  float top,\\n  float near,\\n  float far\\n) {\\n  return mat4(\\n    vec4(2.0 * near / (right - left), 0.0, 0.0, 0.0),\\n    vec4(0, 2.0 * near / (top - bottom), 0.0, 0.0),\\n    vec4(\\n      (right + left) / (right - left),\\n      (top + bottom) / (top - bottom),\\n      -(far + near) / (far - near),\\n      -1\\n    ),\\n    vec4(0.0, 0.0, -2.0 * far * near / (far - near), 0.0)\\n  );\\n}\\n\\nmat4 perspective(float fovDegrees, float aspect, float near, float far) {\\n  float y = tan(fovDegrees * DEGREE / 2.0) * near;\\n  float x = y * aspect;\\n  return frustum(-x, x, -y, y, near, far);\\n}\\nmat4 ortho(\\n  float left,\\n  float right,\\n  float bottom,\\n  float top,\\n  float near,\\n  float far\\n) {\\n  return mat4(\\n    vec4(2.0 / (right - left), 0.0, 0.0, 0.0),\\n    vec4(0.0, 2.0 / (top - bottom), 0.0, 0.0),\\n    vec4(0.0, 0.0, -2.0 / (far - near), 0.0),\\n    vec4(\\n      -(right + left) / (right - left),\\n      -(top + bottom) / (top - bottom),\\n      -(far + near) / (far - near),\\n      1.0\\n    )\\n  );\\n}\\n\\n// END ../common/matrices.glsl\\n// START ../common/remix.glsl\\n\\nfloat remix(float fromA, float fromB, float toA, float toB, float value) {\\n  return mix(toA, toB, unmix(fromA, fromB, value));\\n}\\n\\nvec4 remix(float fromA, float fromB, vec4 toA, vec4 toB, float value) {\\n  return mix(toA, toB, unmix(fromA, fromB, value));\\n}\\n\\n// #pragma glslify: export(remix)\\n\\n\\n// END ../common/remix.glsl\\n// START ../common/simplex2DTexture.glsl\\n// START ./triFns.glsl\\n\\n// (x, y) -> (u, v, R)\\n// where u is horizontal, v is south-west to north-east\\n// and R is wether the it is in the right triangle\\nvec3 xy2tri(vec2 xy) {\\n  float v = xy.y / SQRT3_2;\\n  float u = xy.x - v / 2.0;\\n  float R = float(\\n    mod(u + v, 2.0) > 1.0 != (mod(floor(u) + floor(v), 2.0) == 1.0)\\n  );\\n  return vec3(u, v, R);\\n}\\nvec3 triCenter(vec3 uvR) {\\n  vec3 base = floor(uvR);\\n  vec2 centerOffset = mix(vec2(1.0 / 3.0), vec2(2.0 / 3.0), uvR.z);\\n  return base + vec3(centerOffset, 0.0);\\n}\\nvec2 tri2xy(vec3 uvR) {\\n  float y = uvR.t * SQRT3_2;\\n  float x = uvR.s + uvR.t / 2.0;\\n  return vec2(x, y);\\n}\\nvec2 tri2xy(vec2 uv) {\\n  float y = uv.t * SQRT3_2;\\n  float x = uv.s + uv.t / 2.0;\\n  return vec2(x, y);\\n}\\nfloat triSdf(vec2 uv) {\\n  vec3 hex = vec3(uv.x, uv.y, -uv.x - uv.y);\\n  return max3(hex);\\n}\\n\\n// END ./triFns.glsl\\n\\nuniform sampler2D gradients;\\n\\n/* Create random direction vector\\n */\\nvec2 randomGradient(vec2 i) {\\n  // Random float. No precomputed gradients mean this works for any number of grid coordinates\\n  float random =\\n    2920.0 *\\n    sin(float(i.x) * 2.1942 + float(i.y) * 1.71324 + 8.912) *\\n    cos(float(i.x) * 2.3157 * float(i.y) * 2.17832 + 9.758);\\n  //    random = (i.x + 1667.) * (i.x + 2083.) * (i.y + 2659.) * (i.y * 50.77 + .3769);\\n  //    random = sin(SQRT2 * i.x) + cos(GOLDEN_RATIO * i.y) + tan((i.x + i.y) * SQRT3);\\n  return vec2(cos(random), sin(random));\\n}\\n\\nfloat dotGridGradient2(vec2 cell, vec2 pos) {\\n  vec2 xy_d = cell - pos;\\n  if (length(xy_d) > 0.45) return -0.0;\\n  float r = 1.0;\\n  float part = pow(max(0.0, 1.0 - dot(xy_d, xy_d)), 4.0);\\n  //    vec2 gradient = texelFetch(gradients, ivec2(cell), 0).xy;\\n  vec2 gradient = randomGradient(cell);\\n  return part * dot(gradient, xy_d);\\n}\\n\\n// resulting range is [-0.68, 0.68]. Use unmix to normalize if necessary.\\nfloat simplex2D(vec2 xy) {\\n  vec3 uvR = xy2tri(xy);\\n  vec2 baseUV = floor(uvR.xy);\\n\\n  float a = dotGridGradient2(tri2xy(baseUV), xy);\\n  float b = dotGridGradient2(tri2xy(baseUV + vec2(1, 0)), xy);\\n  float c = dotGridGradient2(tri2xy(baseUV + vec2(0, 1)), xy);\\n  float d = dotGridGradient2(tri2xy(baseUV + vec2(1, 1)), xy);\\n\\n  return b + c + mix(a, d, uvR.z);\\n}\\n\\n// #pragma glslify: export(simplex2D)\\n\\n\\n// END ../common/simplex2DTexture.glsl\\n// START ../common/visualize.glsl\\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\\n  float isLow = float(t < 0.0);\\n  float isHigh = float(t > 1.0);\\n  float isMid = 1.0 - isLow - isHigh;\\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\\n}\\n\\nvec4 visualize(float t) {\\n  const vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\\n  const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\\n  return visualize(BLUE, RED, t);\\n}\\n\\n// #pragma glslify: export(visualize)\\n\\n\\n// END ../common/visualize.glsl\\n// START ../common/waves.glsl\\nfloat waves(vec4 color, vec2 position, vec2 direction, float highResTimeStamp) {\\n  return sin(\\n    dot(position, direction / pow(length(direction), 2.0)) +\\n      float(highResTimeStamp) / 200.0\\n  );\\n}\\n\\n// #pragma glslify: export(waves)\\n\\n\\n// END ../common/waves.glsl\\n\\nuniform sampler2D texture;\\nuniform vec4 colorPrimary;\\nuniform vec4 colorSecondary;\\nuniform vec4 colorBackground;\\nuniform float a;\\nuniform float b;\\nuniform int bandCount;\\nuniform float iTime;\\nuniform vec2 iMouse;\\nuniform vec2 iResolution;\\nin vec2 coord;\\nout vec4 fragColor;\\n\\nvec2 f(vec2 z) {\\n  //  const vec2 c = vec2(-0.4, 0.6);\\n  //  vec2 c = fromPolar(0.7885, (a + b / 50.0) * 6.0);\\n  //  vec2 c = fromPolar(0.7885, iTime / 2.0);\\n  //  vec2 c = fromPolar(0.7885, 4.0);\\n  vec2 c = 0.01 * (iMouse - 0.5 * iResolution);\\n  return complexMul(z, z) + c;\\n}\\n\\nvec2 complexSqr(vec2 z) {\\n  return complexMul(z, z);\\n}\\nvec2 f2(vec2 z) {\\n  const float n = 8.0;\\n  return complexDiv(\\n    1.0 + (n - 1.0) * complexPow(z, n),\\n    n * complexPow(z, n - 1.0)\\n  );\\n}\\n\\nvec2 f3(vec2 z) {\\n  vec2 z2 = complexMul(z, z);\\n  vec2 z3 = complexMul(z2, z);\\n  return complexDiv(vec2(1.0, 0.0) + 2.0 * z3, 3.0 * z2);\\n}\\nvec2 flf(vec2 z) {\\n  vec2 z2 = complexMul(z, z);\\n  vec2 z3 = complexMul(z2, z);\\n  return complexDiv(vec2(1.0, 0.0) - z3 / 6.0, complexSqr(z - z2 / 2.0)) +\\n  vec2(-a, b);\\n}\\n\\n// START ../common/juliaIteration.glsl\\n#define JULIA_ITERATION(NAME, F, R, MAXIT)                                     \\\\\\n  vec3 NAME(vec2 start) {                                                      \\\\\\n    const float rSqr = (R) * (R);                                              \\\\\\n    vec2 p = start;                                                            \\\\\\n    for (uint i = uint(0); i < (MAXIT); i++) {                                 \\\\\\n      p = F(p);                                                                \\\\\\n      if (dot(p, p) > rSqr) {                                                  \\\\\\n        return vec3(p, float(i));                                              \\\\\\n      }                                                                        \\\\\\n    }                                                                          \\\\\\n    return vec3(p, float(MAXIT));                                              \\\\\\n  }\\n\\n// END ../common/juliaIteration.glsl\\n\\nJULIA_ITERATION(julia, f, 2.0, 20u)\\n\\nvoid main() {\\n  vec2 fragCoord = (coord - 0.5) * iResolution * 0.005;\\n  vec3 res = julia(fragCoord);\\n  float f = res.z / 20.0;\\n\\n  //    fragColor = mix(colorBackground, colorPrimary, banded(bandCount, unmix(-.35, .35, f2)));\\n  fragColor = mix(\\n    colorBackground,\\n    colorPrimary,\\n    min(banded(bandCount, f), 1.0)\\n  );\\n  fragColor = vec4(res, 1.0);\\n  //    fragColor = visualize(f);\\n  //    fragColor = visualize(float(i == 1000u));\\n}\\n\"\nconst sourceMap = {\"version\":3,\"sources\":[\"/home/runner/work/workshop/workshop/src/noises/julia.frag\",\"/home/runner/work/workshop/workshop/src/common/banded.glsl\",\"/home/runner/work/workshop/workshop/src/common/between.glsl\",\"/home/runner/work/workshop/workshop/src/common/constants.glsl\",\"/home/runner/work/workshop/workshop/src/common/unmix.glsl\",\"/home/runner/work/workshop/workshop/src/common/fromPolar.glsl\",\"/home/runner/work/workshop/workshop/src/common/toPolar.glsl\",\"/home/runner/work/workshop/workshop/src/common/polar.glsl\",\"/home/runner/work/workshop/workshop/src/common/complex.glsl\",\"/home/runner/work/workshop/workshop/src/common/colors.glsl\",\"/home/runner/work/workshop/workshop/src/common/max3.glsl\",\"/home/runner/work/workshop/workshop/src/common/hexFns.glsl\",\"/home/runner/work/workshop/workshop/src/common/matrices.glsl\",\"/home/runner/work/workshop/workshop/src/common/remix.glsl\",\"/home/runner/work/workshop/workshop/src/common/triFns.glsl\",\"/home/runner/work/workshop/workshop/src/common/simplex2DTexture.glsl\",\"/home/runner/work/workshop/workshop/src/common/visualize.glsl\",\"/home/runner/work/workshop/workshop/src/common/waves.glsl\",\"/home/runner/work/workshop/workshop/src/common/juliaIteration.glsl\"],\"names\":[],\"mappings\":\"AAAA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC5IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AjBOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AkB7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AlBmDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA\"}\nexport { sourceMap };\n","/**\n * Helper class to count frames per second.\n */\nexport class FPSController {\n   __init() {this.count = 0}\n\n   __init2() {this.lastTime = performance.now()}\n  constructor(\n      notify,\n      window = 10,\n  ) {;this.notify = notify;this.window = window;FPSController.prototype.__init.call(this);FPSController.prototype.__init2.call(this);}\n\n  tick(time = performance.now()) {\n    const window = this.window\n    this.count = (this.count + 1) % window\n    if (this.count === 0) {\n      const fps = Math.floor((window * 1000) / (time - this.lastTime))\n      this.notify(fps)\n      this.lastTime = time\n    }\n  }\n}\n","\nexport default \"#version 300 es\\n\\nprecision highp float;\\n\\n// START ../common/constants.glsl\\nconst float SQRT1_2 = 0.7071067811865476;\\nconst float SQRT1_3 = 0.57735026919;\\nconst float SQRT2 = 1.4142135623730951;\\nconst float SQRT3 = 1.732050807568877;\\n// sqrt(3)/2 = sin(60*)\\nconst float SQRT3_2 = 0.86602540378;\\nconst float GOLDEN_RATIO = 1.61803398875;\\nconst float PI = 3.141592653589793;\\nconst float TAU = 6.28318530718;\\n/**\\n * One degree in radians. Use like `sin(30 * DEG)`.\\n */\\nconst float DEGREE = 0.017453292519943295;\\n\\n// END ../common/constants.glsl\\n// START ../common/fromPolar.glsl\\n// START ./unmix.glsl\\nfloat unmix(float a, float b, float value) {\\n  return (value - a) / (b - a);\\n}\\n\\n// #pragma glslify: export(unmix)\\n\\n\\n// END ./unmix.glsl\\n\\nvec3 fromPolar(float radius, float phi, float z) {\\n  return vec3(radius * cos(phi), radius * sin(phi), z);\\n}\\n\\nvec2 fromPolar(float radius, float phi) {\\n  return vec2(radius * cos(phi), radius * sin(phi));\\n}\\n\\nvec2 fromPolar(vec2 polar) {\\n  return fromPolar(polar.x, polar.y);\\n}\\n\\n// #pragma glslify: export(fromPolar)\\n\\n\\n// END ../common/fromPolar.glsl\\n// START ../common/linstep.glsl\\nfloat linstep(float a, float b, float t) {\\n  return clamp((t - a) / (b - a), 0.0, 1.0);\\n}\\nvec2 linstep(vec2 a, vec2 b, float t) {\\n  return clamp((t - a) / (b - a), 0.0, 1.0);\\n}\\nvec3 linstep(vec3 a, vec3 b, float t) {\\n  return clamp((t - a) / (b - a), 0.0, 1.0);\\n}\\nvec4 linstep(vec4 a, vec4 b, float t) {\\n  return clamp((t - a) / (b - a), 0.0, 1.0);\\n}\\n\\n// END ../common/linstep.glsl\\n// START ../common/matrices.glsl\\n\\nmat2 rot2(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat2(c, s, -s, c);\\n}\\nmat3 rotX(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\\n}\\nmat3 rotY(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\\n}\\nmat3 rotZ(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\\n}\\n/**\\n * Returns a matrix that puts the camera at the eye point `ex, ey, ez` looking\\n * toward the center point `cx, cy, cz` with an up direction of `ux, uy, uz`.\\n * This emulates the OpenGL function `gluLookAt()`.\\n */\\nmat4 lookAt(vec3 eye, vec3 focus, vec3 up) {\\n  vec3 f = normalize(eye - focus);\\n  vec3 s = normalize(cross(up, f));\\n  vec3 t = normalize(cross(f, s));\\n\\n  return mat4(\\n    vec4(s.x, t.x, f.x, 0.0),\\n    vec4(s.y, t.y, f.y, 0.0),\\n    vec4(s.z, t.z, f.z, 0.0),\\n    vec4(-dot(s, eye), -dot(t, eye), -dot(f, eye), 1)\\n  );\\n}\\n\\n// the OpenGL function `glFrustum()`.\\nmat4 frustum(\\n  float left,\\n  float right,\\n  float bottom,\\n  float top,\\n  float near,\\n  float far\\n) {\\n  return mat4(\\n    vec4(2.0 * near / (right - left), 0.0, 0.0, 0.0),\\n    vec4(0, 2.0 * near / (top - bottom), 0.0, 0.0),\\n    vec4(\\n      (right + left) / (right - left),\\n      (top + bottom) / (top - bottom),\\n      -(far + near) / (far - near),\\n      -1\\n    ),\\n    vec4(0.0, 0.0, -2.0 * far * near / (far - near), 0.0)\\n  );\\n}\\n\\nmat4 perspective(float fovDegrees, float aspect, float near, float far) {\\n  float y = tan(fovDegrees * DEGREE / 2.0) * near;\\n  float x = y * aspect;\\n  return frustum(-x, x, -y, y, near, far);\\n}\\nmat4 ortho(\\n  float left,\\n  float right,\\n  float bottom,\\n  float top,\\n  float near,\\n  float far\\n) {\\n  return mat4(\\n    vec4(2.0 / (right - left), 0.0, 0.0, 0.0),\\n    vec4(0.0, 2.0 / (top - bottom), 0.0, 0.0),\\n    vec4(0.0, 0.0, -2.0 / (far - near), 0.0),\\n    vec4(\\n      -(right + left) / (right - left),\\n      -(top + bottom) / (top - bottom),\\n      -(far + near) / (far - near),\\n      1.0\\n    )\\n  );\\n}\\n\\n// END ../common/matrices.glsl\\n// START ../common/sdf2d/addChamfer.glsl\\n\\nfloat addChamfer(float d, float a, float b) {\\n  // exact variant, but abs is larger when a and b aren't perpendicular\\n  // which is worse than underestimating, which is what the simple version does.\\n  //  vec2 p = vec2(a, b);\\n  //  if (p.x < d && p.y < d) {\\n  //    p = rot2(0.25 * PI) * p;\\n  //    p.y = abs(p.y);\\n  //    p.y -= min(p.y, d * SQRT1_2);\\n  //    p.x -= d * SQRT1_2;\\n  //    //    p -= vec2(SQRT1_2) * clamp(dot(p, vec2(SQRT1_2)), 0.0, d);\\n  //    float fillet = -length(p);\\n  //    return -sign(p.x) * fillet;\\n  //  } else {\\n  //  }\\n  float tillet = (a + b - d) * SQRT1_2;\\n  return min(tillet, min(a, b));\\n}\\n\\n// #pragma glslify: export(addChamfer)\\n\\n\\n// END ../common/sdf2d/addChamfer.glsl\\n// START ../common/sdf2d/addFillet.glsl\\nfloat addFillet(float r, float a, float b) {\\n  if (a < r && b < r) {\\n    return r - distance(vec2(a, b), vec2(r));\\n  } else {\\n    return min(a, b);\\n  }\\n}\\n\\n// #pragma glslify: export(addFillet)\\n\\n\\n// END ../common/sdf2d/addFillet.glsl\\n// START ../common/sdf2d/sdArc.glsl\\n// START ../../common/toPolar.glsl\\n\\nvec2 toPolar(vec2 xy) {\\n  return vec2(length(xy), atan(xy.y, xy.x));\\n}\\n\\nmat2 toPolarDerivate(vec2 xy) {\\n  return mat2(xy.x * xy.x, xy.y * xy.y, -xy.y, xy.x) / dot(xy, xy);\\n}\\n\\n// #pragma glslify: export(toPolar)\\n\\n\\n// END ../../common/toPolar.glsl\\n\\nfloat sdArc(float angle, vec2 p) {\\n  vec2 polar = toPolar(p);\\n  vec2 closestPolar = vec2(polar.x = 1.0, clamp(polar.y, -angle, angle));\\n  vec2 closest = fromPolar(closestPolar);\\n  return distance(closest, p);\\n}\\n\\nfloat sdArc(float angle, float radius, float thickness, vec2 p) {\\n  return sdArc(angle, p / radius) * radius - 0.5 * thickness;\\n}\\n\\n// #pragma glslify: export(sdArc)\\n\\n\\n// END ../common/sdf2d/sdArc.glsl\\n// START ../common/sdf2d/sdArcRect.glsl\\n\\n/**\\n * 2D signed distance function to an arc with square ends. The opening of the\\n * arc is on the left (negative X direction). The total spanned angle is\\n * `2 * halfAngle`.\\n *\\n * `radius` is the center radius of the arc.\\n *\\n * `width.x` is the thickness of the arc.\\n *\\n * `width.y` is how much the flat end of the arc is extructed. This is a\\n * parameter as is it trivial to add with the current implementation. Set to 0\\n * to just have a flat-ended arc.\\n */\\nfloat sdArcRect(float halfAngle, float radius, vec2 width, vec2 p) {\\n  // Symmetric across x axis; all points on top.\\n  p.y = abs(p.y);\\n  // Rotate so that the end of the arc is at the x axis.\\n  p = rot2(-halfAngle) * p;\\n  if (p.y > 0.0) {\\n    // p is \\\"above the end of the arc\\\"; calculate as for sdRectangle.\\n    p.x = abs(p.x - radius);\\n    p -= 0.5 * width;\\n    return length(max(p, 0.0)) + min(0.0, max(p.x, p.y));\\n  } else {\\n    // Otherwise, the distance is basically just the radial distance to the arc.\\n    // For the inside of the sdf, we have to take the end into account.\\n    return max(abs(length(p) - radius) - 0.5 * width.x, p.y - 0.5 * width.y);\\n  }\\n}\\n\\n// END ../common/sdf2d/sdArcRect.glsl\\n// START ../sdfs2d/vizz.glsl\\n// START ../common/between.glsl\\nbool between(float min, float max, float value) {\\n  return min <= value && value <= max;\\n}\\n\\n// #pragma glslify: export(between)\\n\\n\\n// END ../common/between.glsl\\n// START ../common/ungamma.glsl\\nvec3 ungamma(vec4 col) {\\n  return pow(col.rgb, vec3(2.2));\\n}\\nvec3 ungamma(vec3 col) {\\n  return pow(col, vec3(2.2));\\n}\\n\\n// END ../common/ungamma.glsl\\n// START ../common/colors.glsl\\nconst vec3 INDIAN_RED = vec3(0.804, 0.361, 0.361);\\nconst vec3 LIGHT_CORAL = vec3(0.941, 0.502, 0.502);\\nconst vec3 SALMON = vec3(0.98, 0.502, 0.447);\\nconst vec3 DARK_SALMON = vec3(0.914, 0.588, 0.478);\\nconst vec3 LIGHT_SALMON = vec3(1.0, 0.627, 0.478);\\nconst vec3 CRIMSON = vec3(0.863, 0.078, 0.235);\\nconst vec3 RED = vec3(1.0, 0.0, 0.0);\\nconst vec3 FIRE_BRICK = vec3(0.698, 0.133, 0.133);\\nconst vec3 DARK_RED = vec3(0.545, 0.0, 0.0);\\nconst vec3 PINK = vec3(1.0, 0.753, 0.796);\\nconst vec3 LIGHT_PINK = vec3(1.0, 0.714, 0.757);\\nconst vec3 HOT_PINK = vec3(1.0, 0.412, 0.706);\\nconst vec3 DEEP_PINK = vec3(1.0, 0.078, 0.576);\\nconst vec3 MEDIUM_VIOLET_RED = vec3(0.78, 0.082, 0.522);\\nconst vec3 PALE_VIOLET_RED = vec3(0.859, 0.439, 0.576);\\nconst vec3 CORAL = vec3(1.0, 0.498, 0.314);\\nconst vec3 TOMATO = vec3(1.0, 0.388, 0.278);\\nconst vec3 ORANGE_RED = vec3(1.0, 0.271, 0.0);\\nconst vec3 DARK_ORANGE = vec3(1.0, 0.549, 0.0);\\nconst vec3 ORANGE = vec3(1.0, 0.647, 0.0);\\nconst vec3 GOLD = vec3(1.0, 0.843, 0.0);\\nconst vec3 YELLOW = vec3(1.0, 1.0, 0.0);\\nconst vec3 LIGHT_YELLOW = vec3(1.0, 1.0, 0.878);\\nconst vec3 LEMON_CHION = vec3(1.0, 0.98, 0.804);\\nconst vec3 LIGHT_GOLDENROD_YELLOW = vec3(0.98, 0.98, 0.824);\\nconst vec3 PAPAYA_WHIP = vec3(1.0, 0.937, 0.835);\\nconst vec3 MOCCASIN = vec3(1.0, 0.894, 0.71);\\nconst vec3 PEACH_PU = vec3(1.0, 0.855, 0.725);\\nconst vec3 PALE_GOLDENROD = vec3(0.933, 0.91, 0.667);\\nconst vec3 KHAKI = vec3(0.941, 0.902, 0.549);\\nconst vec3 DARK_KHAKI = vec3(0.741, 0.718, 0.42);\\nconst vec3 LAVENDER = vec3(0.902, 0.902, 0.98);\\nconst vec3 THISTLE = vec3(0.847, 0.749, 0.847);\\nconst vec3 PLUM = vec3(0.867, 0.627, 0.867);\\nconst vec3 VIOLET = vec3(0.933, 0.51, 0.933);\\nconst vec3 ORCHID = vec3(0.855, 0.439, 0.839);\\nconst vec3 FUCHSIA = vec3(1.0, 0.0, 1.0);\\nconst vec3 MAGENTA = vec3(1.0, 0.0, 1.0);\\nconst vec3 MEDIUM_ORCHID = vec3(0.729, 0.333, 0.827);\\nconst vec3 MEDIUM_PURPLE = vec3(0.576, 0.439, 0.859);\\nconst vec3 BLUE_VIOLET = vec3(0.541, 0.169, 0.886);\\nconst vec3 DARK_VIOLET = vec3(0.58, 0.0, 0.827);\\nconst vec3 DARK_ORCHID = vec3(0.6, 0.196, 0.8);\\nconst vec3 DARK_MAGENTA = vec3(0.545, 0.0, 0.545);\\nconst vec3 PURPLE = vec3(0.502, 0.0, 0.502);\\nconst vec3 INDIGO = vec3(0.294, 0.0, 0.51);\\nconst vec3 SLATE_BLUE = vec3(0.416, 0.353, 0.804);\\nconst vec3 DARK_SLATE_BLUE = vec3(0.282, 0.239, 0.545);\\nconst vec3 GREEN_YELLOW = vec3(0.678, 1.0, 0.184);\\nconst vec3 CHARTREUSE = vec3(0.498, 1.0, 0.0);\\nconst vec3 LAWN_GREEN = vec3(0.486, 0.988, 0.0);\\nconst vec3 LIME = vec3(0.0, 1.0, 0.0);\\nconst vec3 LIME_GREEN = vec3(0.196, 0.804, 0.196);\\nconst vec3 PALE_GREEN = vec3(0.596, 0.984, 0.596);\\nconst vec3 LIGHT_GREEN = vec3(0.565, 0.933, 0.565);\\nconst vec3 MEDIUM_SPRING_GREEN = vec3(0.0, 0.98, 0.604);\\nconst vec3 SPRING_GREEN = vec3(0.0, 1.0, 0.498);\\nconst vec3 MEDIUM_SEA_GREEN = vec3(0.235, 0.702, 0.443);\\nconst vec3 SEA_GREEN = vec3(0.18, 0.545, 0.341);\\nconst vec3 FOREST_GREEN = vec3(0.133, 0.545, 0.133);\\nconst vec3 GREEN = vec3(0.0, 0.502, 0.0);\\nconst vec3 DARK_GREEN = vec3(0.0, 0.392, 0.0);\\nconst vec3 YELLOW_GREEN = vec3(0.604, 0.804, 0.196);\\nconst vec3 OLIVE_DRAB = vec3(0.42, 0.557, 0.137);\\nconst vec3 OLIVE = vec3(0.502, 0.502, 0.0);\\nconst vec3 DARK_OLIVE_GREEN = vec3(0.333, 0.42, 0.184);\\nconst vec3 MEDIUM_AQUAMARINE = vec3(0.4, 0.804, 0.667);\\nconst vec3 DARK_SEA_GREEN = vec3(0.561, 0.737, 0.561);\\nconst vec3 LIGHT_SEA_GREEN = vec3(0.125, 0.698, 0.667);\\nconst vec3 DARK_CYAN = vec3(0.0, 0.545, 0.545);\\nconst vec3 TEAL = vec3(0.0, 0.502, 0.502);\\nconst vec3 AQUA = vec3(0.0, 1.0, 1.0);\\nconst vec3 CYAN = vec3(0.0, 1.0, 1.0);\\nconst vec3 LIGHT_CYAN = vec3(0.878, 1.0, 1.0);\\nconst vec3 PALE_TURQUOISE = vec3(0.686, 0.933, 0.933);\\nconst vec3 AQUAMARINE = vec3(0.498, 1.0, 0.831);\\nconst vec3 TURQUOISE = vec3(0.251, 0.878, 0.816);\\nconst vec3 MEDIUM_TURQUOISE = vec3(0.282, 0.82, 0.8);\\nconst vec3 DARK_TURQUOISE = vec3(0.0, 0.808, 0.82);\\nconst vec3 CADET_BLUE = vec3(0.373, 0.62, 0.627);\\nconst vec3 STEEL_BLUE = vec3(0.275, 0.51, 0.706);\\nconst vec3 LIGHT_STEEL_BLUE = vec3(0.69, 0.769, 0.871);\\nconst vec3 POWDER_BLUE = vec3(0.69, 0.878, 0.902);\\nconst vec3 LIGHT_BLUE = vec3(0.678, 0.847, 0.902);\\nconst vec3 SKY_BLUE = vec3(0.529, 0.808, 0.922);\\nconst vec3 LIGHT_SKY_BLUE = vec3(0.529, 0.808, 0.98);\\nconst vec3 DEEP_SKY_BLUE = vec3(0.0, 0.749, 1.0);\\nconst vec3 DODGER_BLUE = vec3(0.118, 0.565, 1.0);\\nconst vec3 CORNLOWER_BLUE = vec3(0.392, 0.584, 0.929);\\nconst vec3 MEDIUM_SLATE_BLUE = vec3(0.482, 0.408, 0.933);\\nconst vec3 ROYAL_BLUE = vec3(0.255, 0.412, 0.882);\\nconst vec3 BLUE = vec3(0.0, 0.0, 1.0);\\nconst vec3 MEDIUM_BLUE = vec3(0.0, 0.0, 0.804);\\nconst vec3 DARK_BLUE = vec3(0.0, 0.0, 0.545);\\nconst vec3 NAVY = vec3(0.0, 0.0, 0.502);\\nconst vec3 MIDNIGHT_BLUE = vec3(0.098, 0.098, 0.439);\\nconst vec3 CORNSILK = vec3(1.0, 0.973, 0.863);\\nconst vec3 BLANCHED_ALMOND = vec3(1.0, 0.922, 0.804);\\nconst vec3 BISQUE = vec3(1.0, 0.894, 0.769);\\nconst vec3 NAVAJO_WHITE = vec3(1.0, 0.871, 0.678);\\nconst vec3 WHEAT = vec3(0.961, 0.871, 0.702);\\nconst vec3 BURLY_WOOD = vec3(0.871, 0.722, 0.529);\\nconst vec3 TAN = vec3(0.824, 0.706, 0.549);\\nconst vec3 ROSY_BROWN = vec3(0.737, 0.561, 0.561);\\nconst vec3 SANDY_BROWN = vec3(0.957, 0.643, 0.376);\\nconst vec3 GOLDENROD = vec3(0.855, 0.647, 0.125);\\nconst vec3 DARK_GOLDENROD = vec3(0.722, 0.525, 0.043);\\nconst vec3 PERU = vec3(0.804, 0.522, 0.247);\\nconst vec3 CHOCOLATE = vec3(0.824, 0.412, 0.118);\\nconst vec3 SADDLE_BROWN = vec3(0.545, 0.271, 0.075);\\nconst vec3 SIENNA = vec3(0.627, 0.322, 0.176);\\nconst vec3 BROWN = vec3(0.647, 0.165, 0.165);\\nconst vec3 MAROON = vec3(0.502, 0.0, 0.0);\\nconst vec3 WHITE = vec3(1.0, 1.0, 1.0);\\nconst vec3 SNOW = vec3(1.0, 0.98, 0.98);\\nconst vec3 HONEYDEW = vec3(0.941, 1.0, 0.941);\\nconst vec3 MINT_CREAM = vec3(0.961, 1.0, 0.98);\\nconst vec3 AZURE = vec3(0.941, 1.0, 1.0);\\nconst vec3 ALICE_BLUE = vec3(0.941, 0.973, 1.0);\\nconst vec3 GHOST_WHITE = vec3(0.973, 0.973, 1.0);\\nconst vec3 WHITE_SMOKE = vec3(0.961, 0.961, 0.961);\\nconst vec3 SEASHELL = vec3(1.0, 0.961, 0.933);\\nconst vec3 BEIGE = vec3(0.961, 0.961, 0.863);\\nconst vec3 OLD_LACE = vec3(0.992, 0.961, 0.902);\\nconst vec3 FLORAL_WHITE = vec3(1.0, 0.98, 0.941);\\nconst vec3 IVORY = vec3(1.0, 1.0, 0.941);\\nconst vec3 ANTIQUE_WHITE = vec3(0.98, 0.922, 0.843);\\nconst vec3 LINEN = vec3(0.98, 0.941, 0.902);\\nconst vec3 LAVENDER_BLUSH = vec3(1.0, 0.941, 0.961);\\nconst vec3 MISTY_ROSE = vec3(1.0, 0.894, 0.882);\\nconst vec3 GAINSBORO = vec3(0.863, 0.863, 0.863);\\nconst vec3 LIGHT_GREY = vec3(0.827, 0.827, 0.827);\\nconst vec3 SILVER = vec3(0.753, 0.753, 0.753);\\nconst vec3 DARK_GRAY = vec3(0.663, 0.663, 0.663);\\nconst vec3 GRAY = vec3(0.502, 0.502, 0.502);\\nconst vec3 DIM_GRAY = vec3(0.412, 0.412, 0.412);\\nconst vec3 LIGHT_SLATE_GRAY = vec3(0.467, 0.533, 0.6);\\nconst vec3 SLATE_GRAY = vec3(0.439, 0.502, 0.565);\\nconst vec3 DARK_SLATE_GRAY = vec3(0.184, 0.31, 0.31);\\nconst vec3 BLACK = vec3(0.0, 0.0, 0.0);\\n\\n// END ../common/colors.glsl\\n\\nuniform vec4 colorPrimary;\\nuniform vec4 colorSecondary;\\nuniform vec4 colorBackground;\\nuniform vec2 iMouse;\\n\\n// show with square wave\\nvec3 vizz(float val) {\\n  vec3 color0 = ungamma(colorBackground);\\n  vec3 color1 = ungamma(colorPrimary);\\n  vec3 color2 = ungamma(colorSecondary);\\n  vec3 cc = val >= 0.0 ? color1 : color2;\\n  float v = abs(mod(abs(val) - 0.5, 2.0) - 1.0);\\n  const float k = 0.5 * 0.1;\\n  if (between(-0.5, 0.5, val)) {\\n    return mix(color2, color1, smoothstep(-k, +k, val));\\n  }\\n  return mix(cc, color0, smoothstep(-0.5 - k, -0.5 + k, -v));\\n}\\n// #pragma glslify: export(vizz)\\nvec3 vizz(float val, float mouseVal, vec2 fragCoord, vec2 mouse, vec2 iMouse) {\\n  vec3 color = vizz(val);\\n\\n  if (-1.0 != iMouse.x) {\\n    color = mix(\\n      color,\\n      ungamma(BLUE),\\n      smoothstep(-0.2, -0.0, -abs(distance(mouse, fragCoord) - abs(mouseVal)))\\n    );\\n  }\\n\\n  return color;\\n}\\n\\n#define VIZZ(SDF)                                                              \\\\\\n  (vizz(                                                                       \\\\\\n    SDF((coord - 0.5) * iResolution * 0.1),                                    \\\\\\n    SDF((iMouse - 0.5 * iResolution) * 0.1),                                   \\\\\\n    coord * iResolution * 0.1,                                                 \\\\\\n    iMouse * 0.1,                                                              \\\\\\n    iMouse                                                                     \\\\\\n  ))\\n\\n// show with one line at 0\\nvec3 vizz2(float val) {\\n  vec3 color0 = ungamma(colorBackground);\\n  vec3 color1 = ungamma(colorPrimary);\\n  vec3 color2 = ungamma(colorSecondary);\\n  vec3 cc = val >= 0.0 ? color1 : color2;\\n  const float k = 0.1;\\n  vec2 dVal = vec2(dFdx(val), dFdy(val));\\n  return mix(\\n    color0,\\n    color1,\\n    smoothstep(-k, +k, -abs(val / length(dVal)) + 0.8)\\n  );\\n}\\n\\n// END ../sdfs2d/vizz.glsl\\n\\nuniform vec2 iResolution;\\nuniform float iTime;\\nuniform float a, b, c;\\nin vec2 coord;\\nout vec4 fragColor;\\n\\nfloat sdf(vec2 p) {\\n  float d = 10000.0;\\n  float t = iTime * 5.0;\\n  for (int i = 0; i < 9; i++) {\\n    float fi = float(i);\\n    // same thing as 0 but offset in time by i:\\n    float ti = t + fi;\\n    float tt = floor(ti / 9.0) + linstep(8.0, 9.0, fract(ti / 9.0) * 9.0);\\n    // same thing as 0 but offset by i:\\n    tt += fi;\\n    vec2 p2 = rot2(tt * 40.0 * DEGREE) * p;\\n    float d2 = sdArcRect(20.0 * DEGREE, 10.0, vec2(6.0, 0.0), p2);\\n    d = min(d, d2);\\n  }\\n  return d;\\n  //  return sdArc(b * PI, 10.0, 5.0, p);\\n}\\n\\nvoid main() {\\n  vec3 color = VIZZ(sdf);\\n  color = pow(color, vec3(1.0 / 2.2)); // gamma correction\\n  fragColor = vec4(color, 1);\\n}\\n\"\nconst sourceMap = {\"version\":3,\"sources\":[\"/home/runner/work/workshop/workshop/src/noises/magic.frag\",\"/home/runner/work/workshop/workshop/src/common/constants.glsl\",\"/home/runner/work/workshop/workshop/src/common/unmix.glsl\",\"/home/runner/work/workshop/workshop/src/common/fromPolar.glsl\",\"/home/runner/work/workshop/workshop/src/common/linstep.glsl\",\"/home/runner/work/workshop/workshop/src/common/matrices.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf2d/addChamfer.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf2d/addFillet.glsl\",\"/home/runner/work/workshop/workshop/src/common/toPolar.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf2d/sdArc.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf2d/sdArcRect.glsl\",\"/home/runner/work/workshop/workshop/src/common/between.glsl\",\"/home/runner/work/workshop/workshop/src/common/ungamma.glsl\",\"/home/runner/work/workshop/workshop/src/common/colors.glsl\",\"/home/runner/work/workshop/workshop/src/sdfs2d/vizz.glsl\"],\"names\":[],\"mappings\":\"AAAA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;Ad/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA\"}\nexport { sourceMap };\n"," function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }import debounce from \"lodash/debounce\"\nimport mapValues from \"lodash/mapValues\"\nimport { useCallback, useEffect, useRef, useState } from \"react\"\nimport {\n  PAPER_SIZE_A4,\n\n  PaperSizeFromString,\n  PaperSizeToString,\n} from \"../paperBox1/PaperSize\"\n\nconst parseHash = (hash) => {\n  return !hash\n    ? {}\n    : hash\n        .substring(1)\n        .split(\"&\")\n        .map((part) => {\n          const [key, value] = part.split(\"=\")\n          return [decodeURIComponent(key), decodeURIComponent(value)]\n        })\n        .reduce(\n          (obj, [key, value]) => {\n            obj[key] = value\n            return obj\n          },\n          {} ,\n        )\n}\nconst objectToHash = (o) => {\n  return (\n    \"#\" +\n    Object.entries(o)\n      .map(\n        ([key, value]) =>\n          encodeURIComponent(key) + \"=\" + encodeURIComponent(value),\n      )\n      .join(\"&\")\n  )\n}\n\nconst defaultDeserialize = (\n  x,\n) =>\n  mapValues(x, (v, key) => {\n    if (\"paperSize\" === key) {\n      try {\n        return PaperSizeFromString(v)\n      } catch (e) {\n        console.error(e)\n        return PAPER_SIZE_A4\n      }\n    } else if (\"true\" === v) {\n      return true\n    } else if (\"false\" === v) {\n      return false\n    } else if (\"NaN\" === v) {\n      return NaN\n    } else if (\"undefined\" === v) {\n      return undefined\n    } else if (\"null\" === v) {\n      return null\n    } else if (\"\" === v) {\n      return \"\"\n    } else if (!isNaN(+v)) {\n      return +v\n    } else {\n      return v\n    }\n  })\nconst defaultSerialize = (x) =>\n  mapValues(x, (v, key) =>\n    key === \"paperSize\" ? PaperSizeToString(v ) : \"\" + v,\n  )\n\nexport function useHashState(\n  initialState,\n  {\n    deserialize = defaultDeserialize,\n    serialize = defaultSerialize,\n    wait = 1000,\n  } = {},\n) {\n  const createInitialState = useCallback(() => {\n    const state =\n      \"function\" === typeof initialState\n        ? (initialState )()\n        : initialState\n    // hash overrides parameter\n    const mergedState = deserialize(\n      Object.assign(serialize(state), parseHash(document.location.hash)),\n    ) \n    console.log(\"replaceState\")\n    history.replaceState(\n      undefined,\n      document.title,\n      objectToHash(serialize(mergedState)),\n    )\n\n    return mergedState\n  }, [deserialize, initialState, serialize])\n  const [state, setState] = useState(createInitialState)\n  const updateHashRef = useRef()\n  useEffect(() => _optionalChain([updateHashRef, 'access', _ => _.current, 'optionalCall', _2 => _2(state)]), [state])\n  if (!updateHashRef.current) {\n    console.log(\"pushState\")\n    updateHashRef.current = debounce(function (newState) {\n      history.pushState(\n        undefined,\n        document.title,\n        objectToHash(serialize(newState)),\n      )\n    }, wait)\n  }\n\n  useEffect(() => {\n    const onHashChange = () => {\n      setState(createInitialState())\n    }\n    window.addEventListener(\"hashchange\", onHashChange)\n    return () => {\n      window.removeEventListener(\"hashchange\", onHashChange)\n    }\n  }, [createInitialState])\n  return [state, setState]\n}\n","import last from \"lodash/last\"\nimport { SVGPathData } from \"svg-pathdata\"\n\n\n\n\n\n\n\n\n\n\nimport { V as VV } from \"ts3dutils\"\n\nexport function H(x) {\n  return { type: SVGPathData.HORIZ_LINE_TO, relative: false, x: x }\n}\n\nexport function A(\n  rx,\n  ry,\n  xAxisRotation,\n  largeArcFlag,\n  sweepFlag,\n  p,\n) {\n  return {\n    lArcFlag: largeArcFlag,\n    rX: rx,\n    rY: ry,\n    relative: false,\n    sweepFlag: sweepFlag,\n    type: SVGPathData.ARC,\n    x: p.x,\n    xRot: 0,\n    y: p.y,\n  }\n}\n\nexport const C = (\n  x1,\n  y1,\n  x2,\n  y2,\n  x,\n  y,\n) => ({\n  type: SVGPathData.CURVE_TO,\n  x1,\n  y1,\n  x2,\n  y2,\n  x,\n  y,\n  relative: false,\n})\n\nexport const V = (y) => ({\n  type: SVGPathData.VERT_LINE_TO,\n  y,\n  relative: false,\n})\n\nexport const S = (x2, y2, x, y) => ({\n  type: SVGPathData.SMOOTH_CURVE_TO,\n  x2,\n  y2,\n  x,\n  y,\n  relative: false,\n})\n\n\n\nexport function M(a1, a2) {\n  const [x, y] = a2 === undefined ? [(a1 ).x, (a1 ).y] : [a1, a2]\n  return { type: SVGPathData.MOVE_TO, x, y, relative: false }\n}\n\nexport const m = (x, y) => ({\n  type: SVGPathData.MOVE_TO,\n  x,\n  y,\n  relative: true,\n})\n\n\n\nexport function L(a1, a2) {\n  const [x, y] = a2 === undefined ? [(a1 ).x, (a1 ).y] : [a1, a2]\n  return { type: SVGPathData.LINE_TO, x, y, relative: false }\n}\n\nexport const l = (x, y) => ({\n  type: SVGPathData.LINE_TO,\n  x,\n  y,\n  relative: true,\n})\n\nexport const Z = () => ({ type: SVGPathData.CLOSE_PATH })\n\nexport const encode = (...path) => {\n  const modPath = []\n  let lastX = 0,\n    lastY = 0\n  for (const c of path) {\n    if (\"function\" === typeof c) {\n      for (const c2 of c(lastX, lastY)) {\n        modPath.push(c2)\n      }\n    } else {\n      modPath.push(c)\n    }\n    const lastC = last(modPath)\n    if (\"x\" in lastC) lastX = lastC.x\n    if (\"y\" in lastC) lastY = lastC.y\n  }\n  return new SVGPathData(modPath).round(3).encode()\n}\n \n\nexport function Corner(rad, x, y) {\n  return (prevX, prevY) => {\n    const prev = VV(prevX, prevY)\n    const p1 = VV(x, y)\n    const dir1 = prev.to(p1).toLength(rad)\n    const p2 = VV(p1.x + dir1.y, p1.y - dir1.x)\n    return [L(p1.minus(dir1)), A(rad, rad, 0, 0, 0, p2)]\n  }\n}\n"," function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } }import { MINUS } from \"ts3dutils\"\n\n \n// Always portrait orientation,\n\n// Always portrait orientation,\nexport const PAPER_SIZES_A = [\n  [841, 1189, \"A0\"],\n  [594, 841, \"A1\"],\n  [420, 594, \"A2\"],\n  [297, 420, \"A3\"],\n  [210, 297, \"A4\"],\n  [148, 210, \"A5\"],\n  [105, 148, \"A6\"],\n  [74, 105, \"A7\"],\n  [52, 74, \"A8\"],\n  [37, 52, \"A9\"],\n  [26, 37, \"A10\"],\n]\n\nexport function PaperSizeEquals([aw, ah], [bw, bh]) {\n  return aw === bw && bh === bw\n}\n\nexport const PAPER_SIZES_B = [\n  [1000, 1414, \"C0\"],\n  [707, 1000, \"C1\"],\n  [500, 707, \"C2\"],\n  [353, 500, \"C3\"],\n  [250, 353, \"C4\"],\n  [176, 250, \"C5\"],\n  [125, 176, \"C6\"],\n  [88, 125, \"C7\"],\n  [62, 88, \"C8\"],\n  [44, 62, \"C9\"],\n  [31, 44, \"C10\"],\n]\n\n// C size envelopes fit A size paper.\nexport const PAPER_SIZES_C = [\n  [917, 1297, \"C0\"],\n  [648, 917, \"C1\"],\n  [458, 648, \"C2\"],\n  [324, 458, \"C3\"],\n  [229, 324, \"C4\"],\n  [162, 229, \"C5\"],\n  [114, 162, \"C6\"],\n  [81, 114, \"C7\"],\n  [57, 81, \"C8\"],\n  [40, 57, \"C9\"],\n  [28, 40, \"C10\"],\n]\nexport const PAPER_SIZES = [\n  ...PAPER_SIZES_A,\n  [150, 150, \"Origami 15cm\"],\n  [100, 100, \"Origami 10cm\"],\n  [75, 75, \"Origami 7.5cm\"],\n  [215.9, 279.4, \"Letter\"],\n  [215.9, 355.6, \"Legal\"],\n]\n\nexport const ALL_PAPER_SIZES = [\n  ...PAPER_SIZES,\n  ...PAPER_SIZES_C,\n  ...PAPER_SIZES_B,\n]\n\nexport function PaperSizeFromString(str) {\n  const byName = PAPER_SIZES.find(([, , name]) => name === str)\n  if (byName) return byName\n  const [a, b] = str.split(\"x\")\n  return [+a, +b, \"Custom\"]\n}\nexport function PaperSizeFromDimensions(a, b) {\n  ;[a, b] = [a, b].sort(MINUS)\n  return _nullishCoalesce(PAPER_SIZES.find(([x, y]) => x === a && y === b), () => ( [a, b, \"Custom\"]))\n}\nexport function PaperSizeToString([a, b, name]) {\n  return name === \"Custom\" ? \"\" + a + \"x\" + b : name\n}\n\nexport const PAPER_SIZE_A4 = PAPER_SIZES_A[4]\n","\nexport default \"#version 300 es\\nprecision mediump float;\\n\\n// START ../common/banded.glsl\\nfloat banded(float bandCount, float t) {\\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\\n}\\nfloat banded(int bandCount, float t) {\\n  return banded(float(bandCount), t);\\n}\\n\\n// #pragma glslify: export(banded)\\n\\n\\n// END ../common/banded.glsl\\n// START ../common/between.glsl\\nbool between(float min, float max, float value) {\\n  return min <= value && value <= max;\\n}\\n\\n// #pragma glslify: export(between)\\n\\n\\n// END ../common/between.glsl\\n// START ../common/hexFns.glsl\\n// START ./max3.glsl\\nfloat max3(float a, float b, float c) {\\n  return max(a, max(b, c));\\n}\\nfloat max3(vec3 v) {\\n  return max(v.x, max(v.y, v.z));\\n}\\n\\n// #pragma glslify: export(max3)\\n\\n\\n// END ./max3.glsl\\n// START ./constants.glsl\\nconst float SQRT1_2 = 0.7071067811865476;\\nconst float SQRT1_3 = 0.57735026919;\\nconst float SQRT2 = 1.4142135623730951;\\nconst float SQRT3 = 1.732050807568877;\\n// sqrt(3)/2 = sin(60*)\\nconst float SQRT3_2 = 0.86602540378;\\nconst float GOLDEN_RATIO = 1.61803398875;\\nconst float PI = 3.141592653589793;\\nconst float TAU = 6.28318530718;\\n/**\\n * One degree in radians. Use like `sin(30 * DEG)`.\\n */\\nconst float DEGREE = 0.017453292519943295;\\n\\n// END ./constants.glsl\\n\\nvec3 hexRound(vec3 hex) {\\n  vec3 r = floor(hex + 0.5);\\n  vec3 diff = abs(r - hex);\\n\\n  if (diff.x > diff.y && diff.x > diff.z) {\\n    r.x = -(r.y + r.z);\\n  } else if (diff.y > diff.z) {\\n    r.y = -(r.x + r.z);\\n  } else {\\n    r.z = -(r.x + r.y);\\n  }\\n\\n  return r;\\n}\\nvec2 hex2Ra(vec3 hex) {\\n  float y = hex.t * SQRT3_2;\\n  float x = hex.s + hex.t / 2.0;\\n  return vec2(x, y);\\n}\\n\\nfloat hexSdf(vec3 hex) {\\n  return max3(abs(hex.yzx + hex.zxy / 2.0));\\n}\\nvec3 ra2Hex(vec2 xy) {\\n  float hex_t = xy.y / SQRT3_2;\\n  float hex_s = xy.x - hex_t / 2.0;\\n  return vec3(hex_s, hex_t, -(hex_s + hex_t));\\n}\\n\\n// END ../common/hexFns.glsl\\n// START ../common/remix.glsl\\n// START ./unmix.glsl\\nfloat unmix(float a, float b, float value) {\\n  return (value - a) / (b - a);\\n}\\n\\n// #pragma glslify: export(unmix)\\n\\n\\n// END ./unmix.glsl\\n\\nfloat remix(float fromA, float fromB, float toA, float toB, float value) {\\n  return mix(toA, toB, unmix(fromA, fromB, value));\\n}\\n\\nvec4 remix(float fromA, float fromB, vec4 toA, vec4 toB, float value) {\\n  return mix(toA, toB, unmix(fromA, fromB, value));\\n}\\n\\n// #pragma glslify: export(remix)\\n\\n\\n// END ../common/remix.glsl\\n// START ../common/simplex2DTexture.glsl\\n// START ./triFns.glsl\\n\\n// (x, y) -> (u, v, R)\\n// where u is horizontal, v is south-west to north-east\\n// and R is wether the it is in the right triangle\\nvec3 xy2tri(vec2 xy) {\\n  float v = xy.y / SQRT3_2;\\n  float u = xy.x - v / 2.0;\\n  float R = float(\\n    mod(u + v, 2.0) > 1.0 != (mod(floor(u) + floor(v), 2.0) == 1.0)\\n  );\\n  return vec3(u, v, R);\\n}\\nvec3 triCenter(vec3 uvR) {\\n  vec3 base = floor(uvR);\\n  vec2 centerOffset = mix(vec2(1.0 / 3.0), vec2(2.0 / 3.0), uvR.z);\\n  return base + vec3(centerOffset, 0.0);\\n}\\nvec2 tri2xy(vec3 uvR) {\\n  float y = uvR.t * SQRT3_2;\\n  float x = uvR.s + uvR.t / 2.0;\\n  return vec2(x, y);\\n}\\nvec2 tri2xy(vec2 uv) {\\n  float y = uv.t * SQRT3_2;\\n  float x = uv.s + uv.t / 2.0;\\n  return vec2(x, y);\\n}\\nfloat triSdf(vec2 uv) {\\n  vec3 hex = vec3(uv.x, uv.y, -uv.x - uv.y);\\n  return max3(hex);\\n}\\n\\n// END ./triFns.glsl\\n\\nuniform sampler2D gradients;\\n\\n/* Create random direction vector\\n */\\nvec2 randomGradient(vec2 i) {\\n  // Random float. No precomputed gradients mean this works for any number of grid coordinates\\n  float random =\\n    2920.0 *\\n    sin(float(i.x) * 2.1942 + float(i.y) * 1.71324 + 8.912) *\\n    cos(float(i.x) * 2.3157 * float(i.y) * 2.17832 + 9.758);\\n  //    random = (i.x + 1667.) * (i.x + 2083.) * (i.y + 2659.) * (i.y * 50.77 + .3769);\\n  //    random = sin(SQRT2 * i.x) + cos(GOLDEN_RATIO * i.y) + tan((i.x + i.y) * SQRT3);\\n  return vec2(cos(random), sin(random));\\n}\\n\\nfloat dotGridGradient2(vec2 cell, vec2 pos) {\\n  vec2 xy_d = cell - pos;\\n  if (length(xy_d) > 0.45) return -0.0;\\n  float r = 1.0;\\n  float part = pow(max(0.0, 1.0 - dot(xy_d, xy_d)), 4.0);\\n  //    vec2 gradient = texelFetch(gradients, ivec2(cell), 0).xy;\\n  vec2 gradient = randomGradient(cell);\\n  return part * dot(gradient, xy_d);\\n}\\n\\n// resulting range is [-0.68, 0.68]. Use unmix to normalize if necessary.\\nfloat simplex2D(vec2 xy) {\\n  vec3 uvR = xy2tri(xy);\\n  vec2 baseUV = floor(uvR.xy);\\n\\n  float a = dotGridGradient2(tri2xy(baseUV), xy);\\n  float b = dotGridGradient2(tri2xy(baseUV + vec2(1, 0)), xy);\\n  float c = dotGridGradient2(tri2xy(baseUV + vec2(0, 1)), xy);\\n  float d = dotGridGradient2(tri2xy(baseUV + vec2(1, 1)), xy);\\n\\n  return b + c + mix(a, d, uvR.z);\\n}\\n\\n// #pragma glslify: export(simplex2D)\\n\\n\\n// END ../common/simplex2DTexture.glsl\\n// START ../common/transform.glsl\\nvec3 transform(mat4 pm, vec3 p) {\\n  vec4 pStar = pm * vec4(p, 1);\\n  return pStar.xyz / pStar.w;\\n}\\n\\nvec2 transform(mat4 pm, vec2 p) {\\n  vec4 pStar = pm * vec4(p, 0, 1);\\n  return pStar.xy / pStar.w;\\n}\\n\\n// END ../common/transform.glsl\\n// START ../common/ungamma.glsl\\nvec3 ungamma(vec4 col) {\\n  return pow(col.rgb, vec3(2.2));\\n}\\nvec3 ungamma(vec3 col) {\\n  return pow(col, vec3(2.2));\\n}\\n\\n// END ../common/ungamma.glsl\\n// START ../common/visualize.glsl\\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\\n  float isLow = float(t < 0.0);\\n  float isHigh = float(t > 1.0);\\n  float isMid = 1.0 - isLow - isHigh;\\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\\n}\\n\\nvec4 visualize(float t) {\\n  const vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\\n  const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\\n  return visualize(BLUE, RED, t);\\n}\\n\\n// #pragma glslify: export(visualize)\\n\\n\\n// END ../common/visualize.glsl\\n// START ../common/waves.glsl\\nfloat waves(vec4 color, vec2 position, vec2 direction, float highResTimeStamp) {\\n  return sin(\\n    dot(position, direction / pow(length(direction), 2.0)) +\\n      float(highResTimeStamp) / 200.0\\n  );\\n}\\n\\n// #pragma glslify: export(waves)\\n\\n\\n// END ../common/waves.glsl\\n\\nin float n;\\nin vec2 coord;\\nout vec4 fragColor;\\nuniform float a;\\nuniform int bandCount;\\nuniform mat4 viewModel;\\nuniform sampler2D texture;\\nuniform vec2 iResolution;\\nuniform vec4 colorBackground;\\nuniform vec4 colorPrimary;\\nuniform vec4 colorSecondary;\\n\\nfloat simplex01(vec2 pos) {\\n  return unmix(-0.68, 0.68, simplex2D(pos));\\n}\\n\\nvoid main() {\\n  vec2 fragCoord = transform(viewModel, coord * iResolution);\\n  fragCoord *= 0.01;\\n  //  fragCoord = coord;\\n  float f = mix(simplex2D(fragCoord), simplex2D(fragCoord * 4.0), a);\\n  float f2 = simplex2D(fragCoord);\\n\\n  vec3 color = mix(\\n    ungamma(colorBackground),\\n    ungamma(colorPrimary),\\n    banded(bandCount, unmix(-0.35, 0.35, f2))\\n  );\\n  color = pow(color, vec3(1.0 / 2.2)); // gamma correction\\n\\n  //    fragColor = mix(fragColor, colorSecondary, float(between(0.0, 1., f)));\\n  fragColor = vec4(color, 1);\\n}\\n\"\nconst sourceMap = {\"version\":3,\"sources\":[\"/home/runner/work/workshop/workshop/src/noises/simplex.frag\",\"/home/runner/work/workshop/workshop/src/common/banded.glsl\",\"/home/runner/work/workshop/workshop/src/common/between.glsl\",\"/home/runner/work/workshop/workshop/src/common/max3.glsl\",\"/home/runner/work/workshop/workshop/src/common/constants.glsl\",\"/home/runner/work/workshop/workshop/src/common/hexFns.glsl\",\"/home/runner/work/workshop/workshop/src/common/unmix.glsl\",\"/home/runner/work/workshop/workshop/src/common/remix.glsl\",\"/home/runner/work/workshop/workshop/src/common/triFns.glsl\",\"/home/runner/work/workshop/workshop/src/common/simplex2DTexture.glsl\",\"/home/runner/work/workshop/workshop/src/common/transform.glsl\",\"/home/runner/work/workshop/workshop/src/common/ungamma.glsl\",\"/home/runner/work/workshop/workshop/src/common/visualize.glsl\",\"/home/runner/work/workshop/workshop/src/common/waves.glsl\"],\"names\":[],\"mappings\":\"AAAA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AbIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA\"}\nexport { sourceMap };\n","\nexport default \"#version 300 es\\nprecision mediump float;\\n\\n// START ../common/banded.glsl\\nfloat banded(float bandCount, float t) {\\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\\n}\\nfloat banded(int bandCount, float t) {\\n  return banded(float(bandCount), t);\\n}\\n\\n// #pragma glslify: export(banded)\\n\\n\\n// END ../common/banded.glsl\\n// START ../common/between.glsl\\nbool between(float min, float max, float value) {\\n  return min <= value && value <= max;\\n}\\n\\n// #pragma glslify: export(between)\\n\\n\\n// END ../common/between.glsl\\n// START ../common/perlin2DTexture.glsl\\nuniform sampler2D gradients;\\n/* Create random direction vector\\n */\\nvec2 randomGradient(vec2 i) {\\n  // Random float. No precomputed gradients mean this works for any number of grid coordinates\\n  float random =\\n    2920.0 *\\n    sin(float(i.x) * 2.1942 + float(i.y) * 1.71324 + 8.912) *\\n    cos(float(i.x) * 2.3157 * float(i.y) * 2.17832 + 9.758);\\n  //    random = (i.x + 1667.) * (i.x + 2083.) * (i.y + 2659.) * (i.y * 50.77 + .3769);\\n  //    random = sin(SQRT2 * i.x) + cos(GOLDEN_RATIO * i.y) + tan((i.x + i.y) * SQRT3);\\n  return vec2(cos(random), sin(random));\\n}\\nfloat dotGridGradient(vec2 cell, vec2 pos) {\\n  vec2 d = cell - pos;\\n\\n  //  vec2 gradient = texelFetch(gradients, ivec2(cell), 0).xy;\\n  vec2 gradient = randomGradient(vec2(cell));\\n\\n  return dot(gradient, d);\\n}\\n\\nfloat mixx(float a, float b, float t) {\\n  return mix(a, b, smoothstep(0.0, 1.0, t));\\n  //    return mix(a, b, t);\\n}\\n\\n// resulting range is [-0.68, 0.68]. Use unmix to normalize if necessary.\\nfloat perlin2D(vec2 xy) {\\n  float x0 = floor(xy.x);\\n  float x1 = x0 + 1.0;\\n  float y0 = floor(xy.y);\\n  float y1 = y0 + 1.0;\\n\\n  // Interpolate between grid point gradients\\n  float n00 = dotGridGradient(vec2(x0, y0), xy);\\n  float n10 = dotGridGradient(vec2(x1, y0), xy);\\n  float ny0 = mixx(n00, n10, xy.x - x0);\\n\\n  float n01 = dotGridGradient(vec2(x0, y1), xy);\\n  float n11 = dotGridGradient(vec2(x1, y1), xy);\\n  float ny1 = mixx(n01, n11, xy.x - x0);\\n\\n  return mixx(ny0, ny1, xy.y - y0);\\n}\\n\\n// #pragma glslify: export(perlin2D)\\n\\n\\n// END ../common/perlin2DTexture.glsl\\n// START ../common/remix.glsl\\n// START ./unmix.glsl\\nfloat unmix(float a, float b, float value) {\\n  return (value - a) / (b - a);\\n}\\n\\n// #pragma glslify: export(unmix)\\n\\n\\n// END ./unmix.glsl\\n\\nfloat remix(float fromA, float fromB, float toA, float toB, float value) {\\n  return mix(toA, toB, unmix(fromA, fromB, value));\\n}\\n\\nvec4 remix(float fromA, float fromB, vec4 toA, vec4 toB, float value) {\\n  return mix(toA, toB, unmix(fromA, fromB, value));\\n}\\n\\n// #pragma glslify: export(remix)\\n\\n\\n// END ../common/remix.glsl\\n// START ../common/transform.glsl\\nvec3 transform(mat4 pm, vec3 p) {\\n  vec4 pStar = pm * vec4(p, 1);\\n  return pStar.xyz / pStar.w;\\n}\\n\\nvec2 transform(mat4 pm, vec2 p) {\\n  vec4 pStar = pm * vec4(p, 0, 1);\\n  return pStar.xy / pStar.w;\\n}\\n\\n// END ../common/transform.glsl\\n// START ../common/waves.glsl\\nfloat waves(vec4 color, vec2 position, vec2 direction, float highResTimeStamp) {\\n  return sin(\\n    dot(position, direction / pow(length(direction), 2.0)) +\\n      float(highResTimeStamp) / 200.0\\n  );\\n}\\n\\n// #pragma glslify: export(waves)\\n\\n\\n// END ../common/waves.glsl\\n// START ../common/visualize.glsl\\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\\n  float isLow = float(t < 0.0);\\n  float isHigh = float(t > 1.0);\\n  float isMid = 1.0 - isLow - isHigh;\\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\\n}\\n\\nvec4 visualize(float t) {\\n  const vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\\n  const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\\n  return visualize(BLUE, RED, t);\\n}\\n\\n// #pragma glslify: export(visualize)\\n\\n\\n// END ../common/visualize.glsl\\n// START ../common/hexFns.glsl\\n// START ./max3.glsl\\nfloat max3(float a, float b, float c) {\\n  return max(a, max(b, c));\\n}\\nfloat max3(vec3 v) {\\n  return max(v.x, max(v.y, v.z));\\n}\\n\\n// #pragma glslify: export(max3)\\n\\n\\n// END ./max3.glsl\\n// START ./constants.glsl\\nconst float SQRT1_2 = 0.7071067811865476;\\nconst float SQRT1_3 = 0.57735026919;\\nconst float SQRT2 = 1.4142135623730951;\\nconst float SQRT3 = 1.732050807568877;\\n// sqrt(3)/2 = sin(60*)\\nconst float SQRT3_2 = 0.86602540378;\\nconst float GOLDEN_RATIO = 1.61803398875;\\nconst float PI = 3.141592653589793;\\nconst float TAU = 6.28318530718;\\n/**\\n * One degree in radians. Use like `sin(30 * DEG)`.\\n */\\nconst float DEGREE = 0.017453292519943295;\\n\\n// END ./constants.glsl\\n\\nvec3 hexRound(vec3 hex) {\\n  vec3 r = floor(hex + 0.5);\\n  vec3 diff = abs(r - hex);\\n\\n  if (diff.x > diff.y && diff.x > diff.z) {\\n    r.x = -(r.y + r.z);\\n  } else if (diff.y > diff.z) {\\n    r.y = -(r.x + r.z);\\n  } else {\\n    r.z = -(r.x + r.y);\\n  }\\n\\n  return r;\\n}\\nvec2 hex2Ra(vec3 hex) {\\n  float y = hex.t * SQRT3_2;\\n  float x = hex.s + hex.t / 2.0;\\n  return vec2(x, y);\\n}\\n\\nfloat hexSdf(vec3 hex) {\\n  return max3(abs(hex.yzx + hex.zxy / 2.0));\\n}\\nvec3 ra2Hex(vec2 xy) {\\n  float hex_t = xy.y / SQRT3_2;\\n  float hex_s = xy.x - hex_t / 2.0;\\n  return vec3(hex_s, hex_t, -(hex_s + hex_t));\\n}\\n\\n// END ../common/hexFns.glsl\\n\\nin vec2 coord;\\nout vec4 fragColor;\\nuniform float a;\\nuniform float highResTimeStamp;\\nuniform float iTime;\\nuniform int bandCount;\\nuniform mat4 viewModel;\\nuniform sampler2D texture;\\nuniform vec2 iResolution;\\nuniform vec4 colorBackground;\\nuniform vec4 colorPrimary;\\nuniform vec4 colorSecondary;\\n\\nfloat perlin01(vec2 pos) {\\n  return unmix(-0.68, 0.68, perlin2D(pos));\\n}\\n\\nvoid main() {\\n  vec2 fragCoord = transform(viewModel, coord * iResolution);\\n  fragCoord *= 0.01;\\n  vec4 waves1 = mix(\\n    colorBackground,\\n    colorPrimary,\\n    float(\\n      waves(colorPrimary, fragCoord, vec2(0.2, 0.05), iTime * 1000.0) >= 0.7\\n    )\\n  );\\n  vec4 waves2 = mix(\\n    colorSecondary,\\n    colorBackground,\\n    float(\\n      waves(colorPrimary, fragCoord, vec2(0.002, 0.1), iTime * 1000.0) >= 0.7\\n    )\\n  );\\n\\n  float perl = perlin2D(fragCoord);\\n  float perl01 = unmix(-0.68, 0.68, perl);\\n  float band = banded(3.0, perl01);\\n  float isTop = float(band == 1.0);\\n  float isBottom = float(band == 0.0);\\n  fragColor =\\n    waves2 * isTop +\\n    waves1 * isBottom +\\n    (1.0 - isTop - isBottom) *\\n      mix(\\n        colorBackground,\\n        colorPrimary,\\n        banded(float(bandCount), unmix(0.333, 0.666, perl01))\\n      );\\n  //        + vec4(0.0, 0.0, 0.0, 1.0) * float(between(0.0, 0.3, perl));\\n  // fragColor = mix(colorBackground, colorPrimary, banded(float(bandCount), perl01));\\n  // fragColor = visualize(blue, red, perl01);\\n\\n  //    fragColor = mix(colorBackground, colorPrimary, unmix(-0.5, 0.5, perl));\\n  //fragColor = texelFetch(gradients, ivec2(coord), 0);\\n}\\n\"\nconst sourceMap = {\"version\":3,\"sources\":[\"/home/runner/work/workshop/workshop/src/noises/test3.frag\",\"/home/runner/work/workshop/workshop/src/common/banded.glsl\",\"/home/runner/work/workshop/workshop/src/common/between.glsl\",\"/home/runner/work/workshop/workshop/src/common/perlin2DTexture.glsl\",\"/home/runner/work/workshop/workshop/src/common/unmix.glsl\",\"/home/runner/work/workshop/workshop/src/common/remix.glsl\",\"/home/runner/work/workshop/workshop/src/common/transform.glsl\",\"/home/runner/work/workshop/workshop/src/common/waves.glsl\",\"/home/runner/work/workshop/workshop/src/common/visualize.glsl\",\"/home/runner/work/workshop/workshop/src/common/max3.glsl\",\"/home/runner/work/workshop/workshop/src/common/constants.glsl\",\"/home/runner/work/workshop/workshop/src/common/hexFns.glsl\"],\"names\":[],\"mappings\":\"AAAA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AXnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA\"}\nexport { sourceMap };\n","\nexport default \"#version 300 es\\nprecision mediump float;\\n\\n// START ../common/banded.glsl\\nfloat banded(float bandCount, float t) {\\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\\n}\\nfloat banded(int bandCount, float t) {\\n  return banded(float(bandCount), t);\\n}\\n\\n// #pragma glslify: export(banded)\\n\\n\\n// END ../common/banded.glsl\\n// START ../common/between.glsl\\nbool between(float min, float max, float value) {\\n  return min <= value && value <= max;\\n}\\n\\n// #pragma glslify: export(between)\\n\\n\\n// END ../common/between.glsl\\n// START ../common/colors.glsl\\nconst vec3 INDIAN_RED = vec3(0.804, 0.361, 0.361);\\nconst vec3 LIGHT_CORAL = vec3(0.941, 0.502, 0.502);\\nconst vec3 SALMON = vec3(0.98, 0.502, 0.447);\\nconst vec3 DARK_SALMON = vec3(0.914, 0.588, 0.478);\\nconst vec3 LIGHT_SALMON = vec3(1.0, 0.627, 0.478);\\nconst vec3 CRIMSON = vec3(0.863, 0.078, 0.235);\\nconst vec3 RED = vec3(1.0, 0.0, 0.0);\\nconst vec3 FIRE_BRICK = vec3(0.698, 0.133, 0.133);\\nconst vec3 DARK_RED = vec3(0.545, 0.0, 0.0);\\nconst vec3 PINK = vec3(1.0, 0.753, 0.796);\\nconst vec3 LIGHT_PINK = vec3(1.0, 0.714, 0.757);\\nconst vec3 HOT_PINK = vec3(1.0, 0.412, 0.706);\\nconst vec3 DEEP_PINK = vec3(1.0, 0.078, 0.576);\\nconst vec3 MEDIUM_VIOLET_RED = vec3(0.78, 0.082, 0.522);\\nconst vec3 PALE_VIOLET_RED = vec3(0.859, 0.439, 0.576);\\nconst vec3 CORAL = vec3(1.0, 0.498, 0.314);\\nconst vec3 TOMATO = vec3(1.0, 0.388, 0.278);\\nconst vec3 ORANGE_RED = vec3(1.0, 0.271, 0.0);\\nconst vec3 DARK_ORANGE = vec3(1.0, 0.549, 0.0);\\nconst vec3 ORANGE = vec3(1.0, 0.647, 0.0);\\nconst vec3 GOLD = vec3(1.0, 0.843, 0.0);\\nconst vec3 YELLOW = vec3(1.0, 1.0, 0.0);\\nconst vec3 LIGHT_YELLOW = vec3(1.0, 1.0, 0.878);\\nconst vec3 LEMON_CHION = vec3(1.0, 0.98, 0.804);\\nconst vec3 LIGHT_GOLDENROD_YELLOW = vec3(0.98, 0.98, 0.824);\\nconst vec3 PAPAYA_WHIP = vec3(1.0, 0.937, 0.835);\\nconst vec3 MOCCASIN = vec3(1.0, 0.894, 0.71);\\nconst vec3 PEACH_PU = vec3(1.0, 0.855, 0.725);\\nconst vec3 PALE_GOLDENROD = vec3(0.933, 0.91, 0.667);\\nconst vec3 KHAKI = vec3(0.941, 0.902, 0.549);\\nconst vec3 DARK_KHAKI = vec3(0.741, 0.718, 0.42);\\nconst vec3 LAVENDER = vec3(0.902, 0.902, 0.98);\\nconst vec3 THISTLE = vec3(0.847, 0.749, 0.847);\\nconst vec3 PLUM = vec3(0.867, 0.627, 0.867);\\nconst vec3 VIOLET = vec3(0.933, 0.51, 0.933);\\nconst vec3 ORCHID = vec3(0.855, 0.439, 0.839);\\nconst vec3 FUCHSIA = vec3(1.0, 0.0, 1.0);\\nconst vec3 MAGENTA = vec3(1.0, 0.0, 1.0);\\nconst vec3 MEDIUM_ORCHID = vec3(0.729, 0.333, 0.827);\\nconst vec3 MEDIUM_PURPLE = vec3(0.576, 0.439, 0.859);\\nconst vec3 BLUE_VIOLET = vec3(0.541, 0.169, 0.886);\\nconst vec3 DARK_VIOLET = vec3(0.58, 0.0, 0.827);\\nconst vec3 DARK_ORCHID = vec3(0.6, 0.196, 0.8);\\nconst vec3 DARK_MAGENTA = vec3(0.545, 0.0, 0.545);\\nconst vec3 PURPLE = vec3(0.502, 0.0, 0.502);\\nconst vec3 INDIGO = vec3(0.294, 0.0, 0.51);\\nconst vec3 SLATE_BLUE = vec3(0.416, 0.353, 0.804);\\nconst vec3 DARK_SLATE_BLUE = vec3(0.282, 0.239, 0.545);\\nconst vec3 GREEN_YELLOW = vec3(0.678, 1.0, 0.184);\\nconst vec3 CHARTREUSE = vec3(0.498, 1.0, 0.0);\\nconst vec3 LAWN_GREEN = vec3(0.486, 0.988, 0.0);\\nconst vec3 LIME = vec3(0.0, 1.0, 0.0);\\nconst vec3 LIME_GREEN = vec3(0.196, 0.804, 0.196);\\nconst vec3 PALE_GREEN = vec3(0.596, 0.984, 0.596);\\nconst vec3 LIGHT_GREEN = vec3(0.565, 0.933, 0.565);\\nconst vec3 MEDIUM_SPRING_GREEN = vec3(0.0, 0.98, 0.604);\\nconst vec3 SPRING_GREEN = vec3(0.0, 1.0, 0.498);\\nconst vec3 MEDIUM_SEA_GREEN = vec3(0.235, 0.702, 0.443);\\nconst vec3 SEA_GREEN = vec3(0.18, 0.545, 0.341);\\nconst vec3 FOREST_GREEN = vec3(0.133, 0.545, 0.133);\\nconst vec3 GREEN = vec3(0.0, 0.502, 0.0);\\nconst vec3 DARK_GREEN = vec3(0.0, 0.392, 0.0);\\nconst vec3 YELLOW_GREEN = vec3(0.604, 0.804, 0.196);\\nconst vec3 OLIVE_DRAB = vec3(0.42, 0.557, 0.137);\\nconst vec3 OLIVE = vec3(0.502, 0.502, 0.0);\\nconst vec3 DARK_OLIVE_GREEN = vec3(0.333, 0.42, 0.184);\\nconst vec3 MEDIUM_AQUAMARINE = vec3(0.4, 0.804, 0.667);\\nconst vec3 DARK_SEA_GREEN = vec3(0.561, 0.737, 0.561);\\nconst vec3 LIGHT_SEA_GREEN = vec3(0.125, 0.698, 0.667);\\nconst vec3 DARK_CYAN = vec3(0.0, 0.545, 0.545);\\nconst vec3 TEAL = vec3(0.0, 0.502, 0.502);\\nconst vec3 AQUA = vec3(0.0, 1.0, 1.0);\\nconst vec3 CYAN = vec3(0.0, 1.0, 1.0);\\nconst vec3 LIGHT_CYAN = vec3(0.878, 1.0, 1.0);\\nconst vec3 PALE_TURQUOISE = vec3(0.686, 0.933, 0.933);\\nconst vec3 AQUAMARINE = vec3(0.498, 1.0, 0.831);\\nconst vec3 TURQUOISE = vec3(0.251, 0.878, 0.816);\\nconst vec3 MEDIUM_TURQUOISE = vec3(0.282, 0.82, 0.8);\\nconst vec3 DARK_TURQUOISE = vec3(0.0, 0.808, 0.82);\\nconst vec3 CADET_BLUE = vec3(0.373, 0.62, 0.627);\\nconst vec3 STEEL_BLUE = vec3(0.275, 0.51, 0.706);\\nconst vec3 LIGHT_STEEL_BLUE = vec3(0.69, 0.769, 0.871);\\nconst vec3 POWDER_BLUE = vec3(0.69, 0.878, 0.902);\\nconst vec3 LIGHT_BLUE = vec3(0.678, 0.847, 0.902);\\nconst vec3 SKY_BLUE = vec3(0.529, 0.808, 0.922);\\nconst vec3 LIGHT_SKY_BLUE = vec3(0.529, 0.808, 0.98);\\nconst vec3 DEEP_SKY_BLUE = vec3(0.0, 0.749, 1.0);\\nconst vec3 DODGER_BLUE = vec3(0.118, 0.565, 1.0);\\nconst vec3 CORNLOWER_BLUE = vec3(0.392, 0.584, 0.929);\\nconst vec3 MEDIUM_SLATE_BLUE = vec3(0.482, 0.408, 0.933);\\nconst vec3 ROYAL_BLUE = vec3(0.255, 0.412, 0.882);\\nconst vec3 BLUE = vec3(0.0, 0.0, 1.0);\\nconst vec3 MEDIUM_BLUE = vec3(0.0, 0.0, 0.804);\\nconst vec3 DARK_BLUE = vec3(0.0, 0.0, 0.545);\\nconst vec3 NAVY = vec3(0.0, 0.0, 0.502);\\nconst vec3 MIDNIGHT_BLUE = vec3(0.098, 0.098, 0.439);\\nconst vec3 CORNSILK = vec3(1.0, 0.973, 0.863);\\nconst vec3 BLANCHED_ALMOND = vec3(1.0, 0.922, 0.804);\\nconst vec3 BISQUE = vec3(1.0, 0.894, 0.769);\\nconst vec3 NAVAJO_WHITE = vec3(1.0, 0.871, 0.678);\\nconst vec3 WHEAT = vec3(0.961, 0.871, 0.702);\\nconst vec3 BURLY_WOOD = vec3(0.871, 0.722, 0.529);\\nconst vec3 TAN = vec3(0.824, 0.706, 0.549);\\nconst vec3 ROSY_BROWN = vec3(0.737, 0.561, 0.561);\\nconst vec3 SANDY_BROWN = vec3(0.957, 0.643, 0.376);\\nconst vec3 GOLDENROD = vec3(0.855, 0.647, 0.125);\\nconst vec3 DARK_GOLDENROD = vec3(0.722, 0.525, 0.043);\\nconst vec3 PERU = vec3(0.804, 0.522, 0.247);\\nconst vec3 CHOCOLATE = vec3(0.824, 0.412, 0.118);\\nconst vec3 SADDLE_BROWN = vec3(0.545, 0.271, 0.075);\\nconst vec3 SIENNA = vec3(0.627, 0.322, 0.176);\\nconst vec3 BROWN = vec3(0.647, 0.165, 0.165);\\nconst vec3 MAROON = vec3(0.502, 0.0, 0.0);\\nconst vec3 WHITE = vec3(1.0, 1.0, 1.0);\\nconst vec3 SNOW = vec3(1.0, 0.98, 0.98);\\nconst vec3 HONEYDEW = vec3(0.941, 1.0, 0.941);\\nconst vec3 MINT_CREAM = vec3(0.961, 1.0, 0.98);\\nconst vec3 AZURE = vec3(0.941, 1.0, 1.0);\\nconst vec3 ALICE_BLUE = vec3(0.941, 0.973, 1.0);\\nconst vec3 GHOST_WHITE = vec3(0.973, 0.973, 1.0);\\nconst vec3 WHITE_SMOKE = vec3(0.961, 0.961, 0.961);\\nconst vec3 SEASHELL = vec3(1.0, 0.961, 0.933);\\nconst vec3 BEIGE = vec3(0.961, 0.961, 0.863);\\nconst vec3 OLD_LACE = vec3(0.992, 0.961, 0.902);\\nconst vec3 FLORAL_WHITE = vec3(1.0, 0.98, 0.941);\\nconst vec3 IVORY = vec3(1.0, 1.0, 0.941);\\nconst vec3 ANTIQUE_WHITE = vec3(0.98, 0.922, 0.843);\\nconst vec3 LINEN = vec3(0.98, 0.941, 0.902);\\nconst vec3 LAVENDER_BLUSH = vec3(1.0, 0.941, 0.961);\\nconst vec3 MISTY_ROSE = vec3(1.0, 0.894, 0.882);\\nconst vec3 GAINSBORO = vec3(0.863, 0.863, 0.863);\\nconst vec3 LIGHT_GREY = vec3(0.827, 0.827, 0.827);\\nconst vec3 SILVER = vec3(0.753, 0.753, 0.753);\\nconst vec3 DARK_GRAY = vec3(0.663, 0.663, 0.663);\\nconst vec3 GRAY = vec3(0.502, 0.502, 0.502);\\nconst vec3 DIM_GRAY = vec3(0.412, 0.412, 0.412);\\nconst vec3 LIGHT_SLATE_GRAY = vec3(0.467, 0.533, 0.6);\\nconst vec3 SLATE_GRAY = vec3(0.439, 0.502, 0.565);\\nconst vec3 DARK_SLATE_GRAY = vec3(0.184, 0.31, 0.31);\\nconst vec3 BLACK = vec3(0.0, 0.0, 0.0);\\n\\n// END ../common/colors.glsl\\n// START ../common/hexFns.glsl\\n// START ./max3.glsl\\nfloat max3(float a, float b, float c) {\\n  return max(a, max(b, c));\\n}\\nfloat max3(vec3 v) {\\n  return max(v.x, max(v.y, v.z));\\n}\\n\\n// #pragma glslify: export(max3)\\n\\n\\n// END ./max3.glsl\\n// START ./constants.glsl\\nconst float SQRT1_2 = 0.7071067811865476;\\nconst float SQRT1_3 = 0.57735026919;\\nconst float SQRT2 = 1.4142135623730951;\\nconst float SQRT3 = 1.732050807568877;\\n// sqrt(3)/2 = sin(60*)\\nconst float SQRT3_2 = 0.86602540378;\\nconst float GOLDEN_RATIO = 1.61803398875;\\nconst float PI = 3.141592653589793;\\nconst float TAU = 6.28318530718;\\n/**\\n * One degree in radians. Use like `sin(30 * DEG)`.\\n */\\nconst float DEGREE = 0.017453292519943295;\\n\\n// END ./constants.glsl\\n\\nvec3 hexRound(vec3 hex) {\\n  vec3 r = floor(hex + 0.5);\\n  vec3 diff = abs(r - hex);\\n\\n  if (diff.x > diff.y && diff.x > diff.z) {\\n    r.x = -(r.y + r.z);\\n  } else if (diff.y > diff.z) {\\n    r.y = -(r.x + r.z);\\n  } else {\\n    r.z = -(r.x + r.y);\\n  }\\n\\n  return r;\\n}\\nvec2 hex2Ra(vec3 hex) {\\n  float y = hex.t * SQRT3_2;\\n  float x = hex.s + hex.t / 2.0;\\n  return vec2(x, y);\\n}\\n\\nfloat hexSdf(vec3 hex) {\\n  return max3(abs(hex.yzx + hex.zxy / 2.0));\\n}\\nvec3 ra2Hex(vec2 xy) {\\n  float hex_t = xy.y / SQRT3_2;\\n  float hex_s = xy.x - hex_t / 2.0;\\n  return vec3(hex_s, hex_t, -(hex_s + hex_t));\\n}\\n\\n// END ../common/hexFns.glsl\\n// START ../common/matrices.glsl\\n\\nmat2 rot2(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat2(c, s, -s, c);\\n}\\nmat3 rotX(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\\n}\\nmat3 rotY(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\\n}\\nmat3 rotZ(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\\n}\\n/**\\n * Returns a matrix that puts the camera at the eye point `ex, ey, ez` looking\\n * toward the center point `cx, cy, cz` with an up direction of `ux, uy, uz`.\\n * This emulates the OpenGL function `gluLookAt()`.\\n */\\nmat4 lookAt(vec3 eye, vec3 focus, vec3 up) {\\n  vec3 f = normalize(eye - focus);\\n  vec3 s = normalize(cross(up, f));\\n  vec3 t = normalize(cross(f, s));\\n\\n  return mat4(\\n    vec4(s.x, t.x, f.x, 0.0),\\n    vec4(s.y, t.y, f.y, 0.0),\\n    vec4(s.z, t.z, f.z, 0.0),\\n    vec4(-dot(s, eye), -dot(t, eye), -dot(f, eye), 1)\\n  );\\n}\\n\\n// the OpenGL function `glFrustum()`.\\nmat4 frustum(\\n  float left,\\n  float right,\\n  float bottom,\\n  float top,\\n  float near,\\n  float far\\n) {\\n  return mat4(\\n    vec4(2.0 * near / (right - left), 0.0, 0.0, 0.0),\\n    vec4(0, 2.0 * near / (top - bottom), 0.0, 0.0),\\n    vec4(\\n      (right + left) / (right - left),\\n      (top + bottom) / (top - bottom),\\n      -(far + near) / (far - near),\\n      -1\\n    ),\\n    vec4(0.0, 0.0, -2.0 * far * near / (far - near), 0.0)\\n  );\\n}\\n\\nmat4 perspective(float fovDegrees, float aspect, float near, float far) {\\n  float y = tan(fovDegrees * DEGREE / 2.0) * near;\\n  float x = y * aspect;\\n  return frustum(-x, x, -y, y, near, far);\\n}\\nmat4 ortho(\\n  float left,\\n  float right,\\n  float bottom,\\n  float top,\\n  float near,\\n  float far\\n) {\\n  return mat4(\\n    vec4(2.0 / (right - left), 0.0, 0.0, 0.0),\\n    vec4(0.0, 2.0 / (top - bottom), 0.0, 0.0),\\n    vec4(0.0, 0.0, -2.0 / (far - near), 0.0),\\n    vec4(\\n      -(right + left) / (right - left),\\n      -(top + bottom) / (top - bottom),\\n      -(far + near) / (far - near),\\n      1.0\\n    )\\n  );\\n}\\n\\n// END ../common/matrices.glsl\\n// START ../common/perlin2DTexture.glsl\\nuniform sampler2D gradients;\\n/* Create random direction vector\\n */\\nvec2 randomGradient(vec2 i) {\\n  // Random float. No precomputed gradients mean this works for any number of grid coordinates\\n  float random =\\n    2920.0 *\\n    sin(float(i.x) * 2.1942 + float(i.y) * 1.71324 + 8.912) *\\n    cos(float(i.x) * 2.3157 * float(i.y) * 2.17832 + 9.758);\\n  //    random = (i.x + 1667.) * (i.x + 2083.) * (i.y + 2659.) * (i.y * 50.77 + .3769);\\n  //    random = sin(SQRT2 * i.x) + cos(GOLDEN_RATIO * i.y) + tan((i.x + i.y) * SQRT3);\\n  return vec2(cos(random), sin(random));\\n}\\nfloat dotGridGradient(vec2 cell, vec2 pos) {\\n  vec2 d = cell - pos;\\n\\n  //  vec2 gradient = texelFetch(gradients, ivec2(cell), 0).xy;\\n  vec2 gradient = randomGradient(vec2(cell));\\n\\n  return dot(gradient, d);\\n}\\n\\nfloat mixx(float a, float b, float t) {\\n  return mix(a, b, smoothstep(0.0, 1.0, t));\\n  //    return mix(a, b, t);\\n}\\n\\n// resulting range is [-0.68, 0.68]. Use unmix to normalize if necessary.\\nfloat perlin2D(vec2 xy) {\\n  float x0 = floor(xy.x);\\n  float x1 = x0 + 1.0;\\n  float y0 = floor(xy.y);\\n  float y1 = y0 + 1.0;\\n\\n  // Interpolate between grid point gradients\\n  float n00 = dotGridGradient(vec2(x0, y0), xy);\\n  float n10 = dotGridGradient(vec2(x1, y0), xy);\\n  float ny0 = mixx(n00, n10, xy.x - x0);\\n\\n  float n01 = dotGridGradient(vec2(x0, y1), xy);\\n  float n11 = dotGridGradient(vec2(x1, y1), xy);\\n  float ny1 = mixx(n01, n11, xy.x - x0);\\n\\n  return mixx(ny0, ny1, xy.y - y0);\\n}\\n\\n// #pragma glslify: export(perlin2D)\\n\\n\\n// END ../common/perlin2DTexture.glsl\\n// START ../common/remix.glsl\\n// START ./unmix.glsl\\nfloat unmix(float a, float b, float value) {\\n  return (value - a) / (b - a);\\n}\\n\\n// #pragma glslify: export(unmix)\\n\\n\\n// END ./unmix.glsl\\n\\nfloat remix(float fromA, float fromB, float toA, float toB, float value) {\\n  return mix(toA, toB, unmix(fromA, fromB, value));\\n}\\n\\nvec4 remix(float fromA, float fromB, vec4 toA, vec4 toB, float value) {\\n  return mix(toA, toB, unmix(fromA, fromB, value));\\n}\\n\\n// #pragma glslify: export(remix)\\n\\n\\n// END ../common/remix.glsl\\n// START ../common/transform.glsl\\nvec3 transform(mat4 pm, vec3 p) {\\n  vec4 pStar = pm * vec4(p, 1);\\n  return pStar.xyz / pStar.w;\\n}\\n\\nvec2 transform(mat4 pm, vec2 p) {\\n  vec4 pStar = pm * vec4(p, 0, 1);\\n  return pStar.xy / pStar.w;\\n}\\n\\n// END ../common/transform.glsl\\n// START ../common/triFns.glsl\\n\\n// (x, y) -> (u, v, R)\\n// where u is horizontal, v is south-west to north-east\\n// and R is wether the it is in the right triangle\\nvec3 xy2tri(vec2 xy) {\\n  float v = xy.y / SQRT3_2;\\n  float u = xy.x - v / 2.0;\\n  float R = float(\\n    mod(u + v, 2.0) > 1.0 != (mod(floor(u) + floor(v), 2.0) == 1.0)\\n  );\\n  return vec3(u, v, R);\\n}\\nvec3 triCenter(vec3 uvR) {\\n  vec3 base = floor(uvR);\\n  vec2 centerOffset = mix(vec2(1.0 / 3.0), vec2(2.0 / 3.0), uvR.z);\\n  return base + vec3(centerOffset, 0.0);\\n}\\nvec2 tri2xy(vec3 uvR) {\\n  float y = uvR.t * SQRT3_2;\\n  float x = uvR.s + uvR.t / 2.0;\\n  return vec2(x, y);\\n}\\nvec2 tri2xy(vec2 uv) {\\n  float y = uv.t * SQRT3_2;\\n  float x = uv.s + uv.t / 2.0;\\n  return vec2(x, y);\\n}\\nfloat triSdf(vec2 uv) {\\n  vec3 hex = vec3(uv.x, uv.y, -uv.x - uv.y);\\n  return max3(hex);\\n}\\n\\n// END ../common/triFns.glsl\\n// START ../common/visualize.glsl\\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\\n  float isLow = float(t < 0.0);\\n  float isHigh = float(t > 1.0);\\n  float isMid = 1.0 - isLow - isHigh;\\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\\n}\\n\\nvec4 visualize(float t) {\\n  const vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\\n  const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\\n  return visualize(BLUE, RED, t);\\n}\\n\\n// #pragma glslify: export(visualize)\\n\\n\\n// END ../common/visualize.glsl\\n// START ../common/waves.glsl\\nfloat waves(vec4 color, vec2 position, vec2 direction, float highResTimeStamp) {\\n  return sin(\\n    dot(position, direction / pow(length(direction), 2.0)) +\\n      float(highResTimeStamp) / 200.0\\n  );\\n}\\n\\n// #pragma glslify: export(waves)\\n\\n\\n// END ../common/waves.glsl\\n\\nin float n;\\nin vec2 coord;\\nout vec4 fragColor;\\nuniform float a;\\nuniform float iTime;\\nuniform int bandCount;\\nuniform mat4 viewModel;\\nuniform sampler2D texture;\\nuniform vec2 iResolution;\\nuniform vec4 colorBackground;\\nuniform vec4 colorPrimary;\\nuniform vec4 colorSecondary;\\n\\nfloat perlin01(vec2 pos) {\\n  return unmix(-0.68, 0.68, perlin2D(pos));\\n}\\nvoid main() {\\n  vec2 fragCoord = transform(viewModel, coord * iResolution);\\n  fragCoord *= 0.01;\\n  vec3 uvR = xy2tri(fragCoord);\\n  vec3 triCenter = triCenter(uvR);\\n  vec2 centerXY = tri2xy(triCenter);\\n\\n  vec2 d2 = fragCoord - centerXY;\\n\\n  float d = triSdf(\\n    xy2tri(rot2(iTime * mix(-1.0, 1.0, uvR.z)) * d2).xy * mix(-1.0, 1.0, uvR.z)\\n  );\\n  float isHex = float(between(0.15, 0.2, d));\\n  fragColor = mix(\\n    colorBackground,\\n    colorPrimary,\\n    isHex * banded(bandCount, perlin01(centerXY / 20.0))\\n  );\\n\\n  //fragColor = visualize(blue, red, mod(floor(sheared.x) + floor(sheared.y), 2.0));\\n\\n}\\n\\n\"\nconst sourceMap = {\"version\":3,\"sources\":[\"/home/runner/work/workshop/workshop/src/noises/test2.frag\",\"/home/runner/work/workshop/workshop/src/common/banded.glsl\",\"/home/runner/work/workshop/workshop/src/common/between.glsl\",\"/home/runner/work/workshop/workshop/src/common/colors.glsl\",\"/home/runner/work/workshop/workshop/src/common/max3.glsl\",\"/home/runner/work/workshop/workshop/src/common/constants.glsl\",\"/home/runner/work/workshop/workshop/src/common/hexFns.glsl\",\"/home/runner/work/workshop/workshop/src/common/matrices.glsl\",\"/home/runner/work/workshop/workshop/src/common/perlin2DTexture.glsl\",\"/home/runner/work/workshop/workshop/src/common/unmix.glsl\",\"/home/runner/work/workshop/workshop/src/common/remix.glsl\",\"/home/runner/work/workshop/workshop/src/common/transform.glsl\",\"/home/runner/work/workshop/workshop/src/common/triFns.glsl\",\"/home/runner/work/workshop/workshop/src/common/visualize.glsl\",\"/home/runner/work/workshop/workshop/src/common/waves.glsl\"],\"names\":[],\"mappings\":\"AAAA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC5IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AdOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA\"}\nexport { sourceMap };\n"],"names":["sourceMap","BoundNumberField","state","prop","setStatePartial","props","variant","size","type","value","onChange","e","target","label","map","webpackContext","req","id","webpackContextResolve","__webpack_require__","o","Error","code","keys","Object","resolve","module","exports","INCH","fmtdeg","x","radiusFromSideWidth","sides","sideWidth","Math","sin","sideWithFromRadius","radius","centerToSideFromSideWidth","tan","radiusFromCenterToSide","centerToSide","cos","sideWidthFromCenterToSide","RegularPolygon","startAngle","sideLength","undefined","d","M","V3","polar","i","L","Z","RotStep","children","count","stepDeg","key","transform","openInNewTab","url","newWindow","window","open","opener","_optionalChain","ops","lastAccessLHS","length","op","fn","args","call","GenericDemo","sx","animate","Renderer","focusable","rendererRef","rendererRef2","useRef","fps","setFps","useState","anchorEl","setAnchorEl","renderProgress","setRenderProgress","render","useCallback","async","event","dim","currentTarget","dataset","split","current","URL","createObjectURL","renderImage","console","error","useEffect","openMenu","resolutionScale","setResolutionScale","resolutionScales","devicePixelRatio","closeMenu","Card","position","Menu","onClose","MenuItem","onClick","ListItem","ListItemText","Select","Box","margin","right","CircularProgress","Fab","MoreVert","left","CardMedia","component","ReactGlCanvas","onFps","width","height","canvasRef","renderer1","start","destroy","theme","useTheme","assign","dyn","colorBackground","palette","background","default","gl","colorPrimary","primary","main","colorSecondary","secondary","ref","style","SimpleCanvasRenderer","__init","this","mousePos","__init2","__init3","__init4","stop","constructor","fragShader","canvas","prototype","__init5","create","alpha","premultipliedAlpha","fixCanvasRes","clientWidth","clientHeight","viewport","log","addEventListener","getBoundingClientRect","offsetX","offsetY","planeMesh","plane","startX","startY","compile","fpsController","FPSController","makeCurrent","updateShader","buildShader","f","lastResult","lastArgs","some","v","memoizeLast","vs","fs","fsSrc","shader","clear","sourceMapConsumer","SourceMapConsumer","newMessage","message","replace","match","line","originalPosition","originalPositionFor","column","source","bind","abs","_","_2","tick","_3","uniforms","iResolution","iMouse","iTime","draw","onProgress","_4","document","createElement","renderer","step","enable","SCISSOR_TEST","donePixels","y","scissorWidth","min","scissorHeight","scissor","_5","Promise","reject","toBlob","blob","PanController","lastPos","O","pressedKeys","pauseCam","reset","M4","identity","_6","lockUp","__init6","__init7","__init8","setState","m","copy","registerListeners","mouseMoveTarget","keyUpDownTarget","_7","unregister","_8","wheel","mousemove","keydown","keyup","removeEventListener","unregisterListeners","_9","_10","__initStatic","TRACKED_KEYS","speed","a","s","w","likeO","translate","times","_11","_12","factor","pow","sign","deltaY","p","negated","scale","XYZ","_13","_14","preventDefault","stopPropagation","pagePos","V","pageX","pageY","delta","to","buttons","_15","_16","includes","getTransform","toShortString","posFactor","trans","getTranslation","round","fromShortString","cam","transXStr","transYStr","scaleStr","random","PI","initialState","bandCount","b","c","band","minValue","maxValue","floor","PanningCanvasRenderer","options","super","tabIndex","panController","onCamChange","modelView","viewModel","inversed","setCam","ShadertoyLikeDemo","frag","useHashState","simplexRef","Grid","container","spacing","padding","item","sm","xs","md","display","flexDirection","alignItems","gap","CardContent","Slider","max","lastTime","performance","now","notify","time","parseHash","hash","substring","part","decodeURIComponent","reduce","obj","objectToHash","entries","encodeURIComponent","join","defaultDeserialize","NaN","isNaN","defaultSerialize","deserialize","serialize","wait","createInitialState","mergedState","location","history","replaceState","title","updateHashRef","newState","pushState","onHashChange","H","HORIZ_LINE_TO","relative","A","rx","ry","xAxisRotation","largeArcFlag","sweepFlag","lArcFlag","rX","rY","ARC","xRot","C","x1","y1","x2","y2","CURVE_TO","VERT_LINE_TO","a1","a2","MOVE_TO","LINE_TO","l","CLOSE_PATH","encode","path","modPath","lastX","lastY","c2","push","lastC","Corner","rad","prevX","prevY","prev","p1","dir1","toLength","p2","minus","PAPER_SIZES_A","PAPER_SIZES_C","PAPER_SIZES","PaperSizeFromString","str","byName","find","name","PaperSizeFromDimensions","sort","lhs","rhsFn","PaperSizeToString","PAPER_SIZE_A4"],"sourceRoot":""}