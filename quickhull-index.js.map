{"version":3,"file":"quickhull-index.js","mappings":"6KAAC,SAASA,EAAiBC,EAAKC,GAAS,OAAW,MAAPD,EAAsBA,EAAqBC,GAAW,CA+CnG,SAASC,EACPC,EACAC,GAEA,MAAMC,EAAS,GACf,IAAK,IAAIC,EAAI,EAAGA,EAAIH,EAAII,OAAQD,IAASF,EAAKD,EAAIG,GAAIA,EAAGH,IAAME,EAAOG,KAAKF,GAC3E,OAAOD,CACT,CAGA,SAASI,EAAUC,EAAGC,GACpB,OAAQD,EAAE,KAAOC,EAAE,IAAMD,EAAE,KAAOC,EAAE,IAAQD,EAAE,KAAOC,EAAE,IAAMD,EAAE,KAAOC,EAAE,EAC1E,CAuFA,MAAMC,EAAY,KAAa,UAAUC,KA6NnCC,EAAa,KAAa,QAAQD,KAElCE,EAASC,GACb,IAAIC,SAAQ,CAACC,EAASC,IAAWC,WAAWF,EAASF,KA4JvD,aACE,MAAMK,GAAY,IAAAC,QAAO,MAQzB,OANA,IAAAC,YAAU,KACR,MAAMC,EAAO,KAAYC,OAAO,CAAEC,OAAQL,EAAUM,UACpDH,EAAKI,oBA/JT,SAAmBf,GAEjB,MAAMgB,GAAS,QAAkB,KAAM,IACrC,EAAAC,GAAGC,aACAC,KAAK,EAAAF,GAAGG,KACRC,MAAM,OAEO,IAAI,MACnBC,eAAe,aACfA,eAAe,SACRC,SAAWP,EACrB,MAAMQ,EAIL,IACDC,iBACE,IAAIC,GAAO,IAAI,MAAOJ,eAAe,aAAaA,eAAe,SACjE,IAAK,MAAOK,EAAaC,KAvO7B,UAA6BZ,QACrB,CAAC,QAAS,CAAEa,UAAW,KAC7B,MAAOC,EAAGC,EAAGC,EAAGC,GAAKjB,EACfkB,EAIL,GAED,SAASC,EAAO1C,EAAG2C,GACjB,MAAOC,EAAIC,EAAIC,GAAML,EAAOzC,GAAG+C,SAC/B,OA/HJ,SAA+BV,EAAGC,EAAGC,EAAGI,GACtC,MAAMK,EAAYX,EAAEY,GAAGX,GAAGY,MAAMb,EAAEY,GAAGV,IACrC,OAAOF,EAAEY,GAAGN,GAAGQ,IAAIH,EACrB,CA4HWI,CAAsB7B,EAAOqB,GAAKrB,EAAOsB,GAAKtB,EAAOuB,GAAKH,EACnE,CACA,IAAIU,EAAS,EACbZ,EAAOvC,KAAK,CAAE6C,SAAU,CAAC,EAAG,EAAG,GAAIO,mBAAoB,GAAID,OAAQA,MACnEZ,EAAOvC,KAAK,CAAE6C,SAAU,CAAC,EAAG,EAAG,GAAIO,mBAAoB,GAAID,OAAQA,MACnEZ,EAAOvC,KAAK,CAAE6C,SAAU,CAAC,EAAG,EAAG,GAAIO,mBAAoB,GAAID,OAAQA,MACnEZ,EAAOvC,KAAK,CAAE6C,SAAU,CAAC,EAAG,EAAG,GAAIO,mBAAoB,GAAID,OAAQA,MACnEE,QAAQC,IAAI,OAAQd,EAAO,EAAGnB,EAAO,KACjCmB,EAAO,EAAGnB,EAAO,IAAM,GACzBkB,EAAOgB,SAASC,IAAM,QAAUA,EAAEX,SAAU,EAAG,UAC3C,CAAC,2BAA4B,CAAEY,GAAI,CAAC,EAAG,EAAG,EAAG,KACnD,IAAK,IAAIC,EAAK,EAAGA,EAAK,EAAGA,IAAM,CAC7B,MAAMxB,EAAYK,EAAOoB,MAAM,EAAGD,EAAK,GAAGE,SAASJ,GAAMA,EAAEX,gBACrD,CAAC,sBAAuB,CAAEX,YAAW2B,GAAI,CAACH,KAChD,MAAMI,EAAO,GACb,IAAK,IAAIC,EAAK,EAAGA,EAAK1C,EAAOtB,OAAQgE,IACnBvB,EAAOkB,EAAIrC,EAAO0C,IAAO,GAC9BD,EAAK9D,KAAK+D,GAGvBxB,EAAOmB,GAAIN,mBAAqBU,OAC1B,CACJ,+BACA,CAAE5B,YAAW2B,GAAI,CAACH,GAAKD,GAAIK,EAAME,IAAK,OAE1C,CACA,IAAK,IAAIN,EAAK,EAAGA,EAAKnB,EAAOxC,OAAQ2D,IAAM,CACzC,MAAMO,EAAQ1B,EAAOmB,GAMrB,GALAL,QAAQC,IAAI,WAAYI,EAAI,cAAeO,EAAMb,mBAAmBrD,aAC9D,CACJ,oCACA,CAAE8D,GAAI,CAACH,GAAKD,GAAIQ,EAAMb,qBAEpB,IAAMa,EAAMb,mBAAmBrD,OAAQ,SAC3C,MAAMmE,GAAoB,QAAQD,EAAMb,oBAAqBW,GAC3DvB,EAAOkB,EAAIrC,EAAO0C,WAEd,CAAC,2BAA4B,CAAEF,GAAI,CAACH,GAAKD,GAAI,CAACS,KACpD,MAAMC,EAAe9C,EAAO6C,GACtBE,EAAoB1E,EACxB6C,GACA,CAACiB,EAAG1D,IAAM0C,EAAO1C,EAAGqE,GAAgB,SAEhC,CACJ,oCACA,CAAEN,GAAIO,EAAmBX,GAAI,CAACS,KAEhC,MAAMG,EAAgB,GACtB,IAAK,MAAMC,KAAmBF,EAAmB,CAC/C,MAAMG,EAAmBrE,IACvB,MAAMsE,EAAoBH,EAAcI,WAAWC,GACjDzE,EAAUyE,EAAIxE,MAEX,IAAMsE,EACTH,EAAcrE,KAAKE,IAEnB,QAAemE,EAAeG,EAChC,EAEFD,EAAgB,CACdhC,EAAO+B,GAAiBzB,SAAS,GACjCN,EAAO+B,GAAiBzB,SAAS,KAEnC0B,EAAgB,CACdhC,EAAO+B,GAAiBzB,SAAS,GACjCN,EAAO+B,GAAiBzB,SAAS,KAEnC0B,EAAgB,CACdhC,EAAO+B,GAAiBzB,SAAS,GACjCN,EAAO+B,GAAiBzB,SAAS,IAErC,CAEA,IAAK,MAAM8B,KAAYN,EAAe,CACpC,MAAMO,EAAgBrC,EAAOxC,OAC7BwC,EAAOvC,KAAK,CACV6C,SAAU,CAACqB,EAAmBS,EAAS,GAAIA,EAAS,IACpDvB,mBAAoB,GACpBD,OAAQA,MAEVZ,EAAOqC,GAAexB,oBAAqB,QACzCgB,EAAkBR,SAASU,GACzB/B,EAAO+B,GAAiBlB,mBAAmByB,QACxCd,GAAOvB,EAAOoC,EAAevD,EAAO0C,IAAO,YAI5C,CACJ,qBACA,CAAE7B,UAAWK,EAAOqB,SAASJ,GAAMA,EAAEX,WAAWgB,GAAI,CAACe,UAEjD,CACJ,mCACA,CACEf,GAAI,CAACe,GACLnB,GAAIlB,EAAOqC,GAAexB,mBAC1BY,IAAK,OAGX,MACM,CAAC,uBAAwB,CAAEH,GAAIO,EAAmBU,IAAK1E,IAK7DiD,QAAQC,IAAI,gBAAiBf,EAAOoB,QAASS,IAC7C,QAAc7B,EAAQ6B,GACtBf,QAAQC,IAAIf,EAAOoB,SACnBD,GAAMU,EAAkBS,QAAQE,GAAcA,GAAarB,IAAI3D,YACzD,CACJ,uBACA,CAAEmC,UAAWK,EAAOqB,SAASJ,GAAMA,EAAEX,aAEvCQ,QAAQC,IAAI,oBAAqBc,GACjCf,QAAQC,IAAI,SAAUf,EACxB,CACA,OAAOA,EAAOqB,SAASJ,GAAMA,EAAEX,UACjC,CAuGoCmC,CAAmB3D,GAC7CY,EAAGC,YACLH,GAAO,IAAI,MAAOJ,eAAe,aAAaA,eAAe,SAC7DI,EAAKH,SAAWP,EAChBU,EAAKkD,UAAYhD,EAAGC,UACpBH,EAAKmD,oCACLnD,EAAKoD,WAEPtD,EAAM7B,KAAK,CAAE+B,OAAMC,cAAaC,aAC1B1B,EAAM,KAEd8C,QAAQC,IAAI,eACd,CACA8B,GACA/B,QAAQC,IAAIzB,GACZ,IAAIwD,EAAK,EACT,MAAMC,EAAS,KAAOrE,OACpB,4SAWA,iOAaFZ,EAAGkF,WAAW,EAAG,EAAG,EAAG,GACvBlF,EAAGmF,SAASnF,EAAGoF,MAGfpF,EAAGqF,WAAWrF,EAAGsF,YACjBtF,EAAGuF,eACHvF,EAAGwF,YAAY,GAAIxF,EAAGa,OAAO4E,MAAQzF,EAAGa,OAAOsB,OAAQ,GAAK,KAC5DnC,EAAG0F,QAAO,IAAAC,GAAE,GAAI,EAAG,KAAM,EAAA1E,GAAG2E,EAAG,EAAA3E,GAAG4E,GAClC7F,EAAGqF,WAAWrF,EAAG8F,WACjB9F,EAAG+F,UAAU,IAEb/F,EAAGgG,OAAOhG,EAAGiG,WACbjG,EAAGgG,OAAOhG,EAAGkG,YACblG,EAAGgG,OAAOhG,EAAGmG,OACbnG,EAAGoG,UAAUpG,EAAGqG,UAAWrG,EAAGsG,qBAE9BtD,QAAQC,IAAIjD,EAAGa,QACfb,EAAGa,OAAO0F,gBAAkB,OAC5BvG,EAAGa,OAAO2F,QACVxG,EAAGa,OAAO4F,UAAY,SAAU5G,GAC9BmD,QAAQC,IAAI,WACZ,MAAMyD,GAAQ,QACZ1B,GAAM,MAAQnF,EAAE8G,KAAO,EAAI,MAAQ9G,EAAE8G,IAAM,EAAK,GAChD,EACAnF,EAAM9B,OAAS,GAEbgH,IAAU1B,IACZA,EAAK0B,EACL1D,QAAQC,IAAI+B,EAAIxD,EAAMwD,GAAIrD,YAAaH,EAAMwD,GAAIpD,IAErD,EACA,IAAIgF,EAAU,EAAA3F,GAAG2E,EACbiB,EAAM,EAAAC,GAAGC,SAGb/G,EAAGa,OAAOmG,YAAc,SAAUnH,GAChCmD,QAAQC,IAAI,eACZ,MAAMgE,GAAU,IAAAtB,GAAE9F,EAAEqH,MAAOrH,EAAEsH,OACvBC,EAAQR,EAAQlE,GAAGuE,GACT,EAAZpH,EAAEwH,UAEJR,EAAMA,EAAIS,QAAkB,IAAVF,EAAMhF,EAAW,MACnCyE,EAAMA,EAAIU,QAAkB,IAAVH,EAAMI,EAAW,OAIrCZ,EAAUK,CACZ,EAEOjH,EAAGyH,SAAQ,SAAUC,EAAKC,GAC3B3C,EAAK,EAAIxD,EAAM9B,QAAQsF,IAG3BhF,EAAG4H,MAAM5H,EAAG6H,iBAAmB7H,EAAG8H,kBAClC9H,EAAGuF,eAGHvF,EAAG+H,WAAWlB,GACd7G,EAAGgI,MAAM,KACThI,EAAGiI,WAAW,IAAM,IAAM,IAE1B,MAAMC,EAAY1G,EAAMwD,GAAItD,KACtByG,EAAiB3G,EAAMwD,GAAIpD,GACjC5B,EAAGoI,iBAAiBC,EAAE,KAAO,GAAK,GAAK,IACvC,IAAK,MAAM3E,KAAMxE,EAAiBiJ,EAAe/E,IAAI,IAAM,KAAQ,CACjE,MAAMkF,EACJ,QAAUH,EAAexE,IACrB,OACA,OAASwE,EAAexE,IACxB,MACA,OACNsB,EACGsD,SAAS,CAAED,MAAO,KAAWA,GAAOtI,KAAM+F,UAAW,KACrDyC,YAAYN,EAAUO,mBAAeC,EAAW1I,EAAG2I,OAAQjF,EAAI,EACpE,CACA,IAAK,MAAMkF,KAAM1J,EAAiBiJ,EAAe3E,IAAI,IAAM,KACzDyB,EACGsD,SAAS,CAAED,MAAOpJ,EAAiBiJ,EAAe1D,KAAK,IAAM,MAC7DoE,KAAKX,EAAWlI,EAAG4E,UAAgB,EAALgE,EAAQ,GAE3C5I,EAAGoI,iBAAiBC,EAAE,KAAO,GAAK,GAAK,IAEvCpD,EACGsD,SAAS,CACRD,MAAO,KAAW,QAAQtI,KAC1B+F,UAAW,KAEZyC,YAAYN,EAAUO,mBAAeC,EAAW1I,EAAG2I,QACtD1D,EAAOsD,SAAS,CAAED,MAAO,CAAC,EAAG,EAAG,EAAG,KAAMO,KAAKX,EAAWlI,EAAG8I,OAC5D7D,EAAOsD,SAAS,CAAED,MAAO,CAAC,EAAG,EAAG,EAAG,MAAQO,KAAKX,EAAWlI,EAAG4E,UAGhE,GACF,CAQImE,CAAUpI,EAAI,GACb,IAGD,gBAAoB,MAAO,CAAEqI,MAAO,CAAEC,QAAS,OAAQC,cAAe,SAAU/G,OAAQ,SACpF,gBAAoB,SAAU,CAAEgH,IAAK3I,EAAWwI,MAAO,CAAEI,SAAU,GAAKC,SAAU,IAGzF,C","sources":["/dev/workshop/./src/quickhull/index.tsx?"],"sourcesContent":[" function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } }\nimport * as chroma from \"chroma.ts\"\nimport * as React from \"react\"\nimport { useEffect, useRef } from \"react\"\nimport {\n  arrayFromFunction,\n  arraySwap,\n  bagRemoveIndex,\n  clamp,\n  DEG,\n\n  M4,\n  removeIndexes,\n\n  unique,\n  V,\n  V3,\n  withMax,\n} from \"ts3dutils\"\nimport { Mesh, Shader, TSGLContext } from \"tsgl\"\n\n// export function text(text: string, size: number, depth: number = 1, font: opentype.Font = defaultFont) {\n\n//   const path = font.getPath(text, 0, 0, size)\n//   const subpaths: opentype.PathCommand[][] = []\n//   path.commands.forEach(c => {\n//     if (c.type == 'M') {\n//       subpaths.push([])\n//     }\n//     subpaths.last.push(c)\n//   })\n//   const loops = subpaths.map(sp => {\n//     const path = new opentype.Path()\n//     path.commands = sp\n//     const loop = Edge.reversePath(Edge.pathFromSVG(path.toPathData(13))).map(e => e.mirrorY())\n//     // assert(Edge.isLoop(loop))\n//     return loop\n//   })\n//   // const faces = Face.assembleFacesFromLoops(loops, new PlaneSurface(P3.XY), PlaneFace as any)\n//   // const generator = callsce('B2T.text', text, size, depth)\n//   // return BRep.join(faces.map(face => B2T.extrudeFace(face as PlaneFace, V(0, 0, -depth))), generator)\n// }\n\nfunction distanceAboveTriangle(a, b, c, x) {\n  const abcNormal = a.to(b).cross(a.to(c))\n  return a.to(x).dot(abcNormal)\n}\nfunction filterIndexes(\n  arr,\n  test,\n) {\n  const result = []\n  for (let i = 0; i < arr.length; i++) if (test(arr[i], i, arr)) result.push(i)\n  return result\n}\n\n\nfunction edgeEqual(e, j) {\n  return (e[0] === j[0] && e[1] === j[1]) || (e[0] === j[1] && e[1] === j[0])\n}\n\nfunction index(points) {\n  const [a, b, c, d] = points\n  const facets = []\n  // height of point \"above\" the facet i\n  function height(i, x) {\n    const [ai, bi, ci] = facets[i].triangle\n    return distanceAboveTriangle(points[ai], points[bi], points[ci], x)\n  }\n  facets.push({ triangle: [0, 1, 2], pointsAboveIndexes: [] })\n  facets.push({ triangle: [1, 0, 3], pointsAboveIndexes: [] })\n  facets.push({ triangle: [2, 1, 3], pointsAboveIndexes: [] })\n  facets.push({ triangle: [0, 2, 3], pointsAboveIndexes: [] })\n  console.log(\"glug\", height(0, points[3]))\n  if (height(0, points[3]) > 0)\n    facets.forEach((f) => arraySwap(f.triangle, 0, 1))\n  console.log(\"glug\", height(0, points[3]))\n  for (let i = 0; i < 4; i++) {\n    facets[i].pointsAboveIndexes = filterIndexes(\n      points,\n      (x) => height(i, x) > 0,\n    )\n  }\n  for (let fi = 0; fi < facets.length; fi++) {\n    const facet = facets[fi]\n    console.log(\"triangle\", fi, \"pointsAbove\", facet.pointsAboveIndexes.length)\n    if (0 === facet.pointsAboveIndexes.length) continue\n    const highestPointIndex = withMax(facet.pointsAboveIndexes, (pi) => {\n      const p = points[pi]\n      return height(fi, p)\n    })\n    const highestPoint = points[highestPointIndex]\n    const visibleTriIndexes = filterIndexes(\n      facets,\n      (f, i) => height(i, highestPoint) > 0,\n    )\n    const horizonRidges = []\n    for (const visibleTriIndex of visibleTriIndexes) {\n      const addOrRemoveEdge = (e) => {\n        const existingEdgeIndex = horizonRidges.findIndex((e2) =>\n          edgeEqual(e2, e),\n        )\n        if (-1 === existingEdgeIndex) {\n          horizonRidges.push(e)\n        } else {\n          bagRemoveIndex(horizonRidges, existingEdgeIndex)\n        }\n      }\n      addOrRemoveEdge([\n        facets[visibleTriIndex].triangle[0],\n        facets[visibleTriIndex].triangle[1],\n      ])\n      addOrRemoveEdge([\n        facets[visibleTriIndex].triangle[1],\n        facets[visibleTriIndex].triangle[2],\n      ])\n      addOrRemoveEdge([\n        facets[visibleTriIndex].triangle[2],\n        facets[visibleTriIndex].triangle[0],\n      ])\n    }\n    // create new triangles with \"pointsAbove\" arrays\n    for (const horRidge of horizonRidges) {\n      const newTriangleIndex = facets.length\n      facets.push({\n        triangle: [highestPointIndex, horRidge[0], horRidge[1]],\n        pointsAboveIndexes: [],\n      })\n      facets[newTriangleIndex].pointsAboveIndexes = unique(\n        visibleTriIndexes.flatMap((visibleTriIndex) =>\n          facets[visibleTriIndex].pointsAboveIndexes.filter((pi) =>\n            height(newTriangleIndex, points[pi]),\n          ),\n        ),\n      )\n    }\n    // remove old triangles\n    visibleTriIndexes.forEach((i) => {\n      bagRemoveIndex(facets, i)\n    })\n    console.log(\"visibleTriIndexes\", visibleTriIndexes)\n    console.log(\"facets\", facets)\n  }\n  return facets.flatMap((f) => f.triangle)\n}\n\nconst GL_DELETE = chroma.color(\"orange\").gl()\n\n\n\n\n\n\n\n\n\n\n\n\nfunction* quickHullAnnotated(points) {\n  yield [\"start\", { triangles: [] }]\n  const [a, b, c, d] = points\n  const facets\n\n\n\n = []\n  // height of point \"above\" the facet i\n  function height(i, x) {\n    const [ai, bi, ci] = facets[i].triangle\n    return distanceAboveTriangle(points[ai], points[bi], points[ci], x)\n  }\n  let fInfex = 0\n  facets.push({ triangle: [0, 1, 2], pointsAboveIndexes: [], fInfex: fInfex++ })\n  facets.push({ triangle: [1, 0, 3], pointsAboveIndexes: [], fInfex: fInfex++ })\n  facets.push({ triangle: [2, 1, 3], pointsAboveIndexes: [], fInfex: fInfex++ })\n  facets.push({ triangle: [0, 2, 3], pointsAboveIndexes: [], fInfex: fInfex++ })\n  console.log(\"glug\", height(0, points[3]))\n  if (height(0, points[3]) > 0)\n    facets.forEach((f) => arraySwap(f.triangle, 0, 1))\n  yield [\"selecting first 4 points\", { hp: [0, 1, 2, 3] }]\n  for (let fi = 0; fi < 4; fi++) {\n    const triangles = facets.slice(0, fi + 1).flatMap((f) => f.triangle)\n    yield [\"creating base tetra\", { triangles, hf: [fi] }]\n    const pais = []\n    for (let pi = 0; pi < points.length; pi++) {\n      const isAbove = height(fi, points[pi]) > 0\n      isAbove && pais.push(pi)\n      // yield ['finding points \"above\" facet', { triangles, hp: [pi], hpc: isAbove ? 'yes' : 'no' }]\n    }\n    facets[fi].pointsAboveIndexes = pais\n    yield [\n      'finding points \"above\" facet',\n      { triangles, hf: [fi], hp: pais, hpc: \"yes\" },\n    ]\n  }\n  for (let fi = 0; fi < facets.length; fi++) {\n    const facet = facets[fi]\n    console.log(\"triangle\", fi, \"pointsAbove\", facet.pointsAboveIndexes.length)\n    yield [\n      \"finding highest point above facet\",\n      { hf: [fi], hp: facet.pointsAboveIndexes },\n    ]\n    if (0 === facet.pointsAboveIndexes.length) continue\n    const highestPointIndex = withMax(facet.pointsAboveIndexes, (pi) =>\n      height(fi, points[pi]),\n    )\n    yield [\"highet point above facet\", { hf: [fi], hp: [highestPointIndex] }]\n    const highestPoint = points[highestPointIndex]\n    const visibleTriIndexes = filterIndexes(\n      facets,\n      (f, i) => height(i, highestPoint) > 0,\n    )\n    yield [\n      \"facets visible from highest point\",\n      { hf: visibleTriIndexes, hp: [highestPointIndex] },\n    ]\n    const horizonRidges = []\n    for (const visibleTriIndex of visibleTriIndexes) {\n      const addOrRemoveEdge = (e) => {\n        const existingEdgeIndex = horizonRidges.findIndex((e2) =>\n          edgeEqual(e2, e),\n        )\n        if (-1 === existingEdgeIndex) {\n          horizonRidges.push(e)\n        } else {\n          bagRemoveIndex(horizonRidges, existingEdgeIndex)\n        }\n      }\n      addOrRemoveEdge([\n        facets[visibleTriIndex].triangle[0],\n        facets[visibleTriIndex].triangle[1],\n      ])\n      addOrRemoveEdge([\n        facets[visibleTriIndex].triangle[1],\n        facets[visibleTriIndex].triangle[2],\n      ])\n      addOrRemoveEdge([\n        facets[visibleTriIndex].triangle[2],\n        facets[visibleTriIndex].triangle[0],\n      ])\n    }\n    // create new triangles with \"pointsAbove\" arrays\n    for (const horRidge of horizonRidges) {\n      const newFacetIndex = facets.length\n      facets.push({\n        triangle: [highestPointIndex, horRidge[0], horRidge[1]],\n        pointsAboveIndexes: [],\n        fInfex: fInfex++,\n      })\n      facets[newFacetIndex].pointsAboveIndexes = unique(\n        visibleTriIndexes.flatMap((visibleTriIndex) =>\n          facets[visibleTriIndex].pointsAboveIndexes.filter(\n            (pi) => height(newFacetIndex, points[pi]) > 0,\n          ),\n        ),\n      )\n      yield [\n        \"creating new facet\",\n        { triangles: facets.flatMap((f) => f.triangle), hf: [newFacetIndex] },\n      ]\n      yield [\n        'finding points \"above\" new facet',\n        {\n          hf: [newFacetIndex],\n          hp: facets[newFacetIndex].pointsAboveIndexes,\n          hpc: \"yes\",\n        },\n      ]\n    }\n    yield [\"delete old triangles\", { hf: visibleTriIndexes, hfc: GL_DELETE }]\n    // remove old triangles\n    // visibleTriIndexes.forEach((i) => {\n    //   bagRemoveIndex(facets, i)\n    // })\n    console.log(\"removeIndexes\", facets.slice(), visibleTriIndexes)\n    removeIndexes(facets, visibleTriIndexes)\n    console.log(facets.slice())\n    fi -= visibleTriIndexes.filter((deletedFi) => deletedFi <= fi).length\n    yield [\n      \"delete old triangles\",\n      { triangles: facets.flatMap((f) => f.triangle) },\n    ]\n    console.log(\"visibleTriIndexes\", visibleTriIndexes)\n    console.log(\"facets\", facets)\n  }\n  return facets.flatMap((f) => f.triangle)\n}\n\nfunction magic(gl) {\n  // const cubeMesh = Mesh.cube()\n  const points = arrayFromFunction(100, () => V3.random())\n  // const points = arrayFromFunction(10000, () => {\n  //   let p, pLength\n  //   do {\n  //     p = V3.random().times(2).minus(V3.XYZ)\n  //     pLength = p.length()\n  //   } while (!(0.3 <= pLength && pLength <= 0.7))\n  //   return p\n  // })\n  // V3.randomUnit().times(lerp(0.3, 0.7, Math.random())))\n  const pointMesh = new Mesh().addIndexBuffer(\"TRIANGLES\")\n  pointMesh.vertices.push(...points)\n  pointMesh.TRIANGLES.push(...index(points))\n  const pointMesh2 = pointMesh.computeWireframeFromFlatTriangles()\n  console.log(pointMesh2.LINES)\n  pointMesh2.compile()\n  const shader = Shader.create(\n    `\n    uniform mat4 ts_ModelViewProjectionMatrix;\n    attribute vec4 ts_Vertex;\n    uniform float pointSize;\n    varying vec4 foo;\n    void main() {\n      foo = vec4(1.0, 1.0, 1.0, 1.0);\n      gl_Position = ts_ModelViewProjectionMatrix * ts_Vertex;\n      gl_PointSize = pointSize;\n    }\n  `,\n    `\n    precision highp float;\n    uniform vec4 color;\n    varying vec4 bar;\n    void main() {\n      gl_FragColor = color;\n      if (length(gl_PointCoord - vec2(0.5, 0.5)) > 0.5) {\n        discard;\n      }\n    }\n  `,\n  )\n\n  gl.clearColor(1, 1, 1, 0)\n  gl.cullFace(gl.BACK)\n\n  // setup camera\n  gl.matrixMode(gl.PROJECTION)\n  gl.loadIdentity()\n  gl.perspective(70, gl.canvas.width / gl.canvas.height, 0.1, 1000)\n  gl.lookAt(V(0, -2, 1.5), V3.O, V3.Z)\n  gl.matrixMode(gl.MODELVIEW)\n  gl.pointSize(10)\n\n  gl.enable(gl.CULL_FACE)\n  gl.enable(gl.DEPTH_TEST)\n  gl.enable(gl.BLEND)\n  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)\n\n  return gl.animate(function (abs, _diff) {\n    const angleDeg = (abs / 1000) * 45\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)\n    gl.loadIdentity()\n    gl.rotate(angleDeg, 0, 0, 1)\n    gl.scale(1.5)\n    gl.translate(-0.5, -0.5, -0.5)\n\n    shader\n      .uniforms({\n        color: [1, 0, 0, 1],\n        pointSize: 5,\n      })\n      .drawBuffers(pointMesh.vertexBuffers, undefined, gl.POINTS)\n    shader.uniforms({ color: [0, 0, 0, 0.5] }).draw(pointMesh, gl.TRIANGLES)\n    shader.uniforms({ color: [1, 1, 0, 1] }).draw(pointMesh, gl.LINES)\n  })\n}\n\nconst hfcDefault = chroma.color(\"blue\").gl()\n\nconst sleep = (ms) =>\n  new Promise((resolve, reject) => setTimeout(resolve, ms))\n\nfunction quickhull(gl) {\n  // const cubeMesh = Mesh.cube()\n  const points = arrayFromFunction(1000, () =>\n    V3.randomUnit()\n      .plus(V3.XYZ)\n      .times(1 / 2),\n  )\n  const startMesh = new Mesh()\n    .addIndexBuffer(\"TRIANGLES\")\n    .addIndexBuffer(\"LINES\")\n  startMesh.vertices = points\n  const state\n\n\n\n = []\n  async function doo() {\n    let mesh = new Mesh().addIndexBuffer(\"TRIANGLES\").addIndexBuffer(\"LINES\")\n    for (const [description, cd] of quickHullAnnotated(points)) {\n      if (cd.triangles) {\n        mesh = new Mesh().addIndexBuffer(\"TRIANGLES\").addIndexBuffer(\"LINES\")\n        mesh.vertices = points\n        mesh.TRIANGLES = cd.triangles\n        mesh.computeWireframeFromFlatTriangles()\n        mesh.compile()\n      }\n      state.push({ mesh, description, cd })\n      await sleep(100)\n    }\n    console.log(\"finished doo\")\n  }\n  doo()\n  console.log(state)\n  let mi = 0\n  const shader = Shader.create(\n    `\n    uniform mat4 ts_ModelViewProjectionMatrix;\n    attribute vec4 ts_Vertex;\n    uniform float pointSize;\n    varying vec4 foo;\n    void main() {\n      foo = vec4(1.0, 1.0, 1.0, 1.0);\n      gl_Position = ts_ModelViewProjectionMatrix * ts_Vertex;\n      gl_PointSize = pointSize;\n    }\n  `,\n    `\n    precision highp float;\n    uniform vec4 color;\n    varying vec4 bar;\n    void main() {\n      gl_FragColor = color;\n      if (length(gl_PointCoord - vec2(0.5, 0.5)) > 0.5) {\n        discard;\n      }\n    }\n  `,\n  )\n\n  gl.clearColor(1, 1, 1, 0)\n  gl.cullFace(gl.BACK)\n\n  // setup camera\n  gl.matrixMode(gl.PROJECTION)\n  gl.loadIdentity()\n  gl.perspective(70, gl.canvas.width / gl.canvas.height, 0.1, 1000)\n  gl.lookAt(V(0, -2, 1.5), V3.O, V3.Z)\n  gl.matrixMode(gl.MODELVIEW)\n  gl.pointSize(10)\n\n  gl.enable(gl.CULL_FACE)\n  gl.enable(gl.DEPTH_TEST)\n  gl.enable(gl.BLEND)\n  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)\n\n  console.log(gl.canvas)\n  gl.canvas.contentEditable = \"true\" // make canvas focusable\n  gl.canvas.focus()\n  gl.canvas.onkeydown = function (e) {\n    console.log(\"keydown\")\n    const newMi = clamp(\n      mi + (\"j\" === e.key ? -1 : \"k\" === e.key ? +1 : 0),\n      0,\n      state.length - 1,\n    )\n    if (newMi !== mi) {\n      mi = newMi\n      console.log(mi, state[mi].description, state[mi].cd)\n    }\n  }\n  let lastPos = V3.O\n  let rot = M4.IDENTITY\n  const zRot = 0\n  const yRot = 0\n  gl.canvas.onmousemove = function (e) {\n    console.log(\"onmousemove\")\n    const pagePos = V(e.pageX, e.pageY)\n    const delta = lastPos.to(pagePos)\n    if (e.buttons & 1) {\n      // zRot -= delta.x * 0.25 * DEG\n      rot = rot.rotateZ(delta.x * 0.25 * DEG)\n      rot = rot.rotateX(delta.y * 0.25 * DEG)\n      // rot = rot.rotate(V3.O, rot.X, delta.y * 0.25 * DEG)\n      // yRot = clamp(yRot - delta.y * 0.25 * DEG, -85 * DEG, 85 * DEG)\n    }\n    lastPos = pagePos\n  }\n\n  return gl.animate(function (abs, _diff) {\n    if (mi + 1 < state.length) mi++\n    // const angleDeg = (abs / 1000) * 10\n    // const angleDeg = 0\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)\n    gl.loadIdentity()\n    // gl.rotate(yRot / DEG, 0, 1, 0)\n    // gl.rotate(-zRot / DEG, 0, 0, 1)\n    gl.multMatrix(rot)\n    gl.scale(1.5)\n    gl.translate(-0.5, -0.5, -0.5)\n\n    const pointMesh = state[mi].mesh\n    const currentDisplay = state[mi].cd\n    gl.projectionMatrix.m[11] -= 1 / (1 << 20) // prevent Z-fighting\n    for (const pi of _nullishCoalesce(currentDisplay.hp, () => ( []))) {\n      const color =\n        \"yes\" === currentDisplay.hpc\n          ? \"lime\"\n          : \"no\" === currentDisplay.hpc\n          ? \"red\"\n          : \"blue\"\n      shader\n        .uniforms({ color: chroma.css(color).gl(), pointSize: 12 })\n        .drawBuffers(pointMesh.vertexBuffers, undefined, gl.POINTS, pi, 1)\n    }\n    for (const ti of _nullishCoalesce(currentDisplay.hf, () => ( []))) {\n      shader\n        .uniforms({ color: _nullishCoalesce(currentDisplay.hfc, () => ( hfcDefault)) })\n        .draw(pointMesh, gl.TRIANGLES, ti * 3, 3)\n    }\n    gl.projectionMatrix.m[11] += 1 / (1 << 20) // prevent Z-fighting\n\n    shader\n      .uniforms({\n        color: chroma.css(\"grey\").gl(),\n        pointSize: 10,\n      })\n      .drawBuffers(pointMesh.vertexBuffers, undefined, gl.POINTS)\n    shader.uniforms({ color: [1, 1, 0, 1] }).draw(pointMesh, gl.LINES)\n    shader.uniforms({ color: [0, 0, 0, 0.5] }).draw(pointMesh, gl.TRIANGLES)\n    // gl.pushMatrix()\n    //gl.translate(30, 0, 0)\n  })\n}\n\nexport default () => {\n  const canvasRef = useRef(null)\n\n  useEffect(() => {\n    const tsgl = TSGLContext.create({ canvas: canvasRef.current })\n    tsgl.addResizeListener()\n    quickhull(tsgl)\n  }, [])\n\n  return (\n    React.createElement('div', { style: { display: \"flex\", flexDirection: \"column\", height: \"100%\" },}\n      , React.createElement('canvas', { ref: canvasRef, style: { flexGrow: 1 }, tabIndex: 0,} )\n    )\n  )\n}\n"],"names":["_nullishCoalesce","lhs","rhsFn","filterIndexes","arr","test","result","i","length","push","edgeEqual","e","j","GL_DELETE","gl","hfcDefault","sleep","ms","Promise","resolve","reject","setTimeout","canvasRef","useRef","useEffect","tsgl","create","canvas","current","addResizeListener","points","V3","randomUnit","plus","XYZ","times","addIndexBuffer","vertices","state","async","mesh","description","cd","triangles","a","b","c","d","facets","height","x","ai","bi","ci","triangle","abcNormal","to","cross","dot","distanceAboveTriangle","fInfex","pointsAboveIndexes","console","log","forEach","f","hp","fi","slice","flatMap","hf","pais","pi","hpc","facet","highestPointIndex","highestPoint","visibleTriIndexes","horizonRidges","visibleTriIndex","addOrRemoveEdge","existingEdgeIndex","findIndex","e2","horRidge","newFacetIndex","filter","hfc","deletedFi","quickHullAnnotated","TRIANGLES","computeWireframeFromFlatTriangles","compile","doo","mi","shader","clearColor","cullFace","BACK","matrixMode","PROJECTION","loadIdentity","perspective","width","lookAt","V","O","Z","MODELVIEW","pointSize","enable","CULL_FACE","DEPTH_TEST","BLEND","blendFunc","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","contentEditable","focus","onkeydown","newMi","key","lastPos","rot","M4","IDENTITY","onmousemove","pagePos","pageX","pageY","delta","buttons","rotateZ","rotateX","y","animate","abs","_diff","clear","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","multMatrix","scale","translate","pointMesh","currentDisplay","projectionMatrix","m","color","uniforms","drawBuffers","vertexBuffers","undefined","POINTS","ti","draw","LINES","quickhull","style","display","flexDirection","ref","flexGrow","tabIndex"],"sourceRoot":""}