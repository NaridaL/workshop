{"version":3,"file":"sdfs3d-index.js","mappings":"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","sources":["/dev/workshop/./src/common/FPSController.ts?","/dev/workshop/./src/paperBox1/common.tsx?","/dev/workshop/./src/paperBox1/svg.ts?","/dev/workshop/./src/sdfs/SimpleCanvasRenderer.tsx?","/dev/workshop/./src/common/memoizeLast.ts?","/dev/workshop/./src/sdfs3d/index.tsx?","/dev/workshop/./src/common/raymarch.vert?","/dev/workshop/./src/sdfs3d/demo3d.frag?","/dev/workshop/./src/sdfs3d/ sync ^\\.\\/.*\\.frag$?"],"sourcesContent":["/**\n * Helper class to count frames per second.\n */\nexport class FPSController {\n   __init() {this.count = 0}\n\n   __init2() {this.lastTime = performance.now()}\n  constructor(\n      notify,\n      window = 10,\n  ) {;this.notify = notify;this.window = window;FPSController.prototype.__init.call(this);FPSController.prototype.__init2.call(this);}\n\n  tick(time = performance.now()) {\n    const window = this.window\n    this.count = (this.count + 1) % window\n    if (this.count === 0) {\n      const fps = Math.floor((window * 1000) / (time - this.lastTime))\n      this.notify(fps)\n      this.lastTime = time\n    }\n  }\n}\n","import * as React from \"react\"\n\nimport { arrayRange, DEG, round10, TAU, V3 } from \"ts3dutils\"\nimport { encode, L, M, Z } from \"./svg\"\n\nexport const INCH = 25.4\nexport const fmtdeg = (x) => \"\" + round10(x / DEG, -1) + \"°\"\n \n\nexport const radiusFromSideWidth = (sides, sideWidth) =>\n  sideWidth / 2 / Math.sin(TAU / sides / 2)\nexport const sideWithFromRadius = (sides, radius) =>\n  radius * 2 * Math.sin(TAU / sides / 2)\nexport const centerToSideFromSideWidth = (\n  sides,\n  sideWidth,\n) => sideWidth / 2 / Math.tan(TAU / sides / 2)\nexport const radiusFromCenterToSide = (\n  sides,\n  centerToSide,\n) => centerToSide / Math.cos(TAU / sides / 2)\nexport const sideWidthFromCenterToSide = (\n  sides,\n  centerToSide,\n) => centerToSide * 2 * Math.tan(TAU / sides / 2)\n\nexport function RegularPolygon({\n  sides,\n  radius,\n  startAngle = 0,\n  sideLength = undefined,\n  ...props\n}\n\n\n\n\n) {\n  if ((undefined !== sideLength) === (undefined !== radius)) {\n    throw new Error(\"must set either sideLength or radius\")\n  }\n  if (undefined === radius) {\n    radius = radiusFromSideWidth(sides, sideLength)\n  }\n  return (\n    React.createElement('path', {\n      d: encode(\n        M(V3.polar(radius, startAngle)),\n        ...arrayRange(0, sides).map((i) =>\n          L(V3.polar(radius, startAngle + i * (TAU / sides))),\n        ),\n        Z(),\n      ),\n      ...props,}\n    )\n  )\n}\n\nexport function RotStep({\n  id,\n  children,\n  count,\n  stepDeg,\n}\n\n\n\n\n) {\n  return (\n    React.createElement(React.Fragment, null\n      , React.createElement('g', { id: id,}, children)\n      , arrayRange(0, count - 1).map((i) => (\n        React.createElement('g', {\n          id: `${id}-${i}`,\n          key: `${id}-${i}`,\n          transform: `rotate(${(i + 1) * stepDeg} 0 0)`,}\n\n          , children\n        )\n      ))\n    )\n  )\n}\n\nexport const openInNewTab = (url) => {\n  const newWindow = window.open(url, \"_blank\", \"noopener,noreferrer\")\n  if (newWindow) newWindow.opener = null\n}\n","import { SVGPathData } from \"svg-pathdata\"\n\n\n\n\n\n\n\n\n\n\n\n\nexport function H(x) {\n  return { type: SVGPathData.HORIZ_LINE_TO, relative: false, x: x }\n}\n\nexport function A(\n  rx,\n  ry,\n  xAxisRotation,\n  largeArcFlag,\n  sweepFlag,\n  p,\n) {\n  return {\n    lArcFlag: largeArcFlag,\n    rX: rx,\n    rY: ry,\n    relative: false,\n    sweepFlag: sweepFlag,\n    type: SVGPathData.ARC,\n    x: p.x,\n    xRot: 0,\n    y: p.y,\n  }\n}\n\nexport const C = (\n  x1,\n  y1,\n  x2,\n  y2,\n  x,\n  y,\n) => ({\n  type: SVGPathData.CURVE_TO,\n  x1,\n  y1,\n  x2,\n  y2,\n  x,\n  y,\n  relative: false,\n})\n\nexport const V = (y) => ({\n  type: SVGPathData.VERT_LINE_TO,\n  y,\n  relative: false,\n})\n\nexport const S = (x2, y2, x, y) => ({\n  type: SVGPathData.SMOOTH_CURVE_TO,\n  x2,\n  y2,\n  x,\n  y,\n  relative: false,\n})\n\n\n\nexport function M(a1, a2) {\n  const [x, y] = a2 === undefined ? [(a1 ).x, (a1 ).y] : [a1, a2]\n  return { type: SVGPathData.MOVE_TO, x, y, relative: false }\n}\n\nexport const m = (x, y) => ({\n  type: SVGPathData.MOVE_TO,\n  x,\n  y,\n  relative: true,\n})\n\n\nexport function L(a1, a2) {\n  const [x, y] = a2 === undefined ? [(a1 ).x, (a1 ).y] : [a1, a2]\n  return { type: SVGPathData.LINE_TO, x, y, relative: false }\n}\nexport const l = (x, y) => ({\n  type: SVGPathData.LINE_TO,\n  x,\n  y,\n  relative: true,\n})\n\nexport const Z = () => ({ type: SVGPathData.CLOSE_PATH })\n\nexport const encode = (...path) => {\n  return new SVGPathData(path).round(3).encode()\n}\n"," function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }import MoreVertIcon from \"@mui/icons-material/MoreVert\"\nimport Box from \"@mui/material/Box\"\nimport Card from \"@mui/material/Card\"\nimport CardMedia from \"@mui/material/CardMedia\"\nimport CircularProgress from \"@mui/material/CircularProgress\"\nimport Fab from \"@mui/material/Fab\"\nimport ListItem from \"@mui/material/ListItem\"\nimport ListItemText from \"@mui/material/ListItemText\"\nimport Menu from \"@mui/material/Menu/Menu\"\nimport MenuItem from \"@mui/material/MenuItem\"\nimport Select from \"@mui/material/Select\"\nimport { useTheme } from \"@mui/material/styles\"\n\nimport * as chroma from \"chroma.ts\"\nimport * as React from \"react\"\nimport {\n\n\n  useCallback,\n  useEffect,\n  useRef,\n  useState,\n} from \"react\"\nimport sleep from \"sleep-promise\"\nimport { SourceMapConsumer } from \"source-map-js\"\nimport { Mesh, Shader, TSGLContext } from \"tsgl\"\n\nimport { FPSController } from \"../common/FPSController\"\nimport { memoizeLast } from \"../common/memoizeLast\"\nimport { openInNewTab } from \"../paperBox1/common\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nexport function GenericDemo({\n  sx,\n  animate,\n  state,\n  Renderer,\n  focusable,\n  rendererRef,\n}\n\n\n\n\n\n\n) {\n  const rendererRef2 = useRef()\n  const [fps, setFps] = useState(0)\n  const [anchorEl, setAnchorEl] = useState()\n\n  const [renderProgress, setRenderProgress] = useState()\n\n  const render = useCallback(\n    async (event) => {\n      const dim = event.currentTarget.dataset\n        .dim.split(\"x\")\n        .map((x) => +x) \n      setAnchorEl(undefined)\n      if (rendererRef2.current) {\n        try {\n          const url = URL.createObjectURL(\n            await rendererRef2.current.renderImage(dim, setRenderProgress),\n          )\n          setRenderProgress(undefined)\n          openInNewTab(url)\n        } catch (e) {\n          console.error(e)\n        }\n      }\n    },\n    [],\n  )\n  useEffect(() => {\n    if (rendererRef) {\n      rendererRef.current = rendererRef2.current\n    }\n  }, [rendererRef])\n\n  const openMenu = useCallback(\n    (event) => setAnchorEl(event.currentTarget),\n    [],\n  )\n  const [resolutionScale, setResolutionScale] = useState(1)\n  const resolutionScales = [\n    0.5,\n    1,\n    window.devicePixelRatio,\n    2,\n    4 * window.devicePixelRatio,\n  ]\n  const closeMenu = useCallback(() => setAnchorEl(undefined), [])\n  return (\n    React.createElement(Card, { sx: { ...sx, position: \"relative\" },}\n      , React.createElement(Menu, { open: !!anchorEl, anchorEl: anchorEl, onClose: closeMenu,}\n        , React.createElement(MenuItem, { 'data-dim': \"1920x1080\", onClick: render,}, \"Render HD\"\n\n        )\n        , React.createElement(MenuItem, { 'data-dim': \"3840x2160\", onClick: render,}, \"Render 4K\"\n\n        )\n        , React.createElement(ListItem, null\n          , React.createElement(ListItemText, null, \"Res Scale \"  ), \" \"\n          , React.createElement(Select, {\n            value: resolutionScale,\n            onChange: (e) => {\n              setAnchorEl(undefined)\n              setResolutionScale(+e.target.value)\n            },\n            size: \"small\",}\n\n            , resolutionScales.map((x) => (\n              React.createElement(MenuItem, { key: x, value: x,}\n                , x\n              )\n            ))\n          )\n        )\n      )\n      , React.createElement(Box, { sx: { position: \"absolute\", margin: 1, right: 0 },}\n        , renderProgress !== undefined ? (\n          React.createElement(CircularProgress, {\n            variant: \"determinate\",\n            value: renderProgress * 100,}\n          )\n        ) : (\n          React.createElement(Fab, { size: \"small\", onClick: openMenu,}\n            , React.createElement(MoreVertIcon, null )\n          )\n        )\n      )\n      , React.createElement(Box, { sx: { position: \"absolute\", margin: 1, left: 0 },}, fps)\n\n      , React.createElement(CardMedia, {\n        component: ReactGlCanvas,\n        Renderer: Renderer,\n        animate: animate,\n        state: state,\n        rendererRef: rendererRef2,\n        onFps: setFps,\n        resolutionScale: resolutionScale,\n        focusable: focusable,\n        sx: { width: \"100%\", height: \"100%\" },}\n      )\n    )\n  )\n}\n\nexport const ReactGlCanvas = ({\n  Renderer,\n  onFps,\n  animate,\n  state,\n  rendererRef,\n  focusable = false,\n  resolutionScale,\n}\n\n\n\n\n\n\n\n) => {\n  const canvasRef = useRef(null)\n  const rendererRef2 = useRef()\n\n  useEffect(() => {\n    if (canvasRef.current) {\n      const renderer1 = new Renderer(canvasRef.current, {\n        onFps,\n        resolutionScale,\n      })\n      rendererRef2.current = renderer1\n      renderer1.start()\n      if (rendererRef) {\n        rendererRef.current = renderer1\n      }\n      return () => renderer1.destroy()\n    }\n  }, [Renderer, onFps, resolutionScale, rendererRef])\n  const theme = useTheme()\n  useEffect(() => {\n    rendererRef2.current &&\n      Object.assign(rendererRef2.current.dyn, {\n        colorBackground: chroma.css(theme.palette.background.default).gl(),\n        colorPrimary: chroma.css(theme.palette.primary.main).gl(),\n        colorSecondary: chroma.css(theme.palette.secondary.main).gl(),\n      })\n  }, [rendererRef2.current, theme.palette])\n  useEffect(() => {\n    if (rendererRef2.current) rendererRef2.current.animate = animate\n  }, [rendererRef2.current, animate])\n  useEffect(() => {\n    if (rendererRef2.current) Object.assign(rendererRef2.current.dyn, state)\n  }, [rendererRef2.current, state])\n  return React.createElement('canvas', { ref: canvasRef, style: { width: \"100%\", height: \"100%\" },} )\n}\nexport class SimpleCanvasRenderer {\n  \n\n\n\n\n\n  \n\n   __init() {this.mousePos = [-1, -1] }\n\n  \n   __init2() {this.dyn = {}}\n   __init3() {this.animate = true}\n  \n   __init4() {this.stop = () => {}}\n  \n\n  constructor(\n      fragShader\n\n,\n      canvas,\n    {\n      onFps,\n      resolutionScale = window.devicePixelRatio,\n    },\n  ) {;this.fragShader = fragShader;this.canvas = canvas;SimpleCanvasRenderer.prototype.__init.call(this);SimpleCanvasRenderer.prototype.__init2.call(this);SimpleCanvasRenderer.prototype.__init3.call(this);SimpleCanvasRenderer.prototype.__init4.call(this);SimpleCanvasRenderer.prototype.__init5.call(this);\n    const mousemove = (e) => {\n      const canvas = e.currentTarget \n      const { width, height } = canvas.getBoundingClientRect()\n      this.mousePos = [\n        canvas.width * (e.offsetX / width),\n        canvas.height * (1 - e.offsetY / height),\n      ]\n    }\n    const mouseleave = (e) => {\n      this.mousePos = [-1, -1]\n    }\n    const gl = TSGLContext.create({\n      canvas: canvas,\n      alpha: true,\n      premultipliedAlpha: true,\n      // antialias: true,\n      // don't enable by default: bad for perf\n      // throwOnError: true,\n    }) \n    this.gl = gl\n    function fixCanvasRes() {\n      gl.canvas.width = gl.canvas.clientWidth * resolutionScale\n      gl.canvas.height = gl.canvas.clientHeight * resolutionScale\n      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height)\n    }\n    console.log(\"resolutionScale\", resolutionScale)\n    this.resolutionScale = resolutionScale\n    if (this.canvas.clientWidth !== 0) {\n      fixCanvasRes()\n      gl.canvas.addEventListener(\"resize\", fixCanvasRes)\n    }\n    gl.canvas.addEventListener(\"mouseleave\", mouseleave)\n    gl.canvas.addEventListener(\"mousemove\", mousemove)\n    this.planeMesh = Mesh.plane({ startX: -1, startY: -1, width: 2, height: 2 })\n    // Mesh.plane generates tex coords [0,1] and we want [-1, 1] for rendering.\n    // this.planeMesh.coords = [\n    //   [-1, -1],\n    //   [1, -1],\n    //   [-1, 1],\n    //   [1, 1],\n    // ]\n    this.planeMesh.compile(gl)\n    this.fpsController = onFps && new FPSController(onFps)\n    this.gl.makeCurrent()\n    this.updateShader()\n  }\n\n   updateShader() {\n    this.buildShader(\n      // eslint-disable-next-line @typescript-eslint/no-var-requires\n      require(\"../common/raymarch.vert\").default,\n      // eslint-disable-next-line @typescript-eslint/no-var-requires\n      this.fragShader(),\n    )\n  }\n\n   __init5() {this.buildShader = memoizeLast(\n    (vs, fs) => {\n      let sourceMap\n      try {\n        let fsSrc\n        if (typeof fs === \"string\") {\n          fsSrc = fs\n        } else {\n          fsSrc = fs.default\n          sourceMap = fs.sourceMap\n        }\n        // if (this.shader) {\n        //   this.gl.deleteProgram(this.shader.program)\n        // }\n        console.log(\"building shader\")\n\n        this.shader = Shader.create(vs, fsSrc, this.gl)\n      } catch (e) {\n        console.clear()\n        console.error(sourceMap)\n        if (sourceMap) {\n          const sourceMapConsumer = new SourceMapConsumer(sourceMap)\n          const newMessage = (e ).message.replace(\n            /ERROR: 0:(\\d+)/,\n            (match, line) => {\n              const originalPosition = sourceMapConsumer.originalPositionFor({\n                line: +line,\n                column: 0,\n              })\n              console.log(\"originalPosition\", originalPosition)\n              return (\n                \"ERROR \" +\n                originalPosition.source +\n                \":\" +\n                originalPosition.line +\n                \":\" +\n                originalPosition.column\n              )\n            },\n          )\n          ;(e ).message = newMessage\n        }\n\n        if (!this.shader) throw e\n      }\n    },\n  )}\n\n  start() {\n    this.stop = this.gl.animate(this.render.bind(this))\n  }\n\n  render(abs) {\n    console.log(\"render\", this.resolutionScale)\n    this.gl.makeCurrent()\n    this.updateShader()\n    _optionalChain([this, 'access', _ => _.fpsController, 'optionalAccess', _2 => _2.tick, 'call', _3 => _3(abs)])\n    // this.cam.tick(abs)\n    if (!this.shader) return\n    this.shader\n      .uniforms({\n        iResolution: [this.gl.canvas.width, this.gl.canvas.height],\n        iMouse: this.mousePos,\n        iTime: this.animate ? abs / 1000 : 0,\n      })\n      .uniforms(this.dyn)\n      .uniforms(this.uniforms())\n      .draw(this.planeMesh)\n  }\n\n  destroy() {\n    console.log(\"destroy\")\n    this.stop()\n    // this.planeMesh.destroy()\n    // this.shader.destroy()\n  }\n\n  async renderImage(\n    \n    [width, height],\n    onProgress,\n  ) {\n    _optionalChain([onProgress, 'optionalCall', _4 => _4(0)])\n    await sleep(10)\n    const canvas = document.createElement(\"canvas\")\n    canvas.width = width\n    canvas.height = height\n\n    console.log(this.constructor)\n    const renderer = new this.constructor(canvas, { resolutionScale: 4 })\n    Object.assign(renderer.dyn, this.dyn)\n    const step = 256\n    const gl = renderer.gl\n    gl.enable(gl.SCISSOR_TEST)\n    let donePixels = 0\n    for (let x = 0; x < width; x += step) {\n      for (let y = 0; y < height; y += step) {\n        const scissorWidth = Math.min(step, width - x)\n        const scissorHeight = Math.min(step, height - y)\n        gl.scissor(x, y, scissorWidth, scissorHeight)\n        // console.time(\"render block\")\n        renderer.render(0)\n        // console.timeEnd(\"render block\")\n        await sleep(0)\n        donePixels += scissorWidth * scissorHeight\n        _optionalChain([onProgress, 'optionalCall', _5 => _5(donePixels / (width * height))])\n      }\n    }\n    return new Promise((resolve, reject) =>\n      canvas.toBlob(\n        (blob) =>\n          blob ? resolve(blob) : reject(\"error creating png from canvas\"),\n        \"png\",\n      ),\n    )\n  }\n\n  /**\n   * Override this method to add additional uniforms to the simple renderer shader.\n   */\n   uniforms() {\n    return {}\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nexport function memoizeLast(f) {\n  let lastArgs = []\n  let lastResult\n  return function (...args) {\n    if (\n      lastArgs.length !== args.length ||\n      lastArgs.some((v, i) => v !== args[i])\n    ) {\n      lastArgs = args\n      lastResult = f(...args)\n    }\n    return lastResult\n  } \n}\n","import Grid from \"@mui/material/Grid\"\nimport React, { useCallback } from \"react\"\nimport {\n  GenericDemo,\n\n\n  SimpleCanvasRenderer,\n} from \"../sdfs/SimpleCanvasRenderer\"\n\nfunction Demo3D({\n  frag,\n  sx,\n  animate,\n  state,\n  replacer,\n}\n\n\n\n\n\n) {\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  const Renderer = useCallback(\n    class Renderer2 extends SimpleCanvasRenderer  {\n      constructor(canvas, onFps) {\n        // eslint-disable-next-line @typescript-eslint/no-var-requires\n        super(() => require(\"./\" + frag + \".frag\"), canvas, onFps)\n      }\n\n      updateShader() {\n        let fs = this.fragShader().default\n        if (replacer) {\n          fs = fs.replace(\n            \"#define SDF(r, p) demoIcosahedron(r, p)\",\n            `#define SDF(r, p) ${replacer}(r, p)`,\n          )\n        }\n        this.buildShader(\n          // eslint-disable-next-line @typescript-eslint/no-var-requires\n          require(\"../common/raymarch.vert\").default,\n          fs,\n        )\n      }\n    },\n    [frag, replacer],\n  )\n  return (\n    React.createElement(GenericDemo, { sx: sx, Renderer: Renderer, animate: animate, state: state,} )\n  )\n}\n\nexport default () => {\n  return (\n    React.createElement(Grid, { container: true, style: { height: \"99%\" }, spacing: 2, padding: 2,}\n      , [\n        \"demoTetrahedron\",\n        \"demoCube\",\n        \"demoOctahedron\",\n        \"demoDodecahedron\",\n        \"demoIcosahedron\",\n        \"demoVector\",\n        \"demoPlatonic\",\n        \"demoLego\",\n      ].map((frag) => (\n        React.createElement(Grid, { key: frag, item: true, xs: 12, md: 6, lg: 4,}\n          , React.createElement(Demo3D, {\n            frag: \"demo3d\",\n            replacer: frag,\n            sx: { height: 300 },\n            animate: true,\n            state: {},}\n          )\n        )\n      ))\n    )\n  )\n}\n","\nexport default \"#version 300 es\\nprecision highp float;\\n\\nin vec4 ts_Vertex;\\nin vec2 ts_TexCoord;\\nout vec2 coord;\\nvoid main() {\\n  gl_Position = ts_Vertex;\\n  coord = ts_TexCoord;\\n}\\n\"\nconst sourceMap = {\"version\":3,\"sources\":[\"/home/runner/work/workshop/workshop/src/common/raymarch.vert\"],\"names\":[],\"mappings\":\"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA\"}\nexport { sourceMap };\n","\nexport default \"#version 300 es\\n\\nprecision highp float;\\n\\n// START ../common/matrices.glsl\\n// START ./constants.glsl\\nconst float SQRT1_2 = 0.7071067811865476;\\nconst float SQRT1_3 = 0.57735026919;\\nconst float SQRT2 = 1.4142135623730951;\\nconst float SQRT3 = 1.732050807568877;\\n// sqrt(3)/2 = sin(60*)\\nconst float SQRT3_2 = 0.86602540378;\\nconst float GOLDEN_RATIO = 1.61803398875;\\nconst float PI = 3.141592653589793;\\nconst float TAU = 6.28318530718;\\n/**\\n * One degree in radians. Use like `sin(30 * DEG)`.\\n */\\nconst float DEGREE = 0.017453292519943295;\\n\\n// END ./constants.glsl\\n\\nmat2 rot2(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat2(c, s, -s, c);\\n}\\nmat3 rotX(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\\n}\\nmat3 rotY(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\\n}\\nmat3 rotZ(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\\n}\\n/**\\n * Returns a matrix that puts the camera at the eye point `ex, ey, ez` looking\\n * toward the center point `cx, cy, cz` with an up direction of `ux, uy, uz`.\\n * This emulates the OpenGL function `gluLookAt()`.\\n */\\nmat4 lookAt(vec3 eye, vec3 focus, vec3 up) {\\n  vec3 f = normalize(eye - focus);\\n  vec3 s = normalize(cross(up, f));\\n  vec3 t = normalize(cross(f, s));\\n\\n  return mat4(\\n    vec4(s.x, t.x, f.x, 0.0),\\n    vec4(s.y, t.y, f.y, 0.0),\\n    vec4(s.z, t.z, f.z, 0.0),\\n    vec4(-dot(s, eye), -dot(t, eye), -dot(f, eye), 1)\\n  );\\n}\\n\\n// the OpenGL function `glFrustum()`.\\nmat4 frustum(\\n  float left,\\n  float right,\\n  float bottom,\\n  float top,\\n  float near,\\n  float far\\n) {\\n  return mat4(\\n    vec4(2.0 * near / (right - left), 0.0, 0.0, 0.0),\\n    vec4(0, 2.0 * near / (top - bottom), 0.0, 0.0),\\n    vec4(\\n      (right + left) / (right - left),\\n      (top + bottom) / (top - bottom),\\n      -(far + near) / (far - near),\\n      -1\\n    ),\\n    vec4(0.0, 0.0, -2.0 * far * near / (far - near), 0.0)\\n  );\\n}\\n\\nmat4 perspective(float fovDegrees, float aspect, float near, float far) {\\n  float y = tan(fovDegrees * DEGREE / 2.0) * near;\\n  float x = y * aspect;\\n  return frustum(-x, x, -y, y, near, far);\\n}\\nmat4 ortho(\\n  float left,\\n  float right,\\n  float bottom,\\n  float top,\\n  float near,\\n  float far\\n) {\\n  return mat4(\\n    vec4(2.0 / (right - left), 0.0, 0.0, 0.0),\\n    vec4(0.0, 2.0 / (top - bottom), 0.0, 0.0),\\n    vec4(0.0, 0.0, -2.0 / (far - near), 0.0),\\n    vec4(\\n      -(right + left) / (right - left),\\n      -(top + bottom) / (top - bottom),\\n      -(far + near) / (far - near),\\n      1.0\\n    )\\n  );\\n}\\n\\n// END ../common/matrices.glsl\\n// START ../common/max3.glsl\\nfloat max3(float a, float b, float c) {\\n  return max(a, max(b, c));\\n}\\nfloat max3(vec3 v) {\\n  return max(v.x, max(v.y, v.z));\\n}\\n\\n// #pragma glslify: export(max3)\\n\\n\\n// END ../common/max3.glsl\\n// START ../common/polar.glsl\\n// START ../common/fromPolar.glsl\\n// START ./unmix.glsl\\nfloat unmix(float a, float b, float value) {\\n  return (value - a) / (b - a);\\n}\\n\\n// #pragma glslify: export(unmix)\\n\\n\\n// END ./unmix.glsl\\n\\nvec3 fromPolar(float radius, float phi, float z) {\\n  return vec3(radius * cos(phi), radius * sin(phi), z);\\n}\\n\\nvec2 fromPolar(float radius, float phi) {\\n  return vec2(radius * cos(phi), radius * sin(phi));\\n}\\n\\nvec2 fromPolar(vec2 polar) {\\n  return fromPolar(polar.x, polar.y);\\n}\\n\\n// #pragma glslify: export(fromPolar)\\n\\n\\n// END ../common/fromPolar.glsl\\n// START ../common/toPolar.glsl\\n\\nvec2 toPolar(vec2 xy) {\\n  return vec2(length(xy), atan(xy.y, xy.x));\\n}\\n\\nmat2 toPolarDerivate(vec2 xy) {\\n  return mat2(xy.x * xy.x, xy.y * xy.y, -xy.y, xy.x) / dot(xy, xy);\\n}\\n\\n// #pragma glslify: export(toPolar)\\n\\n\\n// END ../common/toPolar.glsl\\n\\n// END ../common/polar.glsl\\n// START ../common/ungamma.glsl\\nvec3 ungamma(vec4 col) {\\n  return pow(col.rgb, vec3(2.2));\\n}\\nvec3 ungamma(vec3 col) {\\n  return pow(col, vec3(2.2));\\n}\\n\\n// END ../common/ungamma.glsl\\n// START ../common/transform.glsl\\nvec3 transform(mat4 pm, vec3 p) {\\n  vec4 pStar = pm * vec4(p, 1);\\n  return pStar.xyz / pStar.w;\\n}\\n\\nvec2 transform(mat4 pm, vec2 p) {\\n  vec4 pStar = pm * vec4(p, 0, 1);\\n  return pStar.xy / pStar.w;\\n}\\n\\n// END ../common/transform.glsl\\n// START ../common/checkerboardGrad.glsl\\n//https://iquilezles.org/articles/checkerfiltering/\\nfloat tri(float x) {\\n  float h = fract(x * 0.5) - 0.5;\\n  return 1.0 - 2.0 * abs(h);\\n}\\nvec2 tri(vec2 x) {\\n  vec2 h = fract(x * 0.5) - 0.5;\\n  return 1.0 - 2.0 * abs(h);\\n}\\n\\nfloat checkerboardGrad(vec2 uv) {\\n  vec2 w = max(abs(dFdx(uv)), abs(dFdy(uv))) + 0.01; // filter kernel\\n  vec2 i = (tri(uv + 0.5 * w) - tri(uv - 0.5 * w)) / w; // analytical integral (box filter)\\n  return 0.5 - 0.5 * i.x * i.y; // xor pattern\\n}\\n\\n// END ../common/checkerboardGrad.glsl\\n// START ../common/colors.glsl\\nconst vec3 INDIAN_RED = vec3(0.804, 0.361, 0.361);\\nconst vec3 LIGHT_CORAL = vec3(0.941, 0.502, 0.502);\\nconst vec3 SALMON = vec3(0.98, 0.502, 0.447);\\nconst vec3 DARK_SALMON = vec3(0.914, 0.588, 0.478);\\nconst vec3 LIGHT_SALMON = vec3(1.0, 0.627, 0.478);\\nconst vec3 CRIMSON = vec3(0.863, 0.078, 0.235);\\nconst vec3 RED = vec3(1.0, 0.0, 0.0);\\nconst vec3 FIRE_BRICK = vec3(0.698, 0.133, 0.133);\\nconst vec3 DARK_RED = vec3(0.545, 0.0, 0.0);\\nconst vec3 PINK = vec3(1.0, 0.753, 0.796);\\nconst vec3 LIGHT_PINK = vec3(1.0, 0.714, 0.757);\\nconst vec3 HOT_PINK = vec3(1.0, 0.412, 0.706);\\nconst vec3 DEEP_PINK = vec3(1.0, 0.078, 0.576);\\nconst vec3 MEDIUM_VIOLET_RED = vec3(0.78, 0.082, 0.522);\\nconst vec3 PALE_VIOLET_RED = vec3(0.859, 0.439, 0.576);\\nconst vec3 CORAL = vec3(1.0, 0.498, 0.314);\\nconst vec3 TOMATO = vec3(1.0, 0.388, 0.278);\\nconst vec3 ORANGE_RED = vec3(1.0, 0.271, 0.0);\\nconst vec3 DARK_ORANGE = vec3(1.0, 0.549, 0.0);\\nconst vec3 ORANGE = vec3(1.0, 0.647, 0.0);\\nconst vec3 GOLD = vec3(1.0, 0.843, 0.0);\\nconst vec3 YELLOW = vec3(1.0, 1.0, 0.0);\\nconst vec3 LIGHT_YELLOW = vec3(1.0, 1.0, 0.878);\\nconst vec3 LEMON_CHION = vec3(1.0, 0.98, 0.804);\\nconst vec3 LIGHT_GOLDENROD_YELLOW = vec3(0.98, 0.98, 0.824);\\nconst vec3 PAPAYA_WHIP = vec3(1.0, 0.937, 0.835);\\nconst vec3 MOCCASIN = vec3(1.0, 0.894, 0.71);\\nconst vec3 PEACH_PU = vec3(1.0, 0.855, 0.725);\\nconst vec3 PALE_GOLDENROD = vec3(0.933, 0.91, 0.667);\\nconst vec3 KHAKI = vec3(0.941, 0.902, 0.549);\\nconst vec3 DARK_KHAKI = vec3(0.741, 0.718, 0.42);\\nconst vec3 LAVENDER = vec3(0.902, 0.902, 0.98);\\nconst vec3 THISTLE = vec3(0.847, 0.749, 0.847);\\nconst vec3 PLUM = vec3(0.867, 0.627, 0.867);\\nconst vec3 VIOLET = vec3(0.933, 0.51, 0.933);\\nconst vec3 ORCHID = vec3(0.855, 0.439, 0.839);\\nconst vec3 FUCHSIA = vec3(1.0, 0.0, 1.0);\\nconst vec3 MAGENTA = vec3(1.0, 0.0, 1.0);\\nconst vec3 MEDIUM_ORCHID = vec3(0.729, 0.333, 0.827);\\nconst vec3 MEDIUM_PURPLE = vec3(0.576, 0.439, 0.859);\\nconst vec3 BLUE_VIOLET = vec3(0.541, 0.169, 0.886);\\nconst vec3 DARK_VIOLET = vec3(0.58, 0.0, 0.827);\\nconst vec3 DARK_ORCHID = vec3(0.6, 0.196, 0.8);\\nconst vec3 DARK_MAGENTA = vec3(0.545, 0.0, 0.545);\\nconst vec3 PURPLE = vec3(0.502, 0.0, 0.502);\\nconst vec3 INDIGO = vec3(0.294, 0.0, 0.51);\\nconst vec3 SLATE_BLUE = vec3(0.416, 0.353, 0.804);\\nconst vec3 DARK_SLATE_BLUE = vec3(0.282, 0.239, 0.545);\\nconst vec3 GREEN_YELLOW = vec3(0.678, 1.0, 0.184);\\nconst vec3 CHARTREUSE = vec3(0.498, 1.0, 0.0);\\nconst vec3 LAWN_GREEN = vec3(0.486, 0.988, 0.0);\\nconst vec3 LIME = vec3(0.0, 1.0, 0.0);\\nconst vec3 LIME_GREEN = vec3(0.196, 0.804, 0.196);\\nconst vec3 PALE_GREEN = vec3(0.596, 0.984, 0.596);\\nconst vec3 LIGHT_GREEN = vec3(0.565, 0.933, 0.565);\\nconst vec3 MEDIUM_SPRING_GREEN = vec3(0.0, 0.98, 0.604);\\nconst vec3 SPRING_GREEN = vec3(0.0, 1.0, 0.498);\\nconst vec3 MEDIUM_SEA_GREEN = vec3(0.235, 0.702, 0.443);\\nconst vec3 SEA_GREEN = vec3(0.18, 0.545, 0.341);\\nconst vec3 FOREST_GREEN = vec3(0.133, 0.545, 0.133);\\nconst vec3 GREEN = vec3(0.0, 0.502, 0.0);\\nconst vec3 DARK_GREEN = vec3(0.0, 0.392, 0.0);\\nconst vec3 YELLOW_GREEN = vec3(0.604, 0.804, 0.196);\\nconst vec3 OLIVE_DRAB = vec3(0.42, 0.557, 0.137);\\nconst vec3 OLIVE = vec3(0.502, 0.502, 0.0);\\nconst vec3 DARK_OLIVE_GREEN = vec3(0.333, 0.42, 0.184);\\nconst vec3 MEDIUM_AQUAMARINE = vec3(0.4, 0.804, 0.667);\\nconst vec3 DARK_SEA_GREEN = vec3(0.561, 0.737, 0.561);\\nconst vec3 LIGHT_SEA_GREEN = vec3(0.125, 0.698, 0.667);\\nconst vec3 DARK_CYAN = vec3(0.0, 0.545, 0.545);\\nconst vec3 TEAL = vec3(0.0, 0.502, 0.502);\\nconst vec3 AQUA = vec3(0.0, 1.0, 1.0);\\nconst vec3 CYAN = vec3(0.0, 1.0, 1.0);\\nconst vec3 LIGHT_CYAN = vec3(0.878, 1.0, 1.0);\\nconst vec3 PALE_TURQUOISE = vec3(0.686, 0.933, 0.933);\\nconst vec3 AQUAMARINE = vec3(0.498, 1.0, 0.831);\\nconst vec3 TURQUOISE = vec3(0.251, 0.878, 0.816);\\nconst vec3 MEDIUM_TURQUOISE = vec3(0.282, 0.82, 0.8);\\nconst vec3 DARK_TURQUOISE = vec3(0.0, 0.808, 0.82);\\nconst vec3 CADET_BLUE = vec3(0.373, 0.62, 0.627);\\nconst vec3 STEEL_BLUE = vec3(0.275, 0.51, 0.706);\\nconst vec3 LIGHT_STEEL_BLUE = vec3(0.69, 0.769, 0.871);\\nconst vec3 POWDER_BLUE = vec3(0.69, 0.878, 0.902);\\nconst vec3 LIGHT_BLUE = vec3(0.678, 0.847, 0.902);\\nconst vec3 SKY_BLUE = vec3(0.529, 0.808, 0.922);\\nconst vec3 LIGHT_SKY_BLUE = vec3(0.529, 0.808, 0.98);\\nconst vec3 DEEP_SKY_BLUE = vec3(0.0, 0.749, 1.0);\\nconst vec3 DODGER_BLUE = vec3(0.118, 0.565, 1.0);\\nconst vec3 CORNLOWER_BLUE = vec3(0.392, 0.584, 0.929);\\nconst vec3 MEDIUM_SLATE_BLUE = vec3(0.482, 0.408, 0.933);\\nconst vec3 ROYAL_BLUE = vec3(0.255, 0.412, 0.882);\\nconst vec3 BLUE = vec3(0.0, 0.0, 1.0);\\nconst vec3 MEDIUM_BLUE = vec3(0.0, 0.0, 0.804);\\nconst vec3 DARK_BLUE = vec3(0.0, 0.0, 0.545);\\nconst vec3 NAVY = vec3(0.0, 0.0, 0.502);\\nconst vec3 MIDNIGHT_BLUE = vec3(0.098, 0.098, 0.439);\\nconst vec3 CORNSILK = vec3(1.0, 0.973, 0.863);\\nconst vec3 BLANCHED_ALMOND = vec3(1.0, 0.922, 0.804);\\nconst vec3 BISQUE = vec3(1.0, 0.894, 0.769);\\nconst vec3 NAVAJO_WHITE = vec3(1.0, 0.871, 0.678);\\nconst vec3 WHEAT = vec3(0.961, 0.871, 0.702);\\nconst vec3 BURLY_WOOD = vec3(0.871, 0.722, 0.529);\\nconst vec3 TAN = vec3(0.824, 0.706, 0.549);\\nconst vec3 ROSY_BROWN = vec3(0.737, 0.561, 0.561);\\nconst vec3 SANDY_BROWN = vec3(0.957, 0.643, 0.376);\\nconst vec3 GOLDENROD = vec3(0.855, 0.647, 0.125);\\nconst vec3 DARK_GOLDENROD = vec3(0.722, 0.525, 0.043);\\nconst vec3 PERU = vec3(0.804, 0.522, 0.247);\\nconst vec3 CHOCOLATE = vec3(0.824, 0.412, 0.118);\\nconst vec3 SADDLE_BROWN = vec3(0.545, 0.271, 0.075);\\nconst vec3 SIENNA = vec3(0.627, 0.322, 0.176);\\nconst vec3 BROWN = vec3(0.647, 0.165, 0.165);\\nconst vec3 MAROON = vec3(0.502, 0.0, 0.0);\\nconst vec3 WHITE = vec3(1.0, 1.0, 1.0);\\nconst vec3 SNOW = vec3(1.0, 0.98, 0.98);\\nconst vec3 HONEYDEW = vec3(0.941, 1.0, 0.941);\\nconst vec3 MINT_CREAM = vec3(0.961, 1.0, 0.98);\\nconst vec3 AZURE = vec3(0.941, 1.0, 1.0);\\nconst vec3 ALICE_BLUE = vec3(0.941, 0.973, 1.0);\\nconst vec3 GHOST_WHITE = vec3(0.973, 0.973, 1.0);\\nconst vec3 WHITE_SMOKE = vec3(0.961, 0.961, 0.961);\\nconst vec3 SEASHELL = vec3(1.0, 0.961, 0.933);\\nconst vec3 BEIGE = vec3(0.961, 0.961, 0.863);\\nconst vec3 OLD_LACE = vec3(0.992, 0.961, 0.902);\\nconst vec3 FLORAL_WHITE = vec3(1.0, 0.98, 0.941);\\nconst vec3 IVORY = vec3(1.0, 1.0, 0.941);\\nconst vec3 ANTIQUE_WHITE = vec3(0.98, 0.922, 0.843);\\nconst vec3 LINEN = vec3(0.98, 0.941, 0.902);\\nconst vec3 LAVENDER_BLUSH = vec3(1.0, 0.941, 0.961);\\nconst vec3 MISTY_ROSE = vec3(1.0, 0.894, 0.882);\\nconst vec3 GAINSBORO = vec3(0.863, 0.863, 0.863);\\nconst vec3 LIGHT_GREY = vec3(0.827, 0.827, 0.827);\\nconst vec3 SILVER = vec3(0.753, 0.753, 0.753);\\nconst vec3 DARK_GRAY = vec3(0.663, 0.663, 0.663);\\nconst vec3 GRAY = vec3(0.502, 0.502, 0.502);\\nconst vec3 DIM_GRAY = vec3(0.412, 0.412, 0.412);\\nconst vec3 LIGHT_SLATE_GRAY = vec3(0.467, 0.533, 0.6);\\nconst vec3 SLATE_GRAY = vec3(0.439, 0.502, 0.565);\\nconst vec3 DARK_SLATE_GRAY = vec3(0.184, 0.31, 0.31);\\nconst vec3 BLACK = vec3(0.0, 0.0, 0.0);\\n\\n// END ../common/colors.glsl\\n// START ../common/sdf3d/sdIcosahedron.glsl\\n\\n// signed distance function for icosahedron\\n// cf. https://en.wikipedia.org/wiki/Regular_icosahedron\\n// s: edge length\\n// p: point to evaluate function for\\nfloat sdIcosahedron(float s, vec3 p) {\\n  // NN = 1/GOLDEN_RATIO = GOLDEN_RATIO - 1\\n  const float K = GOLDEN_RATIO * 0.5;\\n  // the three vertices of the icosahedron triangle which\\n  // is fully inside the +++ octant. (edge length = 1)\\n  const vec3 a = vec3(0.5, K, 0.0);\\n  const vec3 b = vec3(0.0, 0.5, K);\\n  const vec3 c = vec3(K, 0.0, 0.5);\\n  const vec3 ab1 = b - a; // values chosen so edge length is 1\\n  const vec3 n1 = normalize(cross(a, b));\\n  const vec3 n2 = normalize(cross(b, c));\\n  const vec3 n3 = normalize(cross(c, a));\\n  const vec3 xyz1 = normalize(vec3(1.0));\\n  // for edge-length 1\\n  const float INSCRIBED_SPHERE_RADIUS = 0.7557613141;\\n\\n  // we use a rotation where the icosahedron is symmetric\\n  // in all three coordinate planes, and reduce the problem\\n  // to the +++ octant\\n  p = abs(p);\\n\\n  // there is one complete triangle in the +++ octant\\n  // mirror on planes which go through origin and the\\n  // complete triangles sides.\\n  if (dot(p, n1) < 0.0) {\\n    p += -2.0 * dot(p, n1) * n1;\\n  }\\n  if (dot(p, n2) < 0.0) {\\n    p += -2.0 * dot(p, n2) * n2;\\n  }\\n  if (dot(p, n3) < 0.0) {\\n    p += -2.0 * dot(p, n3) * n3;\\n  }\\n\\n  // rotate space around (1,1,1) vector so that all sides of the triangle\\n  // end up mapped on the ab side.\\n  vec3 dirs = vec3(-dot(n1, p), -dot(n2, p), -dot(n3, p));\\n  if (dirs.y > dirs.x && dirs.y > dirs.z) {\\n    p = p.yzx;\\n  } else if (dirs.z > dirs.x && dirs.z > dirs.y) {\\n    p = p.zxy;\\n  }\\n\\n  // check if the point is directly (perpendicular) above the triangle.\\n  // as we have rotated the space, we only need to check if it is\\n  // inside one edge.\\n  vec3 midAB = (a + b) / 2.0;\\n  vec3 pn = normalize(c - midAB);\\n  float w = dot(midAB, pn);\\n  if (dot(p, pn) > w * s) {\\n    // if not, return the distance to the plane the triangle is in\\n    return dot(xyz1, p) - INSCRIBED_SPHERE_RADIUS * s;\\n  }\\n\\n  // project the point onto segment ab, and return the distance to it\\n  float d3 = dot(ab1, p);\\n  d3 = clamp(d3, -0.5 * s, 0.5 * s);\\n  vec3 closestp = midAB * s + d3 * ab1;\\n  return distance(closestp, p);\\n}\\n// #pragma glslify: export(sdIcosahedron)\\n\\n// END ../common/sdf3d/sdIcosahedron.glsl\\n// START ../common/sdf3d/sdDodecahedron.glsl\\n\\nfloat sdDodecahedron(float s, vec3 p, out vec3 color) {\\n  const float PHI = GOLDEN_RATIO;\\n  color = vec3(0.2);\\n  if (p != abs(p)) {\\n    p = abs(p);\\n    if (color == vec3(0.2)) color = RED;\\n  }\\n  p = abs(p);\\n  const vec3 fv =\\n    vec3(1.0 / PHI, 0, PHI) + 2.0 * vec3(1, 0, 1) + 2.0 * vec3(PHI, 0, 0);\\n  const vec3 fv2 =\\n    vec3(PHI, 1.0 / PHI, 0) + 2.0 * vec3(1, 1, 0) + 2.0 * vec3(0, PHI, 0);\\n  const vec3 fv3 =\\n    vec3(0, PHI, 1.0 / PHI) + 2.0 * vec3(0, 1, 1) + 2.0 * vec3(0, 0, PHI);\\n  return max3(\\n    dot(normalize(fv), p),\\n    dot(normalize(fv2), p),\\n    dot(normalize(fv3), p)\\n  ) -\\n  s;\\n  //  float m = p.x + p.y + p.z - s;\\n  //  vec3 q;\\n  //  if (3.0 * p.x < m) q = p.xyz;\\n  //  else if (3.0 * p.y < m) q = p.yzx;\\n  //  else if (3.0 * p.z < m) q = p.zxy;\\n  //  else return m * 0.57735027;\\n  //\\n  //  float k = clamp(0.5 * (q.z - q.y + s), 0.0, s);\\n  //  return length(vec3(q.x, q.y - s + k, q.z - k));\\n}\\nfloat sdDodecahedron(float s, vec3 p) {\\n  vec3 c;\\n  return sdDodecahedron(s, p, c);\\n}\\n\\n// END ../common/sdf3d/sdDodecahedron.glsl\\n// START ../common/sdf3d/sdLego.glsl\\n// START ./sdCylinder.glsl\\nfloat sdCylinder(float radius, float z, vec3 p) {\\n  vec2 d = vec2(length(p.xy), abs(p.z)) - vec2(radius, z);\\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\\n}\\n\\n// #pragma glslify: export(sdCylinder)\\n\\n\\n// END ./sdCylinder.glsl\\n// START ./sdTube.glsl\\nfloat sdTube(float radius, float r2, float z, vec3 p) {\\n  vec2 d = vec2(length(p.xy), abs(p.z)) - vec2(radius, z);\\n  d.x = abs(d.x) - r2;\\n  vec2 closest = vec2(abs(d.x - radius) - r2, clamp(d.y, 0.0, z));\\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\\n}\\n\\n// END ./sdTube.glsl\\n// START ./sdBox.glsl\\n\\nfloat sdBox(vec3 r, vec3 p) {\\n  vec3 q = abs(p) - r;\\n  return length(max(q, 0.0)) + min(max3(q), 0.0);\\n}\\n\\nfloat sdBox(vec3 r, float r2, vec3 p) {\\n  return sdBox(r - r2, p) - r2;\\n}\\n\\n// #pragma glslify: export(sdBox)\\n\\n\\n// END ./sdBox.glsl\\n\\nfloat sdLego(vec3 p) {\\n  const float IWALLT = 0.04;\\n  p.xy = abs(p.xy);\\n  vec2 c = vec2(4.0, 2.0);\\n  //    p.xy = mod(p.xy + c * 0.5, c) - c * 0.5;\\n  p -= vec3(0.0, 0.0, 0.6);\\n  float d;\\n  const float cr = 0.02;\\n  d = sdBox(vec3(2.0, 1.0, 0.6), cr, p);\\n  if (d > 0.5) {\\n    return d;\\n  }\\n  //    top studs\\n  vec3 p8 = vec3(abs(p.xy - vec2(1.0, 0.0)), p.z) - vec3(0.5, 0.5, 0.6);\\n  float dStuds = sdCylinder(0.35 - 0.04, 0.2, p8) - 0.04;\\n  d = min(d, dStuds);\\n  // little holes in bottom of studs\\n  float dStudHoles = sdCylinder(0.2 - 0.04, 0.3, p8 - vec3(0, 0, -0.4)) - 0.04;\\n  d = max(d, -dStudHoles);\\n  // TODO use sdf texture to add LEGO or custom logo to studs\\n\\n  // hole in the bottom\\n  const float WALLT = 4.0 * IWALLT;\\n  float dBottom = sdBox(\\n    vec3(2.0 - WALLT, 1.0 - WALLT, 0.6),\\n    p - vec3(0, 0, -WALLT)\\n  );\\n  d = max(d, -dBottom);\\n\\n  // 12 indentations on inside.\\n  vec3 pa = p;\\n  // 3. move by 1 in X dir\\n  pa.x -= 1.0;\\n  // 2. mirror across XY axis\\n  if (pa.x > pa.y) pa.xy = pa.yx;\\n  // 1. mirror across Y axis\\n  pa.x = abs(pa.x);\\n  float k = sdBox(vec3(0.5 * IWALLT, 0.05, 0.6), pa - vec3(0.5, 0.8, 0));\\n  d = min(d, k);\\n\\n  // center bar\\n  p = vec3(abs(p.xy), p.z);\\n  d = min(d, sdBox(vec3(0.5 * IWALLT, 0.3, 0.5), p - vec3(0, 0.65, 0.1)));\\n\\n  // 3 tubes\\n  vec3 pTube = p;\\n  if (pTube.x > 0.5) pTube.x -= 1.0;\\n  pTube.x = abs(pTube.x);\\n  d = min(d, sdTube(0.35 + 0.5 * IWALLT, 0.5 * IWALLT, 0.6, pTube));\\n  return d;\\n}\\n\\n// END ../common/sdf3d/sdLego.glsl\\n// START ../common/sdf3d/sdOctahedron.glsl\\nfloat sdOctahedron(float s, vec3 p) {\\n  p = abs(p);\\n  float m = p.x + p.y + p.z - s;\\n  vec3 q;\\n  if (3.0 * p.x < m) q = p.xyz;\\n  else if (3.0 * p.y < m) q = p.yzx;\\n  else if (3.0 * p.z < m) q = p.zxy;\\n  else return m * 0.57735027;\\n\\n  float k = clamp(0.5 * (q.z - q.y + s), 0.0, s);\\n  return length(vec3(q.x, q.y - s + k, q.z - k));\\n}\\n// #pragma glslify: export(sdOctahedron)\\n\\nfloat sdOctahedron(vec3 p, float s) {\\n  p = abs(p);\\n\\n  float m = p.x + p.y + p.z - s;\\n  //find point on octohedron surf nearest to p\\n  vec3 projPoint = p - vec3(0.333333 * m); //project onto surface plane\\n  //now push projected point, if outside triangle edge, perpendicular to edge, to edge\\n  vec3 toMove = min(projPoint, 0.0); //if projpoint.x<0 move along (1.0,-0.5,-0.5) , etc\\n  float toMoveSum = dot(toMove, vec3(1.0)); //which is basically along (1.5,0,0) then vec3(-0.5)\\n\\n  vec3 movedPoint = projPoint + toMove * vec3(-1.5) + toMoveSum * vec3(0.5); //better to multiply toMove by a matrix (1s diagonal, 0.5 other)?\\n\\n  movedPoint = max(movedPoint, 0.0); //cap x,y,z to 0 then\\n  movedPoint *= s / dot(movedPoint, vec3(1.0)); //scale about 0,0,0\\n\\n  return length(p - movedPoint);\\n}\\n\\n// END ../common/sdf3d/sdOctahedron.glsl\\n// START ../common/sdf3d/sdArrow.glsl\\n// START ./sdCone.glsl\\n\\n/**\\n * Signed distance function (SDF) of a cone. The tip of the cone is at the\\n * origin and points towards +Z. q is a point on the rim of the cone.\\n */\\nfloat sdCone(vec2 c, float h, vec3 p) {\\n  vec2 q = h * vec2(c.x / c.y, -1.0);\\n  vec2 w = vec2(length(p.xz), p.y);\\n  vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);\\n  vec2 b = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0);\\n  float k = sign(q.y);\\n  float d = min(dot(a, a), dot(b, b));\\n  float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));\\n  return sqrt(d) * sign(s);\\n}\\n// #pragma glslify: export(sdBox)\\n\\nfloat sdConeB(vec2 c, float h, vec3 p) {\\n  float q = length(p.xz);\\n  return max(dot(c.xy, vec2(q, p.y)), -h - p.y);\\n}\\n\\n// END ./sdCone.glsl\\nvec3 perpendicularVector(vec3 a) {\\n  return cross(a, abs(a.z) > abs(a.x) ? vec3(0, 0, 1) : vec3(0, 1, 0));\\n}\\n/**\\n * Signed distance function (SDF) of an arrow. The arrow goes along the X axis.\\n * The shaft of the arrow has thickness TODO. The tip of the arrow has 30°\\n * angle, length of TODO, with the widest point being.\\n */\\nfloat sdArrow(float length, vec3 p) {\\n  float r = 0.01;\\n  return min(\\n    sdCylinder(\\n      0.02 - r,\\n      0.5 * (length - 0.1) - r,\\n      p.yzx - vec3(0, 0, 0.5 * (length - 0.1))\\n    ) -\\n      r,\\n    sdCone(\\n      vec2(sin(15.0 * DEGREE), cos(15.0 * DEGREE)),\\n      0.15 - r,\\n      p.zxy - vec3(0, length - r, 0)\\n    ) -\\n      r\\n  );\\n}\\nfloat sdArrow(vec3 a, vec3 b, vec3 p) {\\n  vec3 x = normalize(b - a);\\n  vec3 y = normalize(perpendicularVector(x));\\n  vec3 z = cross(x, y);\\n  return sdArrow(length(b - a), inverse(mat3(x, y, z)) * (p - a));\\n}\\n\\n// END ../common/sdf3d/sdArrow.glsl\\n// START ../common/sdf3d/sdTetrahedron.glsl\\n// START ./sdCapsule.glsl\\nfloat sdCapsule(vec3 a, vec3 b, float r, vec3 p) {\\n  vec3 pa = p - a;\\n  vec3 ba = b - a;\\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\\n  return length(pa - ba * h) - r;\\n}\\n// #pragma glslify: export(sdCapsule)\\n\\n// END ./sdCapsule.glsl\\n\\n/**\\n * Signed distance function (SDF) of a tetrahedron centered at the origin with\\n * side length `2s`.\\n *\\n * The corners are at `a/b = (+-1,0,sqrt(1/2))` and `c/d = (0,+-1,-sqrt(1/2))`.\\n *\\n * The side length is `||`\\n *\\n * The outscribed sphere has a radius of `sqrt(3/2)`.\\n *\\n * The inscribed sphere has a radius of `sqrt(1/6)`. This is calculated using\\n * the fact that the triangle defined by `mid(a,b) = (0,0,sqrt(1/2))`, `c` and\\n * `mid(c,d) = (0,0,-sqrt(1/2))` is similar to the triangle `mid(a,b)`, `q`, and\\n * `O`.\\n *\\n * For rounded edges, use TODO.\\n *\\n * ```\\n *           ^ Z\\n *           |(+-1, sqrt(1/2))\\n *          /\\\\_\\n *        /    \\\\.q = closest point to center on face\\n *      /    .   \\\\__> Y\\n *    /            \\\\_\\n *  /________________\\\\_(0,-1,sqrt(1/2))\\n * (0,-1,-sqrt(1/2))\\n * ```\\n */\\nfloat sdTetrahedron(float s, vec3 p) {\\n  const vec3 a = vec3(1, 0, SQRT1_2);\\n  const vec3 b = vec3(-1, 0, SQRT1_2);\\n  const vec3 c = vec3(0, 1, -SQRT1_2);\\n  const vec3 d = vec3(0, -1, -SQRT1_2);\\n  const vec3 midBC = 0.5 * (b + c);\\n  const vec3 mirror = normalize(cross(midBC - d, midBC - a));\\n\\n  // Tetra is symmetric in X and Y axes. RED surface in image.\\n  p.xy = abs(p.xy);\\n  // The part z < 0 is symmetric if we rotate it by 90°. BLUE surface in image.\\n  if (p.z < 0.0) {\\n    p = vec3(p.y, p.x, -p.z);\\n  }\\n  // Points below the plane through a, d and mid(b,c) are mirrored through it.\\n  // GREEN surface in image.\\n  p -= 2.0 * mirror * min(dot(p, mirror), 0.0);\\n  // After mirror some points are negative, abs again:\\n  p.xy = abs(p.xy);\\n\\n  // Points are now either above the white surface, or above the positive ab segment.\\n  // We shift the coordinate system so that a is now at the origin.\\n  p -= vec3(1, 0, SQRT1_2) * s;\\n  // Finally, we move points which are directely above the face parallel along\\n  // it to a/origin. We can then calculate the sdf as length(p).\\n  p.x = max(p.x, 0.0);\\n  vec3 midABToC1 = normalize(vec3(0, 1, -SQRT2));\\n\\n  p -= max(dot(midABToC1, p), 0.0) * midABToC1;\\n  return sign(p.z) * length(p);\\n}\\n\\n// Same function but also outputs color for explanation image:\\n//float sdTetrahedron(float s, vec3 p, out vec3 color) {\\n//  //  return distance(vec3(1), p) - 0.2;\\n//  const vec3 a = vec3(0, -1, -SQRT1_2);\\n//  const vec3 b = vec3(0, 1, -SQRT1_2);\\n//  const vec3 c = vec3(1, 0, SQRT1_2);\\n//  const vec3 d = vec3(-1, 0, SQRT1_2);\\n//  const vec3 x = 0.5 * (b + d);\\n//  const vec3 mirror = normalize(cross(x - a, x - c));\\n//\\n//  color = WHITE;\\n//  if (p.xy != abs(p.xy)) {\\n//    p.xy = abs(p.xy);\\n//    if (color == WHITE) color = RED;\\n//  }\\n//  if (p.z < 0.0) {\\n//    p = vec3(p.y, p.x, -p.z);\\n//    if (color == WHITE) color = BLUE;\\n//  }\\n//  if (dot(p, mirror) < 0.0) {\\n//    if (color == WHITE) color = GREEN;\\n//    p -= 2.0 * mirror * min(dot(p, mirror), 0.0);\\n//  }\\n//  p.xy = abs(p.xy);\\n//  p -= vec3(1, 0, SQRT1_2);\\n//  p.x = max(p.x, 0.0);\\n//  vec3 fgh = normalize(vec3(0, 1, -SQRT2));\\n//\\n//  p -= max(dot(fgh, p), 0.0) * fgh;\\n//  return sign(p.z) * length(p);\\n//}\\n\\n\\n// END ../common/sdf3d/sdTetrahedron.glsl\\n\\nuniform sampler2D texture;\\nuniform float iTime;\\nuniform vec4 colorPrimary;\\nuniform vec4 colorSecondary;\\nuniform vec4 colorBackground;\\nuniform float a;\\nuniform float b;\\nuniform float c;\\nuniform float d;\\nuniform int bandCount;\\nuniform vec2 iResolution;\\nuniform vec2 iMouse;\\nin float n;\\nin vec2 coord;\\nout vec4 fragColor;\\n\\n\\nstruct RMHit {\\n  float distance;\\n  vec4 color;\\n};\\nRMHit mixa(RMHit a, RMHit b, float t) {\\n  return RMHit(mix(a.distance, b.distance, t), mix(a.color, b.color, t));\\n}\\nfloat skybox(vec3 p) {\\n  return 32.0 - max3(abs(p));\\n}\\n\\nRMHit add(RMHit a, RMHit b) {\\n  //    return a.distance < b.distance\\n  //        ? RMHit(a.distance, a.color)\\n  //        : RMHit(b.distance, b.color);\\n  return mixa(a, b, float(b.distance < a.distance));\\n}\\n\\nRMHit addFillet(float r, RMHit a, RMHit b) {\\n  if (a.distance < r && b.distance < r) {\\n    return RMHit(\\n      r - distance(vec2(a.distance, b.distance), vec2(r)),\\n      mix(a.color, b.color, (a.distance - b.distance) / r * 0.5 + 0.5)\\n    );\\n  } else {\\n    return add(a, b);\\n  }\\n}\\n\\nRMHit addFillet(float r, RMHit a, RMHit b, vec4 tilletColor) {\\n  if (a.distance < r && b.distance < r) {\\n    return RMHit(\\n      r - distance(vec2(a.distance, b.distance), vec2(r)),\\n      tilletColor\\n    );\\n  } else {\\n    return add(a, b);\\n  }\\n}\\nRMHit addFillet2(float r, RMHit a, RMHit b) {\\n  float h = smoothstep(-r, r, a.distance - b.distance);\\n  return RMHit(\\n    mix(a.distance, b.distance, h) - r * h * (1.0 - h),\\n    mix(a.color, b.color, h)\\n  );\\n}\\n\\nRMHit neg(RMHit a) {\\n  return RMHit(-a.distance, a.color);\\n}\\nRMHit sub(RMHit from, RMHit what) {\\n  RMHit whatNeg = neg(what);\\n  return mixa(from, whatNeg, float(whatNeg.distance > from.distance));\\n}\\n\\nvec3 modv(vec3 v, vec3 dir1, float y) {\\n  float t = dot(v, dir1);\\n  return v - floor(t / y) * y * dir1;\\n}\\nvec3 modRotZ(vec3 p, float count) {\\n  vec2 polarXY = toPolar(p.xy);\\n  return fromPolar(polarXY.x, mod(polarXY.y, TAU / count), p.z);\\n}\\n\\nfloat sin01(float x) {\\n  return 0.5 + 0.5 * sin(x);\\n}\\nfloat cos01(float x) {\\n  return 0.5 + 0.5 * cos(x);\\n}\\n\\nfloat smoothmin(float r, float a, float b) {\\n  float h = smoothstep(-r, r, a - b);\\n  return mix(a, b, h) - r * h * (1.0 - h);\\n}\\n\\nvec2 project(vec2 a, vec2 onto1) {\\n  return onto1 * (dot(a, onto1) / dot(onto1, onto1));\\n}\\n\\nvec3 reject(vec3 a, vec3 b1) {\\n  return a - b1 * dot(a, b1);\\n}\\nfloat demoIcosahedron(float r, vec3 p) {\\n  float d1 = sdIcosahedron(1.0 - r, p - vec3(0, 0, 1)) - r;\\n  return d1;\\n}\\nfloat demoVector(float r, vec3 p) {\\n  //  float d1 = sdArrow(vec3(0), vec3(3), p);\\n  float d1 = sdArrow(1.0, ((p - vec3(0, -1, 0.2)) * 0.5).yzx);\\n  return d1;\\n}\\nfloat demoOctahedron(float r, vec3 p) {\\n  float d1 = sdOctahedron(1.0 - r, p - vec3(0, 0, 1)) - r;\\n  return d1;\\n}\\nfloat demoCube(float r, vec3 p) {\\n  float d1 = sdBox(vec3(1.0 - r), p - vec3(0, 0, 1)) - r;\\n  return d1;\\n}\\nfloat demoTetrahedron(float r, vec3 p) {\\n  float d1 = sdTetrahedron(1.0 - r * sqrt(6.0), p - vec3(0, 0, 1)) - r;\\n  return d1;\\n}\\nfloat demoDodecahedron(float r, vec3 p) {\\n  float d1 = sdDodecahedron(1.0, p - vec3(0, 0, 1)) - r;\\n  return d1;\\n}\\nfloat demoPlatonic(float r, vec3 p) {\\n  float d1 = sdDodecahedron(0.8, p - vec3(0, 0, 1)) - r;\\n  float d2 = sdIcosahedron(1.0 - r, p - vec3(0, 0, 1)) - r;\\n  return mix(d1, d2, sin(iTime) * 0.5 + 0.5);\\n}\\nfloat demoLego(float r, vec3 p) {\\n  float scale = 2.0;\\n  float d1 = sdLego(p * scale - vec3(0, 2, 0)) / scale;\\n  float d2 =\\n    sdLego(rotX(200.0 * DEGREE) * (p * scale - vec3(0, -2, 2))) / scale;\\n  return min(d1, d2);\\n}\\n#define SDF(r, p) demoIcosahedron(r, p)\\n\\nRMHit sdf(vec3 p) {\\n  float scale = 2.0;\\n  float ds = SDF(d * 0.1, p);\\n  float dg = p.z;\\n  if (ds < dg) {\\n    vec3 color = ungamma(colorPrimary);\\n    return RMHit(ds, vec4(color, 1));\\n  } else {\\n    float f = checkerboardGrad(p.xy);\\n\\n    vec3 color = mix(ungamma(colorBackground), ungamma(colorSecondary), f);\\n    return RMHit(dg, vec4(color, 1));\\n  }\\n}\\nfloat sdff(vec3 p) {\\n  return sdf(p).distance;\\n}\\nfloat ambientOcclusion(vec3 pWC, vec3 n1WC) {\\n  float k = 1.0;\\n  float distance = sdff(pWC + n1WC * k);\\n  return clamp(distance / k, 0.0, 1.0);\\n}\\n\\nstruct RMResult {\\n  float distance;\\n  vec3 pos;\\n  vec4 color;\\n};\\nRMResult raymarching2(vec3 start, vec3 dir1) {\\n  vec3 pos = start;\\n  RMHit hit;\\n  for (int i = 0; i < 200; i++) {\\n    hit = sdf(pos);\\n    if (hit.distance < 0.0001 * hit.distance) break;\\n    pos = pos + dir1 * hit.distance;\\n  }\\n  return RMResult(hit.distance, pos, hit.color);\\n}\\n\\nfloat softshadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {\\n  float res = 1.0;\\n  float t = 0.1;\\n  for (int i = 0; i < 1000 && t < maxt; i++) {\\n    float h = sdff(ro + rd * t);\\n    if (h < 0.001) return 0.0;\\n    res = min(res, k * h / t);\\n    t += h;\\n  }\\n  return res;\\n}\\n\\nconst float eps = 1e-4;\\nvec3 sdfNormal1(vec3 p, float d) {\\n  return normalize(\\n    vec3(\\n      sdff(p + vec3(eps, 0.0, 0.0)),\\n      sdff(p + vec3(0.0, eps, 0.0)),\\n      sdff(p + vec3(0.0, 0.0, eps))\\n    ) -\\n      vec3(sdff(p))\\n  );\\n}\\n\\n//layout (depth_greater) out float gl_FragDepth;\\nvoid main() {\\n  vec3 camPos =\\n    vec3(20, 0, 10) +\\n    (-1.0 == iMouse.x\\n      ? vec3(0)\\n      : vec3(0, (iMouse / iResolution * 2.0 - 1.0) * 10.0));\\n  mat4 modelView =\\n    perspective(10.0, iResolution.x / iResolution.y, 0.1, 20.0) *\\n    lookAt(camPos, vec3(0, 0, 1), vec3(0, 0, 1));\\n  mat4 modelViewInverse = inverse(modelView);\\n\\n  vec3 light = normalize(vec3(-1.0, -2.0, -2));\\n\\n  vec3 a = vec3(coord * 2.0 - 1.0, -1.0);\\n  vec3 b = vec3(coord * 2.0 - 1.0, 1.0);\\n  vec3 aWC = transform(modelViewInverse, a);\\n  vec3 bWC = transform(modelViewInverse, b);\\n  vec3 lookDir1 = normalize(bWC - aWC);\\n\\n  RMResult hitWC = raymarching2(aWC, lookDir1);\\n  vec3 hitn1 = sdfNormal1(hitWC.pos, hitWC.distance);\\n  float dWC = distance(aWC, hitWC.pos);\\n  vec3 hitNDC = transform(modelView, hitWC.pos);\\n  vec3 p = hitWC.pos;\\n  float inSun = softshadow(\\n    hitWC.pos + hitn1 * 0.05,\\n    -light,\\n    0.0001,\\n    300.0,\\n    8.0\\n  );\\n  //    float inSun=1.;\\n\\n  vec3 material = hitWC.color.xyz;\\n  if (dWC > 100.0) {\\n    material = vec3(0.0, 0.0, 0.0);\\n    //    } else if (p.z >= 0.001) {\\n    //        material = vec3(0.2, 0.0, 0.0);\\n    //    } else {\\n    //        vec2 c = vec2(4.0, 2.0);\\n    //        vec2 id = floor(((p.xy - c * 0.5) / c) );\\n    //        material += .15 * cos(vec3(id.x, id.y + 2., id.x + id.y + 4.));\\n  }\\n\\n  const vec3 sunlightColor = vec3(3.0);\\n\\n  float aOcc = ambientOcclusion(hitWC.pos, hitn1);\\n\\n  vec3 reflectionDirection = reflect(light, hitn1);\\n\\n  vec3 color = vec3(0.0);\\n  color += material * aOcc;\\n  color += inSun * sunlightColor * material * max(0.0, dot(-light, hitn1));\\n  //    color = (hitn1);\\n\\n  vec3 eyeDirection = -lookDir1;\\n  float uMaterialShininess = 256.0;\\n  float specularLightWeighting = pow(\\n    max(dot(reflectionDirection, eyeDirection), 0.0),\\n    uMaterialShininess\\n  );\\n  color += specularLightWeighting;\\n  //    float lightIntensity = 0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.);\\n  //    float lightIntensity =\\n  //        0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.) + 0.3*specularLightWeighting;\\n  //    fragColor = visualize(blue, red, mix(0.5, 1.0, inSun) * lightIntensity);\\n  //    fragColor = mix(hitWC.color, colorBackground, mix(0.5, 1.0, inSun) * clamp(lightIntensity, 0., 1.));\\n  color = pow(color, vec3(1.0 / 2.2)); // gamma correction\\n  fragColor = vec4(color, 1.0);\\n}\\n\"\nconst sourceMap = {\"version\":3,\"sources\":[\"/home/runner/work/workshop/workshop/src/sdfs3d/demo3d.frag\",\"/home/runner/work/workshop/workshop/src/common/constants.glsl\",\"/home/runner/work/workshop/workshop/src/common/matrices.glsl\",\"/home/runner/work/workshop/workshop/src/common/max3.glsl\",\"/home/runner/work/workshop/workshop/src/common/unmix.glsl\",\"/home/runner/work/workshop/workshop/src/common/fromPolar.glsl\",\"/home/runner/work/workshop/workshop/src/common/toPolar.glsl\",\"/home/runner/work/workshop/workshop/src/common/polar.glsl\",\"/home/runner/work/workshop/workshop/src/common/ungamma.glsl\",\"/home/runner/work/workshop/workshop/src/common/transform.glsl\",\"/home/runner/work/workshop/workshop/src/common/checkerboardGrad.glsl\",\"/home/runner/work/workshop/workshop/src/common/colors.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdIcosahedron.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdDodecahedron.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdCylinder.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdTube.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdBox.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdLego.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdOctahedron.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdCone.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdArrow.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdCapsule.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdTetrahedron.glsl\"],\"names\":[],\"mappings\":\"AAAA;AACA;AACA;AACA;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC3IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AtB9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA\"}\nexport { sourceMap };\n","var map = {\n\t\"./demo3d.frag\": 276\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 8515;"],"names":["FPSController","__init","this","count","__init2","lastTime","performance","now","constructor","notify","window","prototype","call","tick","time","fps","Math","floor","INCH","fmtdeg","x","radiusFromSideWidth","sides","sideWidth","sin","sideWithFromRadius","radius","centerToSideFromSideWidth","tan","radiusFromCenterToSide","centerToSide","cos","sideWidthFromCenterToSide","RegularPolygon","startAngle","sideLength","props","undefined","Error","d","M","V3","polar","map","i","L","Z","RotStep","id","children","stepDeg","key","transform","openInNewTab","url","newWindow","open","opener","H","type","HORIZ_LINE_TO","relative","A","rx","ry","xAxisRotation","largeArcFlag","sweepFlag","p","lArcFlag","rX","rY","ARC","xRot","y","V","VERT_LINE_TO","a1","a2","MOVE_TO","LINE_TO","l","CLOSE_PATH","encode","path","round","_optionalChain","ops","lastAccessLHS","value","length","op","fn","args","GenericDemo","sx","animate","state","Renderer","focusable","rendererRef","rendererRef2","useRef","setFps","useState","anchorEl","setAnchorEl","renderProgress","setRenderProgress","render","useCallback","async","event","dim","currentTarget","dataset","split","current","URL","createObjectURL","renderImage","e","console","error","useEffect","openMenu","resolutionScale","setResolutionScale","resolutionScales","devicePixelRatio","closeMenu","Card","position","Menu","onClose","MenuItem","onClick","ListItem","ListItemText","Select","onChange","target","size","Box","margin","right","CircularProgress","variant","Fab","MoreVert","left","CardMedia","component","ReactGlCanvas","onFps","width","height","canvasRef","renderer1","start","destroy","theme","useTheme","Object","assign","dyn","colorBackground","palette","background","default","gl","colorPrimary","primary","main","colorSecondary","secondary","ref","style","SimpleCanvasRenderer","mousePos","__init3","__init4","stop","fragShader","canvas","__init5","create","alpha","premultipliedAlpha","fixCanvasRes","clientWidth","clientHeight","viewport","log","addEventListener","getBoundingClientRect","offsetX","offsetY","planeMesh","plane","startX","startY","compile","fpsController","makeCurrent","updateShader","buildShader","f","lastResult","lastArgs","some","v","memoizeLast","vs","fs","sourceMap","fsSrc","shader","clear","sourceMapConsumer","SourceMapConsumer","newMessage","message","replace","match","line","originalPosition","originalPositionFor","column","source","bind","abs","_","_2","_3","uniforms","iResolution","iMouse","iTime","draw","onProgress","_4","document","createElement","renderer","step","enable","SCISSOR_TEST","donePixels","scissorWidth","min","scissorHeight","scissor","_5","Promise","resolve","reject","toBlob","blob","Demo3D","frag","replacer","super","container","spacing","padding","item","xs","md","lg","webpackContext","req","webpackContextResolve","__webpack_require__","o","code","keys","module","exports"],"sourceRoot":""}