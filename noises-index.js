"use strict";(self.webpackChunkworkshop=self.webpackChunkworkshop||[]).push([[388],{9764:(n,e,o)=>{o.d(e,{V:()=>a});var t=o(3121),r=o(9526);function a({state:n,prop:e,setStatePartial:o,...a}){return r.createElement(t.Z,{variant:"outlined",size:"small",type:"number",value:n[e],onChange:n=>o({[e]:+n.target.value}),label:e,...a})}},6941:(n,e,o)=>{o.r(e),o.d(e,{band:()=>g,default:()=>y});var t=o(5069),r=o(4854),a=o(871),i=o(3409),l=o(8051),c=o(7392),s=o(9526),f=o(2182),v=o(2004),m=o(9764),u=o(1641);n=o.hmd(n);const x=(0,f.Nv)(512,(()=>f.V3.polar(1,2*(Math.random()-.5)*Math.PI))),d={xOffset:0,yOffset:0,xScale:64,yScale:64,bandCount:2,a:.5,b:.5},p=(n,e,o)=>{const t=0|n,r=t+1,a=0|e,i=a+1,l=n=>n*n*(3-2*n),c=(n,e,o,t)=>{const r=o-n,a=t-e;return(0,f.en)(x,59*n+e).dot(new f.V3(r,a,0))},s=c(t,a,n,e),v=c(r,a,n,e),m=(0,f.t7)(s,v,o?l(n-t):n-t),u=c(t,i,n,e),d=c(r,i,n,e),p=(0,f.t7)(u,d,o?l(n-t):n-t);return(0,f.t7)(m,p,o?l(e-a):e-a)},g=(n,e,o,t)=>(0,f.t7)(n,e,Math.floor(4*(0,f.kL)(n,e,t))/3);const y=()=>{const e=(0,s.useRef)(null),[x,g]=(0,u.q)(d),y=(0,s.useCallback)((n=>g((e=>({...e,...n})))),[g]),h=((0,s.useRef)(),(0,s.useRef)(Object.assign({},x))),b=(0,l.Z)();return(0,s.useEffect)((()=>{!function(e,t,r){let a=!0;const i=512,l=new Uint8Array(512*i),c=new v.xE(i,512,{format:e.RED,type:e.UNSIGNED_BYTE,internalFormat:e.R8}),s=new v.xE(256,256,{format:e.RG,type:e.FLOAT,internalFormat:e.RG32F,data:f.V3.packXY((0,f.Nv)(65536,(()=>f.V3.polar(1,2*(Math.random()-.5)*Math.PI))))}),m=()=>{let n=1/0,e=-1/0;for(let o=0;o<512;o++)for(let t=0;t<i;t++){const c=(0,f.uZ)(.8*(p(r.xOffset+t/r.xScale,r.yOffset+o/r.yScale,a)+.5),0,1),s=Math.random();l[o*i+t]=Math.floor(4*c)/3*255,e=Math.max(e,s),n=Math.min(n,s)}l[0]=0,c.setData(l)},u=v.Kj.plane({detail:128}),x=v.Kj.sphere(0).computeWireframeFromFlatTrianglesClosedMesh().compile();!function(n){const e=[],o=Math.sqrt(3)/2,t=Math.cos(Math.PI/3),r=2*Math.asin(1/Math.sqrt(3));for(let a=-0;a<2;a++)for(let i=-0;i<2;i++)for(let l=-0;l<1;l++){const c=a+(i%2==0?0:t);e.push(n.transform(f.M4.scale(1,.01,.01).translate(c,i*o,l*o)),n.transform(f.M4.scale(1,.01,.01).rotateZ(Math.PI/3).translate(c,i*o,l*o)),n.transform(f.M4.scale(1,.01,.01).rotateZ(Math.PI/3*2).translate(c,i*o,l*o)),n.transform(f.M4.scale(1,.01,.01).rotateZ(Math.PI/2).rotateX((Math.PI-r)/2).translate(c,i*o,l*o)),n.transform(f.M4.scale(1,.01,.01).rotateY(-Math.PI/3*2).rotateX(Math.PI/2-r).translate(c,i*o,l*o)),n.transform(f.M4.scale(1,.01,.01).rotateY(-Math.PI/3).rotateX(Math.PI/2-r).translate(c,i*o,l*o)))}const[a,...i]=e;a.concat(...i)}(v.Kj.rotation([f.V3.Y,f.V3.XY],{anchor:f.V3.O,dir1:f.V3.X},2*Math.PI,3,!0)),console.log(x);const d=v.ex.create("\n      uniform mat4 ts_ModelViewProjectionMatrix;\n      attribute vec4 ts_Vertex;\n      uniform float pointSize;\n      varying vec4 foo;\n      void main() {\n        foo = vec4(1.0, 1.0, 1.0, 1.0);\n        gl_Position = ts_ModelViewProjectionMatrix * ts_Vertex;\n        gl_PointSize = pointSize;\n      }\n    ","\n      precision highp float;\n      uniform vec4 color;\n      varying vec4 bar;\n      void main() {\n        gl_FragColor = color;\n        if (length(gl_PointCoord - vec2(0.5, 0.5)) > 0.5) {\n          discard;\n        }\n      }\n    ");v.ex.create("#version 300 es\n      precision highp float;\n      \n      uniform mat4 ts_ModelViewProjectionMatrix;\n      in vec4 ts_Vertex;\n      uniform float pointSize;\n      uniform vec2 scale;\n      uniform vec2 offset;\n      in vec3 ts_TexCoordUVQ;\n      in vec2 ts_TexCoord;\n      out vec3 coordUVQ;\n      out float n;\n      out vec2 coord;\n      void main() {\n        vec2 texCoordAdjusted = offset + ts_TexCoord * scale;\n        n = 0.0;  \n        gl_Position = ts_ModelViewProjectionMatrix * \n          (ts_Vertex + vec4(0.0, 0.0, n, 0.0));\n        gl_PointSize = pointSize;\n        coordUVQ = ts_TexCoordUVQ;\n        coord = texCoordAdjusted;\n      }\n  ","#version 300 es\n      precision highp float;\n      \n      uniform sampler2D texture;\n      uniform vec4 colorPrimary;\n      uniform vec4 colorBg;\n      uniform int bandCount;\n      in float n;\n      in vec2 coord;\n      out vec4 fragColor;\n      void main() {\n        float fraction = (n + 0.5) * 0.5;\n        fragColor = mix(colorBg, colorPrimary, fraction);\n        \n        if (length(gl_PointCoord - vec2(0.5, 0.5)) > 0.5) {\n          discard;\n        }\n      }\n    ");let g=function(n){return{simplex:v.ex.create(o(9644).Z,o(6275).Z,n),julia:v.ex.create(o(9644).Z,o(4611).Z,n),texShader:v.ex.create("\n      uniform mat4 ts_ModelViewProjectionMatrix;\n      attribute vec4 ts_Vertex;\n      uniform float pointSize;\n      attribute vec3 ts_TexCoordUVQ;\n      attribute vec2 ts_TexCoord;\n      varying vec4 foo;\n      varying vec3 coordUVQ;\n      varying vec2 coord;\n      void main() {\n        foo = vec4(1.0, 1.0, 1.0, 1.0);\n        gl_Position = ts_ModelViewProjectionMatrix * ts_Vertex;\n        gl_PointSize = pointSize;\n        coordUVQ = ts_TexCoordUVQ;\n        coord = ts_TexCoord;\n      }\n    ","\n      precision highp float;\n      uniform sampler2D texture;\n      uniform vec4 colorPrimary;\n      uniform vec4 colorBg;\n      varying vec4 bar;\n      varying vec3 coordUVQ;\n      varying vec2 coord;\n      void main() {\n        float fraction = texture2D(texture, coord).r;\n        gl_FragColor = mix(colorBg, colorPrimary, fraction);\n        \n        if (length(gl_PointCoord - vec2(0.5, 0.5)) > 0.5) {\n          discard;\n        }\n      }\n    "),shader:v.ex.create("\n      uniform mat4 ts_ModelViewProjectionMatrix;\n      attribute vec4 ts_Vertex;\n      uniform float pointSize;\n      varying vec4 foo;\n      void main() {\n        foo = vec4(1.0, 1.0, 1.0, 1.0);\n        gl_Position = ts_ModelViewProjectionMatrix * ts_Vertex;\n        gl_PointSize = pointSize;\n      }\n    ","\n      precision highp float;\n      uniform vec4 color;\n      varying vec4 bar;\n      void main() {\n        gl_FragColor = color;\n        if (length(gl_PointCoord - vec2(0.5, 0.5)) > 0.5) {\n          discard;\n        }\n      }\n    "),perlinShader2:v.ex.create("#version 300 es\n      precision highp float;\n      \n      uniform mat4 ts_ModelViewProjectionMatrix;\n      in vec4 ts_Vertex;\n      uniform float pointSize;\n      uniform vec2 scale;\n      uniform vec2 offset;\n      in vec3 ts_TexCoordUVQ;\n      in vec2 ts_TexCoord;\n      out vec3 coordUVQ;\n      out float n;\n      out vec2 coord;\n      void main() {\n        vec2 texCoordAdjusted = offset + ts_TexCoord * scale;\n        n = 0.0;  \n        gl_Position = ts_ModelViewProjectionMatrix * \n          (ts_Vertex + vec4(0.0, 0.0, n, 0.0));\n        gl_PointSize = pointSize;\n        coordUVQ = ts_TexCoordUVQ;\n        coord = texCoordAdjusted;\n      }\n  ","#version 300 es\n      precision highp float;\n      \n      uniform sampler2D texture;\n      uniform vec4 colorPrimary;\n      uniform vec4 colorBg;\n      uniform int bandCount;\n      in float n;\n      in vec2 coord;\n      out vec4 fragColor;\n      void main() {\n        float fraction = (n + 0.5) * 0.5;\n        fragColor = mix(colorBg, colorPrimary, fraction);\n        \n        if (length(gl_PointCoord - vec2(0.5, 0.5)) > 0.5) {\n          discard;\n        }\n      }\n    ")}}();n.hot,v.ex.create("\n      uniform mat4 ts_ModelViewProjectionMatrix;\n      attribute vec4 ts_Vertex;\n      uniform float pointSize;\n      attribute vec3 ts_TexCoordUVQ;\n      attribute vec2 ts_TexCoord;\n      varying vec4 foo;\n      varying vec3 coordUVQ;\n      varying vec2 coord;\n      void main() {\n        foo = vec4(1.0, 1.0, 1.0, 1.0);\n        gl_Position = ts_ModelViewProjectionMatrix * ts_Vertex;\n        gl_PointSize = pointSize;\n        coordUVQ = ts_TexCoordUVQ;\n        coord = ts_TexCoord;\n      }\n    ","\n      precision highp float;\n      uniform sampler2D texture;\n      uniform vec4 colorPrimary;\n      uniform vec4 colorBg;\n      varying vec4 bar;\n      varying vec3 coordUVQ;\n      varying vec2 coord;\n      void main() {\n        float fraction = texture2D(texture, coord).r;\n        gl_FragColor = mix(colorBg, colorPrimary, fraction);\n        \n        if (length(gl_PointCoord - vec2(0.5, 0.5)) > 0.5) {\n          discard;\n        }\n      }\n    ");const y={pos:(0,f.V)(.75,0,1),lookDir:(0,f.V)(0,0,-1)};(()=>{if(null!==localStorage.getItem("viewState")){const n=JSON.parse(localStorage.getItem("viewState"));y.pos=f.V3.fromArray(n.pos),y.lookDir=f.V3.fromArray(n.lookDir)}})(),e.clearColor(...t.background),e.cullFace(e.BACK);const h=()=>{e.matrixMode(e.PROJECTION),e.loadIdentity(),e.perspective(70,e.canvas.width/e.canvas.height,.1,1e3),e.lookAt((0,f.V)(.75,0,1),(0,f.V)(.75,0,0),f.V3.Y),e.matrixMode(e.MODELVIEW)};h(),e.pointSize(10),e.disable(e.CULL_FACE),e.enable(e.DEPTH_TEST),e.enable(e.BLEND),e.blendFunc(e.SRC_ALPHA,e.ONE_MINUS_SRC_ALPHA);const b={};console.log(e.canvas),e.canvas.contentEditable="true",e.canvas.focus(),e.canvas.onkeydown=function(n){b[n.key]=!0,"o"===n.key&&(a=!a,m()),"2"===n.key&&h(),"1"===n.key&&(e.matrixMode(e.PROJECTION),e.loadIdentity(),e.perspective(70,e.canvas.width/e.canvas.height,.1,1e3),e.lookAt((0,f.V)(0,.5,2.2),f.V3.O,f.V3.Y),e.matrixMode(e.MODELVIEW))},e.canvas.onkeypress=function(n){new f.V3(0,0,0)},e.canvas.onkeyup=function(n){b[n.key]=!1};let T=f.V3.O,R=f.M4.IDENTITY;e.canvas.onmousemove2=function(n){const e=(0,f.V)(n.pageX,n.pageY),o=T.to(e);1&n.buttons&&(R=R.rotateZ(.25*o.x*f.Co),R=R.rotateX(.25*o.y*f.Co)),T=e},e.canvas.onmousemove=function(n){const e=(0,f.V)(n.pageX,n.pageY),o=T.to(e);if(1&n.buttons){const n=f.M4.rotateY(.25*-o.x*f.Co).rotateX(.25*-o.y*f.Co);y.lookDir=n.transformVector(y.lookDir).unit()}T=e};let S=!1;Object.assign(e.animate((function(n,o){const a=new f.V3(+!!b.w-+!!b.s,+!!b.a-+!!b.d,+!!b.e-+!!b.q+ +!!b[" "]).times(.05);if(!a.likeO()){const n=y.lookDir;y.pos=y.pos.plus(f.M4.forSys(n,f.V3.Y.cross(n).unit()).transformVector(a)),localStorage.setItem("viewState",JSON.stringify({pos:y.pos.toArray(),lookDir:y.lookDir.toArray()}))}e.matrixMode(e.PROJECTION),e.loadIdentity(),e.perspective(70,e.canvas.width/e.canvas.height,.1,1e3),e.lookAt(y.pos,y.pos.plus(y.lookDir),f.V3.Y),e.matrixMode(e.MODELVIEW),e.clear(e.COLOR_BUFFER_BIT|e.DEPTH_BUFFER_BIT),e.loadIdentity(),e.pushMatrix(),e.translate(.25,-.5,0),c.bind(0),s.bind(1);const i=n/1e3/40%1,l=n=>f.V3.polar((0,f.t7)(-6,6,n),Math.abs((0,f.t7)(-10,10,n))+f.PI/2,.5),v=f.M4.product(f.M4.perspective(70,1,.1,50),f.M4.lookAt(l(i),l(i+.005).unit().plus((0,f.V)(0,0,.2)),f.V3.Z)),m=v.inversed();S||(console.log(""+v),console.log(v.transformPoint(f.V3.XYZ.negated())),console.log(v.transformPoint(f.V3.XYZ)),S=!0),g.raymarch.uniforms({a:r.a,b:r.b,colorPrimary:t.primary,colorSecondary:t.secondary,colorBg:t.background,scale:[r.xScale,r.yScale],offset:[r.xOffset,r.yOffset],bandCount:r.bandCount,highResTimeStamp:n,secs:n/1e3,gradients:1,lll:v,llli:m}).draw(u),e.popMatrix(),e.pushMatrix(),e.translate(-.75,0,0),e.scale(.5),e.rotate(-90,1,0,0),g.raymarch.uniforms({colorPrimary:t.primary,colorBg:t.background,pointSize:12,texture:0}).draw(x),d.uniforms({color:t.primary,pointSize:12}).draw(x,e.LINES),e.popMatrix()})),{redoTex:m})}(v.ZG.create({canvas:e.current}),{background:c.iv(b.palette.background.default).gl(),primary:c.iv(b.palette.primary.main).gl(),secondary:c.iv(b.palette.secondary.main).gl()},h.current)}),[b.palette.background.default,b.palette.primary.main,b.palette.secondary.main]),(0,s.useEffect)((()=>{Object.assign(h.current,x)}),[x]),s.createElement(a.ZP,{container:!0,style:{height:"99%"}},s.createElement(a.ZP,{item:!0,xs:12,md:9},s.createElement("div",{style:{height:"100%"}},s.createElement("canvas",{ref:e,style:{width:"100%",height:"100%"},width:128,height:128,tabIndex:0}))),s.createElement(a.ZP,{item:!0,xs:12,md:3,sx:{display:"flex",flexDirection:"column",width:"100%",padding:2,alignItems:"stretch",gap:2}},s.createElement(t.Z,null,s.createElement(r.Z,null,"Test with various noise generation functions.")),s.createElement(m.V,{state:x,setStatePartial:y,prop:"xOffset"}),s.createElement(m.V,{state:x,setStatePartial:y,prop:"yOffset"}),s.createElement(m.V,{state:x,setStatePartial:y,prop:"xScale"}),s.createElement(m.V,{state:x,setStatePartial:y,prop:"yScale"}),s.createElement(m.V,{state:x,setStatePartial:y,prop:"bandCount"}),s.createElement("div",null,s.createElement(i.ZP,{value:x.a,onChange:(n,e)=>y({a:e}),min:0,max:1,step:.01})),s.createElement("div",null,s.createElement(i.ZP,{value:x.b,onChange:(n,e)=>y({b:e}),min:0,max:1,step:.01})),x.a))}},1641:(n,e,o)=>{o.d(e,{q:()=>v});var t=o(6897),r=o.n(t),a=o(508),i=o.n(a),l=o(9526);const c=n=>"#"+Object.entries(n).map((([n,e])=>encodeURIComponent(n)+"="+encodeURIComponent(e))).join("&"),s=n=>i()(n,(n=>"true"===n||"false"!==n&&("NaN"===n?NaN:"undefined"===n?void 0:"null"===n?null:""===n?"":isNaN(+n)?n:+n))),f=n=>i()(n,(n=>""+n));function v(n,{deserialize:e=s,serialize:o=f,wait:t=1e3}={}){const a=(0,l.useCallback)((()=>{const t="function"==typeof n?n():n,r=e(Object.assign(o(t),(a=document.location.hash)?a.substr(1).split("&").map((n=>{const[e,o]=n.split("=");return[decodeURIComponent(e),decodeURIComponent(o)]})).reduce(((n,[e,o])=>(n[e]=o,n)),{}):{}));var a;return history.pushState(void 0,document.title,c(o(r))),r}),[e,n,o]),[i,v]=(0,l.useState)(a),m=(0,l.useRef)();return m.current||(m.current=r()((function(n){history.pushState(void 0,document.title,c(o(n)))}),t)),(0,l.useEffect)((()=>m.current(i)),[i]),(0,l.useEffect)((()=>{const n=()=>{v(a())};return window.addEventListener("hashchange",n),()=>{window.removeEventListener("hashchange",n)}}),[a]),[i,v]}},4611:(n,e,o)=>{o.d(e,{Z:()=>t});const t="#version 300 es\nprecision highp float;\n// START ../common/banded.glsl\nfloat banded(float bandCount, float t) {\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\n}\nfloat banded(int bandCount, float t) {\n  return banded(float(bandCount), t);\n}\n\n// #pragma glslify: export(banded)\n\n\n// START ../common/between.glsl\nbool between(float min, float max, float value) {\n  return min <= value && value <= max;\n}\n\n// #pragma glslify: export(between)\n\n\n// START ../common/complex.glsl\n// START ./polar.glsl\n// START ../common/fromPolar.glsl\n// START ./unmix.glsl\nfloat unmix(float a, float b, float value) {\n  return (value - a) / (b - a);\n}\n\n// #pragma glslify: export(unmix)\n\n\n\nvec3 fromPolar(float radius, float phi, float z) {\n  return vec3(radius * cos(phi), radius * sin(phi), z);\n}\n\nvec2 fromPolar(float radius, float phi) {\n  return vec2(radius * cos(phi), radius * sin(phi));\n}\n\nvec2 fromPolar(vec2 polar) {\n  return fromPolar(polar.x, polar.y);\n}\n\n// #pragma glslify: export(fromPolar)\n\n\n// START ../common/toPolar.glsl\n\n\nvec2 toPolar(vec2 xy) {\n  return vec2(length(xy), atan(xy.y, xy.x));\n}\n\nmat2 toPolarDerivate(vec2 xy) {\n  return mat2(xy.x * xy.x, xy.y * xy.y, -xy.y, xy.x) / dot(xy, xy);\n}\n\n// #pragma glslify: export(toPolar)\n\n\n\n\nvec2 complexConj(vec2 z) {\n  return vec2(z.x, -z.y);\n}\n\nvec2 complexMul(vec2 a, vec2 b) {\n  return vec2(a.x * b.x - a.y * b.y, a.y * b.x + a.x * b.y);\n}\n\nvec2 complexDiv(vec2 a, vec2 b) {\n  vec2 bConj = vec2(b.x, -b.y);\n  float divisor = complexMul(b, bConj).x;\n  return complexMul(a, bConj) / divisor;\n}\n\n// return e^z\nvec2 complexPow(vec2 z) {\n  // e^(re + i * im)\n  // = e^re * e^(i * im)\n  return fromPolar(exp(z.x), z.y);\n}\n\n// return w^z\nvec2 complexPow(vec2 w, float z) {\n  // w = r * e ^ (i * phi)\n  // ln(w) = ln(r) + i * phi\n  // w^z = e^(z * log(w)) = e^(z * (ln(r) + i * (phi))\n  vec2 wPolar = toPolar(w);\n  vec2 eExp = z * vec2(log(wPolar.x), wPolar.y);\n  return complexPow(eExp);\n}\n\n// START ../common/hex2Ra.glsl\nvec2 hex2Ra(vec3 hex) {\n  float y = hex.t * 0.866;\n  float x = hex.s + hex.t / 2.0;\n  return vec2(x, y);\n}\n\n// #pragma glslify: export(hex2Ra)\n\n\n// START ../common/hexRound.glsl\nvec3 hexRound(vec3 hex) {\n  vec3 r = floor(hex + 0.5);\n  vec3 diff = abs(r - hex);\n\n  if (diff.x > diff.y && diff.x > diff.z) {\n    r.x = -(r.y + r.z);\n  } else if (diff.y > diff.z) {\n    r.y = -(r.x + r.z);\n  } else {\n    r.z = -(r.x + r.y);\n  }\n\n  return r;\n}\n\n// #pragma glslify: export(hexRound)\n\n\n// START ../common/hexSdf.glsl\n// START ./max3.glsl\nfloat max3(float a, float b, float c) {\n  return max(a, max(b, c));\n}\nfloat max3(vec3 v) {\n  return max(v.x, max(v.y, v.z));\n}\n\n// #pragma glslify: export(max3)\n\n\n\nfloat hexSdf(vec3 hex) {\n  return max3(abs(hex.yzx + hex.zxy / 2.0));\n}\n\n// #pragma glslify: export(hexSdf)\n\n\n// START ../common/matrices.glsl\n// START ./constants.glsl\nconst float SQRT1_2 = 0.7071067811865476;\nconst float SQRT1_3 = 0.57735026919;\nconst float SQRT2 = 1.4142135623730951;\nconst float SQRT3 = 1.732050807568877;\n// sqrt(3)/2 = sin(60*)\nconst float SQRT3_2 = 0.86602540378;\nconst float GOLDEN_RATIO = 1.61803398875;\nconst float PI = 3.141592653589793;\nconst float TAU = 6.28318530718;\n/**\n * One degree in radians. Use like `sin(30 * DEG)`.\n */\nconst float DEGREE = 0.017453292519943295;\n\n\nmat2 rot2(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat2(c, -s, s, c);\n}\nmat3 rotX(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\n}\nmat3 rotY(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\n}\nmat3 rotZ(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\n}\n/**\n * Returns a matrix that puts the camera at the eye point `ex, ey, ez` looking\n * toward the center point `cx, cy, cz` with an up direction of `ux, uy, uz`.\n * This emulates the OpenGL function `gluLookAt()`.\n */\nmat4 lookAt(vec3 eye, vec3 focus, vec3 up) {\n  vec3 f = normalize(eye - focus);\n  vec3 s = normalize(cross(up, f));\n  vec3 t = normalize(cross(f, s));\n\n  return mat4(\n    vec4(s.x, t.x, f.x, 0.0),\n    vec4(s.y, t.y, f.y, 0.0),\n    vec4(s.z, t.z, f.z, 0.0),\n    vec4(-dot(s, eye), -dot(t, eye), -dot(f, eye), 1)\n  );\n}\n\n// the OpenGL function `glFrustum()`.\nmat4 frustum(\n  float left,\n  float right,\n  float bottom,\n  float top,\n  float near,\n  float far\n) {\n  return mat4(\n    vec4(2.0 * near / (right - left), 0.0, 0.0, 0.0),\n    vec4(0, 2.0 * near / (top - bottom), 0.0, 0.0),\n    vec4(\n      (right + left) / (right - left),\n      (top + bottom) / (top - bottom),\n      -(far + near) / (far - near),\n      -1\n    ),\n    vec4(0.0, 0.0, -2.0 * far * near / (far - near), 0.0)\n  );\n}\n\nmat4 perspective(float fovDegrees, float aspect, float near, float far) {\n  float y = tan(fovDegrees * DEGREE / 2.0) * near;\n  float x = y * aspect;\n  return frustum(-x, x, -y, y, near, far);\n}\n\n\n// START ../common/ra2Hex.glsl\nvec3 raToHex(vec2 xy) {\n  float hex_t = xy.y / 0.866;\n  float hex_s = xy.x - hex_t / 2.0;\n  return vec3(hex_s, hex_t, -(hex_s + hex_t));\n}\n\n// #pragma glslify: export(raToHex)\n\n\n// START ../common/remix.glsl\n\n\nfloat remix(float fromA, float fromB, float toA, float toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\nvec4 remix(float fromA, float fromB, vec4 toA, vec4 toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\n// #pragma glslify: export(remix)\n\n\n// START ../common/simplex2DTexture.glsl\nuniform sampler2D gradients;\nuniform int bandCount;\n\nvec3 xy2tri(vec2 xy) {\n  float v = xy.y / 0.866;\n  float u = xy.x - v / 2.0;\n  float R = float(mod(u, 1.0) + mod(v, 1.0) > 1.0);\n  return vec3(u, v, R);\n}\nvec3 triCenter(vec3 uvR) {\n  vec3 base = floor(uvR);\n  vec2 centerOffset = mix(vec2(1.0 / 3.0), vec2(2.0 / 3.0), uvR.z);\n  return base + vec3(centerOffset, 0.0);\n}\nvec2 tri2xy(vec3 uvR) {\n  float y = uvR.t * 0.866;\n  float x = uvR.s + uvR.t / 2.0;\n  return vec2(x, y);\n}\nvec2 tri2xy(vec2 uv) {\n  float y = uv.t * 0.866;\n  float x = uv.s + uv.t / 2.0;\n  return vec2(x, y);\n}\nconst float SQRT2 = 1.4142135623730951;\nconst float GOLDEN_RATIO = 1.61803398875;\nconst float SQRT3 = 1.732050807568877;\n/* Create random direction vector\n */\nvec2 randomGradient(vec2 i) {\n  // Random float. No precomputed gradients mean this works for any number of grid coordinates\n  float random =\n    2920.0 *\n    sin(float(i.x) * 2.1942 + float(i.y) * 1.71324 + 8.912) *\n    cos(float(i.x) * 2.3157 * float(i.y) * 2.17832 + 9.758);\n  //    random = (i.x + 1667.) * (i.x + 2083.) * (i.y + 2659.) * (i.y * 50.77 + .3769);\n  //    random = sin(SQRT2 * i.x) + cos(GOLDEN_RATIO * i.y) + tan((i.x + i.y) * SQRT3);\n  return vec2(cos(random), sin(random));\n}\n\nfloat dotGridGradient2(vec2 cell, vec2 pos) {\n  vec2 xy_d = cell - pos;\n  if (length(xy_d) > 0.4) return 0.0;\n  float r = 1.0;\n  float part = pow(max(0.0, 0.999 - dot(xy_d, xy_d)), 4.0);\n  //    vec2 gradient = texelFetch(gradients, ivec2(cell), 0).xy;\n  vec2 gradient = randomGradient(cell);\n  return part * dot(gradient, xy_d);\n}\n\n// resulting range is [-0.68, 0.68]. Use unmix to normalize if necessary.\nfloat simplex2D(vec2 xy) {\n  vec3 uvR = xy2tri(xy);\n  ivec2 baseUV = ivec2(uvR.xy);\n\n  float a = dotGridGradient2(tri2xy(vec2(baseUV)), xy);\n  float b = dotGridGradient2(tri2xy(vec2(baseUV + ivec2(1, 0))), xy);\n  float c = dotGridGradient2(tri2xy(vec2(baseUV + ivec2(0, 1))), xy);\n  float d = dotGridGradient2(tri2xy(vec2(baseUV + ivec2(1, 1))), xy);\n\n  return b + c + mix(a, d, uvR.z);\n}\n\n// #pragma glslify: export(simplex2D)\n\n\n\n// START ../common/visualize.glsl\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\n  float isLow = float(t < 0.0);\n  float isHigh = float(t > 1.0);\n  float isMid = 1.0 - isLow - isHigh;\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\n}\n\nvec4 visualize(float t) {\n  const vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\n  const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\n  return visualize(BLUE, RED, t);\n}\n\n// #pragma glslify: export(visualize)\n\n\n// START ../common/waves.glsl\nfloat waves(vec4 color, vec2 position, vec2 direction, float highResTimeStamp) {\n  return sin(\n    dot(position, direction / pow(length(direction), 2.0)) +\n      float(highResTimeStamp) / 200.0\n  );\n}\n\n// #pragma glslify: export(waves)\n\n\n\nuniform sampler2D texture;\nuniform vec4 colorPrimary;\nuniform vec4 colorSecondary;\nuniform vec4 colorBg;\nuniform float a;\nuniform float b;\nuniform int bandCount;\nuniform float secs;\nin vec2 coord;\nout vec4 fragColor;\n\nconst vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\nconst vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\nconst vec4 blue = vec4(0.0, 0.0, 1.0, 1.0);\nconst vec4 red = vec4(1.0, 0.0, 0.0, 1.0);\nconst float GOLDEN_RATIO = 1.61803398875;\n\nconst vec2 c = vec2(-0.4, 0.6);\nvec2 f(vec2 z) {\n  //    return complexMul(z, z) + fromPolar(0.7885,(a + b/50.)*6.);\n  return complexMul(z, z) + fromPolar(0.7885, secs / 2.0);\n  //    return complexMul(z, z)  + fromPolar(0.7885,4.);\n}\n\nvec2 complexSqr(vec2 z) {\n  return complexMul(z, z);\n}\nvec2 f2(vec2 z) {\n  const float n = 8.0;\n  return complexDiv(\n    1.0 + (n - 1.0) * complexPow(z, n),\n    n * complexPow(z, n - 1.0)\n  );\n}\n\nvec2 f3(vec2 z) {\n  vec2 z2 = complexMul(z, z);\n  vec2 z3 = complexMul(z2, z);\n  return complexDiv(vec2(1.0, 0.0) + 2.0 * z3, 3.0 * z2);\n}\nvec2 flf(vec2 z) {\n  vec2 z2 = complexMul(z, z);\n  vec2 z3 = complexMul(z2, z);\n  return complexDiv(vec2(1.0, 0.0) - z3 / 6.0, complexSqr(z - z2 / 2.0)) +\n  vec2(-a, b);\n}\n// START ../common/juliaIteration.glsl\n#define JULIA_ITERATION(NAME, F, R, MAXIT)                                     \\\n  vec3 NAME(vec2 start) {                                                      \\\n    const float rSqr = (R) * (R);                                              \\\n    vec2 p = start;                                                            \\\n    for (uint i = uint(0); i < (MAXIT); i++) {                                 \\\n      p = F(p);                                                                \\\n      if (dot(p, p) > rSqr) {                                                  \\\n        return vec3(p, float(i));                                              \\\n      }                                                                        \\\n    }                                                                          \\\n    return vec3(p, float(MAXIT));                                              \\\n  }\n\n\nJULIA_ITERATION(julia, f, 2., 20u)\n\nvoid main() {\n  vec3 res = julia(coord);\n  float f = res.z / 20.0;\n\n  //    fragColor = mix(colorBg, colorPrimary, banded(bandCount, unmix(-.35, .35, f2)));\n  fragColor = mix(colorBg, colorPrimary, min(banded(bandCount, f), 1.0));\n  fragColor = vec4(res, 1.0);\n  //    fragColor = visualize(f);\n  //    fragColor = visualize(float(i == 1000u));\n}\n"},6275:(n,e,o)=>{o.d(e,{Z:()=>t});const t="#version 300 es\nprecision mediump float;\n// START ../common/banded.glsl\nfloat banded(float bandCount, float t) {\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\n}\nfloat banded(int bandCount, float t) {\n  return banded(float(bandCount), t);\n}\n\n// #pragma glslify: export(banded)\n\n\n// START ../common/between.glsl\nbool between(float min, float max, float value) {\n  return min <= value && value <= max;\n}\n\n// #pragma glslify: export(between)\n\n\n// START ../common/simplex2DTexture.glsl\nuniform sampler2D gradients;\nuniform int bandCount;\n\nvec3 xy2tri(vec2 xy) {\n  float v = xy.y / 0.866;\n  float u = xy.x - v / 2.0;\n  float R = float(mod(u, 1.0) + mod(v, 1.0) > 1.0);\n  return vec3(u, v, R);\n}\nvec3 triCenter(vec3 uvR) {\n  vec3 base = floor(uvR);\n  vec2 centerOffset = mix(vec2(1.0 / 3.0), vec2(2.0 / 3.0), uvR.z);\n  return base + vec3(centerOffset, 0.0);\n}\nvec2 tri2xy(vec3 uvR) {\n  float y = uvR.t * 0.866;\n  float x = uvR.s + uvR.t / 2.0;\n  return vec2(x, y);\n}\nvec2 tri2xy(vec2 uv) {\n  float y = uv.t * 0.866;\n  float x = uv.s + uv.t / 2.0;\n  return vec2(x, y);\n}\nconst float SQRT2 = 1.4142135623730951;\nconst float GOLDEN_RATIO = 1.61803398875;\nconst float SQRT3 = 1.732050807568877;\n/* Create random direction vector\n */\nvec2 randomGradient(vec2 i) {\n  // Random float. No precomputed gradients mean this works for any number of grid coordinates\n  float random =\n    2920.0 *\n    sin(float(i.x) * 2.1942 + float(i.y) * 1.71324 + 8.912) *\n    cos(float(i.x) * 2.3157 * float(i.y) * 2.17832 + 9.758);\n  //    random = (i.x + 1667.) * (i.x + 2083.) * (i.y + 2659.) * (i.y * 50.77 + .3769);\n  //    random = sin(SQRT2 * i.x) + cos(GOLDEN_RATIO * i.y) + tan((i.x + i.y) * SQRT3);\n  return vec2(cos(random), sin(random));\n}\n\nfloat dotGridGradient2(vec2 cell, vec2 pos) {\n  vec2 xy_d = cell - pos;\n  if (length(xy_d) > 0.4) return 0.0;\n  float r = 1.0;\n  float part = pow(max(0.0, 0.999 - dot(xy_d, xy_d)), 4.0);\n  //    vec2 gradient = texelFetch(gradients, ivec2(cell), 0).xy;\n  vec2 gradient = randomGradient(cell);\n  return part * dot(gradient, xy_d);\n}\n\n// resulting range is [-0.68, 0.68]. Use unmix to normalize if necessary.\nfloat simplex2D(vec2 xy) {\n  vec3 uvR = xy2tri(xy);\n  ivec2 baseUV = ivec2(uvR.xy);\n\n  float a = dotGridGradient2(tri2xy(vec2(baseUV)), xy);\n  float b = dotGridGradient2(tri2xy(vec2(baseUV + ivec2(1, 0))), xy);\n  float c = dotGridGradient2(tri2xy(vec2(baseUV + ivec2(0, 1))), xy);\n  float d = dotGridGradient2(tri2xy(vec2(baseUV + ivec2(1, 1))), xy);\n\n  return b + c + mix(a, d, uvR.z);\n}\n\n// #pragma glslify: export(simplex2D)\n\n\n// START ../common/remix.glsl\n// START ./unmix.glsl\nfloat unmix(float a, float b, float value) {\n  return (value - a) / (b - a);\n}\n\n// #pragma glslify: export(unmix)\n\n\n\nfloat remix(float fromA, float fromB, float toA, float toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\nvec4 remix(float fromA, float fromB, vec4 toA, vec4 toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\n// #pragma glslify: export(remix)\n\n\n\n// START ../common/waves.glsl\nfloat waves(vec4 color, vec2 position, vec2 direction, float highResTimeStamp) {\n  return sin(\n    dot(position, direction / pow(length(direction), 2.0)) +\n      float(highResTimeStamp) / 200.0\n  );\n}\n\n// #pragma glslify: export(waves)\n\n\n// START ../common/visualize.glsl\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\n  float isLow = float(t < 0.0);\n  float isHigh = float(t > 1.0);\n  float isMid = 1.0 - isLow - isHigh;\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\n}\n\nvec4 visualize(float t) {\n  const vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\n  const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\n  return visualize(BLUE, RED, t);\n}\n\n// #pragma glslify: export(visualize)\n\n\n// START ../common/ra2Hex.glsl\nvec3 raToHex(vec2 xy) {\n  float hex_t = xy.y / 0.866;\n  float hex_s = xy.x - hex_t / 2.0;\n  return vec3(hex_s, hex_t, -(hex_s + hex_t));\n}\n\n// #pragma glslify: export(raToHex)\n\n\n// START ../common/hex2Ra.glsl\nvec2 hex2Ra(vec3 hex) {\n  float y = hex.t * 0.866;\n  float x = hex.s + hex.t / 2.0;\n  return vec2(x, y);\n}\n\n// #pragma glslify: export(hex2Ra)\n\n\n// START ../common/hexRound.glsl\nvec3 hexRound(vec3 hex) {\n  vec3 r = floor(hex + 0.5);\n  vec3 diff = abs(r - hex);\n\n  if (diff.x > diff.y && diff.x > diff.z) {\n    r.x = -(r.y + r.z);\n  } else if (diff.y > diff.z) {\n    r.y = -(r.x + r.z);\n  } else {\n    r.z = -(r.x + r.y);\n  }\n\n  return r;\n}\n\n// #pragma glslify: export(hexRound)\n\n\n// START ../common/hexSdf.glsl\n// START ./max3.glsl\nfloat max3(float a, float b, float c) {\n  return max(a, max(b, c));\n}\nfloat max3(vec3 v) {\n  return max(v.x, max(v.y, v.z));\n}\n\n// #pragma glslify: export(max3)\n\n\n\nfloat hexSdf(vec3 hex) {\n  return max3(abs(hex.yzx + hex.zxy / 2.0));\n}\n\n// #pragma glslify: export(hexSdf)\n\n\n\nuniform sampler2D texture;\nuniform vec4 colorPrimary;\nuniform vec4 colorSecondary;\nuniform vec4 colorBg;\nuniform float a;\nuniform int bandCount;\nin float n;\nin vec2 coord;\nout vec4 fragColor;\n\nconst vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\nconst vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\nconst vec4 blue = vec4(0.0, 0.0, 1.0, 1.0);\nconst vec4 red = vec4(1.0, 0.0, 0.0, 1.0);\n\nfloat simplex01(vec2 pos) {\n  return unmix(-0.68, 0.68, simplex2D(pos));\n}\n\nvoid main() {\n  float f = mix(simplex2D(coord), simplex2D(coord * 4.0), a);\n  float f2 = simplex2D(coord);\n\n  fragColor = mix(\n    colorBg,\n    colorPrimary,\n    banded(bandCount, unmix(-0.35, 0.35, f2))\n  );\n  //    fragColor = mix(fragColor, colorSecondary, float(between(0.0, 1., f)));\n}\n"},9644:(n,e,o)=>{o.d(e,{Z:()=>t});const t="#version 300 es\nprecision highp float;\n\nuniform mat4 ts_ModelViewProjectionMatrix;\nin vec4 ts_Vertex;\nuniform vec2 scale;\nuniform vec2 offset;\nin vec3 ts_TexCoordUVQ;\nin vec2 ts_TexCoord;\nout vec3 coordUVQ;\nout float n;\nout vec2 coord;\nvoid main() {\n  vec2 texCoordAdjusted = offset + ts_TexCoord * scale;\n  gl_Position = ts_Vertex;\n  coordUVQ = ts_TexCoordUVQ;\n  coord = ts_TexCoord;\n}\n"}}]);