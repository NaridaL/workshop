(self.webpackChunkworkshop=self.webpackChunkworkshop||[]).push([[388],{9643:(A,n,e)=>{"use strict";e.d(n,{V:()=>c});var o=e(3121),t=e(9526);function c({state:A,prop:n,setStatePartial:e,...c}){return t.createElement(o.Z,{variant:"outlined",size:"small",type:"number",value:A[n],onChange:A=>e({[n]:+A.target.value}),label:n,...c})}},7189:(A,n,e)=>{"use strict";e.d(n,{q:()=>o});class o{__init(){this.count=0}__init2(){this.lastTime=performance.now()}constructor(A,n=10){this.notify=A,this.window=n,o.prototype.__init.call(this),o.prototype.__init2.call(this)}tick(A=performance.now()){const n=this.window;if(this.count=(this.count+1)%n,0===this.count){const e=Math.floor(1e3*n/(A-this.lastTime));this.notify(e),this.lastTime=A}}}},4341:(A,n,e)=>{"use strict";e.d(n,{q:()=>v});var o=e(6897),t=e.n(o),c=e(508),r=e.n(c),C=e(9526);const a=A=>A?A.substring(1).split("&").map((A=>{const[n,e]=A.split("=");return[decodeURIComponent(n),decodeURIComponent(e)]})).reduce(((A,[n,e])=>(A[n]=e,A)),{}):{},s=A=>"#"+Object.entries(A).map((([A,n])=>encodeURIComponent(A)+"="+encodeURIComponent(n))).join("&"),l=A=>r()(A,(A=>"true"===A||"false"!==A&&("NaN"===A?NaN:"undefined"===A?void 0:"null"===A?null:""===A?"":isNaN(+A)?A:+A))),i=A=>r()(A,(A=>""+A));function v(A,{deserialize:n=l,serialize:e=i,wait:o=1e3}={}){const c=(0,C.useCallback)((()=>{const o="function"==typeof A?A():A,t=n(Object.assign(e(o),a(document.location.hash)));return history.pushState(void 0,document.title,s(e(t))),t}),[n,A,e]),[r,v]=(0,C.useState)(c),m=(0,C.useRef)();return m.current||(m.current=t()((function(A){history.pushState(void 0,document.title,s(e(A)))}),o)),(0,C.useEffect)((()=>m.current(r)),[r]),(0,C.useEffect)((()=>{const A=()=>{v(c())};return window.addEventListener("hashchange",A),()=>{window.removeEventListener("hashchange",A)}}),[c]),[r,v]}},2446:(A,n,e)=>{"use strict";e.r(n),e.d(n,{PanningCanvasRenderer:()=>p,band:()=>d,default:()=>h});var o=e(5069),t=e(4854),c=e(871),r=e(5100),C=e(9526),a=e(2182),s=(e(2004),e(9643)),l=e(4341),i=e(6129);function v(A){let n,e=A[0],o=1;for(;o<A.length;){const t=A[o],c=A[o+1];if(o+=2,("optionalAccess"===t||"optionalCall"===t)&&null==e)return;"access"===t||"optionalAccess"===t?(n=e,e=c(e)):"call"!==t&&"optionalCall"!==t||(e=c(((...A)=>e.call(n,...A))),n=void 0)}return e}class m{__init(){this.lastPos=a.V3.O}__init2(){this.pressedKeys={}}__init3(){this.pauseCam=!1}reset(){a.M4.identity(this.state),v([this,"access",A=>A.onChange,"optionalCall",A=>A(this.state)])}constructor(A,n,e){this.state=A,this.onChange=n,this.lockUp=e,m.prototype.__init.call(this),m.prototype.__init2.call(this),m.prototype.__init3.call(this),m.prototype.__init4.call(this),m.prototype.__init5.call(this),m.prototype.__init6.call(this),m.prototype.__init7.call(this),m.prototype.__init8.call(this)}__init4(){this.setState=A=>{A!==this.state&&a.M4.copy(A,this.state)}}registerListeners(A,n=A){return v([this,"access",A=>A.unregister,"optionalCall",A=>A()]),A.addEventListener("wheel",this.wheel),A.addEventListener("mousemove",this.mousemove),n.addEventListener("keydown",this.keydown),n.addEventListener("keyup",this.keyup),this.unregister=()=>{A.removeEventListener("wheel",this.wheel),A.removeEventListener("mousemove",this.mousemove),n.removeEventListener("keydown",this.keydown),n.removeEventListener("keyup",this.keyup)}}unregisterListeners(){v([this,"access",A=>A.unregister,"optionalCall",A=>A()])}static __initStatic(){this.TRACKED_KEYS=["a","d","s","w"]}tick(){const A=new a.V3(+!!this.pressedKeys.a-+!!this.pressedKeys.d,+!!this.pressedKeys.s-+!!this.pressedKeys.w,0);A.likeO()||(this.state=this.state.translate(A.times(10)),v([this,"access",A=>A.onChange,"optionalCall",A=>A(this.state)]))}__init5(){this.wheel=A=>{const n=A.currentTarget,{width:e,height:o}=n.getBoundingClientRect(),t=Math.pow(1.1,-Math.sign(A.deltaY)),c=new a.V3(n.width*(A.offsetX/e),n.height*(1-A.offsetY/o),0);this.state=this.state.translate(c.negated()).scale(a.V3.XYZ.times(t)).translate(c),v([this,"access",A=>A.onChange,"optionalCall",A=>A(this.state)]),A.preventDefault(),A.stopPropagation()}}__init6(){this.mousemove=A=>{const n=A.currentTarget,{width:e,height:o}=n.getBoundingClientRect(),t=(0,a.V)(A.pageX,A.pageY),c=this.lastPos.to(t);1&A.buttons&&!this.pauseCam&&(this.state=this.state.translate(n.width*(c.x/e),n.height*(-c.y/o),0),v([this,"access",A=>A.onChange,"optionalCall",A=>A(this.state)])),this.lastPos=t}}__init7(){this.keydown=A=>{"r"===A.key?(this.reset(),A.preventDefault()):m.TRACKED_KEYS.includes(A.key)&&(this.pressedKeys[A.key]=!0,A.preventDefault())}}__init8(){this.keyup=A=>{this.pressedKeys[A.key]=void 0,A.preventDefault()}}getTransform(){return this.state}static toShortString(A,n=1){const e=A.getTranslation(),o=A.m[0];return Math.round(e.x*n)+"~"+Math.round(e.y*n)+"~"+Math.round(Math.log(o)/Math.log(1.1))}static fromShortString(A,n=1){const[e,o,t]=A.split("~");return a.M4.translate(new a.V3(+e/n,+o/n,0)).scale(Math.pow(1.1,+t))}}m.__initStatic(),(0,a.Nv)(512,(()=>a.V3.polar(1,2*(Math.random()-.5)*Math.PI)));const f={bandCount:8,a:.5,b:.5,c:.5,cam:"0~0~0"},d=(A,n,e,o)=>(0,a.t7)(A,n,Math.floor(4*(0,a.kL)(A,n,o))/3);class p extends i.A0{constructor(A,n,e){super(A,n,e),n.tabIndex=0,this.panController=new m(a.M4.identity(),e.onCamChange),this.panController.registerListeners(n)}uniforms(){return{modelView:this.panController.getTransform(),viewModel:this.panController.getTransform().inversed()}}setCam(A){this.panController.setState(A)}render(A){this.panController.tick(),super.render(A)}}const u=({frag:A,sx:n,animate:o,state:t})=>{const c=(0,C.useCallback)(class extends p{constructor(n,o){super((()=>e(6466)("./"+A+".frag")),n,o)}},[A]);return C.createElement(i.XM,{sx:n,Renderer:c,animate:o,state:t})},h=()=>{const[A,n]=(0,l.q)(f),[e,a]=(0,C.useState)(0),i=(0,C.useCallback)((A=>n((n=>({...n,...A})))),[n]),v=((0,C.useCallback)((({cam:A})=>{const n=m.fromShortString(A);i({cam:m.toShortString(n)})}),[i]),(0,C.useRef)());return(0,C.useEffect)((()=>{A.cam&&function(A){let n,e=A[0],o=1;for(;o<A.length;){const t=A[o],c=A[o+1];if(o+=2,("optionalAccess"===t||"optionalCall"===t)&&null==e)return;"access"===t||"optionalAccess"===t?(n=e,e=c(e)):"call"!==t&&"optionalCall"!==t||(e=c(((...A)=>e.call(n,...A))),n=void 0)}}([v,"access",A=>A.current,"optionalAccess",A=>A.setCam,"optionalCall",n=>n(m.fromShortString(A.cam))])}),[]),C.createElement(c.ZP,{container:!0,style:{height:"99%"},spacing:2,padding:2},C.createElement(c.ZP,{container:!0,item:!0,sm:9,spacing:2},["tree"].map(((n,e)=>C.createElement(c.ZP,{item:!0,xs:12,key:e},C.createElement(u,{sx:{height:400},animate:!0,state:A,frag:n,rendererRef:v}))))),C.createElement(c.ZP,{item:!0,xs:12,md:3,sx:{display:"flex",flexDirection:"column",width:"100%",alignItems:"stretch",gap:2}},C.createElement(o.Z,null,C.createElement(t.Z,null,"Test with various noise generation functions.")),C.createElement(s.V,{state:A,setStatePartial:i,prop:"bandCount"}),C.createElement(r.ZP,{value:A.a,onChange:(A,n)=>i({a:n}),min:0,max:1,step:.01}),C.createElement(r.ZP,{value:A.b,onChange:(A,n)=>i({b:n}),min:0,max:1,step:.01}),C.createElement(r.ZP,{value:A.c,onChange:(A,n)=>i({c:n}),min:0,max:1,step:.01}),A.a,C.createElement("div",null,"fps: ",e)))}},6415:(A,n,e)=>{"use strict";e.d(n,{$Q:()=>u,PM:()=>c,PN:()=>p,Qn:()=>a,X$:()=>r,XJ:()=>C,YQ:()=>x,_x:()=>i,hv:()=>v,kC:()=>m,li:()=>f,nA:()=>d,nl:()=>g,oe:()=>l,q3:()=>s,t1:()=>h});var o=e(9526),t=e(2182);const c=25.4,r=A=>(0,t.At)(A/t.Co,-1)+"Â°",C=(A,n)=>n/2/Math.sin(t.gc/A/2),a=(A,n)=>2*n*Math.sin(t.gc/A/2),s=(A,n)=>n/2/Math.tan(t.gc/A/2),l=(A,n)=>n/Math.cos(t.gc/A/2),i=(A,n)=>2*n*Math.tan(t.gc/A/2);function v({sides:A,radius:n,startAngle:e=0,sideLength:c,...r}){if(void 0!==c==(void 0!==n))throw new Error("must set either sideLength or radius");void 0===n&&(n=C(A,c));const{x:a,y:s}=t.V3.polar(n,e);return o.createElement("path",{d:g`
        M${a},${s}
        ${(0,t.hS)(0,A).map((o=>g`L${t.V3.polar(n,e+o*(t.gc/A))}`))}Z`,...r})}function m({id:A,children:n,count:e,stepDeg:c}){return o.createElement(o.Fragment,null,o.createElement("g",{id:A},n),(0,t.hS)(0,e-1).map((n=>o.createElement("use",{key:n,xlinkHref:"#"+A,transform:`rotate(${(n+1)*c} 0 0)`}))))}const f=[[841,1189,"A0"],[594,841,"A1"],[420,594,"A2"],[297,420,"A3"],[210,297,"A4"],[148,210,"A5"],[105,148,"A6"],[74,105,"A7"],[52,74,"A8"],[37,52,"A9"],[26,37,"A10"],[150,150,"Origami 15cm"],[100,100,"Origami 10cm"],[75,75,"Origami 7.5cm"],[215.9,279.4,"Letter"],[215.9,355.6,"Legal"]];function d(A){const n=f.find((([,,n])=>n===A));if(n)return n;const[e,o]=A.split("x");return[+e,+o,"Custom"]}function p(A,n){return[A,n]=[A,n].sort(t.uK),null!=(e=f.find((([e,o])=>e===A&&o===n)))?e:(()=>[A,n,"Custom"])();var e}function u([A,n,e]){return"Custom"===e?A+"x"+n:e}const h=f.find((([,,A])=>"A4"===A));function g(A,...n){const e=A=>"number"==typeof A?""+A:"string"==typeof A?A:Array.isArray(A)?A.map(e).join(" "):A.x+","+A.y;let o=A[0];for(let t=0;t<n.length;t++)o+=e(n[t]),o+=A[t+1];return o}const x=A=>{const n=window.open(A,"_blank","noopener,noreferrer");n&&(n.opener=null)}},6129:(A,n,e)=>{"use strict";e.d(n,{XM:()=>y,tz:()=>w,A0:()=>T});var o=e(4625),t=e(8356),c=e(5069),r=e(4353),C=e(3120),a=e(8105),s=e(8958),l=e(7931),i=e(7813),v=e(897),m=e(882),f=e(8051),d=e(7392),p=e(9526),u=e(5583),h=e(5233),g=e(2004),x=e(7189),E=e(6415);function R(A){let n,e=A[0],o=1;for(;o<A.length;){const t=A[o],c=A[o+1];if(o+=2,("optionalAccess"===t||"optionalCall"===t)&&null==e)return;"access"===t||"optionalAccess"===t?(n=e,e=c(e)):"call"!==t&&"optionalCall"!==t||(e=c(((...A)=>e.call(n,...A))),n=void 0)}return e}function y({sx:A,animate:n,state:e,Renderer:f,focusable:d,rendererRef:u}){const h=(0,p.useRef)(),[g,x]=(0,p.useState)(0),[R,y]=(0,p.useState)(),[T,_]=(0,p.useState)(),b=(0,p.useCallback)((async A=>{const n=A.currentTarget.dataset.dim.split("x").map((A=>+A));if(y(void 0),h.current)try{const A=URL.createObjectURL(await h.current.renderImage(n,_));_(void 0),(0,E.YQ)(A)}catch(A){console.error(A)}}),[]);(0,p.useEffect)((()=>{u&&(u.current=h.current)}),[u]);const L=(0,p.useCallback)((A=>y(A.currentTarget)),[]),[D,S]=(0,p.useState)(1),k=[.5,1,window.devicePixelRatio,2,4*window.devicePixelRatio],N=(0,p.useCallback)((()=>y(void 0)),[]);return p.createElement(c.Z,{sx:{...A,position:"relative"}},p.createElement(i.Z,{open:!!R,anchorEl:R,onClose:N},p.createElement(v.Z,{"data-dim":"1920x1080",onClick:b},"Render HD"),p.createElement(v.Z,{"data-dim":"3840x2160",onClick:b},"Render 4K"),p.createElement(s.ZP,null,p.createElement(l.Z,null,"Res Scale ")," ",p.createElement(m.Z,{value:D,onChange:A=>{y(void 0),S(+A.target.value)},size:"small"},k.map((A=>p.createElement(v.Z,{key:A,value:A},A)))))),p.createElement(t.Z,{sx:{position:"absolute",margin:1,right:0}},void 0!==T?p.createElement(C.Z,{variant:"determinate",value:100*T}):p.createElement(a.Z,{size:"small",onClick:L},p.createElement(o.Z,null))),p.createElement(t.Z,{sx:{position:"absolute",margin:1,left:0}},g),p.createElement(r.Z,{component:w,Renderer:f,animate:n,state:e,rendererRef:h,onFps:x,resolutionScale:D,focusable:d,sx:{width:"100%",height:"100%"}}))}const w=({Renderer:A,onFps:n,animate:e,state:o,rendererRef:t,focusable:c=!1,resolutionScale:r})=>{const C=(0,p.useRef)(null),a=(0,p.useRef)();(0,p.useEffect)((()=>{if(C.current){const e=new A(C.current,{onFps:n,resolutionScale:r});return a.current=e,e.start(),t&&(t.current=e),()=>e.destroy()}}),[A,n,r,t]);const s=(0,f.Z)();return(0,p.useEffect)((()=>{a.current&&Object.assign(a.current.dyn,{colorBackground:d.iv(s.palette.background.default).gl(),colorPrimary:d.iv(s.palette.primary.main).gl(),colorSecondary:d.iv(s.palette.secondary.main).gl()})}),[a.current,s.palette]),(0,p.useEffect)((()=>{a.current&&(a.current.animate=e)}),[a.current,e]),(0,p.useEffect)((()=>{a.current&&Object.assign(a.current.dyn,o)}),[a.current,o]),p.createElement("canvas",{ref:C,style:{width:"100%",height:"100%"}})};class T{__init(){this.mousePos=[-1,-1]}__init2(){this.dyn={}}__init3(){this.animate=!0}__init4(){this.stop=()=>{}}constructor(A,n,{onFps:e,resolutionScale:o=window.devicePixelRatio}){this.fragShader=A,this.canvas=n,T.prototype.__init.call(this),T.prototype.__init2.call(this),T.prototype.__init3.call(this),T.prototype.__init4.call(this),T.prototype.__init5.call(this);const t=g.ZG.create({canvas:n,alpha:!0,premultipliedAlpha:!0});function c(){t.canvas.width=t.canvas.clientWidth*o,t.canvas.height=t.canvas.clientHeight*o,t.viewport(0,0,t.canvas.width,t.canvas.height)}this.gl=t,console.log("resolutionScale",o),this.resolutionScale=o,0!==this.canvas.clientWidth&&(c(),t.canvas.addEventListener("resize",c)),t.canvas.addEventListener("mouseleave",(A=>{this.mousePos=[-1,-1]})),t.canvas.addEventListener("mousemove",(A=>{const n=A.currentTarget,{width:e,height:o}=n.getBoundingClientRect();this.mousePos=[n.width*(A.offsetX/e),n.height*(1-A.offsetY/o)]})),this.planeMesh=g.Kj.plane({startX:-1,startY:-1,width:2,height:2}),this.planeMesh.compile(t),this.fpsController=e&&new x.q(e),this.gl.makeCurrent(),this.updateShader()}updateShader(){this.buildShader(e(34).Z,this.fragShader())}__init5(){this.buildShader=function(A){let n,e=[];return function(...o){return(e.length!==o.length||e.some(((A,n)=>A!==o[n])))&&(e=o,n=A(...o)),n}}(((A,n)=>{let e;try{let o;"string"==typeof n?o=n:(o=n.default,e=n.sourceMap),console.log("building shader"),this.shader=g.ex.create(A,o,this.gl)}catch(A){if(console.clear(),console.error(e),e){const n=new h.SourceMapConsumer(e),o=A.message.replace(/ERROR: 0:(\d+)/,((A,e)=>{const o=n.originalPositionFor({line:+e,column:0});return console.log("originalPosition",o),"ERROR "+o.source+":"+o.line+":"+o.column}));A.message=o}if(!this.shader)throw A}}))}start(){this.stop=this.gl.animate(this.render.bind(this))}render(A){console.log("render",this.resolutionScale),this.gl.makeCurrent(),this.updateShader(),R([this,"access",A=>A.fpsController,"optionalAccess",A=>A.tick,"call",n=>n(A)]),this.shader&&this.shader.uniforms({iResolution:[this.gl.canvas.width,this.gl.canvas.height],iMouse:this.mousePos,iTime:this.animate?A/1e3:0}).uniforms(this.dyn).uniforms(this.uniforms()).draw(this.planeMesh)}destroy(){console.log("destroy"),this.stop()}async renderImage([A,n],e){R([e,"optionalCall",A=>A(0)]),await(0,u.Z)(10);const o=document.createElement("canvas");o.width=A,o.height=n,console.log(this.constructor);const t=new this.constructor(o,{resolutionScale:4});Object.assign(t.dyn,this.dyn);const c=256,r=t.gl;r.enable(r.SCISSOR_TEST);let C=0;for(let o=0;o<A;o+=c)for(let a=0;a<n;a+=c){const s=Math.min(c,A-o),l=Math.min(c,n-a);r.scissor(o,a,s,l),t.render(0),await(0,u.Z)(0),C+=s*l,R([e,"optionalCall",e=>e(C/(A*n))])}return new Promise(((A,n)=>o.toBlob((e=>e?A(e):n("error creating png from canvas")),"png")))}uniforms(){return{}}}},34:(A,n,e)=>{"use strict";e.d(n,{Z:()=>o});const o="#version 300 es\nprecision highp float;\n\nin vec4 ts_Vertex;\nin vec2 ts_TexCoord;\nout vec2 coord;\nvoid main() {\n  gl_Position = ts_Vertex;\n  coord = ts_TexCoord;\n}\n"},1105:(A,n,e)=>{"use strict";e.r(n),e.d(n,{default:()=>o,sourceMap:()=>t});const o="#version 300 es\nprecision highp float;\n\n// START ../common/banded.glsl\nfloat banded(float bandCount, float t) {\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\n}\nfloat banded(int bandCount, float t) {\n  return banded(float(bandCount), t);\n}\n\n// #pragma glslify: export(banded)\n\n\n// END ../common/banded.glsl\n// START ../common/between.glsl\nbool between(float min, float max, float value) {\n  return min <= value && value <= max;\n}\n\n// #pragma glslify: export(between)\n\n\n// END ../common/between.glsl\n// START ../common/constants.glsl\nconst float SQRT1_2 = 0.7071067811865476;\nconst float SQRT1_3 = 0.57735026919;\nconst float SQRT2 = 1.4142135623730951;\nconst float SQRT3 = 1.732050807568877;\n// sqrt(3)/2 = sin(60*)\nconst float SQRT3_2 = 0.86602540378;\nconst float GOLDEN_RATIO = 1.61803398875;\nconst float PI = 3.141592653589793;\nconst float TAU = 6.28318530718;\n/**\n * One degree in radians. Use like `sin(30 * DEG)`.\n */\nconst float DEGREE = 0.017453292519943295;\n\n// END ../common/constants.glsl\n// START ../common/complex.glsl\n// START ./polar.glsl\n// START ../common/fromPolar.glsl\n// START ./unmix.glsl\nfloat unmix(float a, float b, float value) {\n  return (value - a) / (b - a);\n}\n\n// #pragma glslify: export(unmix)\n\n\n// END ./unmix.glsl\n\nvec3 fromPolar(float radius, float phi, float z) {\n  return vec3(radius * cos(phi), radius * sin(phi), z);\n}\n\nvec2 fromPolar(float radius, float phi) {\n  return vec2(radius * cos(phi), radius * sin(phi));\n}\n\nvec2 fromPolar(vec2 polar) {\n  return fromPolar(polar.x, polar.y);\n}\n\n// #pragma glslify: export(fromPolar)\n\n\n// END ../common/fromPolar.glsl\n// START ../common/toPolar.glsl\n\nvec2 toPolar(vec2 xy) {\n  return vec2(length(xy), atan(xy.y, xy.x));\n}\n\nmat2 toPolarDerivate(vec2 xy) {\n  return mat2(xy.x * xy.x, xy.y * xy.y, -xy.y, xy.x) / dot(xy, xy);\n}\n\n// #pragma glslify: export(toPolar)\n\n\n// END ../common/toPolar.glsl\n\n// END ./polar.glsl\n\nvec2 complexConj(vec2 z) {\n  return vec2(z.x, -z.y);\n}\n\nvec2 complexMul(vec2 a, vec2 b) {\n  return vec2(a.x * b.x - a.y * b.y, a.y * b.x + a.x * b.y);\n}\n\nvec2 complexDiv(vec2 a, vec2 b) {\n  vec2 bConj = vec2(b.x, -b.y);\n  float divisor = complexMul(b, bConj).x;\n  return complexMul(a, bConj) / divisor;\n}\n\n// return e^z\nvec2 complexPow(vec2 z) {\n  // e^(re + i * im)\n  // = e^re * e^(i * im)\n  return fromPolar(exp(z.x), z.y);\n}\n\n// return w^z\nvec2 complexPow(vec2 w, float z) {\n  // w = r * e ^ (i * phi)\n  // ln(w) = ln(r) + i * phi\n  // w^z = e^(z * log(w)) = e^(z * (ln(r) + i * (phi))\n  vec2 wPolar = toPolar(w);\n  vec2 eExp = z * vec2(log(wPolar.x), wPolar.y);\n  return complexPow(eExp);\n}\n\n// END ../common/complex.glsl\n// START ../common/colors.glsl\nconst vec3 INDIAN_RED = vec3(0.804, 0.361, 0.361);\nconst vec3 LIGHT_CORAL = vec3(0.941, 0.502, 0.502);\nconst vec3 SALMON = vec3(0.98, 0.502, 0.447);\nconst vec3 DARK_SALMON = vec3(0.914, 0.588, 0.478);\nconst vec3 LIGHT_SALMON = vec3(1.0, 0.627, 0.478);\nconst vec3 CRIMSON = vec3(0.863, 0.078, 0.235);\nconst vec3 RED = vec3(1.0, 0.0, 0.0);\nconst vec3 FIRE_BRICK = vec3(0.698, 0.133, 0.133);\nconst vec3 DARK_RED = vec3(0.545, 0.0, 0.0);\nconst vec3 PINK = vec3(1.0, 0.753, 0.796);\nconst vec3 LIGHT_PINK = vec3(1.0, 0.714, 0.757);\nconst vec3 HOT_PINK = vec3(1.0, 0.412, 0.706);\nconst vec3 DEEP_PINK = vec3(1.0, 0.078, 0.576);\nconst vec3 MEDIUM_VIOLET_RED = vec3(0.78, 0.082, 0.522);\nconst vec3 PALE_VIOLET_RED = vec3(0.859, 0.439, 0.576);\nconst vec3 CORAL = vec3(1.0, 0.498, 0.314);\nconst vec3 TOMATO = vec3(1.0, 0.388, 0.278);\nconst vec3 ORANGE_RED = vec3(1.0, 0.271, 0.0);\nconst vec3 DARK_ORANGE = vec3(1.0, 0.549, 0.0);\nconst vec3 ORANGE = vec3(1.0, 0.647, 0.0);\nconst vec3 GOLD = vec3(1.0, 0.843, 0.0);\nconst vec3 YELLOW = vec3(1.0, 1.0, 0.0);\nconst vec3 LIGHT_YELLOW = vec3(1.0, 1.0, 0.878);\nconst vec3 LEMON_CHION = vec3(1.0, 0.98, 0.804);\nconst vec3 LIGHT_GOLDENROD_YELLOW = vec3(0.98, 0.98, 0.824);\nconst vec3 PAPAYA_WHIP = vec3(1.0, 0.937, 0.835);\nconst vec3 MOCCASIN = vec3(1.0, 0.894, 0.71);\nconst vec3 PEACH_PU = vec3(1.0, 0.855, 0.725);\nconst vec3 PALE_GOLDENROD = vec3(0.933, 0.91, 0.667);\nconst vec3 KHAKI = vec3(0.941, 0.902, 0.549);\nconst vec3 DARK_KHAKI = vec3(0.741, 0.718, 0.42);\nconst vec3 LAVENDER = vec3(0.902, 0.902, 0.98);\nconst vec3 THISTLE = vec3(0.847, 0.749, 0.847);\nconst vec3 PLUM = vec3(0.867, 0.627, 0.867);\nconst vec3 VIOLET = vec3(0.933, 0.51, 0.933);\nconst vec3 ORCHID = vec3(0.855, 0.439, 0.839);\nconst vec3 FUCHSIA = vec3(1.0, 0.0, 1.0);\nconst vec3 MAGENTA = vec3(1.0, 0.0, 1.0);\nconst vec3 MEDIUM_ORCHID = vec3(0.729, 0.333, 0.827);\nconst vec3 MEDIUM_PURPLE = vec3(0.576, 0.439, 0.859);\nconst vec3 BLUE_VIOLET = vec3(0.541, 0.169, 0.886);\nconst vec3 DARK_VIOLET = vec3(0.58, 0.0, 0.827);\nconst vec3 DARK_ORCHID = vec3(0.6, 0.196, 0.8);\nconst vec3 DARK_MAGENTA = vec3(0.545, 0.0, 0.545);\nconst vec3 PURPLE = vec3(0.502, 0.0, 0.502);\nconst vec3 INDIGO = vec3(0.294, 0.0, 0.51);\nconst vec3 SLATE_BLUE = vec3(0.416, 0.353, 0.804);\nconst vec3 DARK_SLATE_BLUE = vec3(0.282, 0.239, 0.545);\nconst vec3 GREEN_YELLOW = vec3(0.678, 1.0, 0.184);\nconst vec3 CHARTREUSE = vec3(0.498, 1.0, 0.0);\nconst vec3 LAWN_GREEN = vec3(0.486, 0.988, 0.0);\nconst vec3 LIME = vec3(0.0, 1.0, 0.0);\nconst vec3 LIME_GREEN = vec3(0.196, 0.804, 0.196);\nconst vec3 PALE_GREEN = vec3(0.596, 0.984, 0.596);\nconst vec3 LIGHT_GREEN = vec3(0.565, 0.933, 0.565);\nconst vec3 MEDIUM_SPRING_GREEN = vec3(0.0, 0.98, 0.604);\nconst vec3 SPRING_GREEN = vec3(0.0, 1.0, 0.498);\nconst vec3 MEDIUM_SEA_GREEN = vec3(0.235, 0.702, 0.443);\nconst vec3 SEA_GREEN = vec3(0.18, 0.545, 0.341);\nconst vec3 FOREST_GREEN = vec3(0.133, 0.545, 0.133);\nconst vec3 GREEN = vec3(0.0, 0.502, 0.0);\nconst vec3 DARK_GREEN = vec3(0.0, 0.392, 0.0);\nconst vec3 YELLOW_GREEN = vec3(0.604, 0.804, 0.196);\nconst vec3 OLIVE_DRAB = vec3(0.42, 0.557, 0.137);\nconst vec3 OLIVE = vec3(0.502, 0.502, 0.0);\nconst vec3 DARK_OLIVE_GREEN = vec3(0.333, 0.42, 0.184);\nconst vec3 MEDIUM_AQUAMARINE = vec3(0.4, 0.804, 0.667);\nconst vec3 DARK_SEA_GREEN = vec3(0.561, 0.737, 0.561);\nconst vec3 LIGHT_SEA_GREEN = vec3(0.125, 0.698, 0.667);\nconst vec3 DARK_CYAN = vec3(0.0, 0.545, 0.545);\nconst vec3 TEAL = vec3(0.0, 0.502, 0.502);\nconst vec3 AQUA = vec3(0.0, 1.0, 1.0);\nconst vec3 CYAN = vec3(0.0, 1.0, 1.0);\nconst vec3 LIGHT_CYAN = vec3(0.878, 1.0, 1.0);\nconst vec3 PALE_TURQUOISE = vec3(0.686, 0.933, 0.933);\nconst vec3 AQUAMARINE = vec3(0.498, 1.0, 0.831);\nconst vec3 TURQUOISE = vec3(0.251, 0.878, 0.816);\nconst vec3 MEDIUM_TURQUOISE = vec3(0.282, 0.82, 0.8);\nconst vec3 DARK_TURQUOISE = vec3(0.0, 0.808, 0.82);\nconst vec3 CADET_BLUE = vec3(0.373, 0.62, 0.627);\nconst vec3 STEEL_BLUE = vec3(0.275, 0.51, 0.706);\nconst vec3 LIGHT_STEEL_BLUE = vec3(0.69, 0.769, 0.871);\nconst vec3 POWDER_BLUE = vec3(0.69, 0.878, 0.902);\nconst vec3 LIGHT_BLUE = vec3(0.678, 0.847, 0.902);\nconst vec3 SKY_BLUE = vec3(0.529, 0.808, 0.922);\nconst vec3 LIGHT_SKY_BLUE = vec3(0.529, 0.808, 0.98);\nconst vec3 DEEP_SKY_BLUE = vec3(0.0, 0.749, 1.0);\nconst vec3 DODGER_BLUE = vec3(0.118, 0.565, 1.0);\nconst vec3 CORNLOWER_BLUE = vec3(0.392, 0.584, 0.929);\nconst vec3 MEDIUM_SLATE_BLUE = vec3(0.482, 0.408, 0.933);\nconst vec3 ROYAL_BLUE = vec3(0.255, 0.412, 0.882);\nconst vec3 BLUE = vec3(0.0, 0.0, 1.0);\nconst vec3 MEDIUM_BLUE = vec3(0.0, 0.0, 0.804);\nconst vec3 DARK_BLUE = vec3(0.0, 0.0, 0.545);\nconst vec3 NAVY = vec3(0.0, 0.0, 0.502);\nconst vec3 MIDNIGHT_BLUE = vec3(0.098, 0.098, 0.439);\nconst vec3 CORNSILK = vec3(1.0, 0.973, 0.863);\nconst vec3 BLANCHED_ALMOND = vec3(1.0, 0.922, 0.804);\nconst vec3 BISQUE = vec3(1.0, 0.894, 0.769);\nconst vec3 NAVAJO_WHITE = vec3(1.0, 0.871, 0.678);\nconst vec3 WHEAT = vec3(0.961, 0.871, 0.702);\nconst vec3 BURLY_WOOD = vec3(0.871, 0.722, 0.529);\nconst vec3 TAN = vec3(0.824, 0.706, 0.549);\nconst vec3 ROSY_BROWN = vec3(0.737, 0.561, 0.561);\nconst vec3 SANDY_BROWN = vec3(0.957, 0.643, 0.376);\nconst vec3 GOLDENROD = vec3(0.855, 0.647, 0.125);\nconst vec3 DARK_GOLDENROD = vec3(0.722, 0.525, 0.043);\nconst vec3 PERU = vec3(0.804, 0.522, 0.247);\nconst vec3 CHOCOLATE = vec3(0.824, 0.412, 0.118);\nconst vec3 SADDLE_BROWN = vec3(0.545, 0.271, 0.075);\nconst vec3 SIENNA = vec3(0.627, 0.322, 0.176);\nconst vec3 BROWN = vec3(0.647, 0.165, 0.165);\nconst vec3 MAROON = vec3(0.502, 0.0, 0.0);\nconst vec3 WHITE = vec3(1.0, 1.0, 1.0);\nconst vec3 SNOW = vec3(1.0, 0.98, 0.98);\nconst vec3 HONEYDEW = vec3(0.941, 1.0, 0.941);\nconst vec3 MINT_CREAM = vec3(0.961, 1.0, 0.98);\nconst vec3 AZURE = vec3(0.941, 1.0, 1.0);\nconst vec3 ALICE_BLUE = vec3(0.941, 0.973, 1.0);\nconst vec3 GHOST_WHITE = vec3(0.973, 0.973, 1.0);\nconst vec3 WHITE_SMOKE = vec3(0.961, 0.961, 0.961);\nconst vec3 SEASHELL = vec3(1.0, 0.961, 0.933);\nconst vec3 BEIGE = vec3(0.961, 0.961, 0.863);\nconst vec3 OLD_LACE = vec3(0.992, 0.961, 0.902);\nconst vec3 FLORAL_WHITE = vec3(1.0, 0.98, 0.941);\nconst vec3 IVORY = vec3(1.0, 1.0, 0.941);\nconst vec3 ANTIQUE_WHITE = vec3(0.98, 0.922, 0.843);\nconst vec3 LINEN = vec3(0.98, 0.941, 0.902);\nconst vec3 LAVENDER_BLUSH = vec3(1.0, 0.941, 0.961);\nconst vec3 MISTY_ROSE = vec3(1.0, 0.894, 0.882);\nconst vec3 GAINSBORO = vec3(0.863, 0.863, 0.863);\nconst vec3 LIGHT_GREY = vec3(0.827, 0.827, 0.827);\nconst vec3 SILVER = vec3(0.753, 0.753, 0.753);\nconst vec3 DARK_GRAY = vec3(0.663, 0.663, 0.663);\nconst vec3 GRAY = vec3(0.502, 0.502, 0.502);\nconst vec3 DIM_GRAY = vec3(0.412, 0.412, 0.412);\nconst vec3 LIGHT_SLATE_GRAY = vec3(0.467, 0.533, 0.6);\nconst vec3 SLATE_GRAY = vec3(0.439, 0.502, 0.565);\nconst vec3 DARK_SLATE_GRAY = vec3(0.184, 0.31, 0.31);\nconst vec3 BLACK = vec3(0.0, 0.0, 0.0);\n\n// END ../common/colors.glsl\n// START ../common/hexFns.glsl\n// START ./max3.glsl\nfloat max3(float a, float b, float c) {\n  return max(a, max(b, c));\n}\nfloat max3(vec3 v) {\n  return max(v.x, max(v.y, v.z));\n}\n\n// #pragma glslify: export(max3)\n\n\n// END ./max3.glsl\n\nvec3 hexRound(vec3 hex) {\n  vec3 r = floor(hex + 0.5);\n  vec3 diff = abs(r - hex);\n\n  if (diff.x > diff.y && diff.x > diff.z) {\n    r.x = -(r.y + r.z);\n  } else if (diff.y > diff.z) {\n    r.y = -(r.x + r.z);\n  } else {\n    r.z = -(r.x + r.y);\n  }\n\n  return r;\n}\nvec2 hex2Ra(vec3 hex) {\n  float y = hex.t * SQRT3_2;\n  float x = hex.s + hex.t / 2.0;\n  return vec2(x, y);\n}\n\nfloat hexSdf(vec3 hex) {\n  return max3(abs(hex.yzx + hex.zxy / 2.0));\n}\nvec3 ra2Hex(vec2 xy) {\n  float hex_t = xy.y / SQRT3_2;\n  float hex_s = xy.x - hex_t / 2.0;\n  return vec3(hex_s, hex_t, -(hex_s + hex_t));\n}\n\n// END ../common/hexFns.glsl\n// START ../common/matrices.glsl\n\nmat2 rot2(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat2(c, s, -s, c);\n}\nmat3 rotX(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\n}\nmat3 rotY(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\n}\nmat3 rotZ(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\n}\n/**\n * Returns a matrix that puts the camera at the eye point `ex, ey, ez` looking\n * toward the center point `cx, cy, cz` with an up direction of `ux, uy, uz`.\n * This emulates the OpenGL function `gluLookAt()`.\n */\nmat4 lookAt(vec3 eye, vec3 focus, vec3 up) {\n  vec3 f = normalize(eye - focus);\n  vec3 s = normalize(cross(up, f));\n  vec3 t = normalize(cross(f, s));\n\n  return mat4(\n    vec4(s.x, t.x, f.x, 0.0),\n    vec4(s.y, t.y, f.y, 0.0),\n    vec4(s.z, t.z, f.z, 0.0),\n    vec4(-dot(s, eye), -dot(t, eye), -dot(f, eye), 1)\n  );\n}\n\n// the OpenGL function `glFrustum()`.\nmat4 frustum(\n  float left,\n  float right,\n  float bottom,\n  float top,\n  float near,\n  float far\n) {\n  return mat4(\n    vec4(2.0 * near / (right - left), 0.0, 0.0, 0.0),\n    vec4(0, 2.0 * near / (top - bottom), 0.0, 0.0),\n    vec4(\n      (right + left) / (right - left),\n      (top + bottom) / (top - bottom),\n      -(far + near) / (far - near),\n      -1\n    ),\n    vec4(0.0, 0.0, -2.0 * far * near / (far - near), 0.0)\n  );\n}\n\nmat4 perspective(float fovDegrees, float aspect, float near, float far) {\n  float y = tan(fovDegrees * DEGREE / 2.0) * near;\n  float x = y * aspect;\n  return frustum(-x, x, -y, y, near, far);\n}\nmat4 ortho(\n  float left,\n  float right,\n  float bottom,\n  float top,\n  float near,\n  float far\n) {\n  return mat4(\n    vec4(2.0 / (right - left), 0.0, 0.0, 0.0),\n    vec4(0.0, 2.0 / (top - bottom), 0.0, 0.0),\n    vec4(0.0, 0.0, -2.0 / (far - near), 0.0),\n    vec4(\n      -(right + left) / (right - left),\n      -(top + bottom) / (top - bottom),\n      -(far + near) / (far - near),\n      1.0\n    )\n  );\n}\n\n// END ../common/matrices.glsl\n// START ../common/remix.glsl\n\nfloat remix(float fromA, float fromB, float toA, float toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\nvec4 remix(float fromA, float fromB, vec4 toA, vec4 toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\n// #pragma glslify: export(remix)\n\n\n// END ../common/remix.glsl\n// START ../common/simplex2DTexture.glsl\n// START ./triFns.glsl\n\n// (x, y) -> (u, v, R)\n// where u is horizontal, v is south-west to north-east\n// and R is wether the it is in the right triangle\nvec3 xy2tri(vec2 xy) {\n  float v = xy.y / SQRT3_2;\n  float u = xy.x - v / 2.0;\n  float R = float(\n    mod(u + v, 2.0) > 1.0 != (mod(floor(u) + floor(v), 2.0) == 1.0)\n  );\n  return vec3(u, v, R);\n}\nvec3 triCenter(vec3 uvR) {\n  vec3 base = floor(uvR);\n  vec2 centerOffset = mix(vec2(1.0 / 3.0), vec2(2.0 / 3.0), uvR.z);\n  return base + vec3(centerOffset, 0.0);\n}\nvec2 tri2xy(vec3 uvR) {\n  float y = uvR.t * SQRT3_2;\n  float x = uvR.s + uvR.t / 2.0;\n  return vec2(x, y);\n}\nvec2 tri2xy(vec2 uv) {\n  float y = uv.t * SQRT3_2;\n  float x = uv.s + uv.t / 2.0;\n  return vec2(x, y);\n}\nfloat triSdf(vec2 uv) {\n  vec3 hex = vec3(uv.x, uv.y, -uv.x - uv.y);\n  return max3(hex);\n}\n\n// END ./triFns.glsl\n\nuniform sampler2D gradients;\n\n/* Create random direction vector\n */\nvec2 randomGradient(vec2 i) {\n  // Random float. No precomputed gradients mean this works for any number of grid coordinates\n  float random =\n    2920.0 *\n    sin(float(i.x) * 2.1942 + float(i.y) * 1.71324 + 8.912) *\n    cos(float(i.x) * 2.3157 * float(i.y) * 2.17832 + 9.758);\n  //    random = (i.x + 1667.) * (i.x + 2083.) * (i.y + 2659.) * (i.y * 50.77 + .3769);\n  //    random = sin(SQRT2 * i.x) + cos(GOLDEN_RATIO * i.y) + tan((i.x + i.y) * SQRT3);\n  return vec2(cos(random), sin(random));\n}\n\nfloat dotGridGradient2(vec2 cell, vec2 pos) {\n  vec2 xy_d = cell - pos;\n  if (length(xy_d) > 0.45) return -0.0;\n  float r = 1.0;\n  float part = pow(max(0.0, 1.0 - dot(xy_d, xy_d)), 4.0);\n  //    vec2 gradient = texelFetch(gradients, ivec2(cell), 0).xy;\n  vec2 gradient = randomGradient(cell);\n  return part * dot(gradient, xy_d);\n}\n\n// resulting range is [-0.68, 0.68]. Use unmix to normalize if necessary.\nfloat simplex2D(vec2 xy) {\n  vec3 uvR = xy2tri(xy);\n  vec2 baseUV = floor(uvR.xy);\n\n  float a = dotGridGradient2(tri2xy(baseUV), xy);\n  float b = dotGridGradient2(tri2xy(baseUV + vec2(1, 0)), xy);\n  float c = dotGridGradient2(tri2xy(baseUV + vec2(0, 1)), xy);\n  float d = dotGridGradient2(tri2xy(baseUV + vec2(1, 1)), xy);\n\n  return b + c + mix(a, d, uvR.z);\n}\n\n// #pragma glslify: export(simplex2D)\n\n\n// END ../common/simplex2DTexture.glsl\n// START ../common/visualize.glsl\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\n  float isLow = float(t < 0.0);\n  float isHigh = float(t > 1.0);\n  float isMid = 1.0 - isLow - isHigh;\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\n}\n\nvec4 visualize(float t) {\n  const vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\n  const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\n  return visualize(BLUE, RED, t);\n}\n\n// #pragma glslify: export(visualize)\n\n\n// END ../common/visualize.glsl\n// START ../common/waves.glsl\nfloat waves(vec4 color, vec2 position, vec2 direction, float highResTimeStamp) {\n  return sin(\n    dot(position, direction / pow(length(direction), 2.0)) +\n      float(highResTimeStamp) / 200.0\n  );\n}\n\n// #pragma glslify: export(waves)\n\n\n// END ../common/waves.glsl\n\nuniform sampler2D texture;\nuniform vec4 colorPrimary;\nuniform vec4 colorSecondary;\nuniform vec4 colorBackground;\nuniform float a;\nuniform float b;\nuniform int bandCount;\nuniform float iTime;\nuniform vec2 iMouse;\nuniform vec2 iResolution;\nin vec2 coord;\nout vec4 fragColor;\n\nvec2 f(vec2 z) {\n  //  const vec2 c = vec2(-0.4, 0.6);\n  //  vec2 c = fromPolar(0.7885, (a + b / 50.0) * 6.0);\n  //  vec2 c = fromPolar(0.7885, iTime / 2.0);\n  //  vec2 c = fromPolar(0.7885, 4.0);\n  vec2 c = 0.01 * (iMouse - 0.5 * iResolution);\n  return complexMul(z, z) + c;\n}\n\nvec2 complexSqr(vec2 z) {\n  return complexMul(z, z);\n}\nvec2 f2(vec2 z) {\n  const float n = 8.0;\n  return complexDiv(\n    1.0 + (n - 1.0) * complexPow(z, n),\n    n * complexPow(z, n - 1.0)\n  );\n}\n\nvec2 f3(vec2 z) {\n  vec2 z2 = complexMul(z, z);\n  vec2 z3 = complexMul(z2, z);\n  return complexDiv(vec2(1.0, 0.0) + 2.0 * z3, 3.0 * z2);\n}\nvec2 flf(vec2 z) {\n  vec2 z2 = complexMul(z, z);\n  vec2 z3 = complexMul(z2, z);\n  return complexDiv(vec2(1.0, 0.0) - z3 / 6.0, complexSqr(z - z2 / 2.0)) +\n  vec2(-a, b);\n}\n\n// START ../common/juliaIteration.glsl\n#define JULIA_ITERATION(NAME, F, R, MAXIT)                                     \\\n  vec3 NAME(vec2 start) {                                                      \\\n    const float rSqr = (R) * (R);                                              \\\n    vec2 p = start;                                                            \\\n    for (uint i = uint(0); i < (MAXIT); i++) {                                 \\\n      p = F(p);                                                                \\\n      if (dot(p, p) > rSqr) {                                                  \\\n        return vec3(p, float(i));                                              \\\n      }                                                                        \\\n    }                                                                          \\\n    return vec3(p, float(MAXIT));                                              \\\n  }\n\n// END ../common/juliaIteration.glsl\n\nJULIA_ITERATION(julia, f, 2.0, 20u)\n\nvoid main() {\n  vec2 fragCoord = (coord - 0.5) * iResolution * 0.005;\n  vec3 res = julia(fragCoord);\n  float f = res.z / 20.0;\n\n  //    fragColor = mix(colorBackground, colorPrimary, banded(bandCount, unmix(-.35, .35, f2)));\n  fragColor = mix(\n    colorBackground,\n    colorPrimary,\n    min(banded(bandCount, f), 1.0)\n  );\n  fragColor = vec4(res, 1.0);\n  //    fragColor = visualize(f);\n  //    fragColor = visualize(float(i == 1000u));\n}\n",t={version:3,sources:["/home/runner/work/workshop/workshop/src/noises/julia.frag","/home/runner/work/workshop/workshop/src/common/banded.glsl","/home/runner/work/workshop/workshop/src/common/between.glsl","/home/runner/work/workshop/workshop/src/common/constants.glsl","/home/runner/work/workshop/workshop/src/common/unmix.glsl","/home/runner/work/workshop/workshop/src/common/fromPolar.glsl","/home/runner/work/workshop/workshop/src/common/toPolar.glsl","/home/runner/work/workshop/workshop/src/common/polar.glsl","/home/runner/work/workshop/workshop/src/common/complex.glsl","/home/runner/work/workshop/workshop/src/common/colors.glsl","/home/runner/work/workshop/workshop/src/common/max3.glsl","/home/runner/work/workshop/workshop/src/common/hexFns.glsl","/home/runner/work/workshop/workshop/src/common/matrices.glsl","/home/runner/work/workshop/workshop/src/common/remix.glsl","/home/runner/work/workshop/workshop/src/common/triFns.glsl","/home/runner/work/workshop/workshop/src/common/simplex2DTexture.glsl","/home/runner/work/workshop/workshop/src/common/visualize.glsl","/home/runner/work/workshop/workshop/src/common/waves.glsl","/home/runner/work/workshop/workshop/src/common/juliaIteration.glsl"],names:[],mappings:"AAAA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC5IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AjBOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AkB7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AlBmDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"}},728:(A,n,e)=>{"use strict";e.r(n),e.d(n,{default:()=>o,sourceMap:()=>t});const o='#version 300 es\n\nprecision highp float;\n\n// START ../common/constants.glsl\nconst float SQRT1_2 = 0.7071067811865476;\nconst float SQRT1_3 = 0.57735026919;\nconst float SQRT2 = 1.4142135623730951;\nconst float SQRT3 = 1.732050807568877;\n// sqrt(3)/2 = sin(60*)\nconst float SQRT3_2 = 0.86602540378;\nconst float GOLDEN_RATIO = 1.61803398875;\nconst float PI = 3.141592653589793;\nconst float TAU = 6.28318530718;\n/**\n * One degree in radians. Use like `sin(30 * DEG)`.\n */\nconst float DEGREE = 0.017453292519943295;\n\n// END ../common/constants.glsl\n// START ../common/fromPolar.glsl\n// START ./unmix.glsl\nfloat unmix(float a, float b, float value) {\n  return (value - a) / (b - a);\n}\n\n// #pragma glslify: export(unmix)\n\n\n// END ./unmix.glsl\n\nvec3 fromPolar(float radius, float phi, float z) {\n  return vec3(radius * cos(phi), radius * sin(phi), z);\n}\n\nvec2 fromPolar(float radius, float phi) {\n  return vec2(radius * cos(phi), radius * sin(phi));\n}\n\nvec2 fromPolar(vec2 polar) {\n  return fromPolar(polar.x, polar.y);\n}\n\n// #pragma glslify: export(fromPolar)\n\n\n// END ../common/fromPolar.glsl\n// START ../common/linstep.glsl\nfloat linstep(float a, float b, float t) {\n  return clamp((t - a) / (b - a), 0.0, 1.0);\n}\nvec2 linstep(vec2 a, vec2 b, float t) {\n  return clamp((t - a) / (b - a), 0.0, 1.0);\n}\nvec3 linstep(vec3 a, vec3 b, float t) {\n  return clamp((t - a) / (b - a), 0.0, 1.0);\n}\nvec4 linstep(vec4 a, vec4 b, float t) {\n  return clamp((t - a) / (b - a), 0.0, 1.0);\n}\n\n// END ../common/linstep.glsl\n// START ../common/matrices.glsl\n\nmat2 rot2(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat2(c, s, -s, c);\n}\nmat3 rotX(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\n}\nmat3 rotY(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\n}\nmat3 rotZ(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\n}\n/**\n * Returns a matrix that puts the camera at the eye point `ex, ey, ez` looking\n * toward the center point `cx, cy, cz` with an up direction of `ux, uy, uz`.\n * This emulates the OpenGL function `gluLookAt()`.\n */\nmat4 lookAt(vec3 eye, vec3 focus, vec3 up) {\n  vec3 f = normalize(eye - focus);\n  vec3 s = normalize(cross(up, f));\n  vec3 t = normalize(cross(f, s));\n\n  return mat4(\n    vec4(s.x, t.x, f.x, 0.0),\n    vec4(s.y, t.y, f.y, 0.0),\n    vec4(s.z, t.z, f.z, 0.0),\n    vec4(-dot(s, eye), -dot(t, eye), -dot(f, eye), 1)\n  );\n}\n\n// the OpenGL function `glFrustum()`.\nmat4 frustum(\n  float left,\n  float right,\n  float bottom,\n  float top,\n  float near,\n  float far\n) {\n  return mat4(\n    vec4(2.0 * near / (right - left), 0.0, 0.0, 0.0),\n    vec4(0, 2.0 * near / (top - bottom), 0.0, 0.0),\n    vec4(\n      (right + left) / (right - left),\n      (top + bottom) / (top - bottom),\n      -(far + near) / (far - near),\n      -1\n    ),\n    vec4(0.0, 0.0, -2.0 * far * near / (far - near), 0.0)\n  );\n}\n\nmat4 perspective(float fovDegrees, float aspect, float near, float far) {\n  float y = tan(fovDegrees * DEGREE / 2.0) * near;\n  float x = y * aspect;\n  return frustum(-x, x, -y, y, near, far);\n}\nmat4 ortho(\n  float left,\n  float right,\n  float bottom,\n  float top,\n  float near,\n  float far\n) {\n  return mat4(\n    vec4(2.0 / (right - left), 0.0, 0.0, 0.0),\n    vec4(0.0, 2.0 / (top - bottom), 0.0, 0.0),\n    vec4(0.0, 0.0, -2.0 / (far - near), 0.0),\n    vec4(\n      -(right + left) / (right - left),\n      -(top + bottom) / (top - bottom),\n      -(far + near) / (far - near),\n      1.0\n    )\n  );\n}\n\n// END ../common/matrices.glsl\n// START ../common/sdf2d/addChamfer.glsl\n\nfloat addChamfer(float d, float a, float b) {\n  // exact variant, but abs is larger when a and b aren\'t perpendicular\n  // which is worse than underestimating, which is what the simple version does.\n  //  vec2 p = vec2(a, b);\n  //  if (p.x < d && p.y < d) {\n  //    p = rot2(0.25 * PI) * p;\n  //    p.y = abs(p.y);\n  //    p.y -= min(p.y, d * SQRT1_2);\n  //    p.x -= d * SQRT1_2;\n  //    //    p -= vec2(SQRT1_2) * clamp(dot(p, vec2(SQRT1_2)), 0.0, d);\n  //    float fillet = -length(p);\n  //    return -sign(p.x) * fillet;\n  //  } else {\n  //  }\n  float tillet = (a + b - d) * SQRT1_2;\n  return min(tillet, min(a, b));\n}\n\n// #pragma glslify: export(addChamfer)\n\n\n// END ../common/sdf2d/addChamfer.glsl\n// START ../common/sdf2d/addFillet.glsl\nfloat addFillet(float r, float a, float b) {\n  if (a < r && b < r) {\n    return r - distance(vec2(a, b), vec2(r));\n  } else {\n    return min(a, b);\n  }\n}\n\n// #pragma glslify: export(addFillet)\n\n\n// END ../common/sdf2d/addFillet.glsl\n// START ../common/sdf2d/sdArc.glsl\n// START ../../common/toPolar.glsl\n\nvec2 toPolar(vec2 xy) {\n  return vec2(length(xy), atan(xy.y, xy.x));\n}\n\nmat2 toPolarDerivate(vec2 xy) {\n  return mat2(xy.x * xy.x, xy.y * xy.y, -xy.y, xy.x) / dot(xy, xy);\n}\n\n// #pragma glslify: export(toPolar)\n\n\n// END ../../common/toPolar.glsl\n\nfloat sdArc(float angle, vec2 p) {\n  vec2 polar = toPolar(p);\n  vec2 closestPolar = vec2(polar.x = 1.0, clamp(polar.y, -angle, angle));\n  vec2 closest = fromPolar(closestPolar);\n  return distance(closest, p);\n}\n\nfloat sdArc(float angle, float radius, float thickness, vec2 p) {\n  return sdArc(angle, p / radius) * radius - 0.5 * thickness;\n}\n\n// #pragma glslify: export(sdArc)\n\n\n// END ../common/sdf2d/sdArc.glsl\n// START ../common/sdf2d/sdArcRect.glsl\n\n/**\n * 2D signed distance function to an arc with square ends. The opening of the\n * arc is on the left (negative X direction). The total spanned angle is\n * `2 * halfAngle`.\n *\n * `radius` is the center radius of the arc.\n *\n * `width.x` is the thickness of the arc.\n *\n * `width.y` is how much the flat end of the arc is extructed. This is a\n * parameter as is it trivial to add with the current implementation. Set to 0\n * to just have a flat-ended arc.\n */\nfloat sdArcRect(float halfAngle, float radius, vec2 width, vec2 p) {\n  // Symmetric across x axis; all points on top.\n  p.y = abs(p.y);\n  // Rotate so that the end of the arc is at the x axis.\n  p = rot2(-halfAngle) * p;\n  if (p.y > 0.0) {\n    // p is "above the end of the arc"; calculate as for sdRectangle.\n    p.x = abs(p.x - radius);\n    p -= 0.5 * width;\n    return length(max(p, 0.0)) + min(0.0, max(p.x, p.y));\n  } else {\n    // Otherwise, the distance is basically just the radial distance to the arc.\n    // For the inside of the sdf, we have to take the end into account.\n    return max(abs(length(p) - radius) - 0.5 * width.x, p.y - 0.5 * width.y);\n  }\n}\n\n// END ../common/sdf2d/sdArcRect.glsl\n// START ../sdfs2d/vizz.glsl\n// START ../common/between.glsl\nbool between(float min, float max, float value) {\n  return min <= value && value <= max;\n}\n\n// #pragma glslify: export(between)\n\n\n// END ../common/between.glsl\n// START ../common/ungamma.glsl\nvec3 ungamma(vec4 col) {\n  return pow(col.rgb, vec3(2.2));\n}\nvec3 ungamma(vec3 col) {\n  return pow(col, vec3(2.2));\n}\n\n// END ../common/ungamma.glsl\n// START ../common/colors.glsl\nconst vec3 INDIAN_RED = vec3(0.804, 0.361, 0.361);\nconst vec3 LIGHT_CORAL = vec3(0.941, 0.502, 0.502);\nconst vec3 SALMON = vec3(0.98, 0.502, 0.447);\nconst vec3 DARK_SALMON = vec3(0.914, 0.588, 0.478);\nconst vec3 LIGHT_SALMON = vec3(1.0, 0.627, 0.478);\nconst vec3 CRIMSON = vec3(0.863, 0.078, 0.235);\nconst vec3 RED = vec3(1.0, 0.0, 0.0);\nconst vec3 FIRE_BRICK = vec3(0.698, 0.133, 0.133);\nconst vec3 DARK_RED = vec3(0.545, 0.0, 0.0);\nconst vec3 PINK = vec3(1.0, 0.753, 0.796);\nconst vec3 LIGHT_PINK = vec3(1.0, 0.714, 0.757);\nconst vec3 HOT_PINK = vec3(1.0, 0.412, 0.706);\nconst vec3 DEEP_PINK = vec3(1.0, 0.078, 0.576);\nconst vec3 MEDIUM_VIOLET_RED = vec3(0.78, 0.082, 0.522);\nconst vec3 PALE_VIOLET_RED = vec3(0.859, 0.439, 0.576);\nconst vec3 CORAL = vec3(1.0, 0.498, 0.314);\nconst vec3 TOMATO = vec3(1.0, 0.388, 0.278);\nconst vec3 ORANGE_RED = vec3(1.0, 0.271, 0.0);\nconst vec3 DARK_ORANGE = vec3(1.0, 0.549, 0.0);\nconst vec3 ORANGE = vec3(1.0, 0.647, 0.0);\nconst vec3 GOLD = vec3(1.0, 0.843, 0.0);\nconst vec3 YELLOW = vec3(1.0, 1.0, 0.0);\nconst vec3 LIGHT_YELLOW = vec3(1.0, 1.0, 0.878);\nconst vec3 LEMON_CHION = vec3(1.0, 0.98, 0.804);\nconst vec3 LIGHT_GOLDENROD_YELLOW = vec3(0.98, 0.98, 0.824);\nconst vec3 PAPAYA_WHIP = vec3(1.0, 0.937, 0.835);\nconst vec3 MOCCASIN = vec3(1.0, 0.894, 0.71);\nconst vec3 PEACH_PU = vec3(1.0, 0.855, 0.725);\nconst vec3 PALE_GOLDENROD = vec3(0.933, 0.91, 0.667);\nconst vec3 KHAKI = vec3(0.941, 0.902, 0.549);\nconst vec3 DARK_KHAKI = vec3(0.741, 0.718, 0.42);\nconst vec3 LAVENDER = vec3(0.902, 0.902, 0.98);\nconst vec3 THISTLE = vec3(0.847, 0.749, 0.847);\nconst vec3 PLUM = vec3(0.867, 0.627, 0.867);\nconst vec3 VIOLET = vec3(0.933, 0.51, 0.933);\nconst vec3 ORCHID = vec3(0.855, 0.439, 0.839);\nconst vec3 FUCHSIA = vec3(1.0, 0.0, 1.0);\nconst vec3 MAGENTA = vec3(1.0, 0.0, 1.0);\nconst vec3 MEDIUM_ORCHID = vec3(0.729, 0.333, 0.827);\nconst vec3 MEDIUM_PURPLE = vec3(0.576, 0.439, 0.859);\nconst vec3 BLUE_VIOLET = vec3(0.541, 0.169, 0.886);\nconst vec3 DARK_VIOLET = vec3(0.58, 0.0, 0.827);\nconst vec3 DARK_ORCHID = vec3(0.6, 0.196, 0.8);\nconst vec3 DARK_MAGENTA = vec3(0.545, 0.0, 0.545);\nconst vec3 PURPLE = vec3(0.502, 0.0, 0.502);\nconst vec3 INDIGO = vec3(0.294, 0.0, 0.51);\nconst vec3 SLATE_BLUE = vec3(0.416, 0.353, 0.804);\nconst vec3 DARK_SLATE_BLUE = vec3(0.282, 0.239, 0.545);\nconst vec3 GREEN_YELLOW = vec3(0.678, 1.0, 0.184);\nconst vec3 CHARTREUSE = vec3(0.498, 1.0, 0.0);\nconst vec3 LAWN_GREEN = vec3(0.486, 0.988, 0.0);\nconst vec3 LIME = vec3(0.0, 1.0, 0.0);\nconst vec3 LIME_GREEN = vec3(0.196, 0.804, 0.196);\nconst vec3 PALE_GREEN = vec3(0.596, 0.984, 0.596);\nconst vec3 LIGHT_GREEN = vec3(0.565, 0.933, 0.565);\nconst vec3 MEDIUM_SPRING_GREEN = vec3(0.0, 0.98, 0.604);\nconst vec3 SPRING_GREEN = vec3(0.0, 1.0, 0.498);\nconst vec3 MEDIUM_SEA_GREEN = vec3(0.235, 0.702, 0.443);\nconst vec3 SEA_GREEN = vec3(0.18, 0.545, 0.341);\nconst vec3 FOREST_GREEN = vec3(0.133, 0.545, 0.133);\nconst vec3 GREEN = vec3(0.0, 0.502, 0.0);\nconst vec3 DARK_GREEN = vec3(0.0, 0.392, 0.0);\nconst vec3 YELLOW_GREEN = vec3(0.604, 0.804, 0.196);\nconst vec3 OLIVE_DRAB = vec3(0.42, 0.557, 0.137);\nconst vec3 OLIVE = vec3(0.502, 0.502, 0.0);\nconst vec3 DARK_OLIVE_GREEN = vec3(0.333, 0.42, 0.184);\nconst vec3 MEDIUM_AQUAMARINE = vec3(0.4, 0.804, 0.667);\nconst vec3 DARK_SEA_GREEN = vec3(0.561, 0.737, 0.561);\nconst vec3 LIGHT_SEA_GREEN = vec3(0.125, 0.698, 0.667);\nconst vec3 DARK_CYAN = vec3(0.0, 0.545, 0.545);\nconst vec3 TEAL = vec3(0.0, 0.502, 0.502);\nconst vec3 AQUA = vec3(0.0, 1.0, 1.0);\nconst vec3 CYAN = vec3(0.0, 1.0, 1.0);\nconst vec3 LIGHT_CYAN = vec3(0.878, 1.0, 1.0);\nconst vec3 PALE_TURQUOISE = vec3(0.686, 0.933, 0.933);\nconst vec3 AQUAMARINE = vec3(0.498, 1.0, 0.831);\nconst vec3 TURQUOISE = vec3(0.251, 0.878, 0.816);\nconst vec3 MEDIUM_TURQUOISE = vec3(0.282, 0.82, 0.8);\nconst vec3 DARK_TURQUOISE = vec3(0.0, 0.808, 0.82);\nconst vec3 CADET_BLUE = vec3(0.373, 0.62, 0.627);\nconst vec3 STEEL_BLUE = vec3(0.275, 0.51, 0.706);\nconst vec3 LIGHT_STEEL_BLUE = vec3(0.69, 0.769, 0.871);\nconst vec3 POWDER_BLUE = vec3(0.69, 0.878, 0.902);\nconst vec3 LIGHT_BLUE = vec3(0.678, 0.847, 0.902);\nconst vec3 SKY_BLUE = vec3(0.529, 0.808, 0.922);\nconst vec3 LIGHT_SKY_BLUE = vec3(0.529, 0.808, 0.98);\nconst vec3 DEEP_SKY_BLUE = vec3(0.0, 0.749, 1.0);\nconst vec3 DODGER_BLUE = vec3(0.118, 0.565, 1.0);\nconst vec3 CORNLOWER_BLUE = vec3(0.392, 0.584, 0.929);\nconst vec3 MEDIUM_SLATE_BLUE = vec3(0.482, 0.408, 0.933);\nconst vec3 ROYAL_BLUE = vec3(0.255, 0.412, 0.882);\nconst vec3 BLUE = vec3(0.0, 0.0, 1.0);\nconst vec3 MEDIUM_BLUE = vec3(0.0, 0.0, 0.804);\nconst vec3 DARK_BLUE = vec3(0.0, 0.0, 0.545);\nconst vec3 NAVY = vec3(0.0, 0.0, 0.502);\nconst vec3 MIDNIGHT_BLUE = vec3(0.098, 0.098, 0.439);\nconst vec3 CORNSILK = vec3(1.0, 0.973, 0.863);\nconst vec3 BLANCHED_ALMOND = vec3(1.0, 0.922, 0.804);\nconst vec3 BISQUE = vec3(1.0, 0.894, 0.769);\nconst vec3 NAVAJO_WHITE = vec3(1.0, 0.871, 0.678);\nconst vec3 WHEAT = vec3(0.961, 0.871, 0.702);\nconst vec3 BURLY_WOOD = vec3(0.871, 0.722, 0.529);\nconst vec3 TAN = vec3(0.824, 0.706, 0.549);\nconst vec3 ROSY_BROWN = vec3(0.737, 0.561, 0.561);\nconst vec3 SANDY_BROWN = vec3(0.957, 0.643, 0.376);\nconst vec3 GOLDENROD = vec3(0.855, 0.647, 0.125);\nconst vec3 DARK_GOLDENROD = vec3(0.722, 0.525, 0.043);\nconst vec3 PERU = vec3(0.804, 0.522, 0.247);\nconst vec3 CHOCOLATE = vec3(0.824, 0.412, 0.118);\nconst vec3 SADDLE_BROWN = vec3(0.545, 0.271, 0.075);\nconst vec3 SIENNA = vec3(0.627, 0.322, 0.176);\nconst vec3 BROWN = vec3(0.647, 0.165, 0.165);\nconst vec3 MAROON = vec3(0.502, 0.0, 0.0);\nconst vec3 WHITE = vec3(1.0, 1.0, 1.0);\nconst vec3 SNOW = vec3(1.0, 0.98, 0.98);\nconst vec3 HONEYDEW = vec3(0.941, 1.0, 0.941);\nconst vec3 MINT_CREAM = vec3(0.961, 1.0, 0.98);\nconst vec3 AZURE = vec3(0.941, 1.0, 1.0);\nconst vec3 ALICE_BLUE = vec3(0.941, 0.973, 1.0);\nconst vec3 GHOST_WHITE = vec3(0.973, 0.973, 1.0);\nconst vec3 WHITE_SMOKE = vec3(0.961, 0.961, 0.961);\nconst vec3 SEASHELL = vec3(1.0, 0.961, 0.933);\nconst vec3 BEIGE = vec3(0.961, 0.961, 0.863);\nconst vec3 OLD_LACE = vec3(0.992, 0.961, 0.902);\nconst vec3 FLORAL_WHITE = vec3(1.0, 0.98, 0.941);\nconst vec3 IVORY = vec3(1.0, 1.0, 0.941);\nconst vec3 ANTIQUE_WHITE = vec3(0.98, 0.922, 0.843);\nconst vec3 LINEN = vec3(0.98, 0.941, 0.902);\nconst vec3 LAVENDER_BLUSH = vec3(1.0, 0.941, 0.961);\nconst vec3 MISTY_ROSE = vec3(1.0, 0.894, 0.882);\nconst vec3 GAINSBORO = vec3(0.863, 0.863, 0.863);\nconst vec3 LIGHT_GREY = vec3(0.827, 0.827, 0.827);\nconst vec3 SILVER = vec3(0.753, 0.753, 0.753);\nconst vec3 DARK_GRAY = vec3(0.663, 0.663, 0.663);\nconst vec3 GRAY = vec3(0.502, 0.502, 0.502);\nconst vec3 DIM_GRAY = vec3(0.412, 0.412, 0.412);\nconst vec3 LIGHT_SLATE_GRAY = vec3(0.467, 0.533, 0.6);\nconst vec3 SLATE_GRAY = vec3(0.439, 0.502, 0.565);\nconst vec3 DARK_SLATE_GRAY = vec3(0.184, 0.31, 0.31);\nconst vec3 BLACK = vec3(0.0, 0.0, 0.0);\n\n// END ../common/colors.glsl\n\nuniform vec4 colorPrimary;\nuniform vec4 colorSecondary;\nuniform vec4 colorBackground;\nuniform vec2 iMouse;\n\n// show with square wave\nvec3 vizz(float val) {\n  vec3 color0 = ungamma(colorBackground);\n  vec3 color1 = ungamma(colorPrimary);\n  vec3 color2 = ungamma(colorSecondary);\n  vec3 cc = val >= 0.0 ? color1 : color2;\n  float v = abs(mod(abs(val) - 0.5, 2.0) - 1.0);\n  const float k = 0.5 * 0.1;\n  if (between(-0.5, 0.5, val)) {\n    return mix(color2, color1, smoothstep(-k, +k, val));\n  }\n  return mix(cc, color0, smoothstep(-0.5 - k, -0.5 + k, -v));\n}\n// #pragma glslify: export(vizz)\nvec3 vizz(float val, float mouseVal, vec2 fragCoord, vec2 mouse, vec2 iMouse) {\n  vec3 color = vizz(val);\n\n  if (-1.0 != iMouse.x) {\n    color = mix(\n      color,\n      ungamma(BLUE),\n      smoothstep(-0.2, -0.0, -abs(distance(mouse, fragCoord) - abs(mouseVal)))\n    );\n  }\n\n  return color;\n}\n\n#define VIZZ(SDF)                                                              \\\n  (vizz(                                                                       \\\n    SDF((coord - 0.5) * iResolution * 0.1),                                    \\\n    SDF((iMouse - 0.5 * iResolution) * 0.1),                                   \\\n    coord * iResolution * 0.1,                                                 \\\n    iMouse * 0.1,                                                              \\\n    iMouse                                                                     \\\n  ))\n\n// show with one line at 0\nvec3 vizz2(float val) {\n  vec3 color0 = ungamma(colorBackground);\n  vec3 color1 = ungamma(colorPrimary);\n  vec3 color2 = ungamma(colorSecondary);\n  vec3 cc = val >= 0.0 ? color1 : color2;\n  const float k = 0.1;\n  vec2 dVal = vec2(dFdx(val), dFdy(val));\n  return mix(\n    color0,\n    color1,\n    smoothstep(-k, +k, -abs(val / length(dVal)) + 0.8)\n  );\n}\n\n// END ../sdfs2d/vizz.glsl\n\nuniform vec2 iResolution;\nuniform float iTime;\nuniform float a, b, c;\nin vec2 coord;\nout vec4 fragColor;\n\nfloat sdf(vec2 p) {\n  float d = 10000.0;\n  float t = iTime * 5.0;\n  for (int i = 0; i < 9; i++) {\n    float fi = float(i);\n    // same thing as 0 but offset in time by i:\n    float ti = t + fi;\n    float tt = floor(ti / 9.0) + linstep(8.0, 9.0, fract(ti / 9.0) * 9.0);\n    // same thing as 0 but offset by i:\n    tt += fi;\n    vec2 p2 = rot2(tt * 40.0 * DEGREE) * p;\n    float d2 = sdArcRect(20.0 * DEGREE, 10.0, vec2(6.0, 0.0), p2);\n    d = min(d, d2);\n  }\n  return d;\n  //  return sdArc(b * PI, 10.0, 5.0, p);\n}\n\nvoid main() {\n  vec3 color = VIZZ(sdf);\n  color = pow(color, vec3(1.0 / 2.2)); // gamma correction\n  fragColor = vec4(color, 1);\n}\n',t={version:3,sources:["/home/runner/work/workshop/workshop/src/noises/magic.frag","/home/runner/work/workshop/workshop/src/common/constants.glsl","/home/runner/work/workshop/workshop/src/common/unmix.glsl","/home/runner/work/workshop/workshop/src/common/fromPolar.glsl","/home/runner/work/workshop/workshop/src/common/linstep.glsl","/home/runner/work/workshop/workshop/src/common/matrices.glsl","/home/runner/work/workshop/workshop/src/common/sdf2d/addChamfer.glsl","/home/runner/work/workshop/workshop/src/common/sdf2d/addFillet.glsl","/home/runner/work/workshop/workshop/src/common/toPolar.glsl","/home/runner/work/workshop/workshop/src/common/sdf2d/sdArc.glsl","/home/runner/work/workshop/workshop/src/common/sdf2d/sdArcRect.glsl","/home/runner/work/workshop/workshop/src/common/between.glsl","/home/runner/work/workshop/workshop/src/common/ungamma.glsl","/home/runner/work/workshop/workshop/src/common/colors.glsl","/home/runner/work/workshop/workshop/src/sdfs2d/vizz.glsl"],names:[],mappings:"AAAA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;Ad/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"}},3869:(A,n,e)=>{"use strict";e.r(n),e.d(n,{default:()=>o,sourceMap:()=>t});const o='#version 300 es\n\nprecision highp float;\n\n// START ../common/banded.glsl\nfloat banded(float bandCount, float t) {\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\n}\nfloat banded(int bandCount, float t) {\n  return banded(float(bandCount), t);\n}\n\n// #pragma glslify: export(banded)\n\n\n// END ../common/banded.glsl\n// START ../common/checkerboardGrad.glsl\n//https://iquilezles.org/articles/checkerfiltering/\nfloat tri(float x) {\n  float h = fract(x * 0.5) - 0.5;\n  return 1.0 - 2.0 * abs(h);\n}\nvec2 tri(vec2 x) {\n  vec2 h = fract(x * 0.5) - 0.5;\n  return 1.0 - 2.0 * abs(h);\n}\n\nfloat checkerboardGrad(vec2 uv) {\n  vec2 w = max(abs(dFdx(uv)), abs(dFdy(uv))) + 0.01; // filter kernel\n  vec2 i = (tri(uv + 0.5 * w) - tri(uv - 0.5 * w)) / w; // analytical integral (box filter)\n  return 0.5 - 0.5 * i.x * i.y; // xor pattern\n}\n\n// END ../common/checkerboardGrad.glsl\n// START ../common/colors.glsl\nconst vec3 INDIAN_RED = vec3(0.804, 0.361, 0.361);\nconst vec3 LIGHT_CORAL = vec3(0.941, 0.502, 0.502);\nconst vec3 SALMON = vec3(0.98, 0.502, 0.447);\nconst vec3 DARK_SALMON = vec3(0.914, 0.588, 0.478);\nconst vec3 LIGHT_SALMON = vec3(1.0, 0.627, 0.478);\nconst vec3 CRIMSON = vec3(0.863, 0.078, 0.235);\nconst vec3 RED = vec3(1.0, 0.0, 0.0);\nconst vec3 FIRE_BRICK = vec3(0.698, 0.133, 0.133);\nconst vec3 DARK_RED = vec3(0.545, 0.0, 0.0);\nconst vec3 PINK = vec3(1.0, 0.753, 0.796);\nconst vec3 LIGHT_PINK = vec3(1.0, 0.714, 0.757);\nconst vec3 HOT_PINK = vec3(1.0, 0.412, 0.706);\nconst vec3 DEEP_PINK = vec3(1.0, 0.078, 0.576);\nconst vec3 MEDIUM_VIOLET_RED = vec3(0.78, 0.082, 0.522);\nconst vec3 PALE_VIOLET_RED = vec3(0.859, 0.439, 0.576);\nconst vec3 CORAL = vec3(1.0, 0.498, 0.314);\nconst vec3 TOMATO = vec3(1.0, 0.388, 0.278);\nconst vec3 ORANGE_RED = vec3(1.0, 0.271, 0.0);\nconst vec3 DARK_ORANGE = vec3(1.0, 0.549, 0.0);\nconst vec3 ORANGE = vec3(1.0, 0.647, 0.0);\nconst vec3 GOLD = vec3(1.0, 0.843, 0.0);\nconst vec3 YELLOW = vec3(1.0, 1.0, 0.0);\nconst vec3 LIGHT_YELLOW = vec3(1.0, 1.0, 0.878);\nconst vec3 LEMON_CHION = vec3(1.0, 0.98, 0.804);\nconst vec3 LIGHT_GOLDENROD_YELLOW = vec3(0.98, 0.98, 0.824);\nconst vec3 PAPAYA_WHIP = vec3(1.0, 0.937, 0.835);\nconst vec3 MOCCASIN = vec3(1.0, 0.894, 0.71);\nconst vec3 PEACH_PU = vec3(1.0, 0.855, 0.725);\nconst vec3 PALE_GOLDENROD = vec3(0.933, 0.91, 0.667);\nconst vec3 KHAKI = vec3(0.941, 0.902, 0.549);\nconst vec3 DARK_KHAKI = vec3(0.741, 0.718, 0.42);\nconst vec3 LAVENDER = vec3(0.902, 0.902, 0.98);\nconst vec3 THISTLE = vec3(0.847, 0.749, 0.847);\nconst vec3 PLUM = vec3(0.867, 0.627, 0.867);\nconst vec3 VIOLET = vec3(0.933, 0.51, 0.933);\nconst vec3 ORCHID = vec3(0.855, 0.439, 0.839);\nconst vec3 FUCHSIA = vec3(1.0, 0.0, 1.0);\nconst vec3 MAGENTA = vec3(1.0, 0.0, 1.0);\nconst vec3 MEDIUM_ORCHID = vec3(0.729, 0.333, 0.827);\nconst vec3 MEDIUM_PURPLE = vec3(0.576, 0.439, 0.859);\nconst vec3 BLUE_VIOLET = vec3(0.541, 0.169, 0.886);\nconst vec3 DARK_VIOLET = vec3(0.58, 0.0, 0.827);\nconst vec3 DARK_ORCHID = vec3(0.6, 0.196, 0.8);\nconst vec3 DARK_MAGENTA = vec3(0.545, 0.0, 0.545);\nconst vec3 PURPLE = vec3(0.502, 0.0, 0.502);\nconst vec3 INDIGO = vec3(0.294, 0.0, 0.51);\nconst vec3 SLATE_BLUE = vec3(0.416, 0.353, 0.804);\nconst vec3 DARK_SLATE_BLUE = vec3(0.282, 0.239, 0.545);\nconst vec3 GREEN_YELLOW = vec3(0.678, 1.0, 0.184);\nconst vec3 CHARTREUSE = vec3(0.498, 1.0, 0.0);\nconst vec3 LAWN_GREEN = vec3(0.486, 0.988, 0.0);\nconst vec3 LIME = vec3(0.0, 1.0, 0.0);\nconst vec3 LIME_GREEN = vec3(0.196, 0.804, 0.196);\nconst vec3 PALE_GREEN = vec3(0.596, 0.984, 0.596);\nconst vec3 LIGHT_GREEN = vec3(0.565, 0.933, 0.565);\nconst vec3 MEDIUM_SPRING_GREEN = vec3(0.0, 0.98, 0.604);\nconst vec3 SPRING_GREEN = vec3(0.0, 1.0, 0.498);\nconst vec3 MEDIUM_SEA_GREEN = vec3(0.235, 0.702, 0.443);\nconst vec3 SEA_GREEN = vec3(0.18, 0.545, 0.341);\nconst vec3 FOREST_GREEN = vec3(0.133, 0.545, 0.133);\nconst vec3 GREEN = vec3(0.0, 0.502, 0.0);\nconst vec3 DARK_GREEN = vec3(0.0, 0.392, 0.0);\nconst vec3 YELLOW_GREEN = vec3(0.604, 0.804, 0.196);\nconst vec3 OLIVE_DRAB = vec3(0.42, 0.557, 0.137);\nconst vec3 OLIVE = vec3(0.502, 0.502, 0.0);\nconst vec3 DARK_OLIVE_GREEN = vec3(0.333, 0.42, 0.184);\nconst vec3 MEDIUM_AQUAMARINE = vec3(0.4, 0.804, 0.667);\nconst vec3 DARK_SEA_GREEN = vec3(0.561, 0.737, 0.561);\nconst vec3 LIGHT_SEA_GREEN = vec3(0.125, 0.698, 0.667);\nconst vec3 DARK_CYAN = vec3(0.0, 0.545, 0.545);\nconst vec3 TEAL = vec3(0.0, 0.502, 0.502);\nconst vec3 AQUA = vec3(0.0, 1.0, 1.0);\nconst vec3 CYAN = vec3(0.0, 1.0, 1.0);\nconst vec3 LIGHT_CYAN = vec3(0.878, 1.0, 1.0);\nconst vec3 PALE_TURQUOISE = vec3(0.686, 0.933, 0.933);\nconst vec3 AQUAMARINE = vec3(0.498, 1.0, 0.831);\nconst vec3 TURQUOISE = vec3(0.251, 0.878, 0.816);\nconst vec3 MEDIUM_TURQUOISE = vec3(0.282, 0.82, 0.8);\nconst vec3 DARK_TURQUOISE = vec3(0.0, 0.808, 0.82);\nconst vec3 CADET_BLUE = vec3(0.373, 0.62, 0.627);\nconst vec3 STEEL_BLUE = vec3(0.275, 0.51, 0.706);\nconst vec3 LIGHT_STEEL_BLUE = vec3(0.69, 0.769, 0.871);\nconst vec3 POWDER_BLUE = vec3(0.69, 0.878, 0.902);\nconst vec3 LIGHT_BLUE = vec3(0.678, 0.847, 0.902);\nconst vec3 SKY_BLUE = vec3(0.529, 0.808, 0.922);\nconst vec3 LIGHT_SKY_BLUE = vec3(0.529, 0.808, 0.98);\nconst vec3 DEEP_SKY_BLUE = vec3(0.0, 0.749, 1.0);\nconst vec3 DODGER_BLUE = vec3(0.118, 0.565, 1.0);\nconst vec3 CORNLOWER_BLUE = vec3(0.392, 0.584, 0.929);\nconst vec3 MEDIUM_SLATE_BLUE = vec3(0.482, 0.408, 0.933);\nconst vec3 ROYAL_BLUE = vec3(0.255, 0.412, 0.882);\nconst vec3 BLUE = vec3(0.0, 0.0, 1.0);\nconst vec3 MEDIUM_BLUE = vec3(0.0, 0.0, 0.804);\nconst vec3 DARK_BLUE = vec3(0.0, 0.0, 0.545);\nconst vec3 NAVY = vec3(0.0, 0.0, 0.502);\nconst vec3 MIDNIGHT_BLUE = vec3(0.098, 0.098, 0.439);\nconst vec3 CORNSILK = vec3(1.0, 0.973, 0.863);\nconst vec3 BLANCHED_ALMOND = vec3(1.0, 0.922, 0.804);\nconst vec3 BISQUE = vec3(1.0, 0.894, 0.769);\nconst vec3 NAVAJO_WHITE = vec3(1.0, 0.871, 0.678);\nconst vec3 WHEAT = vec3(0.961, 0.871, 0.702);\nconst vec3 BURLY_WOOD = vec3(0.871, 0.722, 0.529);\nconst vec3 TAN = vec3(0.824, 0.706, 0.549);\nconst vec3 ROSY_BROWN = vec3(0.737, 0.561, 0.561);\nconst vec3 SANDY_BROWN = vec3(0.957, 0.643, 0.376);\nconst vec3 GOLDENROD = vec3(0.855, 0.647, 0.125);\nconst vec3 DARK_GOLDENROD = vec3(0.722, 0.525, 0.043);\nconst vec3 PERU = vec3(0.804, 0.522, 0.247);\nconst vec3 CHOCOLATE = vec3(0.824, 0.412, 0.118);\nconst vec3 SADDLE_BROWN = vec3(0.545, 0.271, 0.075);\nconst vec3 SIENNA = vec3(0.627, 0.322, 0.176);\nconst vec3 BROWN = vec3(0.647, 0.165, 0.165);\nconst vec3 MAROON = vec3(0.502, 0.0, 0.0);\nconst vec3 WHITE = vec3(1.0, 1.0, 1.0);\nconst vec3 SNOW = vec3(1.0, 0.98, 0.98);\nconst vec3 HONEYDEW = vec3(0.941, 1.0, 0.941);\nconst vec3 MINT_CREAM = vec3(0.961, 1.0, 0.98);\nconst vec3 AZURE = vec3(0.941, 1.0, 1.0);\nconst vec3 ALICE_BLUE = vec3(0.941, 0.973, 1.0);\nconst vec3 GHOST_WHITE = vec3(0.973, 0.973, 1.0);\nconst vec3 WHITE_SMOKE = vec3(0.961, 0.961, 0.961);\nconst vec3 SEASHELL = vec3(1.0, 0.961, 0.933);\nconst vec3 BEIGE = vec3(0.961, 0.961, 0.863);\nconst vec3 OLD_LACE = vec3(0.992, 0.961, 0.902);\nconst vec3 FLORAL_WHITE = vec3(1.0, 0.98, 0.941);\nconst vec3 IVORY = vec3(1.0, 1.0, 0.941);\nconst vec3 ANTIQUE_WHITE = vec3(0.98, 0.922, 0.843);\nconst vec3 LINEN = vec3(0.98, 0.941, 0.902);\nconst vec3 LAVENDER_BLUSH = vec3(1.0, 0.941, 0.961);\nconst vec3 MISTY_ROSE = vec3(1.0, 0.894, 0.882);\nconst vec3 GAINSBORO = vec3(0.863, 0.863, 0.863);\nconst vec3 LIGHT_GREY = vec3(0.827, 0.827, 0.827);\nconst vec3 SILVER = vec3(0.753, 0.753, 0.753);\nconst vec3 DARK_GRAY = vec3(0.663, 0.663, 0.663);\nconst vec3 GRAY = vec3(0.502, 0.502, 0.502);\nconst vec3 DIM_GRAY = vec3(0.412, 0.412, 0.412);\nconst vec3 LIGHT_SLATE_GRAY = vec3(0.467, 0.533, 0.6);\nconst vec3 SLATE_GRAY = vec3(0.439, 0.502, 0.565);\nconst vec3 DARK_SLATE_GRAY = vec3(0.184, 0.31, 0.31);\nconst vec3 BLACK = vec3(0.0, 0.0, 0.0);\n\n// END ../common/colors.glsl\n// START ../common/linstep.glsl\nfloat linstep(float a, float b, float t) {\n  return clamp((t - a) / (b - a), 0.0, 1.0);\n}\nvec2 linstep(vec2 a, vec2 b, float t) {\n  return clamp((t - a) / (b - a), 0.0, 1.0);\n}\nvec3 linstep(vec3 a, vec3 b, float t) {\n  return clamp((t - a) / (b - a), 0.0, 1.0);\n}\nvec4 linstep(vec4 a, vec4 b, float t) {\n  return clamp((t - a) / (b - a), 0.0, 1.0);\n}\n\n// END ../common/linstep.glsl\n// START ../common/matrices.glsl\n// START ./constants.glsl\nconst float SQRT1_2 = 0.7071067811865476;\nconst float SQRT1_3 = 0.57735026919;\nconst float SQRT2 = 1.4142135623730951;\nconst float SQRT3 = 1.732050807568877;\n// sqrt(3)/2 = sin(60*)\nconst float SQRT3_2 = 0.86602540378;\nconst float GOLDEN_RATIO = 1.61803398875;\nconst float PI = 3.141592653589793;\nconst float TAU = 6.28318530718;\n/**\n * One degree in radians. Use like `sin(30 * DEG)`.\n */\nconst float DEGREE = 0.017453292519943295;\n\n// END ./constants.glsl\n\nmat2 rot2(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat2(c, s, -s, c);\n}\nmat3 rotX(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\n}\nmat3 rotY(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\n}\nmat3 rotZ(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\n}\n/**\n * Returns a matrix that puts the camera at the eye point `ex, ey, ez` looking\n * toward the center point `cx, cy, cz` with an up direction of `ux, uy, uz`.\n * This emulates the OpenGL function `gluLookAt()`.\n */\nmat4 lookAt(vec3 eye, vec3 focus, vec3 up) {\n  vec3 f = normalize(eye - focus);\n  vec3 s = normalize(cross(up, f));\n  vec3 t = normalize(cross(f, s));\n\n  return mat4(\n    vec4(s.x, t.x, f.x, 0.0),\n    vec4(s.y, t.y, f.y, 0.0),\n    vec4(s.z, t.z, f.z, 0.0),\n    vec4(-dot(s, eye), -dot(t, eye), -dot(f, eye), 1)\n  );\n}\n\n// the OpenGL function `glFrustum()`.\nmat4 frustum(\n  float left,\n  float right,\n  float bottom,\n  float top,\n  float near,\n  float far\n) {\n  return mat4(\n    vec4(2.0 * near / (right - left), 0.0, 0.0, 0.0),\n    vec4(0, 2.0 * near / (top - bottom), 0.0, 0.0),\n    vec4(\n      (right + left) / (right - left),\n      (top + bottom) / (top - bottom),\n      -(far + near) / (far - near),\n      -1\n    ),\n    vec4(0.0, 0.0, -2.0 * far * near / (far - near), 0.0)\n  );\n}\n\nmat4 perspective(float fovDegrees, float aspect, float near, float far) {\n  float y = tan(fovDegrees * DEGREE / 2.0) * near;\n  float x = y * aspect;\n  return frustum(-x, x, -y, y, near, far);\n}\nmat4 ortho(\n  float left,\n  float right,\n  float bottom,\n  float top,\n  float near,\n  float far\n) {\n  return mat4(\n    vec4(2.0 / (right - left), 0.0, 0.0, 0.0),\n    vec4(0.0, 2.0 / (top - bottom), 0.0, 0.0),\n    vec4(0.0, 0.0, -2.0 / (far - near), 0.0),\n    vec4(\n      -(right + left) / (right - left),\n      -(top + bottom) / (top - bottom),\n      -(far + near) / (far - near),\n      1.0\n    )\n  );\n}\n\n// END ../common/matrices.glsl\n// START ../common/max3.glsl\nfloat max3(float a, float b, float c) {\n  return max(a, max(b, c));\n}\nfloat max3(vec3 v) {\n  return max(v.x, max(v.y, v.z));\n}\n\n// #pragma glslify: export(max3)\n\n\n// END ../common/max3.glsl\n// START ../common/min3.glsl\nfloat min3(float a, float b, float c) {\n  return min(a, min(b, c));\n}\nfloat min3(vec3 v) {\n  return min(v.x, min(v.y, v.z));\n}\n\n// #pragma glslify: export(min3)\n\n\n// END ../common/min3.glsl\n// START ../common/polar.glsl\n// START ../common/fromPolar.glsl\n// START ./unmix.glsl\nfloat unmix(float a, float b, float value) {\n  return (value - a) / (b - a);\n}\n\n// #pragma glslify: export(unmix)\n\n\n// END ./unmix.glsl\n\nvec3 fromPolar(float radius, float phi, float z) {\n  return vec3(radius * cos(phi), radius * sin(phi), z);\n}\n\nvec2 fromPolar(float radius, float phi) {\n  return vec2(radius * cos(phi), radius * sin(phi));\n}\n\nvec2 fromPolar(vec2 polar) {\n  return fromPolar(polar.x, polar.y);\n}\n\n// #pragma glslify: export(fromPolar)\n\n\n// END ../common/fromPolar.glsl\n// START ../common/toPolar.glsl\n\nvec2 toPolar(vec2 xy) {\n  return vec2(length(xy), atan(xy.y, xy.x));\n}\n\nmat2 toPolarDerivate(vec2 xy) {\n  return mat2(xy.x * xy.x, xy.y * xy.y, -xy.y, xy.x) / dot(xy, xy);\n}\n\n// #pragma glslify: export(toPolar)\n\n\n// END ../common/toPolar.glsl\n\n// END ../common/polar.glsl\n// START ../common/sdf2d/sdArcRect.glsl\n\n/**\n * 2D signed distance function to an arc with square ends. The opening of the\n * arc is on the left (negative X direction). The total spanned angle is\n * `2 * halfAngle`.\n *\n * `radius` is the center radius of the arc.\n *\n * `width.x` is the thickness of the arc.\n *\n * `width.y` is how much the flat end of the arc is extructed. This is a\n * parameter as is it trivial to add with the current implementation. Set to 0\n * to just have a flat-ended arc.\n */\nfloat sdArcRect(float halfAngle, float radius, vec2 width, vec2 p) {\n  // Symmetric across x axis; all points on top.\n  p.y = abs(p.y);\n  // Rotate so that the end of the arc is at the x axis.\n  p = rot2(-halfAngle) * p;\n  if (p.y > 0.0) {\n    // p is "above the end of the arc"; calculate as for sdRectangle.\n    p.x = abs(p.x - radius);\n    p -= 0.5 * width;\n    return length(max(p, 0.0)) + min(0.0, max(p.x, p.y));\n  } else {\n    // Otherwise, the distance is basically just the radial distance to the arc.\n    // For the inside of the sdf, we have to take the end into account.\n    return max(abs(length(p) - radius) - 0.5 * width.x, p.y - 0.5 * width.y);\n  }\n}\n\n// END ../common/sdf2d/sdArcRect.glsl\n// START ../common/sdf2d/sdGear.glsl\n// START ../dot2.glsl\nfloat dot2(vec3 x) {\n  return dot(x, x);\n}\nfloat dot2(vec2 x) {\n  return dot(x, x);\n}\n\n// END ../dot2.glsl\n// START ./addFillet.glsl\nfloat addFillet(float r, float a, float b) {\n  if (a < r && b < r) {\n    return r - distance(vec2(a, b), vec2(r));\n  } else {\n    return min(a, b);\n  }\n}\n\n// #pragma glslify: export(addFillet)\n\n\n// END ./addFillet.glsl\n\n/**\n * SDF of one side of an invlute gear tooth. It starts at (baseRadius,0)\n * perpendicular to x-axis and goes right/up.\n *\n * Oq and qp are perpendicular.`|q| = 1` Calc |qp| with pythagoras.\n *\n * ```\n * |__\n * |  \\_q\n * |___|_________\n * O\n *         p\n * ```\n */\nfloat sdInvolute(float baseRadius, vec2 p) {\n  if (p.x < baseRadius) {\n    return -p.y;\n  } else {\n    float qpLength = sqrt(dot2(p) - baseRadius * baseRadius);\n    float qopAngle = acos(baseRadius / length(p));\n    float pAngle = atan(p.y, p.x);\n    float qAngle = qopAngle + pAngle;\n    float d = qpLength - qAngle * baseRadius;\n    return d;\n  }\n}\nvec2 opRotSym(float n, vec2 p) {\n  vec2 polar = toPolar(p);\n  float f = TAU / n;\n  polar.y = (fract(polar.y / f + 0.5) - 0.5) * f;\n  p = fromPolar(polar);\n  return p;\n}\n/**\n * 2D signed distance function (SDF) of an (external) involute gear. The gear is\n * centered at origin and has `n` teeth.\n *\n * Involute gear primer: The "pitch" circle/radius is where two gears touch each\n * other. The circular pitch is the distance, along the pitch circle, between\n * two teeth. `pitchRadius = (float(n) * circularPitch) / TAU`\n *\n * For two gears to be compatible they need to have the same pressure angle and\n * circular pitch.\n *\n * The base circle/radius is the circle from which the involute tooth profile is\n * constructed. `baseRadius = cos(pressureAngle) * pitchRadius`.\n *\n * The teeth profiles go from "dedendum circle" (see code) to "addendum circle".\n * The difference between dedendum circle and base circle is filled by a fillet.\n *\n * See also http://faculty.mercer.edu/jenkins_he/documents/Gears2R1.pdf\n */\nfloat sdGear(int n, float pressureAngle, float circularPitch, vec2 p) {\n  float pitchRadius = float(n) * circularPitch / TAU;\n  float baseRadius = cos(pressureAngle) * pitchRadius;\n\n  float addendumRadius = pitchRadius + 1.0 / PI * circularPitch;\n  float d3 = length(p) - addendumRadius;\n  if (d3 > 0.1) {\n    return d3;\n  }\n  float dedendumRadius = pitchRadius - 1.25 / PI * circularPitch;\n  float d2 = length(p) - dedendumRadius;\n  if (d2 < -0.1) {\n    return d2;\n  }\n  p = opRotSym(float(n), p);\n  //  float d = distance(vec2(1, 0.1), p) - 0.1;\n  p.y = abs(p.y);\n  vec2 polar = toPolar(p);\n  float f = TAU / float(n);\n  polar.y = (fract(polar.y / f + 0.5) - 0.5) * f;\n  polar.y -= 1.3 / float(n);\n  float d = sdInvolute(baseRadius, fromPolar(polar));\n\n  return max(addFillet(baseRadius - dedendumRadius, d, d2), d3);\n}\n\n/**\n * See sdGear. Not quite `-sdGear`, as the dedendum and addendum radii are\n * reversed to avoid intersections.\n */\nfloat sdGearInternal(int n, float pressureAngle, float circularPitch, vec2 p) {\n  float pitchRadius = float(n) * circularPitch / TAU;\n  float baseRadius = cos(pressureAngle) * pitchRadius;\n\n  float addendumRadius = pitchRadius - 1.0 / PI * circularPitch;\n  float d3 = -(length(p) - addendumRadius);\n  if (d3 > 0.1) {\n    return d3;\n  }\n  float dedendumRadius = pitchRadius + 1.25 / PI * circularPitch;\n  float d2 = -(length(p) - dedendumRadius);\n  if (d2 < -0.1) {\n    return d2;\n  }\n  p = opRotSym(float(n), p);\n  //  float d = distance(vec2(1, 0.1), p) - 0.1;\n  p.y = abs(p.y);\n  vec2 polar = toPolar(p);\n  float f = TAU / float(n);\n  polar.y = (fract(polar.y / f + 0.5) - 0.5) * f;\n  polar.y -= 1.0 / 1.3 / float(n);\n  float d = -sdInvolute(baseRadius, fromPolar(polar));\n\n  return max(min(d, d2), d3);\n}\n\n// END ../common/sdf2d/sdGear.glsl\n// START ../common/sdf3d/opRepLim.glsl\nvec3 opRepLim(vec3 p, vec3 cellSize, vec3 limit) {\n  return p - cellSize * clamp(round(p / cellSize), vec3(0.0), limit);\n}\nvec2 opRepLim(vec2 p, vec2 cellSize, vec2 limit) {\n  return p - cellSize * clamp(round(p / cellSize), vec2(0.0), limit);\n}\nfloat opRepLim(float p, float cellSize, float limit) {\n  return p - cellSize * clamp(round(p / cellSize), 0.0, limit);\n}\n\n// #pragma glslify: export(opRepLim)\n\n\n// END ../common/sdf3d/opRepLim.glsl\n// START ../common/sdf3d/sdArrow.glsl\n// START ./sdCylinder.glsl\nfloat sdCylinder(float radius, float z, vec3 p) {\n  vec2 d = vec2(length(p.xy), abs(p.z)) - vec2(radius, z);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// #pragma glslify: export(sdCylinder)\n\n\n// END ./sdCylinder.glsl\n// START ./sdCone.glsl\n\n/**\n * Signed distance function (SDF) of a cone. The tip of the cone is at the\n * origin and points towards +Z. q is a point on the rim of the cone.\n */\nfloat sdCone(vec2 c, float h, vec3 p) {\n  vec2 q = h * vec2(c.x / c.y, -1.0);\n  vec2 w = vec2(length(p.xz), p.y);\n  vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);\n  vec2 b = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0);\n  float k = sign(q.y);\n  float d = min(dot(a, a), dot(b, b));\n  float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));\n  return sqrt(d) * sign(s);\n}\n// #pragma glslify: export(sdBox)\n\nfloat sdConeB(vec2 c, float h, vec3 p) {\n  float q = length(p.xz);\n  return max(dot(c.xy, vec2(q, p.y)), -h - p.y);\n}\n\n// END ./sdCone.glsl\nvec3 perpendicularVector(vec3 a) {\n  return cross(a, abs(a.z) > abs(a.x) ? vec3(0, 0, 1) : vec3(0, 1, 0));\n}\n/**\n * Signed distance function (SDF) of an arrow. The arrow goes along the X axis.\n * The shaft of the arrow has thickness TODO. The tip of the arrow has 30Â°\n * angle, length of TODO, with the widest point being.\n */\nfloat sdArrow(float length, vec3 p) {\n  float r = 0.01;\n  return min(\n    sdCylinder(\n      0.02 - r,\n      0.5 * (length - 0.1) - r,\n      p.yzx - vec3(0, 0, 0.5 * (length - 0.1))\n    ) -\n      r,\n    sdCone(\n      vec2(sin(15.0 * DEGREE), cos(15.0 * DEGREE)),\n      0.15 - r,\n      p.zxy - vec3(0, length - r, 0)\n    ) -\n      r\n  );\n}\nfloat sdArrow(vec3 a, vec3 b, vec3 p) {\n  vec3 x = normalize(b - a);\n  vec3 y = normalize(perpendicularVector(x));\n  vec3 z = cross(x, y);\n  return sdArrow(length(b - a), inverse(mat3(x, y, z)) * (p - a));\n}\n\n// END ../common/sdf3d/sdArrow.glsl\n// START ../common/sdf3d/sdBox.glsl\n\nfloat sdBox(vec3 r, vec3 p) {\n  vec3 q = abs(p) - r;\n  return length(max(q, 0.0)) + min(max3(q), 0.0);\n}\n\nfloat sdBox(vec3 r, float r2, vec3 p) {\n  return sdBox(r - r2, p) - r2;\n}\n\n// #pragma glslify: export(sdBox)\n\n\n// END ../common/sdf3d/sdBox.glsl\n// START ../common/sdf3d/sdTorus.glsl\nfloat sdTorus(float r0, float r1, vec3 p) {\n  vec3 closestCenter = vec3(normalize(p.xy) * r0, 0.0);\n  return distance(closestCenter, p) - r1;\n}\n\n// #pragma glslify: export(sdTorus)\n\n\n// END ../common/sdf3d/sdTorus.glsl\n// START ../common/transform.glsl\nvec3 transform(mat4 pm, vec3 p) {\n  vec4 pStar = pm * vec4(p, 1);\n  return pStar.xyz / pStar.w;\n}\n\nvec2 transform(mat4 pm, vec2 p) {\n  vec4 pStar = pm * vec4(p, 0, 1);\n  return pStar.xy / pStar.w;\n}\n\n// END ../common/transform.glsl\n// START ../common/ungamma.glsl\nvec3 ungamma(vec4 col) {\n  return pow(col.rgb, vec3(2.2));\n}\nvec3 ungamma(vec3 col) {\n  return pow(col, vec3(2.2));\n}\n\n// END ../common/ungamma.glsl\n// START ../common/visualize.glsl\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\n  float isLow = float(t < 0.0);\n  float isHigh = float(t > 1.0);\n  float isMid = 1.0 - isLow - isHigh;\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\n}\n\nvec4 visualize(float t) {\n  const vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\n  const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\n  return visualize(BLUE, RED, t);\n}\n\n// #pragma glslify: export(visualize)\n\n\n// END ../common/visualize.glsl\n\nuniform sampler2D texture;\nuniform float iTime;\nuniform vec4 colorPrimary;\nuniform vec4 colorSecondary;\nuniform vec4 colorBackground;\nuniform float a;\nuniform float b;\nuniform float c;\nuniform float d;\nuniform int bandCount;\nuniform vec2 iResolution;\nuniform vec2 iMouse;\nin float n;\nin vec2 coord;\nout vec4 fragColor;\n\n\nstruct Hit {\n  float distance;\n  vec4 color;\n};\nHit mixa(Hit a, Hit b, float t) {\n  return Hit(mix(a.distance, b.distance, t), mix(a.color, b.color, t));\n}\nfloat skybox(vec3 p) {\n  return 32.0 - max3(abs(p));\n}\n\nHit add(Hit a, Hit b) {\n  //    return a.distance < b.distance\n  //        ? Hit(a.distance, a.color)\n  //        : Hit(b.distance, b.color);\n  return mixa(a, b, float(b.distance < a.distance));\n}\n\nHit addFillet(float r, Hit a, Hit b) {\n  if (a.distance < r && b.distance < r) {\n    return Hit(\n      r - distance(vec2(a.distance, b.distance), vec2(r)),\n      mix(a.color, b.color, (a.distance - b.distance) / r * 0.5 + 0.5)\n    );\n  } else {\n    return add(a, b);\n  }\n}\n\nHit addFillet(float r, Hit a, Hit b, vec4 tilletColor) {\n  if (a.distance < r && b.distance < r) {\n    return Hit(\n      r - distance(vec2(a.distance, b.distance), vec2(r)),\n      tilletColor\n    );\n  } else {\n    return add(a, b);\n  }\n}\nHit addFillet2(float r, Hit a, Hit b) {\n  float h = smoothstep(-r, r, a.distance - b.distance);\n  return Hit(\n    mix(a.distance, b.distance, h) - r * h * (1.0 - h),\n    mix(a.color, b.color, h)\n  );\n}\n\nHit neg(Hit a) {\n  return Hit(-a.distance, a.color);\n}\nHit sub(Hit from, Hit what) {\n  Hit whatNeg = neg(what);\n  return mixa(from, whatNeg, float(whatNeg.distance > from.distance));\n}\n\nvec3 modv(vec3 v, vec3 dir1, float y) {\n  float t = dot(v, dir1);\n  return v - floor(t / y) * y * dir1;\n}\nvec3 modRotZ(vec3 p, float count) {\n  vec2 polarXY = toPolar(p.xy);\n  return fromPolar(polarXY.x, mod(polarXY.y, TAU / count), p.z);\n}\n\nfloat sin01(float x) {\n  return 0.5 + 0.5 * sin(x);\n}\nfloat cos01(float x) {\n  return 0.5 + 0.5 * cos(x);\n}\n\nfloat smoothmin(float r, float a, float b) {\n  float h = smoothstep(-r, r, a - b);\n  return mix(a, b, h) - r * h * (1.0 - h);\n}\n\nvec2 project(vec2 a, vec2 onto1) {\n  return onto1 * (dot(a, onto1) / dot(onto1, onto1));\n}\n\nvec3 reject(vec3 a, vec3 b1) {\n  return a - b1 * dot(a, b1);\n}\nHit gizmo(vec3 p) {\n  vec3 absp = abs(p);\n\n  Hit res = Hit(sdArrow(1.0, p), vec4(RED, 1));\n  res = add(res, Hit(sdArrow(1.0, p.yzx), vec4(GREEN, 1)));\n  res = add(res, Hit(sdArrow(1.0, p.zxy), vec4(BLUE, 1)));\n  res = add(res, Hit(length(p) - 0.05, vec4(BLACK, 1)));\n  return res;\n}\n/**\n * Simple rubiks cube. Not actually 3x3x3 cubes but one static 3x3x2 block and\n * one rotating 3x3x1. Axes are switched at the beginning so it looks like\n * different moves are being made.\n */\nfloat rubiks(vec3 p) {\n  const float turnTimeInv = 1.0 / 0.5;\n  int turnNo = int(iTime * turnTimeInv) % 4;\n  if (turnNo == 0) {\n    p.x = -p.x;\n  } else if (turnNo == 1) {\n    p = vec3(p.y, p.z, -p.x);\n  } else if (turnNo == 2) {\n    p = p;\n  } else {\n    p = p.yzx;\n  }\n  p += 1.0;\n  vec3 p1 = opRepLim(p, vec3(1), vec3(2, 1, 2));\n  float d1 = sdBox(vec3(0.45), 0.05, p1);\n\n  vec3 p2 = p;\n  p2 -= vec3(1, 0, 1);\n  p2 = rotY(smoothstep(0.0, 1.0, fract(iTime * turnTimeInv)) * 0.5 * PI) * p2;\n  p2 = opRepLim(p2 - vec3(-1, 2, -1), vec3(1), vec3(2, 0, 2));\n  float d2 = sdBox(vec3(0.45), 0.05, p2);\n\n  return min(d1, d2);\n}\nfloat rots(vec3 p) {\n  p.y -= -6.0;\n  float turnTimeInv = 2.0 * pow(1.1, floor(p.y - 0.5));\n  int turnNo = int(iTime * turnTimeInv) % 4;\n  p.y = opRepLim(p.y - 2.0, 1.0, 7.0);\n  float d2 = sdBox(\n    vec3(0.4, 0.45, 0.8),\n    0.05,\n    rotY(iTime * turnTimeInv * 0.5 * PI) * p\n  );\n\n  return d2;\n}\n\nfloat sdOpExtrude(float thickness, float cornerRadius, float xyDist, float z) {\n  xyDist += cornerRadius;\n  z += cornerRadius;\n  float zDist = abs(z) - 0.5 * thickness;\n  return length(max(vec2(xyDist, zDist), 0.0)) +\n  min(max(xyDist, zDist), 0.0) -\n  cornerRadius;\n}\nfloat sdOpExtrude(float thickness, float xyDist, float z) {\n  return sdOpExtrude(thickness, 0.0, xyDist, z);\n}\n#define MIN3(A, B, C) (min(min(A, B), C))\n/**\n * - S = sun gear teeth\n * - P = planet gear teeth\n * - R = ring gear teeth\n *\n * R+S must divide evenly by number of planets for teeth to mesh properly.\n * (Specifically because the gears are evenly spaced.)\n *\n * cf https://woodgears.ca/gear/planetary.html\n */\nfloat gears(int S, vec2 p) {\n  int P = 11,\n    R = S + 2 * P;\n  float t = 0.9 * iTime;\n  p.xy = rot2(-t * -float(S) / float(R)) * p;\n  float circularPitch = a;\n  float gearDist = float(S + P) * circularPitch / TAU;\n  float dRingBorder = length(p) - 5.0;\n  if (dRingBorder > 0.0) {\n    return dRingBorder;\n  }\n\n  // sun gear\n  vec2 p1 = p;\n  p1 = rot2(t) * p1;\n  float d1 = max(\n    sdGear(S, 20.0 * DEGREE, circularPitch, p1),\n    -(length(p1) - 0.2)\n  );\n\n  // planet gear\n  vec2 p2 = p;\n  //  p2 = rot2(t * float(S) / float(S + R)) * p2;\n  float angleSegment = floor(toPolar(p2).y / (TAU / 3.0) + 0.5);\n  p2 = opRotSym(3.0, p2);\n  p2 -= vec2(gearDist, 0);\n  //  p2 = rot2(t * -float(S) / float(S + R)) * p2;\n  p2 = rot2((-t + angleSegment * TAU / 3.0) * (float(S) / float(P))) * p2;\n  float d2 = max(\n    sdGear(P, 20.0 * DEGREE, circularPitch, p2),\n    -(length(p2) - 0.2)\n  );\n\n  // ring gear\n  vec2 p3 = p;\n  p3 = rot2(t * -float(S) / float(R)) * p3;\n  float d3 = max(\n    sdGearInternal(R, 20.0 * DEGREE, circularPitch, p3),\n    dRingBorder\n  );\n  return min3(d1, d2, d3);\n}\nfloat gears(vec3 p) {\n  p -= vec3(0, 0, 1);\n  p = p.yzx;\n  float d = sdOpExtrude(4.0, 0.02, gears(22, p.xy), p.z);\n  return d;\n}\nfloat boxes(vec3 p) {\n  float d1 = p.y - 2.0;\n  float d2 = p.z - 1.2;\n  float d3 = sdBox(vec3(4), p);\n  return max(d1, d2);\n}\nconst float RR = 0.2;\nfloat loader(vec2 p) {\n  float d = 10000.0;\n  float t = iTime * 6.0;\n  for (int i = 0; i < 9; i++) {\n    float fi = float(i);\n    // same thing as 0 but offset in time by i:\n    float ti = t + fi;\n    float tt = floor(ti / 9.0) + linstep(8.0, 9.0, fract(ti / 9.0) * 9.0);\n    // same thing as 0 but offset by i:\n    tt += fi;\n    vec2 p2 = rot2(tt * 40.0 * DEGREE) * p - vec2(RR / sin(20.0 * DEGREE), 0);\n    float d2 = sdArcRect(20.0 * DEGREE, 10.0, vec2(6.0, 0.0), p2);\n    d = min(d, d2);\n  }\n  return d - RR;\n  //  return sdArc(b * PI, 10.0, 5.0, p);\n}\nfloat loader(vec3 p) {\n  p -= vec3(0, 0, 1);\n  p = p.yzx;\n  float d = sdOpExtrude(4.0, RR, loader(p.xy), p.z);\n  return d;\n}\nfloat spinring(vec3 p) {\n  float l = abs(length(p) - 15.0);\n  if (l > 2.0) {\n    return l;\n  }\n  p.xy = rot2(p.z * a) * p.xy;\n  return sdTorus(15.0, 0.3, p.zyx) * 0.1;\n}\nHit sdf(vec3 p) {\n  vec3 p2 = p;\n\n  float ds;\n  {\n    float scale = 0.1;\n    vec3 p2 = p - vec3(0.5, -0.5, 0.0);\n    ds = rubiks(p2 / scale) * scale;\n  }\n  {\n    vec3 p3 = p2;\n    p3 -= vec3(-0.5, 0.5, 0);\n    p3 = p3.zxy;\n    ds = min(ds, gears(p3 * 15.0) / 15.0);\n  }\n  {\n    vec3 p3 = p2;\n    p3 -= vec3(0.5, 0.5, 0);\n    ds = min(ds, loader(p3 * 100.0) * 00.01);\n  }\n  float dg = p.z;\n  Hit hit;\n  hit = Hit(ds, vec4(ungamma(colorPrimary), 1));\n  return hit;\n\n  if (ds < dg) {\n    hit = Hit(ds, vec4(ungamma(colorPrimary), 1));\n  } else {\n    float f = checkerboardGrad(p.xy);\n\n    vec3 color = mix(ungamma(colorBackground), ungamma(colorSecondary), f);\n    hit = Hit(dg, vec4(color, 1));\n  }\n  hit = add(hit, gizmo(p2));\n  return hit;\n}\nfloat sdff(vec3 p) {\n  return sdf(p).distance;\n}\nfloat ambientOcclusion(vec3 pWC, vec3 n1WC) {\n  float k = 1.0;\n  float distance = sdff(pWC + n1WC * k);\n  return clamp(distance / k, 0.0, 1.0);\n}\n\nstruct RMResult {\n  float distance;\n  vec3 pos;\n  vec4 color;\n};\nRMResult raymarching2(vec3 start, vec3 dir1) {\n  vec3 pos = start;\n  Hit hit;\n  for (int i = 0; i < 500; i++) {\n    hit = sdf(pos);\n    if (hit.distance < 0.001 || hit.distance > 100.0) break;\n    pos = pos + dir1 * hit.distance;\n  }\n  return RMResult(hit.distance, pos, hit.color);\n}\n\nfloat softshadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {\n  float res = 1.0;\n  float t = 0.1;\n  for (int i = 0; i < 100 && t < maxt; i++) {\n    float h = sdff(ro + rd * t);\n    if (h < 0.001) return 0.0;\n    res = min(res, k * h / t);\n    t += h;\n  }\n  return res;\n}\n\nvec3 sdfNormal1(vec3 p, float d) {\n  const float EPS = 1e-4;\n  return normalize(\n    vec3(\n      sdff(p + vec3(EPS, 0.0, 0.0)),\n      sdff(p + vec3(0.0, EPS, 0.0)),\n      sdff(p + vec3(0.0, 0.0, EPS))\n    ) -\n      vec3(sdff(p))\n  );\n}\n\n//layout (depth_greater) out float gl_FragDepth;\nvoid main() {\n  vec3 camPos =\n    vec3(5, 5, 5) +\n    (-1.0 == iMouse.x\n      ? vec3(0)\n      : vec3(0, (iMouse / iResolution * 2.0 - 1.0) * 10.0));\n  float aspectRatio = iResolution.x / iResolution.y;\n  float width = 3.0;\n  float height = width / aspectRatio;\n  mat4 modelView =\n    //    perspective(1.0, iResolution.x / iResolution.y, 0.1, 20.0) *\n    ortho(-0.5 * width, 0.5 * width, -0.5 * height, 0.5 * height, 0.1, 20.0) *\n    lookAt(camPos, vec3(0, 0, 0.0), vec3(0, 0, 1));\n  mat4 modelViewInverse = inverse(modelView);\n\n  vec3 light = normalize(vec3(-0.1, -1, -5));\n\n  vec3 a = vec3(coord * 2.0 - 1.0, -1.0);\n  vec3 b = vec3(coord * 2.0 - 1.0, 1.0);\n  vec3 aWC = transform(modelViewInverse, a);\n  vec3 bWC = transform(modelViewInverse, b);\n  vec3 lookDir1 = normalize(bWC - aWC);\n\n  RMResult hitWC = raymarching2(aWC, lookDir1);\n  vec3 hitn1 = sdfNormal1(hitWC.pos, hitWC.distance);\n  float dWC = distance(aWC, hitWC.pos);\n  vec3 hitNDC = transform(modelView, hitWC.pos);\n  vec3 p = hitWC.pos;\n  //  float inSun = softshadow(\n  //    hitWC.pos + hitn1 * 0.05,\n  //    -light,\n  //    0.0001,\n  //    300.0,\n  //    8.0\n  //  );\n  float inSun = 1.0;\n  //    float inSun=1.;\n\n  vec3 color;\n  vec3 material = hitWC.color.xyz;\n  if (hitWC.distance > 20.0) {\n    color = ungamma(colorBackground);\n  } else {\n    color = vec3(0.0);\n    const vec3 sunlightColor = vec3(3.0);\n\n    //  float aOcc = ambientOcclusion(hitWC.pos, hitn1);\n    float aOcc = 1.0;\n\n    vec3 reflectionDirection = reflect(light, hitn1);\n\n    //  color += material * aOcc;\n    color += inSun * sunlightColor * material * max(0.0, dot(-light, hitn1));\n    //    color = (hitn1);\n    vec3 eyeDirection = -lookDir1;\n    float uMaterialShininess = 256.0;\n    float specularLightWeighting = pow(\n      max(dot(reflectionDirection, eyeDirection), 0.0),\n      uMaterialShininess\n    );\n    //  color += specularLightWeighting;\n    //    float lightIntensity = 0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.);\n    //    float lightIntensity =\n    //        0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.) + 0.3*specularLightWeighting;\n    //    fragColor = visualize(blue, red, mix(0.5, 1.0, inSun) * lightIntensity);\n    //    fragColor = mix(hitWC.color, colorBackground, mix(0.5, 1.0, inSun) * clamp(lightIntensity, 0., 1.));\n    color = pow(color, vec3(1.0 / 2.2)); // gamma correction\n  }\n\n  fragColor = vec4(color, 1.0);\n}\n\nvoid mainImage(out vec4 c, vec2 w) {\n  vec4 p = vec4(w, 0.0, 1.0);\n\n  float v = 0.0,\n    f,\n    r[17];\n  vec4 s = vec4(2, 2, 1, 0);\n\n  for (int i = 0; i < 17; i++) r[i] = 0.0;\n\n  r[0] = p.x + p.y;\n  r[1] = p.y;\n\n  for (int i = 0; i < 17; i++) {\n    f = -2.0 * floor(r[i] / 2.0) / s[0];\n    for (int j = 0; j < 3; j++) {\n      r[i + j] += f * s[j];\n    }\n\n  }\n\n  for (int i = 0; i < 17; i++) {\n    v += mod(r[i], 2.0) * exp2(float(i));\n  }\n  v /= exp2(17.0);\n\n  c = vec4(v);\n}\n',t={version:3,sources:["/home/runner/work/workshop/workshop/src/noises/magic2.frag","/home/runner/work/workshop/workshop/src/common/banded.glsl","/home/runner/work/workshop/workshop/src/common/checkerboardGrad.glsl","/home/runner/work/workshop/workshop/src/common/colors.glsl","/home/runner/work/workshop/workshop/src/common/linstep.glsl","/home/runner/work/workshop/workshop/src/common/constants.glsl","/home/runner/work/workshop/workshop/src/common/matrices.glsl","/home/runner/work/workshop/workshop/src/common/max3.glsl","/home/runner/work/workshop/workshop/src/common/min3.glsl","/home/runner/work/workshop/workshop/src/common/unmix.glsl","/home/runner/work/workshop/workshop/src/common/fromPolar.glsl","/home/runner/work/workshop/workshop/src/common/toPolar.glsl","/home/runner/work/workshop/workshop/src/common/polar.glsl","/home/runner/work/workshop/workshop/src/common/sdf2d/sdArcRect.glsl","/home/runner/work/workshop/workshop/src/common/dot2.glsl","/home/runner/work/workshop/workshop/src/common/sdf2d/addFillet.glsl","/home/runner/work/workshop/workshop/src/common/sdf2d/sdGear.glsl","/home/runner/work/workshop/workshop/src/common/sdf3d/opRepLim.glsl","/home/runner/work/workshop/workshop/src/common/sdf3d/sdCylinder.glsl","/home/runner/work/workshop/workshop/src/common/sdf3d/sdCone.glsl","/home/runner/work/workshop/workshop/src/common/sdf3d/sdArrow.glsl","/home/runner/work/workshop/workshop/src/common/sdf3d/sdBox.glsl","/home/runner/work/workshop/workshop/src/common/sdf3d/sdTorus.glsl","/home/runner/work/workshop/workshop/src/common/transform.glsl","/home/runner/work/workshop/workshop/src/common/ungamma.glsl","/home/runner/work/workshop/workshop/src/common/visualize.glsl"],names:[],mappings:"AAAA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC5IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AChHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AzBOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"}},1429:(A,n,e)=>{"use strict";e.r(n),e.d(n,{default:()=>o,sourceMap:()=>t});const o='#version 300 es\n\nprecision highp float;\n\n// START ../common/banded.glsl\nfloat banded(float bandCount, float t) {\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\n}\nfloat banded(int bandCount, float t) {\n  return banded(float(bandCount), t);\n}\n\n// #pragma glslify: export(banded)\n\n\n// END ../common/banded.glsl\n// START ../common/checkerboardGrad.glsl\n//https://iquilezles.org/articles/checkerfiltering/\nfloat tri(float x) {\n  float h = fract(x * 0.5) - 0.5;\n  return 1.0 - 2.0 * abs(h);\n}\nvec2 tri(vec2 x) {\n  vec2 h = fract(x * 0.5) - 0.5;\n  return 1.0 - 2.0 * abs(h);\n}\n\nfloat checkerboardGrad(vec2 uv) {\n  vec2 w = max(abs(dFdx(uv)), abs(dFdy(uv))) + 0.01; // filter kernel\n  vec2 i = (tri(uv + 0.5 * w) - tri(uv - 0.5 * w)) / w; // analytical integral (box filter)\n  return 0.5 - 0.5 * i.x * i.y; // xor pattern\n}\n\n// END ../common/checkerboardGrad.glsl\n// START ../common/colors.glsl\nconst vec3 INDIAN_RED = vec3(0.804, 0.361, 0.361);\nconst vec3 LIGHT_CORAL = vec3(0.941, 0.502, 0.502);\nconst vec3 SALMON = vec3(0.98, 0.502, 0.447);\nconst vec3 DARK_SALMON = vec3(0.914, 0.588, 0.478);\nconst vec3 LIGHT_SALMON = vec3(1.0, 0.627, 0.478);\nconst vec3 CRIMSON = vec3(0.863, 0.078, 0.235);\nconst vec3 RED = vec3(1.0, 0.0, 0.0);\nconst vec3 FIRE_BRICK = vec3(0.698, 0.133, 0.133);\nconst vec3 DARK_RED = vec3(0.545, 0.0, 0.0);\nconst vec3 PINK = vec3(1.0, 0.753, 0.796);\nconst vec3 LIGHT_PINK = vec3(1.0, 0.714, 0.757);\nconst vec3 HOT_PINK = vec3(1.0, 0.412, 0.706);\nconst vec3 DEEP_PINK = vec3(1.0, 0.078, 0.576);\nconst vec3 MEDIUM_VIOLET_RED = vec3(0.78, 0.082, 0.522);\nconst vec3 PALE_VIOLET_RED = vec3(0.859, 0.439, 0.576);\nconst vec3 CORAL = vec3(1.0, 0.498, 0.314);\nconst vec3 TOMATO = vec3(1.0, 0.388, 0.278);\nconst vec3 ORANGE_RED = vec3(1.0, 0.271, 0.0);\nconst vec3 DARK_ORANGE = vec3(1.0, 0.549, 0.0);\nconst vec3 ORANGE = vec3(1.0, 0.647, 0.0);\nconst vec3 GOLD = vec3(1.0, 0.843, 0.0);\nconst vec3 YELLOW = vec3(1.0, 1.0, 0.0);\nconst vec3 LIGHT_YELLOW = vec3(1.0, 1.0, 0.878);\nconst vec3 LEMON_CHION = vec3(1.0, 0.98, 0.804);\nconst vec3 LIGHT_GOLDENROD_YELLOW = vec3(0.98, 0.98, 0.824);\nconst vec3 PAPAYA_WHIP = vec3(1.0, 0.937, 0.835);\nconst vec3 MOCCASIN = vec3(1.0, 0.894, 0.71);\nconst vec3 PEACH_PU = vec3(1.0, 0.855, 0.725);\nconst vec3 PALE_GOLDENROD = vec3(0.933, 0.91, 0.667);\nconst vec3 KHAKI = vec3(0.941, 0.902, 0.549);\nconst vec3 DARK_KHAKI = vec3(0.741, 0.718, 0.42);\nconst vec3 LAVENDER = vec3(0.902, 0.902, 0.98);\nconst vec3 THISTLE = vec3(0.847, 0.749, 0.847);\nconst vec3 PLUM = vec3(0.867, 0.627, 0.867);\nconst vec3 VIOLET = vec3(0.933, 0.51, 0.933);\nconst vec3 ORCHID = vec3(0.855, 0.439, 0.839);\nconst vec3 FUCHSIA = vec3(1.0, 0.0, 1.0);\nconst vec3 MAGENTA = vec3(1.0, 0.0, 1.0);\nconst vec3 MEDIUM_ORCHID = vec3(0.729, 0.333, 0.827);\nconst vec3 MEDIUM_PURPLE = vec3(0.576, 0.439, 0.859);\nconst vec3 BLUE_VIOLET = vec3(0.541, 0.169, 0.886);\nconst vec3 DARK_VIOLET = vec3(0.58, 0.0, 0.827);\nconst vec3 DARK_ORCHID = vec3(0.6, 0.196, 0.8);\nconst vec3 DARK_MAGENTA = vec3(0.545, 0.0, 0.545);\nconst vec3 PURPLE = vec3(0.502, 0.0, 0.502);\nconst vec3 INDIGO = vec3(0.294, 0.0, 0.51);\nconst vec3 SLATE_BLUE = vec3(0.416, 0.353, 0.804);\nconst vec3 DARK_SLATE_BLUE = vec3(0.282, 0.239, 0.545);\nconst vec3 GREEN_YELLOW = vec3(0.678, 1.0, 0.184);\nconst vec3 CHARTREUSE = vec3(0.498, 1.0, 0.0);\nconst vec3 LAWN_GREEN = vec3(0.486, 0.988, 0.0);\nconst vec3 LIME = vec3(0.0, 1.0, 0.0);\nconst vec3 LIME_GREEN = vec3(0.196, 0.804, 0.196);\nconst vec3 PALE_GREEN = vec3(0.596, 0.984, 0.596);\nconst vec3 LIGHT_GREEN = vec3(0.565, 0.933, 0.565);\nconst vec3 MEDIUM_SPRING_GREEN = vec3(0.0, 0.98, 0.604);\nconst vec3 SPRING_GREEN = vec3(0.0, 1.0, 0.498);\nconst vec3 MEDIUM_SEA_GREEN = vec3(0.235, 0.702, 0.443);\nconst vec3 SEA_GREEN = vec3(0.18, 0.545, 0.341);\nconst vec3 FOREST_GREEN = vec3(0.133, 0.545, 0.133);\nconst vec3 GREEN = vec3(0.0, 0.502, 0.0);\nconst vec3 DARK_GREEN = vec3(0.0, 0.392, 0.0);\nconst vec3 YELLOW_GREEN = vec3(0.604, 0.804, 0.196);\nconst vec3 OLIVE_DRAB = vec3(0.42, 0.557, 0.137);\nconst vec3 OLIVE = vec3(0.502, 0.502, 0.0);\nconst vec3 DARK_OLIVE_GREEN = vec3(0.333, 0.42, 0.184);\nconst vec3 MEDIUM_AQUAMARINE = vec3(0.4, 0.804, 0.667);\nconst vec3 DARK_SEA_GREEN = vec3(0.561, 0.737, 0.561);\nconst vec3 LIGHT_SEA_GREEN = vec3(0.125, 0.698, 0.667);\nconst vec3 DARK_CYAN = vec3(0.0, 0.545, 0.545);\nconst vec3 TEAL = vec3(0.0, 0.502, 0.502);\nconst vec3 AQUA = vec3(0.0, 1.0, 1.0);\nconst vec3 CYAN = vec3(0.0, 1.0, 1.0);\nconst vec3 LIGHT_CYAN = vec3(0.878, 1.0, 1.0);\nconst vec3 PALE_TURQUOISE = vec3(0.686, 0.933, 0.933);\nconst vec3 AQUAMARINE = vec3(0.498, 1.0, 0.831);\nconst vec3 TURQUOISE = vec3(0.251, 0.878, 0.816);\nconst vec3 MEDIUM_TURQUOISE = vec3(0.282, 0.82, 0.8);\nconst vec3 DARK_TURQUOISE = vec3(0.0, 0.808, 0.82);\nconst vec3 CADET_BLUE = vec3(0.373, 0.62, 0.627);\nconst vec3 STEEL_BLUE = vec3(0.275, 0.51, 0.706);\nconst vec3 LIGHT_STEEL_BLUE = vec3(0.69, 0.769, 0.871);\nconst vec3 POWDER_BLUE = vec3(0.69, 0.878, 0.902);\nconst vec3 LIGHT_BLUE = vec3(0.678, 0.847, 0.902);\nconst vec3 SKY_BLUE = vec3(0.529, 0.808, 0.922);\nconst vec3 LIGHT_SKY_BLUE = vec3(0.529, 0.808, 0.98);\nconst vec3 DEEP_SKY_BLUE = vec3(0.0, 0.749, 1.0);\nconst vec3 DODGER_BLUE = vec3(0.118, 0.565, 1.0);\nconst vec3 CORNLOWER_BLUE = vec3(0.392, 0.584, 0.929);\nconst vec3 MEDIUM_SLATE_BLUE = vec3(0.482, 0.408, 0.933);\nconst vec3 ROYAL_BLUE = vec3(0.255, 0.412, 0.882);\nconst vec3 BLUE = vec3(0.0, 0.0, 1.0);\nconst vec3 MEDIUM_BLUE = vec3(0.0, 0.0, 0.804);\nconst vec3 DARK_BLUE = vec3(0.0, 0.0, 0.545);\nconst vec3 NAVY = vec3(0.0, 0.0, 0.502);\nconst vec3 MIDNIGHT_BLUE = vec3(0.098, 0.098, 0.439);\nconst vec3 CORNSILK = vec3(1.0, 0.973, 0.863);\nconst vec3 BLANCHED_ALMOND = vec3(1.0, 0.922, 0.804);\nconst vec3 BISQUE = vec3(1.0, 0.894, 0.769);\nconst vec3 NAVAJO_WHITE = vec3(1.0, 0.871, 0.678);\nconst vec3 WHEAT = vec3(0.961, 0.871, 0.702);\nconst vec3 BURLY_WOOD = vec3(0.871, 0.722, 0.529);\nconst vec3 TAN = vec3(0.824, 0.706, 0.549);\nconst vec3 ROSY_BROWN = vec3(0.737, 0.561, 0.561);\nconst vec3 SANDY_BROWN = vec3(0.957, 0.643, 0.376);\nconst vec3 GOLDENROD = vec3(0.855, 0.647, 0.125);\nconst vec3 DARK_GOLDENROD = vec3(0.722, 0.525, 0.043);\nconst vec3 PERU = vec3(0.804, 0.522, 0.247);\nconst vec3 CHOCOLATE = vec3(0.824, 0.412, 0.118);\nconst vec3 SADDLE_BROWN = vec3(0.545, 0.271, 0.075);\nconst vec3 SIENNA = vec3(0.627, 0.322, 0.176);\nconst vec3 BROWN = vec3(0.647, 0.165, 0.165);\nconst vec3 MAROON = vec3(0.502, 0.0, 0.0);\nconst vec3 WHITE = vec3(1.0, 1.0, 1.0);\nconst vec3 SNOW = vec3(1.0, 0.98, 0.98);\nconst vec3 HONEYDEW = vec3(0.941, 1.0, 0.941);\nconst vec3 MINT_CREAM = vec3(0.961, 1.0, 0.98);\nconst vec3 AZURE = vec3(0.941, 1.0, 1.0);\nconst vec3 ALICE_BLUE = vec3(0.941, 0.973, 1.0);\nconst vec3 GHOST_WHITE = vec3(0.973, 0.973, 1.0);\nconst vec3 WHITE_SMOKE = vec3(0.961, 0.961, 0.961);\nconst vec3 SEASHELL = vec3(1.0, 0.961, 0.933);\nconst vec3 BEIGE = vec3(0.961, 0.961, 0.863);\nconst vec3 OLD_LACE = vec3(0.992, 0.961, 0.902);\nconst vec3 FLORAL_WHITE = vec3(1.0, 0.98, 0.941);\nconst vec3 IVORY = vec3(1.0, 1.0, 0.941);\nconst vec3 ANTIQUE_WHITE = vec3(0.98, 0.922, 0.843);\nconst vec3 LINEN = vec3(0.98, 0.941, 0.902);\nconst vec3 LAVENDER_BLUSH = vec3(1.0, 0.941, 0.961);\nconst vec3 MISTY_ROSE = vec3(1.0, 0.894, 0.882);\nconst vec3 GAINSBORO = vec3(0.863, 0.863, 0.863);\nconst vec3 LIGHT_GREY = vec3(0.827, 0.827, 0.827);\nconst vec3 SILVER = vec3(0.753, 0.753, 0.753);\nconst vec3 DARK_GRAY = vec3(0.663, 0.663, 0.663);\nconst vec3 GRAY = vec3(0.502, 0.502, 0.502);\nconst vec3 DIM_GRAY = vec3(0.412, 0.412, 0.412);\nconst vec3 LIGHT_SLATE_GRAY = vec3(0.467, 0.533, 0.6);\nconst vec3 SLATE_GRAY = vec3(0.439, 0.502, 0.565);\nconst vec3 DARK_SLATE_GRAY = vec3(0.184, 0.31, 0.31);\nconst vec3 BLACK = vec3(0.0, 0.0, 0.0);\n\n// END ../common/colors.glsl\n// START ../common/complex.glsl\n// START ./polar.glsl\n// START ../common/fromPolar.glsl\n// START ./unmix.glsl\nfloat unmix(float a, float b, float value) {\n  return (value - a) / (b - a);\n}\n\n// #pragma glslify: export(unmix)\n\n\n// END ./unmix.glsl\n\nvec3 fromPolar(float radius, float phi, float z) {\n  return vec3(radius * cos(phi), radius * sin(phi), z);\n}\n\nvec2 fromPolar(float radius, float phi) {\n  return vec2(radius * cos(phi), radius * sin(phi));\n}\n\nvec2 fromPolar(vec2 polar) {\n  return fromPolar(polar.x, polar.y);\n}\n\n// #pragma glslify: export(fromPolar)\n\n\n// END ../common/fromPolar.glsl\n// START ../common/toPolar.glsl\n\nvec2 toPolar(vec2 xy) {\n  return vec2(length(xy), atan(xy.y, xy.x));\n}\n\nmat2 toPolarDerivate(vec2 xy) {\n  return mat2(xy.x * xy.x, xy.y * xy.y, -xy.y, xy.x) / dot(xy, xy);\n}\n\n// #pragma glslify: export(toPolar)\n\n\n// END ../common/toPolar.glsl\n\n// END ./polar.glsl\n\nvec2 complexConj(vec2 z) {\n  return vec2(z.x, -z.y);\n}\n\nvec2 complexMul(vec2 a, vec2 b) {\n  return vec2(a.x * b.x - a.y * b.y, a.y * b.x + a.x * b.y);\n}\n\nvec2 complexDiv(vec2 a, vec2 b) {\n  vec2 bConj = vec2(b.x, -b.y);\n  float divisor = complexMul(b, bConj).x;\n  return complexMul(a, bConj) / divisor;\n}\n\n// return e^z\nvec2 complexPow(vec2 z) {\n  // e^(re + i * im)\n  // = e^re * e^(i * im)\n  return fromPolar(exp(z.x), z.y);\n}\n\n// return w^z\nvec2 complexPow(vec2 w, float z) {\n  // w = r * e ^ (i * phi)\n  // ln(w) = ln(r) + i * phi\n  // w^z = e^(z * log(w)) = e^(z * (ln(r) + i * (phi))\n  vec2 wPolar = toPolar(w);\n  vec2 eExp = z * vec2(log(wPolar.x), wPolar.y);\n  return complexPow(eExp);\n}\n\n// END ../common/complex.glsl\n// START ../common/constants.glsl\nconst float SQRT1_2 = 0.7071067811865476;\nconst float SQRT1_3 = 0.57735026919;\nconst float SQRT2 = 1.4142135623730951;\nconst float SQRT3 = 1.732050807568877;\n// sqrt(3)/2 = sin(60*)\nconst float SQRT3_2 = 0.86602540378;\nconst float GOLDEN_RATIO = 1.61803398875;\nconst float PI = 3.141592653589793;\nconst float TAU = 6.28318530718;\n/**\n * One degree in radians. Use like `sin(30 * DEG)`.\n */\nconst float DEGREE = 0.017453292519943295;\n\n// END ../common/constants.glsl\n// START ../common/linstep.glsl\nfloat linstep(float a, float b, float t) {\n  return clamp((t - a) / (b - a), 0.0, 1.0);\n}\nvec2 linstep(vec2 a, vec2 b, float t) {\n  return clamp((t - a) / (b - a), 0.0, 1.0);\n}\nvec3 linstep(vec3 a, vec3 b, float t) {\n  return clamp((t - a) / (b - a), 0.0, 1.0);\n}\nvec4 linstep(vec4 a, vec4 b, float t) {\n  return clamp((t - a) / (b - a), 0.0, 1.0);\n}\n\n// END ../common/linstep.glsl\n// START ../common/matrices.glsl\n\nmat2 rot2(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat2(c, s, -s, c);\n}\nmat3 rotX(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\n}\nmat3 rotY(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\n}\nmat3 rotZ(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\n}\n/**\n * Returns a matrix that puts the camera at the eye point `ex, ey, ez` looking\n * toward the center point `cx, cy, cz` with an up direction of `ux, uy, uz`.\n * This emulates the OpenGL function `gluLookAt()`.\n */\nmat4 lookAt(vec3 eye, vec3 focus, vec3 up) {\n  vec3 f = normalize(eye - focus);\n  vec3 s = normalize(cross(up, f));\n  vec3 t = normalize(cross(f, s));\n\n  return mat4(\n    vec4(s.x, t.x, f.x, 0.0),\n    vec4(s.y, t.y, f.y, 0.0),\n    vec4(s.z, t.z, f.z, 0.0),\n    vec4(-dot(s, eye), -dot(t, eye), -dot(f, eye), 1)\n  );\n}\n\n// the OpenGL function `glFrustum()`.\nmat4 frustum(\n  float left,\n  float right,\n  float bottom,\n  float top,\n  float near,\n  float far\n) {\n  return mat4(\n    vec4(2.0 * near / (right - left), 0.0, 0.0, 0.0),\n    vec4(0, 2.0 * near / (top - bottom), 0.0, 0.0),\n    vec4(\n      (right + left) / (right - left),\n      (top + bottom) / (top - bottom),\n      -(far + near) / (far - near),\n      -1\n    ),\n    vec4(0.0, 0.0, -2.0 * far * near / (far - near), 0.0)\n  );\n}\n\nmat4 perspective(float fovDegrees, float aspect, float near, float far) {\n  float y = tan(fovDegrees * DEGREE / 2.0) * near;\n  float x = y * aspect;\n  return frustum(-x, x, -y, y, near, far);\n}\nmat4 ortho(\n  float left,\n  float right,\n  float bottom,\n  float top,\n  float near,\n  float far\n) {\n  return mat4(\n    vec4(2.0 / (right - left), 0.0, 0.0, 0.0),\n    vec4(0.0, 2.0 / (top - bottom), 0.0, 0.0),\n    vec4(0.0, 0.0, -2.0 / (far - near), 0.0),\n    vec4(\n      -(right + left) / (right - left),\n      -(top + bottom) / (top - bottom),\n      -(far + near) / (far - near),\n      1.0\n    )\n  );\n}\n\n// END ../common/matrices.glsl\n// START ../common/max3.glsl\nfloat max3(float a, float b, float c) {\n  return max(a, max(b, c));\n}\nfloat max3(vec3 v) {\n  return max(v.x, max(v.y, v.z));\n}\n\n// #pragma glslify: export(max3)\n\n\n// END ../common/max3.glsl\n// START ../common/min3.glsl\nfloat min3(float a, float b, float c) {\n  return min(a, min(b, c));\n}\nfloat min3(vec3 v) {\n  return min(v.x, min(v.y, v.z));\n}\n\n// #pragma glslify: export(min3)\n\n\n// END ../common/min3.glsl\n// START ../common/sdf2d/sdArcRect.glsl\n\n/**\n * 2D signed distance function to an arc with square ends. The opening of the\n * arc is on the left (negative X direction). The total spanned angle is\n * `2 * halfAngle`.\n *\n * `radius` is the center radius of the arc.\n *\n * `width.x` is the thickness of the arc.\n *\n * `width.y` is how much the flat end of the arc is extructed. This is a\n * parameter as is it trivial to add with the current implementation. Set to 0\n * to just have a flat-ended arc.\n */\nfloat sdArcRect(float halfAngle, float radius, vec2 width, vec2 p) {\n  // Symmetric across x axis; all points on top.\n  p.y = abs(p.y);\n  // Rotate so that the end of the arc is at the x axis.\n  p = rot2(-halfAngle) * p;\n  if (p.y > 0.0) {\n    // p is "above the end of the arc"; calculate as for sdRectangle.\n    p.x = abs(p.x - radius);\n    p -= 0.5 * width;\n    return length(max(p, 0.0)) + min(0.0, max(p.x, p.y));\n  } else {\n    // Otherwise, the distance is basically just the radial distance to the arc.\n    // For the inside of the sdf, we have to take the end into account.\n    return max(abs(length(p) - radius) - 0.5 * width.x, p.y - 0.5 * width.y);\n  }\n}\n\n// END ../common/sdf2d/sdArcRect.glsl\n// START ../common/sdf2d/sdRectangle.glsl\nfloat sdRectangle(vec2 dim, vec2 p) {\n  vec2 d = abs(p) - 0.5 * dim;\n  return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat sdRectangle(float width, float height, vec2 p) {\n  return sdRectangle(vec2(width, height), p);\n}\n\n\n// END ../common/sdf2d/sdRectangle.glsl\n// START ../common/sdf2d/sdGear.glsl\n// START ../dot2.glsl\nfloat dot2(vec3 x) {\n  return dot(x, x);\n}\nfloat dot2(vec2 x) {\n  return dot(x, x);\n}\n\n// END ../dot2.glsl\n// START ./addFillet.glsl\nfloat addFillet(float r, float a, float b) {\n  if (a < r && b < r) {\n    return r - distance(vec2(a, b), vec2(r));\n  } else {\n    return min(a, b);\n  }\n}\n\n// #pragma glslify: export(addFillet)\n\n\n// END ./addFillet.glsl\n\n/**\n * SDF of one side of an invlute gear tooth. It starts at (baseRadius,0)\n * perpendicular to x-axis and goes right/up.\n *\n * Oq and qp are perpendicular.`|q| = 1` Calc |qp| with pythagoras.\n *\n * ```\n * |__\n * |  \\_q\n * |___|_________\n * O\n *         p\n * ```\n */\nfloat sdInvolute(float baseRadius, vec2 p) {\n  if (p.x < baseRadius) {\n    return -p.y;\n  } else {\n    float qpLength = sqrt(dot2(p) - baseRadius * baseRadius);\n    float qopAngle = acos(baseRadius / length(p));\n    float pAngle = atan(p.y, p.x);\n    float qAngle = qopAngle + pAngle;\n    float d = qpLength - qAngle * baseRadius;\n    return d;\n  }\n}\nvec2 opRotSym(float n, vec2 p) {\n  vec2 polar = toPolar(p);\n  float f = TAU / n;\n  polar.y = (fract(polar.y / f + 0.5) - 0.5) * f;\n  p = fromPolar(polar);\n  return p;\n}\n/**\n * 2D signed distance function (SDF) of an (external) involute gear. The gear is\n * centered at origin and has `n` teeth.\n *\n * Involute gear primer: The "pitch" circle/radius is where two gears touch each\n * other. The circular pitch is the distance, along the pitch circle, between\n * two teeth. `pitchRadius = (float(n) * circularPitch) / TAU`\n *\n * For two gears to be compatible they need to have the same pressure angle and\n * circular pitch.\n *\n * The base circle/radius is the circle from which the involute tooth profile is\n * constructed. `baseRadius = cos(pressureAngle) * pitchRadius`.\n *\n * The teeth profiles go from "dedendum circle" (see code) to "addendum circle".\n * The difference between dedendum circle and base circle is filled by a fillet.\n *\n * See also http://faculty.mercer.edu/jenkins_he/documents/Gears2R1.pdf\n */\nfloat sdGear(int n, float pressureAngle, float circularPitch, vec2 p) {\n  float pitchRadius = float(n) * circularPitch / TAU;\n  float baseRadius = cos(pressureAngle) * pitchRadius;\n\n  float addendumRadius = pitchRadius + 1.0 / PI * circularPitch;\n  float d3 = length(p) - addendumRadius;\n  if (d3 > 0.1) {\n    return d3;\n  }\n  float dedendumRadius = pitchRadius - 1.25 / PI * circularPitch;\n  float d2 = length(p) - dedendumRadius;\n  if (d2 < -0.1) {\n    return d2;\n  }\n  p = opRotSym(float(n), p);\n  //  float d = distance(vec2(1, 0.1), p) - 0.1;\n  p.y = abs(p.y);\n  vec2 polar = toPolar(p);\n  float f = TAU / float(n);\n  polar.y = (fract(polar.y / f + 0.5) - 0.5) * f;\n  polar.y -= 1.3 / float(n);\n  float d = sdInvolute(baseRadius, fromPolar(polar));\n\n  return max(addFillet(baseRadius - dedendumRadius, d, d2), d3);\n}\n\n/**\n * See sdGear. Not quite `-sdGear`, as the dedendum and addendum radii are\n * reversed to avoid intersections.\n */\nfloat sdGearInternal(int n, float pressureAngle, float circularPitch, vec2 p) {\n  float pitchRadius = float(n) * circularPitch / TAU;\n  float baseRadius = cos(pressureAngle) * pitchRadius;\n\n  float addendumRadius = pitchRadius - 1.0 / PI * circularPitch;\n  float d3 = -(length(p) - addendumRadius);\n  if (d3 > 0.1) {\n    return d3;\n  }\n  float dedendumRadius = pitchRadius + 1.25 / PI * circularPitch;\n  float d2 = -(length(p) - dedendumRadius);\n  if (d2 < -0.1) {\n    return d2;\n  }\n  p = opRotSym(float(n), p);\n  //  float d = distance(vec2(1, 0.1), p) - 0.1;\n  p.y = abs(p.y);\n  vec2 polar = toPolar(p);\n  float f = TAU / float(n);\n  polar.y = (fract(polar.y / f + 0.5) - 0.5) * f;\n  polar.y -= 1.0 / 1.3 / float(n);\n  float d = -sdInvolute(baseRadius, fromPolar(polar));\n\n  return max(min(d, d2), d3);\n}\n\n// END ../common/sdf2d/sdGear.glsl\n// START ../common/sdf3d/opRepLim.glsl\nvec3 opRepLim(vec3 p, vec3 cellSize, vec3 limit) {\n  return p - cellSize * clamp(round(p / cellSize), vec3(0.0), limit);\n}\nvec2 opRepLim(vec2 p, vec2 cellSize, vec2 limit) {\n  return p - cellSize * clamp(round(p / cellSize), vec2(0.0), limit);\n}\nfloat opRepLim(float p, float cellSize, float limit) {\n  return p - cellSize * clamp(round(p / cellSize), 0.0, limit);\n}\n\n// #pragma glslify: export(opRepLim)\n\n\n// END ../common/sdf3d/opRepLim.glsl\n// START ../common/sdf3d/sdArrow.glsl\n// START ./sdCylinder.glsl\nfloat sdCylinder(float radius, float z, vec3 p) {\n  vec2 d = vec2(length(p.xy), abs(p.z)) - vec2(radius, z);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// #pragma glslify: export(sdCylinder)\n\n\n// END ./sdCylinder.glsl\n// START ./sdCone.glsl\n\n/**\n * Signed distance function (SDF) of a cone. The tip of the cone is at the\n * origin and points towards +Z. q is a point on the rim of the cone.\n */\nfloat sdCone(vec2 c, float h, vec3 p) {\n  vec2 q = h * vec2(c.x / c.y, -1.0);\n  vec2 w = vec2(length(p.xz), p.y);\n  vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);\n  vec2 b = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0);\n  float k = sign(q.y);\n  float d = min(dot(a, a), dot(b, b));\n  float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));\n  return sqrt(d) * sign(s);\n}\n// #pragma glslify: export(sdBox)\n\nfloat sdConeB(vec2 c, float h, vec3 p) {\n  float q = length(p.xz);\n  return max(dot(c.xy, vec2(q, p.y)), -h - p.y);\n}\n\n// END ./sdCone.glsl\nvec3 perpendicularVector(vec3 a) {\n  return cross(a, abs(a.z) > abs(a.x) ? vec3(0, 0, 1) : vec3(0, 1, 0));\n}\n/**\n * Signed distance function (SDF) of an arrow. The arrow goes along the X axis.\n * The shaft of the arrow has thickness TODO. The tip of the arrow has 30Â°\n * angle, length of TODO, with the widest point being.\n */\nfloat sdArrow(float length, vec3 p) {\n  float r = 0.01;\n  return min(\n    sdCylinder(\n      0.02 - r,\n      0.5 * (length - 0.1) - r,\n      p.yzx - vec3(0, 0, 0.5 * (length - 0.1))\n    ) -\n      r,\n    sdCone(\n      vec2(sin(15.0 * DEGREE), cos(15.0 * DEGREE)),\n      0.15 - r,\n      p.zxy - vec3(0, length - r, 0)\n    ) -\n      r\n  );\n}\nfloat sdArrow(vec3 a, vec3 b, vec3 p) {\n  vec3 x = normalize(b - a);\n  vec3 y = normalize(perpendicularVector(x));\n  vec3 z = cross(x, y);\n  return sdArrow(length(b - a), inverse(mat3(x, y, z)) * (p - a));\n}\n\n// END ../common/sdf3d/sdArrow.glsl\n// START ../common/sdf3d/sdBox.glsl\n\nfloat sdBox(vec3 r, vec3 p) {\n  vec3 q = abs(p) - r;\n  return length(max(q, 0.0)) + min(max3(q), 0.0);\n}\n\nfloat sdBox(vec3 r, float r2, vec3 p) {\n  return sdBox(r - r2, p) - r2;\n}\n\n// #pragma glslify: export(sdBox)\n\n\n// END ../common/sdf3d/sdBox.glsl\n// START ../common/sdf3d/sdTorus.glsl\nfloat sdTorus(float r0, float r1, vec3 p) {\n  vec3 closestCenter = vec3(normalize(p.xy) * r0, 0.0);\n  return distance(closestCenter, p) - r1;\n}\n\n// #pragma glslify: export(sdTorus)\n\n\n// END ../common/sdf3d/sdTorus.glsl\n// START ../common/transform.glsl\nvec3 transform(mat4 pm, vec3 p) {\n  vec4 pStar = pm * vec4(p, 1);\n  return pStar.xyz / pStar.w;\n}\n\nvec2 transform(mat4 pm, vec2 p) {\n  vec4 pStar = pm * vec4(p, 0, 1);\n  return pStar.xy / pStar.w;\n}\n\n// END ../common/transform.glsl\n// START ../common/ungamma.glsl\nvec3 ungamma(vec4 col) {\n  return pow(col.rgb, vec3(2.2));\n}\nvec3 ungamma(vec3 col) {\n  return pow(col, vec3(2.2));\n}\n\n// END ../common/ungamma.glsl\n// START ../common/visualize.glsl\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\n  float isLow = float(t < 0.0);\n  float isHigh = float(t > 1.0);\n  float isMid = 1.0 - isLow - isHigh;\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\n}\n\nvec4 visualize(float t) {\n  const vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\n  const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\n  return visualize(BLUE, RED, t);\n}\n\n// #pragma glslify: export(visualize)\n\n\n// END ../common/visualize.glsl\n// START ../sdfs2d/vizz.glsl\n// START ../common/between.glsl\nbool between(float min, float max, float value) {\n  return min <= value && value <= max;\n}\n\n// #pragma glslify: export(between)\n\n\n// END ../common/between.glsl\n\nuniform vec4 colorPrimary;\nuniform vec4 colorSecondary;\nuniform vec4 colorBackground;\nuniform vec2 iMouse;\n\n// show with square wave\nvec3 vizz(float val) {\n  vec3 color0 = ungamma(colorBackground);\n  vec3 color1 = ungamma(colorPrimary);\n  vec3 color2 = ungamma(colorSecondary);\n  vec3 cc = val >= 0.0 ? color1 : color2;\n  float v = abs(mod(abs(val) - 0.5, 2.0) - 1.0);\n  const float k = 0.5 * 0.1;\n  if (between(-0.5, 0.5, val)) {\n    return mix(color2, color1, smoothstep(-k, +k, val));\n  }\n  return mix(cc, color0, smoothstep(-0.5 - k, -0.5 + k, -v));\n}\n// #pragma glslify: export(vizz)\nvec3 vizz(float val, float mouseVal, vec2 fragCoord, vec2 mouse, vec2 iMouse) {\n  vec3 color = vizz(val);\n\n  if (-1.0 != iMouse.x) {\n    color = mix(\n      color,\n      ungamma(BLUE),\n      smoothstep(-0.2, -0.0, -abs(distance(mouse, fragCoord) - abs(mouseVal)))\n    );\n  }\n\n  return color;\n}\n\n#define VIZZ(SDF)                                                              \\\n  (vizz(                                                                       \\\n    SDF((coord - 0.5) * iResolution * 0.1),                                    \\\n    SDF((iMouse - 0.5 * iResolution) * 0.1),                                   \\\n    coord * iResolution * 0.1,                                                 \\\n    iMouse * 0.1,                                                              \\\n    iMouse                                                                     \\\n  ))\n\n// show with one line at 0\nvec3 vizz2(float val) {\n  vec3 color0 = ungamma(colorBackground);\n  vec3 color1 = ungamma(colorPrimary);\n  vec3 color2 = ungamma(colorSecondary);\n  vec3 cc = val >= 0.0 ? color1 : color2;\n  const float k = 0.1;\n  vec2 dVal = vec2(dFdx(val), dFdy(val));\n  return mix(\n    color0,\n    color1,\n    smoothstep(-k, +k, -abs(val / length(dVal)) + 0.8)\n  );\n}\n\n// END ../sdfs2d/vizz.glsl\n\nin float n;\nin vec2 coord;\nout vec4 fragColor;\nuniform float a;\nuniform float b;\nuniform float c;\nuniform float d;\nuniform float iTime;\nuniform int bandCount;\nuniform mat4 viewModel;\nuniform sampler2D texture;\nuniform vec2 iResolution;\n\nfloat sdf(vec2 p) {\n  p *= 0.1;\n  p = complexMul(p, fromPolar(1.0, 20.0 * DEGREE * length(p) * a));\n\n  // center rectangle\n  float d = sdRectangle(vec2(1.0), p);\n  float scale = 1.0;\n  for (int i = 0; i < 4; i++) {\n    p = abs(p);\n    p = opRepLim(p, vec2(1.0), vec2(1));\n    p *= 3.0;\n    scale *= 1.0 / 3.0;\n    float id = length(p) - 0.5;\n    //    float id = sdRectangle(vec2(1.0), p);\n    d = min(d, id * scale);\n  }\n  return d * 10.0;\n}\n\nvoid main() {\n  vec2 fragCoord = transform(viewModel, coord * iResolution);\n  vec2 tp = (fragCoord - 0.5 * iResolution) * 0.1;\n  vec3 color = vizz(\n    sdf(transform(viewModel, (coord - 0.5) * iResolution)),\n    sdf(transform(viewModel, (iMouse - 0.5) * iResolution)),\n    transform(viewModel, coord * iResolution),\n    transform(viewModel, iMouse),\n    iMouse\n  );\n  color = vizz2(sdf(tp));\n  color = pow(color, vec3(1.0 / 2.2)); // gamma correction\n  fragColor = vec4(color, 1);\n}\n',t={version:3,sources:["/home/runner/work/workshop/workshop/src/noises/mengerSlices.frag","/home/runner/work/workshop/workshop/src/common/banded.glsl","/home/runner/work/workshop/workshop/src/common/checkerboardGrad.glsl","/home/runner/work/workshop/workshop/src/common/colors.glsl","/home/runner/work/workshop/workshop/src/common/unmix.glsl","/home/runner/work/workshop/workshop/src/common/fromPolar.glsl","/home/runner/work/workshop/workshop/src/common/toPolar.glsl","/home/runner/work/workshop/workshop/src/common/polar.glsl","/home/runner/work/workshop/workshop/src/common/complex.glsl","/home/runner/work/workshop/workshop/src/common/constants.glsl","/home/runner/work/workshop/workshop/src/common/linstep.glsl","/home/runner/work/workshop/workshop/src/common/matrices.glsl","/home/runner/work/workshop/workshop/src/common/max3.glsl","/home/runner/work/workshop/workshop/src/common/min3.glsl","/home/runner/work/workshop/workshop/src/common/sdf2d/sdArcRect.glsl","/home/runner/work/workshop/workshop/src/common/sdf2d/sdRectangle.glsl","/home/runner/work/workshop/workshop/src/common/dot2.glsl","/home/runner/work/workshop/workshop/src/common/sdf2d/addFillet.glsl","/home/runner/work/workshop/workshop/src/common/sdf2d/sdGear.glsl","/home/runner/work/workshop/workshop/src/common/sdf3d/opRepLim.glsl","/home/runner/work/workshop/workshop/src/common/sdf3d/sdCylinder.glsl","/home/runner/work/workshop/workshop/src/common/sdf3d/sdCone.glsl","/home/runner/work/workshop/workshop/src/common/sdf3d/sdArrow.glsl","/home/runner/work/workshop/workshop/src/common/sdf3d/sdBox.glsl","/home/runner/work/workshop/workshop/src/common/sdf3d/sdTorus.glsl","/home/runner/work/workshop/workshop/src/common/transform.glsl","/home/runner/work/workshop/workshop/src/common/ungamma.glsl","/home/runner/work/workshop/workshop/src/common/visualize.glsl","/home/runner/work/workshop/workshop/src/common/between.glsl","/home/runner/work/workshop/workshop/src/sdfs2d/vizz.glsl"],names:[],mappings:"AAAA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AC5IA;AACA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AChHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A7BlCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"}},9066:(A,n,e)=>{"use strict";e.r(n),e.d(n,{default:()=>o,sourceMap:()=>t});const o="#version 300 es\nprecision mediump float;\n\n// START ../common/banded.glsl\nfloat banded(float bandCount, float t) {\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\n}\nfloat banded(int bandCount, float t) {\n  return banded(float(bandCount), t);\n}\n\n// #pragma glslify: export(banded)\n\n\n// END ../common/banded.glsl\n// START ../common/between.glsl\nbool between(float min, float max, float value) {\n  return min <= value && value <= max;\n}\n\n// #pragma glslify: export(between)\n\n\n// END ../common/between.glsl\n// START ../common/hexFns.glsl\n// START ./max3.glsl\nfloat max3(float a, float b, float c) {\n  return max(a, max(b, c));\n}\nfloat max3(vec3 v) {\n  return max(v.x, max(v.y, v.z));\n}\n\n// #pragma glslify: export(max3)\n\n\n// END ./max3.glsl\n// START ./constants.glsl\nconst float SQRT1_2 = 0.7071067811865476;\nconst float SQRT1_3 = 0.57735026919;\nconst float SQRT2 = 1.4142135623730951;\nconst float SQRT3 = 1.732050807568877;\n// sqrt(3)/2 = sin(60*)\nconst float SQRT3_2 = 0.86602540378;\nconst float GOLDEN_RATIO = 1.61803398875;\nconst float PI = 3.141592653589793;\nconst float TAU = 6.28318530718;\n/**\n * One degree in radians. Use like `sin(30 * DEG)`.\n */\nconst float DEGREE = 0.017453292519943295;\n\n// END ./constants.glsl\n\nvec3 hexRound(vec3 hex) {\n  vec3 r = floor(hex + 0.5);\n  vec3 diff = abs(r - hex);\n\n  if (diff.x > diff.y && diff.x > diff.z) {\n    r.x = -(r.y + r.z);\n  } else if (diff.y > diff.z) {\n    r.y = -(r.x + r.z);\n  } else {\n    r.z = -(r.x + r.y);\n  }\n\n  return r;\n}\nvec2 hex2Ra(vec3 hex) {\n  float y = hex.t * SQRT3_2;\n  float x = hex.s + hex.t / 2.0;\n  return vec2(x, y);\n}\n\nfloat hexSdf(vec3 hex) {\n  return max3(abs(hex.yzx + hex.zxy / 2.0));\n}\nvec3 ra2Hex(vec2 xy) {\n  float hex_t = xy.y / SQRT3_2;\n  float hex_s = xy.x - hex_t / 2.0;\n  return vec3(hex_s, hex_t, -(hex_s + hex_t));\n}\n\n// END ../common/hexFns.glsl\n// START ../common/remix.glsl\n// START ./unmix.glsl\nfloat unmix(float a, float b, float value) {\n  return (value - a) / (b - a);\n}\n\n// #pragma glslify: export(unmix)\n\n\n// END ./unmix.glsl\n\nfloat remix(float fromA, float fromB, float toA, float toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\nvec4 remix(float fromA, float fromB, vec4 toA, vec4 toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\n// #pragma glslify: export(remix)\n\n\n// END ../common/remix.glsl\n// START ../common/simplex2DTexture.glsl\n// START ./triFns.glsl\n\n// (x, y) -> (u, v, R)\n// where u is horizontal, v is south-west to north-east\n// and R is wether the it is in the right triangle\nvec3 xy2tri(vec2 xy) {\n  float v = xy.y / SQRT3_2;\n  float u = xy.x - v / 2.0;\n  float R = float(\n    mod(u + v, 2.0) > 1.0 != (mod(floor(u) + floor(v), 2.0) == 1.0)\n  );\n  return vec3(u, v, R);\n}\nvec3 triCenter(vec3 uvR) {\n  vec3 base = floor(uvR);\n  vec2 centerOffset = mix(vec2(1.0 / 3.0), vec2(2.0 / 3.0), uvR.z);\n  return base + vec3(centerOffset, 0.0);\n}\nvec2 tri2xy(vec3 uvR) {\n  float y = uvR.t * SQRT3_2;\n  float x = uvR.s + uvR.t / 2.0;\n  return vec2(x, y);\n}\nvec2 tri2xy(vec2 uv) {\n  float y = uv.t * SQRT3_2;\n  float x = uv.s + uv.t / 2.0;\n  return vec2(x, y);\n}\nfloat triSdf(vec2 uv) {\n  vec3 hex = vec3(uv.x, uv.y, -uv.x - uv.y);\n  return max3(hex);\n}\n\n// END ./triFns.glsl\n\nuniform sampler2D gradients;\n\n/* Create random direction vector\n */\nvec2 randomGradient(vec2 i) {\n  // Random float. No precomputed gradients mean this works for any number of grid coordinates\n  float random =\n    2920.0 *\n    sin(float(i.x) * 2.1942 + float(i.y) * 1.71324 + 8.912) *\n    cos(float(i.x) * 2.3157 * float(i.y) * 2.17832 + 9.758);\n  //    random = (i.x + 1667.) * (i.x + 2083.) * (i.y + 2659.) * (i.y * 50.77 + .3769);\n  //    random = sin(SQRT2 * i.x) + cos(GOLDEN_RATIO * i.y) + tan((i.x + i.y) * SQRT3);\n  return vec2(cos(random), sin(random));\n}\n\nfloat dotGridGradient2(vec2 cell, vec2 pos) {\n  vec2 xy_d = cell - pos;\n  if (length(xy_d) > 0.45) return -0.0;\n  float r = 1.0;\n  float part = pow(max(0.0, 1.0 - dot(xy_d, xy_d)), 4.0);\n  //    vec2 gradient = texelFetch(gradients, ivec2(cell), 0).xy;\n  vec2 gradient = randomGradient(cell);\n  return part * dot(gradient, xy_d);\n}\n\n// resulting range is [-0.68, 0.68]. Use unmix to normalize if necessary.\nfloat simplex2D(vec2 xy) {\n  vec3 uvR = xy2tri(xy);\n  vec2 baseUV = floor(uvR.xy);\n\n  float a = dotGridGradient2(tri2xy(baseUV), xy);\n  float b = dotGridGradient2(tri2xy(baseUV + vec2(1, 0)), xy);\n  float c = dotGridGradient2(tri2xy(baseUV + vec2(0, 1)), xy);\n  float d = dotGridGradient2(tri2xy(baseUV + vec2(1, 1)), xy);\n\n  return b + c + mix(a, d, uvR.z);\n}\n\n// #pragma glslify: export(simplex2D)\n\n\n// END ../common/simplex2DTexture.glsl\n// START ../common/transform.glsl\nvec3 transform(mat4 pm, vec3 p) {\n  vec4 pStar = pm * vec4(p, 1);\n  return pStar.xyz / pStar.w;\n}\n\nvec2 transform(mat4 pm, vec2 p) {\n  vec4 pStar = pm * vec4(p, 0, 1);\n  return pStar.xy / pStar.w;\n}\n\n// END ../common/transform.glsl\n// START ../common/ungamma.glsl\nvec3 ungamma(vec4 col) {\n  return pow(col.rgb, vec3(2.2));\n}\nvec3 ungamma(vec3 col) {\n  return pow(col, vec3(2.2));\n}\n\n// END ../common/ungamma.glsl\n// START ../common/visualize.glsl\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\n  float isLow = float(t < 0.0);\n  float isHigh = float(t > 1.0);\n  float isMid = 1.0 - isLow - isHigh;\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\n}\n\nvec4 visualize(float t) {\n  const vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\n  const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\n  return visualize(BLUE, RED, t);\n}\n\n// #pragma glslify: export(visualize)\n\n\n// END ../common/visualize.glsl\n// START ../common/waves.glsl\nfloat waves(vec4 color, vec2 position, vec2 direction, float highResTimeStamp) {\n  return sin(\n    dot(position, direction / pow(length(direction), 2.0)) +\n      float(highResTimeStamp) / 200.0\n  );\n}\n\n// #pragma glslify: export(waves)\n\n\n// END ../common/waves.glsl\n\nin float n;\nin vec2 coord;\nout vec4 fragColor;\nuniform float a;\nuniform int bandCount;\nuniform mat4 viewModel;\nuniform sampler2D texture;\nuniform vec2 iResolution;\nuniform vec4 colorBackground;\nuniform vec4 colorPrimary;\nuniform vec4 colorSecondary;\n\nfloat simplex01(vec2 pos) {\n  return unmix(-0.68, 0.68, simplex2D(pos));\n}\n\nvoid main() {\n  vec2 fragCoord = transform(viewModel, coord * iResolution);\n  fragCoord *= 0.01;\n  //  fragCoord = coord;\n  float f = mix(simplex2D(fragCoord), simplex2D(fragCoord * 4.0), a);\n  float f2 = simplex2D(fragCoord);\n\n  vec3 color = mix(\n    ungamma(colorBackground),\n    ungamma(colorPrimary),\n    banded(bandCount, unmix(-0.35, 0.35, f2))\n  );\n  color = pow(color, vec3(1.0 / 2.2)); // gamma correction\n\n  //    fragColor = mix(fragColor, colorSecondary, float(between(0.0, 1., f)));\n  fragColor = vec4(color, 1);\n}\n",t={version:3,sources:["/home/runner/work/workshop/workshop/src/noises/simplex.frag","/home/runner/work/workshop/workshop/src/common/banded.glsl","/home/runner/work/workshop/workshop/src/common/between.glsl","/home/runner/work/workshop/workshop/src/common/max3.glsl","/home/runner/work/workshop/workshop/src/common/constants.glsl","/home/runner/work/workshop/workshop/src/common/hexFns.glsl","/home/runner/work/workshop/workshop/src/common/unmix.glsl","/home/runner/work/workshop/workshop/src/common/remix.glsl","/home/runner/work/workshop/workshop/src/common/triFns.glsl","/home/runner/work/workshop/workshop/src/common/simplex2DTexture.glsl","/home/runner/work/workshop/workshop/src/common/transform.glsl","/home/runner/work/workshop/workshop/src/common/ungamma.glsl","/home/runner/work/workshop/workshop/src/common/visualize.glsl","/home/runner/work/workshop/workshop/src/common/waves.glsl"],names:[],mappings:"AAAA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AbIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"}},6622:(A,n,e)=>{"use strict";e.r(n),e.d(n,{default:()=>o,sourceMap:()=>t});const o="#version 300 es\n\nprecision highp float;\n\n// START ../common/banded.glsl\nfloat banded(float bandCount, float t) {\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\n}\nfloat banded(int bandCount, float t) {\n  return banded(float(bandCount), t);\n}\n\n// #pragma glslify: export(banded)\n\n\n// END ../common/banded.glsl\n// START ../common/matrices.glsl\n// START ./constants.glsl\nconst float SQRT1_2 = 0.7071067811865476;\nconst float SQRT1_3 = 0.57735026919;\nconst float SQRT2 = 1.4142135623730951;\nconst float SQRT3 = 1.732050807568877;\n// sqrt(3)/2 = sin(60*)\nconst float SQRT3_2 = 0.86602540378;\nconst float GOLDEN_RATIO = 1.61803398875;\nconst float PI = 3.141592653589793;\nconst float TAU = 6.28318530718;\n/**\n * One degree in radians. Use like `sin(30 * DEG)`.\n */\nconst float DEGREE = 0.017453292519943295;\n\n// END ./constants.glsl\n\nmat2 rot2(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat2(c, s, -s, c);\n}\nmat3 rotX(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\n}\nmat3 rotY(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\n}\nmat3 rotZ(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\n}\n/**\n * Returns a matrix that puts the camera at the eye point `ex, ey, ez` looking\n * toward the center point `cx, cy, cz` with an up direction of `ux, uy, uz`.\n * This emulates the OpenGL function `gluLookAt()`.\n */\nmat4 lookAt(vec3 eye, vec3 focus, vec3 up) {\n  vec3 f = normalize(eye - focus);\n  vec3 s = normalize(cross(up, f));\n  vec3 t = normalize(cross(f, s));\n\n  return mat4(\n    vec4(s.x, t.x, f.x, 0.0),\n    vec4(s.y, t.y, f.y, 0.0),\n    vec4(s.z, t.z, f.z, 0.0),\n    vec4(-dot(s, eye), -dot(t, eye), -dot(f, eye), 1)\n  );\n}\n\n// the OpenGL function `glFrustum()`.\nmat4 frustum(\n  float left,\n  float right,\n  float bottom,\n  float top,\n  float near,\n  float far\n) {\n  return mat4(\n    vec4(2.0 * near / (right - left), 0.0, 0.0, 0.0),\n    vec4(0, 2.0 * near / (top - bottom), 0.0, 0.0),\n    vec4(\n      (right + left) / (right - left),\n      (top + bottom) / (top - bottom),\n      -(far + near) / (far - near),\n      -1\n    ),\n    vec4(0.0, 0.0, -2.0 * far * near / (far - near), 0.0)\n  );\n}\n\nmat4 perspective(float fovDegrees, float aspect, float near, float far) {\n  float y = tan(fovDegrees * DEGREE / 2.0) * near;\n  float x = y * aspect;\n  return frustum(-x, x, -y, y, near, far);\n}\nmat4 ortho(\n  float left,\n  float right,\n  float bottom,\n  float top,\n  float near,\n  float far\n) {\n  return mat4(\n    vec4(2.0 / (right - left), 0.0, 0.0, 0.0),\n    vec4(0.0, 2.0 / (top - bottom), 0.0, 0.0),\n    vec4(0.0, 0.0, -2.0 / (far - near), 0.0),\n    vec4(\n      -(right + left) / (right - left),\n      -(top + bottom) / (top - bottom),\n      -(far + near) / (far - near),\n      1.0\n    )\n  );\n}\n\n// END ../common/matrices.glsl\n// START ../common/max3.glsl\nfloat max3(float a, float b, float c) {\n  return max(a, max(b, c));\n}\nfloat max3(vec3 v) {\n  return max(v.x, max(v.y, v.z));\n}\n\n// #pragma glslify: export(max3)\n\n\n// END ../common/max3.glsl\n// START ../common/visualize.glsl\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\n  float isLow = float(t < 0.0);\n  float isHigh = float(t > 1.0);\n  float isMid = 1.0 - isLow - isHigh;\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\n}\n\nvec4 visualize(float t) {\n  const vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\n  const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\n  return visualize(BLUE, RED, t);\n}\n\n// #pragma glslify: export(visualize)\n\n\n// END ../common/visualize.glsl\n// START ../common/polar.glsl\n// START ../common/fromPolar.glsl\n// START ./unmix.glsl\nfloat unmix(float a, float b, float value) {\n  return (value - a) / (b - a);\n}\n\n// #pragma glslify: export(unmix)\n\n\n// END ./unmix.glsl\n\nvec3 fromPolar(float radius, float phi, float z) {\n  return vec3(radius * cos(phi), radius * sin(phi), z);\n}\n\nvec2 fromPolar(float radius, float phi) {\n  return vec2(radius * cos(phi), radius * sin(phi));\n}\n\nvec2 fromPolar(vec2 polar) {\n  return fromPolar(polar.x, polar.y);\n}\n\n// #pragma glslify: export(fromPolar)\n\n\n// END ../common/fromPolar.glsl\n// START ../common/toPolar.glsl\n\nvec2 toPolar(vec2 xy) {\n  return vec2(length(xy), atan(xy.y, xy.x));\n}\n\nmat2 toPolarDerivate(vec2 xy) {\n  return mat2(xy.x * xy.x, xy.y * xy.y, -xy.y, xy.x) / dot(xy, xy);\n}\n\n// #pragma glslify: export(toPolar)\n\n\n// END ../common/toPolar.glsl\n\n// END ../common/polar.glsl\n// START ../common/ungamma.glsl\nvec3 ungamma(vec4 col) {\n  return pow(col.rgb, vec3(2.2));\n}\nvec3 ungamma(vec3 col) {\n  return pow(col, vec3(2.2));\n}\n\n// END ../common/ungamma.glsl\n// START ../common/transform.glsl\nvec3 transform(mat4 pm, vec3 p) {\n  vec4 pStar = pm * vec4(p, 1);\n  return pStar.xyz / pStar.w;\n}\n\nvec2 transform(mat4 pm, vec2 p) {\n  vec4 pStar = pm * vec4(p, 0, 1);\n  return pStar.xy / pStar.w;\n}\n\n// END ../common/transform.glsl\n// START ../common/OpenSimplex2.glsl\n//////////////// K.jpg's Re-oriented 4-Point BCC Noise (OpenSimplex2) ////////////////\n////////////////////// Output: vec4(dF/dx, dF/dy, dF/dz, value) //////////////////////\n\n// Inspired by Stefan Gustavson's noise\nvec4 permute(vec4 t) {\n  return t * (t * 34.0 + 133.0);\n}\n\n// Gradient set is a normalized expanded rhombic dodecahedron\nvec3 grad(float hash) {\n  // Random vertex of a cube, +/- 1 each\n  vec3 cube = mod(floor(hash / vec3(1.0, 2.0, 4.0)), 2.0) * 2.0 - 1.0;\n\n  // Random edge of the three edges connected to that vertex\n  // Also a cuboctahedral vertex\n  // And corresponds to the face of its dual, the rhombic dodecahedron\n  vec3 cuboct = cube;\n  cuboct[int(hash / 16.0)] = 0.0;\n\n  // In a funky way, pick one of the four points on the rhombic face\n  float type = mod(floor(hash / 8.0), 2.0);\n  vec3 rhomb = (1.0 - type) * cube + type * (cuboct + cross(cube, cuboct));\n\n  // Expand it so that the new edges are the same length\n  // as the existing ones\n  vec3 grad = cuboct * 1.22474487139 + rhomb;\n\n  // To make all gradients the same length, we only need to shorten the\n  // second type of vector. We also put in the whole noise scale constant.\n  // The compiler should reduce it into the existing floats. I think.\n  grad *= (1.0 - 0.042942436724648037 * type) * 32.80201376986577;\n\n  return grad;\n}\n\n// BCC lattice split up into 2 cube lattices\nvec4 openSimplex2Base(vec3 X) {\n  // First half-lattice, closest edge\n  vec3 v1 = round(X);\n  vec3 d1 = X - v1;\n  vec3 score1 = abs(d1);\n  vec3 dir1 = step(max(score1.yzx, score1.zxy), score1);\n  vec3 v2 = v1 + dir1 * sign(d1);\n  vec3 d2 = X - v2;\n\n  // Second half-lattice, closest edge\n  vec3 X2 = X + 144.5;\n  vec3 v3 = round(X2);\n  vec3 d3 = X2 - v3;\n  vec3 score2 = abs(d3);\n  vec3 dir2 = step(max(score2.yzx, score2.zxy), score2);\n  vec3 v4 = v3 + dir2 * sign(d3);\n  vec3 d4 = X2 - v4;\n\n  // Gradient hashes for the four points, two from each half-lattice\n  vec4 hashes = permute(mod(vec4(v1.x, v2.x, v3.x, v4.x), 289.0));\n  hashes = permute(mod(hashes + vec4(v1.y, v2.y, v3.y, v4.y), 289.0));\n  hashes = mod(\n    permute(mod(hashes + vec4(v1.z, v2.z, v3.z, v4.z), 289.0)),\n    48.0\n  );\n\n  // Gradient extrapolations & kernel function\n  vec4 a = max(\n    0.5 - vec4(dot(d1, d1), dot(d2, d2), dot(d3, d3), dot(d4, d4)),\n    0.0\n  );\n  vec4 aa = a * a;\n  vec4 aaaa = aa * aa;\n  vec3 g1 = grad(hashes.x);\n  vec3 g2 = grad(hashes.y);\n  vec3 g3 = grad(hashes.z);\n  vec3 g4 = grad(hashes.w);\n  vec4 extrapolations = vec4(\n    dot(d1, g1),\n    dot(d2, g2),\n    dot(d3, g3),\n    dot(d4, g4)\n  );\n\n  // Derivatives of the noise\n  vec3 derivative =\n    -8.0 * mat4x3(d1, d2, d3, d4) * (aa * a * extrapolations) +\n    mat4x3(g1, g2, g3, g4) * aaaa;\n\n  // Return it all as a vec4\n  return vec4(derivative, dot(aaaa, extrapolations));\n}\n\n// Use this if you don't want Z to look different from X and Y\nvec4 openSimplex2_Conventional(vec3 X) {\n  // Rotate around the main diagonal. Not a skew transform.\n  vec4 result = openSimplex2Base(dot(X, vec3(2.0 / 3.0)) - X);\n  return vec4(dot(result.xyz, vec3(2.0 / 3.0)) - result.xyz, result.w);\n}\n\n// Use this if you want to show X and Y in a plane, then use Z for time, vertical, etc.\nvec4 openSimplex2_ImproveXY(vec3 X) {\n  // Rotate so Z points down the main diagonal. Not a skew transform.\n  mat3 orthonormalMap = mat3(\n    vec3(0.788675134594813, -0.211324865405187, -0.577350269189626),\n    vec3(-0.211324865405187, 0.788675134594813, -0.577350269189626),\n    vec3(0.577350269189626, 0.577350269189626, 0.577350269189626)\n  );\n\n  vec4 result = openSimplex2Base(orthonormalMap * X);\n  return vec4(result.xyz * orthonormalMap, result.w);\n}\n\n//////////////////////////////// End noise code ////////////////////////////////\n\n\n// END ../common/OpenSimplex2.glsl\n// START ../common/checkerboardGrad.glsl\n//https://iquilezles.org/articles/checkerfiltering/\nfloat tri(float x) {\n  float h = fract(x * 0.5) - 0.5;\n  return 1.0 - 2.0 * abs(h);\n}\nvec2 tri(vec2 x) {\n  vec2 h = fract(x * 0.5) - 0.5;\n  return 1.0 - 2.0 * abs(h);\n}\n\nfloat checkerboardGrad(vec2 uv) {\n  vec2 w = max(abs(dFdx(uv)), abs(dFdy(uv))) + 0.01; // filter kernel\n  vec2 i = (tri(uv + 0.5 * w) - tri(uv - 0.5 * w)) / w; // analytical integral (box filter)\n  return 0.5 - 0.5 * i.x * i.y; // xor pattern\n}\n\n// END ../common/checkerboardGrad.glsl\n// START ../common/colors.glsl\nconst vec3 INDIAN_RED = vec3(0.804, 0.361, 0.361);\nconst vec3 LIGHT_CORAL = vec3(0.941, 0.502, 0.502);\nconst vec3 SALMON = vec3(0.98, 0.502, 0.447);\nconst vec3 DARK_SALMON = vec3(0.914, 0.588, 0.478);\nconst vec3 LIGHT_SALMON = vec3(1.0, 0.627, 0.478);\nconst vec3 CRIMSON = vec3(0.863, 0.078, 0.235);\nconst vec3 RED = vec3(1.0, 0.0, 0.0);\nconst vec3 FIRE_BRICK = vec3(0.698, 0.133, 0.133);\nconst vec3 DARK_RED = vec3(0.545, 0.0, 0.0);\nconst vec3 PINK = vec3(1.0, 0.753, 0.796);\nconst vec3 LIGHT_PINK = vec3(1.0, 0.714, 0.757);\nconst vec3 HOT_PINK = vec3(1.0, 0.412, 0.706);\nconst vec3 DEEP_PINK = vec3(1.0, 0.078, 0.576);\nconst vec3 MEDIUM_VIOLET_RED = vec3(0.78, 0.082, 0.522);\nconst vec3 PALE_VIOLET_RED = vec3(0.859, 0.439, 0.576);\nconst vec3 CORAL = vec3(1.0, 0.498, 0.314);\nconst vec3 TOMATO = vec3(1.0, 0.388, 0.278);\nconst vec3 ORANGE_RED = vec3(1.0, 0.271, 0.0);\nconst vec3 DARK_ORANGE = vec3(1.0, 0.549, 0.0);\nconst vec3 ORANGE = vec3(1.0, 0.647, 0.0);\nconst vec3 GOLD = vec3(1.0, 0.843, 0.0);\nconst vec3 YELLOW = vec3(1.0, 1.0, 0.0);\nconst vec3 LIGHT_YELLOW = vec3(1.0, 1.0, 0.878);\nconst vec3 LEMON_CHION = vec3(1.0, 0.98, 0.804);\nconst vec3 LIGHT_GOLDENROD_YELLOW = vec3(0.98, 0.98, 0.824);\nconst vec3 PAPAYA_WHIP = vec3(1.0, 0.937, 0.835);\nconst vec3 MOCCASIN = vec3(1.0, 0.894, 0.71);\nconst vec3 PEACH_PU = vec3(1.0, 0.855, 0.725);\nconst vec3 PALE_GOLDENROD = vec3(0.933, 0.91, 0.667);\nconst vec3 KHAKI = vec3(0.941, 0.902, 0.549);\nconst vec3 DARK_KHAKI = vec3(0.741, 0.718, 0.42);\nconst vec3 LAVENDER = vec3(0.902, 0.902, 0.98);\nconst vec3 THISTLE = vec3(0.847, 0.749, 0.847);\nconst vec3 PLUM = vec3(0.867, 0.627, 0.867);\nconst vec3 VIOLET = vec3(0.933, 0.51, 0.933);\nconst vec3 ORCHID = vec3(0.855, 0.439, 0.839);\nconst vec3 FUCHSIA = vec3(1.0, 0.0, 1.0);\nconst vec3 MAGENTA = vec3(1.0, 0.0, 1.0);\nconst vec3 MEDIUM_ORCHID = vec3(0.729, 0.333, 0.827);\nconst vec3 MEDIUM_PURPLE = vec3(0.576, 0.439, 0.859);\nconst vec3 BLUE_VIOLET = vec3(0.541, 0.169, 0.886);\nconst vec3 DARK_VIOLET = vec3(0.58, 0.0, 0.827);\nconst vec3 DARK_ORCHID = vec3(0.6, 0.196, 0.8);\nconst vec3 DARK_MAGENTA = vec3(0.545, 0.0, 0.545);\nconst vec3 PURPLE = vec3(0.502, 0.0, 0.502);\nconst vec3 INDIGO = vec3(0.294, 0.0, 0.51);\nconst vec3 SLATE_BLUE = vec3(0.416, 0.353, 0.804);\nconst vec3 DARK_SLATE_BLUE = vec3(0.282, 0.239, 0.545);\nconst vec3 GREEN_YELLOW = vec3(0.678, 1.0, 0.184);\nconst vec3 CHARTREUSE = vec3(0.498, 1.0, 0.0);\nconst vec3 LAWN_GREEN = vec3(0.486, 0.988, 0.0);\nconst vec3 LIME = vec3(0.0, 1.0, 0.0);\nconst vec3 LIME_GREEN = vec3(0.196, 0.804, 0.196);\nconst vec3 PALE_GREEN = vec3(0.596, 0.984, 0.596);\nconst vec3 LIGHT_GREEN = vec3(0.565, 0.933, 0.565);\nconst vec3 MEDIUM_SPRING_GREEN = vec3(0.0, 0.98, 0.604);\nconst vec3 SPRING_GREEN = vec3(0.0, 1.0, 0.498);\nconst vec3 MEDIUM_SEA_GREEN = vec3(0.235, 0.702, 0.443);\nconst vec3 SEA_GREEN = vec3(0.18, 0.545, 0.341);\nconst vec3 FOREST_GREEN = vec3(0.133, 0.545, 0.133);\nconst vec3 GREEN = vec3(0.0, 0.502, 0.0);\nconst vec3 DARK_GREEN = vec3(0.0, 0.392, 0.0);\nconst vec3 YELLOW_GREEN = vec3(0.604, 0.804, 0.196);\nconst vec3 OLIVE_DRAB = vec3(0.42, 0.557, 0.137);\nconst vec3 OLIVE = vec3(0.502, 0.502, 0.0);\nconst vec3 DARK_OLIVE_GREEN = vec3(0.333, 0.42, 0.184);\nconst vec3 MEDIUM_AQUAMARINE = vec3(0.4, 0.804, 0.667);\nconst vec3 DARK_SEA_GREEN = vec3(0.561, 0.737, 0.561);\nconst vec3 LIGHT_SEA_GREEN = vec3(0.125, 0.698, 0.667);\nconst vec3 DARK_CYAN = vec3(0.0, 0.545, 0.545);\nconst vec3 TEAL = vec3(0.0, 0.502, 0.502);\nconst vec3 AQUA = vec3(0.0, 1.0, 1.0);\nconst vec3 CYAN = vec3(0.0, 1.0, 1.0);\nconst vec3 LIGHT_CYAN = vec3(0.878, 1.0, 1.0);\nconst vec3 PALE_TURQUOISE = vec3(0.686, 0.933, 0.933);\nconst vec3 AQUAMARINE = vec3(0.498, 1.0, 0.831);\nconst vec3 TURQUOISE = vec3(0.251, 0.878, 0.816);\nconst vec3 MEDIUM_TURQUOISE = vec3(0.282, 0.82, 0.8);\nconst vec3 DARK_TURQUOISE = vec3(0.0, 0.808, 0.82);\nconst vec3 CADET_BLUE = vec3(0.373, 0.62, 0.627);\nconst vec3 STEEL_BLUE = vec3(0.275, 0.51, 0.706);\nconst vec3 LIGHT_STEEL_BLUE = vec3(0.69, 0.769, 0.871);\nconst vec3 POWDER_BLUE = vec3(0.69, 0.878, 0.902);\nconst vec3 LIGHT_BLUE = vec3(0.678, 0.847, 0.902);\nconst vec3 SKY_BLUE = vec3(0.529, 0.808, 0.922);\nconst vec3 LIGHT_SKY_BLUE = vec3(0.529, 0.808, 0.98);\nconst vec3 DEEP_SKY_BLUE = vec3(0.0, 0.749, 1.0);\nconst vec3 DODGER_BLUE = vec3(0.118, 0.565, 1.0);\nconst vec3 CORNLOWER_BLUE = vec3(0.392, 0.584, 0.929);\nconst vec3 MEDIUM_SLATE_BLUE = vec3(0.482, 0.408, 0.933);\nconst vec3 ROYAL_BLUE = vec3(0.255, 0.412, 0.882);\nconst vec3 BLUE = vec3(0.0, 0.0, 1.0);\nconst vec3 MEDIUM_BLUE = vec3(0.0, 0.0, 0.804);\nconst vec3 DARK_BLUE = vec3(0.0, 0.0, 0.545);\nconst vec3 NAVY = vec3(0.0, 0.0, 0.502);\nconst vec3 MIDNIGHT_BLUE = vec3(0.098, 0.098, 0.439);\nconst vec3 CORNSILK = vec3(1.0, 0.973, 0.863);\nconst vec3 BLANCHED_ALMOND = vec3(1.0, 0.922, 0.804);\nconst vec3 BISQUE = vec3(1.0, 0.894, 0.769);\nconst vec3 NAVAJO_WHITE = vec3(1.0, 0.871, 0.678);\nconst vec3 WHEAT = vec3(0.961, 0.871, 0.702);\nconst vec3 BURLY_WOOD = vec3(0.871, 0.722, 0.529);\nconst vec3 TAN = vec3(0.824, 0.706, 0.549);\nconst vec3 ROSY_BROWN = vec3(0.737, 0.561, 0.561);\nconst vec3 SANDY_BROWN = vec3(0.957, 0.643, 0.376);\nconst vec3 GOLDENROD = vec3(0.855, 0.647, 0.125);\nconst vec3 DARK_GOLDENROD = vec3(0.722, 0.525, 0.043);\nconst vec3 PERU = vec3(0.804, 0.522, 0.247);\nconst vec3 CHOCOLATE = vec3(0.824, 0.412, 0.118);\nconst vec3 SADDLE_BROWN = vec3(0.545, 0.271, 0.075);\nconst vec3 SIENNA = vec3(0.627, 0.322, 0.176);\nconst vec3 BROWN = vec3(0.647, 0.165, 0.165);\nconst vec3 MAROON = vec3(0.502, 0.0, 0.0);\nconst vec3 WHITE = vec3(1.0, 1.0, 1.0);\nconst vec3 SNOW = vec3(1.0, 0.98, 0.98);\nconst vec3 HONEYDEW = vec3(0.941, 1.0, 0.941);\nconst vec3 MINT_CREAM = vec3(0.961, 1.0, 0.98);\nconst vec3 AZURE = vec3(0.941, 1.0, 1.0);\nconst vec3 ALICE_BLUE = vec3(0.941, 0.973, 1.0);\nconst vec3 GHOST_WHITE = vec3(0.973, 0.973, 1.0);\nconst vec3 WHITE_SMOKE = vec3(0.961, 0.961, 0.961);\nconst vec3 SEASHELL = vec3(1.0, 0.961, 0.933);\nconst vec3 BEIGE = vec3(0.961, 0.961, 0.863);\nconst vec3 OLD_LACE = vec3(0.992, 0.961, 0.902);\nconst vec3 FLORAL_WHITE = vec3(1.0, 0.98, 0.941);\nconst vec3 IVORY = vec3(1.0, 1.0, 0.941);\nconst vec3 ANTIQUE_WHITE = vec3(0.98, 0.922, 0.843);\nconst vec3 LINEN = vec3(0.98, 0.941, 0.902);\nconst vec3 LAVENDER_BLUSH = vec3(1.0, 0.941, 0.961);\nconst vec3 MISTY_ROSE = vec3(1.0, 0.894, 0.882);\nconst vec3 GAINSBORO = vec3(0.863, 0.863, 0.863);\nconst vec3 LIGHT_GREY = vec3(0.827, 0.827, 0.827);\nconst vec3 SILVER = vec3(0.753, 0.753, 0.753);\nconst vec3 DARK_GRAY = vec3(0.663, 0.663, 0.663);\nconst vec3 GRAY = vec3(0.502, 0.502, 0.502);\nconst vec3 DIM_GRAY = vec3(0.412, 0.412, 0.412);\nconst vec3 LIGHT_SLATE_GRAY = vec3(0.467, 0.533, 0.6);\nconst vec3 SLATE_GRAY = vec3(0.439, 0.502, 0.565);\nconst vec3 DARK_SLATE_GRAY = vec3(0.184, 0.31, 0.31);\nconst vec3 BLACK = vec3(0.0, 0.0, 0.0);\n\n// END ../common/colors.glsl\n// START ../common/sdf3d/sdIcosahedron.glsl\n\n// signed distance function for icosahedron\n// cf. https://en.wikipedia.org/wiki/Regular_icosahedron\n// s: edge length\n// p: point to evaluate function for\nfloat sdIcosahedron(float s, vec3 p) {\n  // NN = 1/GOLDEN_RATIO = GOLDEN_RATIO - 1\n  const float K = GOLDEN_RATIO * 0.5;\n  // the three vertices of the icosahedron triangle which\n  // is fully inside the +++ octant. (edge length = 1)\n  const vec3 a = vec3(0.5, K, 0.0);\n  const vec3 b = vec3(0.0, 0.5, K);\n  const vec3 c = vec3(K, 0.0, 0.5);\n  const vec3 ab1 = b - a; // values chosen so edge length is 1\n  const vec3 n1 = normalize(cross(a, b));\n  const vec3 n2 = normalize(cross(b, c));\n  const vec3 n3 = normalize(cross(c, a));\n  const vec3 xyz1 = normalize(vec3(1.0));\n  // for edge-length 1\n  const float INSCRIBED_SPHERE_RADIUS = 0.7557613141;\n\n  // we use a rotation where the icosahedron is symmetric\n  // in all three coordinate planes, and reduce the problem\n  // to the +++ octant\n  p = abs(p);\n\n  // there is one complete triangle in the +++ octant\n  // mirror on planes which go through origin and the\n  // complete triangles sides.\n  if (dot(p, n1) < 0.0) {\n    p += -2.0 * dot(p, n1) * n1;\n  }\n  if (dot(p, n2) < 0.0) {\n    p += -2.0 * dot(p, n2) * n2;\n  }\n  if (dot(p, n3) < 0.0) {\n    p += -2.0 * dot(p, n3) * n3;\n  }\n\n  // rotate space around (1,1,1) vector so that all sides of the triangle\n  // end up mapped on the ab side.\n  vec3 dirs = vec3(-dot(n1, p), -dot(n2, p), -dot(n3, p));\n  if (dirs.y > dirs.x && dirs.y > dirs.z) {\n    p = p.yzx;\n  } else if (dirs.z > dirs.x && dirs.z > dirs.y) {\n    p = p.zxy;\n  }\n\n  // check if the point is directly (perpendicular) above the triangle.\n  // as we have rotated the space, we only need to check if it is\n  // inside one edge.\n  vec3 midAB = (a + b) / 2.0;\n  vec3 pn = normalize(c - midAB);\n  float w = dot(midAB, pn);\n  if (dot(p, pn) > w * s) {\n    // if not, return the distance to the plane the triangle is in\n    return dot(xyz1, p) - INSCRIBED_SPHERE_RADIUS * s;\n  }\n\n  // project the point onto segment ab, and return the distance to it\n  float d3 = dot(ab1, p);\n  d3 = clamp(d3, -0.5 * s, 0.5 * s);\n  vec3 closestp = midAB * s + d3 * ab1;\n  return distance(closestp, p);\n}\n// #pragma glslify: export(sdIcosahedron)\n\n// END ../common/sdf3d/sdIcosahedron.glsl\n// START ../common/sdf3d/sdDodecahedron.glsl\n\nfloat sdDodecahedron(float s, vec3 p, out vec3 color) {\n  const float PHI = GOLDEN_RATIO;\n  color = vec3(0.2);\n  if (p != abs(p)) {\n    p = abs(p);\n    if (color == vec3(0.2)) color = RED;\n  }\n  p = abs(p);\n  const vec3 fv =\n    vec3(1.0 / PHI, 0, PHI) + 2.0 * vec3(1, 0, 1) + 2.0 * vec3(PHI, 0, 0);\n  const vec3 fv2 =\n    vec3(PHI, 1.0 / PHI, 0) + 2.0 * vec3(1, 1, 0) + 2.0 * vec3(0, PHI, 0);\n  const vec3 fv3 =\n    vec3(0, PHI, 1.0 / PHI) + 2.0 * vec3(0, 1, 1) + 2.0 * vec3(0, 0, PHI);\n  return max3(\n    dot(normalize(fv), p),\n    dot(normalize(fv2), p),\n    dot(normalize(fv3), p)\n  ) -\n  s;\n  //  float m = p.x + p.y + p.z - s;\n  //  vec3 q;\n  //  if (3.0 * p.x < m) q = p.xyz;\n  //  else if (3.0 * p.y < m) q = p.yzx;\n  //  else if (3.0 * p.z < m) q = p.zxy;\n  //  else return m * 0.57735027;\n  //\n  //  float k = clamp(0.5 * (q.z - q.y + s), 0.0, s);\n  //  return length(vec3(q.x, q.y - s + k, q.z - k));\n}\nfloat sdDodecahedron(float s, vec3 p) {\n  vec3 c;\n  return sdDodecahedron(s, p, c);\n}\n\n// END ../common/sdf3d/sdDodecahedron.glsl\n// START ../common/sdf3d/sdLego.glsl\n// START ./sdCylinder.glsl\nfloat sdCylinder(float radius, float z, vec3 p) {\n  vec2 d = vec2(length(p.xy), abs(p.z)) - vec2(radius, z);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// #pragma glslify: export(sdCylinder)\n\n\n// END ./sdCylinder.glsl\n// START ./sdTube.glsl\nfloat sdTube(float radius, float r2, float z, vec3 p) {\n  vec2 d = vec2(length(p.xy), abs(p.z)) - vec2(radius, z);\n  d.x = abs(d.x) - r2;\n  vec2 closest = vec2(abs(d.x - radius) - r2, clamp(d.y, 0.0, z));\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// END ./sdTube.glsl\n// START ./sdBox.glsl\n\nfloat sdBox(vec3 r, vec3 p) {\n  vec3 q = abs(p) - r;\n  return length(max(q, 0.0)) + min(max3(q), 0.0);\n}\n\nfloat sdBox(vec3 r, float r2, vec3 p) {\n  return sdBox(r - r2, p) - r2;\n}\n\n// #pragma glslify: export(sdBox)\n\n\n// END ./sdBox.glsl\n\nfloat sdLego(vec3 p) {\n  const float IWALLT = 0.04;\n  p.xy = abs(p.xy);\n  vec2 c = vec2(4.0, 2.0);\n  //    p.xy = mod(p.xy + c * 0.5, c) - c * 0.5;\n  p -= vec3(0.0, 0.0, 0.6);\n  float d;\n  const float cr = 0.02;\n  d = sdBox(vec3(2.0, 1.0, 0.6), cr, p);\n  if (d > 0.5) {\n    return d;\n  }\n  //    top studs\n  vec3 p8 = vec3(abs(p.xy - vec2(1.0, 0.0)), p.z) - vec3(0.5, 0.5, 0.6);\n  float dStuds = sdCylinder(0.35 - 0.04, 0.2, p8) - 0.04;\n  d = min(d, dStuds);\n  // little holes in bottom of studs\n  float dStudHoles = sdCylinder(0.2 - 0.04, 0.3, p8 - vec3(0, 0, -0.4)) - 0.04;\n  d = max(d, -dStudHoles);\n  // TODO use sdf texture to add LEGO or custom logo to studs\n\n  // hole in the bottom\n  const float WALLT = 4.0 * IWALLT;\n  float dBottom = sdBox(\n    vec3(2.0 - WALLT, 1.0 - WALLT, 0.6),\n    p - vec3(0, 0, -WALLT)\n  );\n  d = max(d, -dBottom);\n\n  // 12 indentations on inside.\n  vec3 pa = p;\n  // 3. move by 1 in X dir\n  pa.x -= 1.0;\n  // 2. mirror across XY axis\n  if (pa.x > pa.y) pa.xy = pa.yx;\n  // 1. mirror across Y axis\n  pa.x = abs(pa.x);\n  float k = sdBox(vec3(0.5 * IWALLT, 0.05, 0.6), pa - vec3(0.5, 0.8, 0));\n  d = min(d, k);\n\n  // center bar\n  p = vec3(abs(p.xy), p.z);\n  d = min(d, sdBox(vec3(0.5 * IWALLT, 0.3, 0.5), p - vec3(0, 0.65, 0.1)));\n\n  // 3 tubes\n  vec3 pTube = p;\n  if (pTube.x > 0.5) pTube.x -= 1.0;\n  pTube.x = abs(pTube.x);\n  d = min(d, sdTube(0.35 + 0.5 * IWALLT, 0.5 * IWALLT, 0.6, pTube));\n  return d;\n}\n\n// END ../common/sdf3d/sdLego.glsl\n// START ../common/sdf3d/sdOctahedron.glsl\nfloat sdOctahedron(float s, vec3 p) {\n  p = abs(p);\n  float m = p.x + p.y + p.z - s;\n  vec3 q;\n  if (3.0 * p.x < m) q = p.xyz;\n  else if (3.0 * p.y < m) q = p.yzx;\n  else if (3.0 * p.z < m) q = p.zxy;\n  else return m * 0.57735027;\n\n  float k = clamp(0.5 * (q.z - q.y + s), 0.0, s);\n  return length(vec3(q.x, q.y - s + k, q.z - k));\n}\n// #pragma glslify: export(sdOctahedron)\n\nfloat sdOctahedron(vec3 p, float s) {\n  p = abs(p);\n\n  float m = p.x + p.y + p.z - s;\n  //find point on octohedron surf nearest to p\n  vec3 projPoint = p - vec3(0.333333 * m); //project onto surface plane\n  //now push projected point, if outside triangle edge, perpendicular to edge, to edge\n  vec3 toMove = min(projPoint, 0.0); //if projpoint.x<0 move along (1.0,-0.5,-0.5) , etc\n  float toMoveSum = dot(toMove, vec3(1.0)); //which is basically along (1.5,0,0) then vec3(-0.5)\n\n  vec3 movedPoint = projPoint + toMove * vec3(-1.5) + toMoveSum * vec3(0.5); //better to multiply toMove by a matrix (1s diagonal, 0.5 other)?\n\n  movedPoint = max(movedPoint, 0.0); //cap x,y,z to 0 then\n  movedPoint *= s / dot(movedPoint, vec3(1.0)); //scale about 0,0,0\n\n  return length(p - movedPoint);\n}\n\n// END ../common/sdf3d/sdOctahedron.glsl\n// START ../common/sdf3d/sdArrow.glsl\n// START ./sdCone.glsl\n\n/**\n * Signed distance function (SDF) of a cone. The tip of the cone is at the\n * origin and points towards +Z. q is a point on the rim of the cone.\n */\nfloat sdCone(vec2 c, float h, vec3 p) {\n  vec2 q = h * vec2(c.x / c.y, -1.0);\n  vec2 w = vec2(length(p.xz), p.y);\n  vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);\n  vec2 b = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0);\n  float k = sign(q.y);\n  float d = min(dot(a, a), dot(b, b));\n  float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));\n  return sqrt(d) * sign(s);\n}\n// #pragma glslify: export(sdBox)\n\nfloat sdConeB(vec2 c, float h, vec3 p) {\n  float q = length(p.xz);\n  return max(dot(c.xy, vec2(q, p.y)), -h - p.y);\n}\n\n// END ./sdCone.glsl\nvec3 perpendicularVector(vec3 a) {\n  return cross(a, abs(a.z) > abs(a.x) ? vec3(0, 0, 1) : vec3(0, 1, 0));\n}\n/**\n * Signed distance function (SDF) of an arrow. The arrow goes along the X axis.\n * The shaft of the arrow has thickness TODO. The tip of the arrow has 30Â°\n * angle, length of TODO, with the widest point being.\n */\nfloat sdArrow(float length, vec3 p) {\n  float r = 0.01;\n  return min(\n    sdCylinder(\n      0.02 - r,\n      0.5 * (length - 0.1) - r,\n      p.yzx - vec3(0, 0, 0.5 * (length - 0.1))\n    ) -\n      r,\n    sdCone(\n      vec2(sin(15.0 * DEGREE), cos(15.0 * DEGREE)),\n      0.15 - r,\n      p.zxy - vec3(0, length - r, 0)\n    ) -\n      r\n  );\n}\nfloat sdArrow(vec3 a, vec3 b, vec3 p) {\n  vec3 x = normalize(b - a);\n  vec3 y = normalize(perpendicularVector(x));\n  vec3 z = cross(x, y);\n  return sdArrow(length(b - a), inverse(mat3(x, y, z)) * (p - a));\n}\n\n// END ../common/sdf3d/sdArrow.glsl\n// START ../common/sdf3d/sdTetrahedron.glsl\n// START ./sdCapsule.glsl\nfloat sdCapsule(vec3 a, vec3 b, float r, vec3 p) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h) - r;\n}\n// #pragma glslify: export(sdCapsule)\n\n// END ./sdCapsule.glsl\n\n/**\n * Signed distance function (SDF) of a tetrahedron centered at the origin with\n * side length `2s`.\n *\n * The corners are at `a/b = (+-1,0,sqrt(1/2))` and `c/d = (0,+-1,-sqrt(1/2))`.\n *\n * The side length is `||`\n *\n * The outscribed sphere has a radius of `sqrt(3/2)`.\n *\n * The inscribed sphere has a radius of `sqrt(1/6)`. This is calculated using\n * the fact that the triangle defined by `mid(a,b) = (0,0,sqrt(1/2))`, `c` and\n * `mid(c,d) = (0,0,-sqrt(1/2))` is similar to the triangle `mid(a,b)`, `q`, and\n * `O`.\n *\n * For rounded edges, use TODO.\n *\n * ```\n *           ^ Z\n *           |(+-1, sqrt(1/2))\n *          /\\_\n *        /    \\.q = closest point to center on face\n *      /    .   \\__> Y\n *    /            \\_\n *  /________________\\_(0,-1,sqrt(1/2))\n * (0,-1,-sqrt(1/2))\n * ```\n */\nfloat sdTetrahedron(float s, vec3 p) {\n  const vec3 a = vec3(1, 0, SQRT1_2);\n  const vec3 b = vec3(-1, 0, SQRT1_2);\n  const vec3 c = vec3(0, 1, -SQRT1_2);\n  const vec3 d = vec3(0, -1, -SQRT1_2);\n  const vec3 midBC = 0.5 * (b + c);\n  const vec3 mirror = normalize(cross(midBC - d, midBC - a));\n\n  // Tetra is symmetric in X and Y axes. RED surface in image.\n  p.xy = abs(p.xy);\n  // The part z < 0 is symmetric if we rotate it by 90Â°. BLUE surface in image.\n  if (p.z < 0.0) {\n    p = vec3(p.y, p.x, -p.z);\n  }\n  // Points below the plane through a, d and mid(b,c) are mirrored through it.\n  // GREEN surface in image.\n  p -= 2.0 * mirror * min(dot(p, mirror), 0.0);\n  // After mirror some points are negative, abs again:\n  p.xy = abs(p.xy);\n\n  // Points are now either above the white surface, or above the positive ab segment.\n  // We shift the coordinate system so that a is now at the origin.\n  p -= vec3(1, 0, SQRT1_2) * s;\n  // Finally, we move points which are directely above the face parallel along\n  // it to a/origin. We can then calculate the sdf as length(p).\n  p.x = max(p.x, 0.0);\n  vec3 midABToC1 = normalize(vec3(0, 1, -SQRT2));\n\n  p -= max(dot(midABToC1, p), 0.0) * midABToC1;\n  return sign(p.z) * length(p);\n}\n\n// Same function but also outputs color for explanation image:\n//float sdTetrahedron(float s, vec3 p, out vec3 color) {\n//  //  return distance(vec3(1), p) - 0.2;\n//  const vec3 a = vec3(0, -1, -SQRT1_2);\n//  const vec3 b = vec3(0, 1, -SQRT1_2);\n//  const vec3 c = vec3(1, 0, SQRT1_2);\n//  const vec3 d = vec3(-1, 0, SQRT1_2);\n//  const vec3 x = 0.5 * (b + d);\n//  const vec3 mirror = normalize(cross(x - a, x - c));\n//\n//  color = WHITE;\n//  if (p.xy != abs(p.xy)) {\n//    p.xy = abs(p.xy);\n//    if (color == WHITE) color = RED;\n//  }\n//  if (p.z < 0.0) {\n//    p = vec3(p.y, p.x, -p.z);\n//    if (color == WHITE) color = BLUE;\n//  }\n//  if (dot(p, mirror) < 0.0) {\n//    if (color == WHITE) color = GREEN;\n//    p -= 2.0 * mirror * min(dot(p, mirror), 0.0);\n//  }\n//  p.xy = abs(p.xy);\n//  p -= vec3(1, 0, SQRT1_2);\n//  p.x = max(p.x, 0.0);\n//  vec3 fgh = normalize(vec3(0, 1, -SQRT2));\n//\n//  p -= max(dot(fgh, p), 0.0) * fgh;\n//  return sign(p.z) * length(p);\n//}\n\n\n// END ../common/sdf3d/sdTetrahedron.glsl\n\nuniform sampler2D texture;\nuniform float iTime;\nuniform vec4 colorPrimary;\nuniform vec4 colorSecondary;\nuniform vec4 colorBackground;\nuniform float a;\nuniform float b;\nuniform float c;\nuniform float d;\nuniform int bandCount;\nuniform vec2 iResolution;\nuniform vec2 iMouse;\nin float n;\nin vec2 coord;\nout vec4 fragColor;\n\n\nstruct Hit {\n  float distance;\n  vec4 color;\n};\nHit mixa(Hit a, Hit b, float t) {\n  return Hit(mix(a.distance, b.distance, t), mix(a.color, b.color, t));\n}\nfloat skybox(vec3 p) {\n  return 32.0 - max3(abs(p));\n}\n\nHit add(Hit a, Hit b) {\n  //    return a.distance < b.distance\n  //        ? Hit(a.distance, a.color)\n  //        : Hit(b.distance, b.color);\n  return mixa(a, b, float(b.distance < a.distance));\n}\n\nHit addFillet(float r, Hit a, Hit b) {\n  if (a.distance < r && b.distance < r) {\n    return Hit(\n      r - distance(vec2(a.distance, b.distance), vec2(r)),\n      mix(a.color, b.color, (a.distance - b.distance) / r * 0.5 + 0.5)\n    );\n  } else {\n    return add(a, b);\n  }\n}\n\nHit addFillet(float r, Hit a, Hit b, vec4 tilletColor) {\n  if (a.distance < r && b.distance < r) {\n    return Hit(\n      r - distance(vec2(a.distance, b.distance), vec2(r)),\n      tilletColor\n    );\n  } else {\n    return add(a, b);\n  }\n}\nHit addFillet2(float r, Hit a, Hit b) {\n  float h = smoothstep(-r, r, a.distance - b.distance);\n  return Hit(\n    mix(a.distance, b.distance, h) - r * h * (1.0 - h),\n    mix(a.color, b.color, h)\n  );\n}\n\nHit neg(Hit a) {\n  return Hit(-a.distance, a.color);\n}\nHit sub(Hit from, Hit what) {\n  Hit whatNeg = neg(what);\n  return mixa(from, whatNeg, float(whatNeg.distance > from.distance));\n}\n\nvec3 modv(vec3 v, vec3 dir1, float y) {\n  float t = dot(v, dir1);\n  return v - floor(t / y) * y * dir1;\n}\nvec3 modRotZ(vec3 p, float count) {\n  vec2 polarXY = toPolar(p.xy);\n  return fromPolar(polarXY.x, mod(polarXY.y, TAU / count), p.z);\n}\n\nfloat sin01(float x) {\n  return 0.5 + 0.5 * sin(x);\n}\nfloat cos01(float x) {\n  return 0.5 + 0.5 * cos(x);\n}\n\nfloat smoothmin(float r, float a, float b) {\n  float h = smoothstep(-r, r, a - b);\n  return mix(a, b, h) - r * h * (1.0 - h);\n}\n\nvec2 project(vec2 a, vec2 onto1) {\n  return onto1 * (dot(a, onto1) / dot(onto1, onto1));\n}\n\nvec3 reject(vec3 a, vec3 b1) {\n  return a - b1 * dot(a, b1);\n}\nHit sdf(vec3 p) {\n  float f =\n    0.5 * openSimplex2_Conventional(2.0 * (p - vec3(0.1 * iTime, 0, 1))).w +\n    0.5;\n  float scale = 2.0;\n  float ds = distance(p, vec3(0, 0, 1)) - 1.0 - 0.2 * f;\n  if (ds > 1.0) {\n    //    ds *= 0.1;\n  }\n  float dg = p.z;\n  if (ds < dg) {\n    vec3 color = mix(\n      ungamma(colorBackground),\n      ungamma(colorPrimary),\n      banded(bandCount, unmix(-1.0, 1.0, f))\n    );\n    color = ungamma(colorPrimary);\n    //    vec3 color = vec3(f);\n\n    return Hit(ds, vec4(color, 1));\n  } else {\n    float f = checkerboardGrad(p.xy);\n\n    vec3 color = mix(ungamma(colorBackground), ungamma(colorSecondary), f);\n    return Hit(dg, vec4(color, 1));\n  }\n}\nfloat sdff(vec3 p) {\n  return sdf(p).distance;\n}\nfloat ambientOcclusion(vec3 pWC, vec3 n1WC) {\n  float k = 1.0;\n  float distance = sdff(pWC + n1WC * k);\n  return clamp(distance / k, 0.0, 1.0);\n}\n\nstruct RMResult {\n  float distance;\n  vec3 pos;\n  vec4 color;\n};\nRMResult raymarching2(vec3 start, vec3 dir1) {\n  vec3 pos = start;\n  Hit hit;\n  for (int i = 0; i < 200; i++) {\n    hit = sdf(pos);\n    if (hit.distance < 0.0001 * hit.distance) break;\n    pos = pos + dir1 * hit.distance;\n  }\n  return RMResult(hit.distance, pos, hit.color);\n}\n\nfloat softshadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {\n  float res = 1.0;\n  float t = 0.1;\n  for (int i = 0; i < 1000 && t < maxt; i++) {\n    float h = sdff(ro + rd * t);\n    if (h < 0.001) return 0.0;\n    res = min(res, k * h / t);\n    t += h;\n  }\n  return res;\n}\n\nconst float eps = 1e-4;\nvec3 sdfNormal1(vec3 p, float d) {\n  return normalize(\n    vec3(\n      sdff(p + vec3(eps, 0.0, 0.0)),\n      sdff(p + vec3(0.0, eps, 0.0)),\n      sdff(p + vec3(0.0, 0.0, eps))\n    ) -\n      vec3(sdff(p))\n  );\n}\n\n//layout (depth_greater) out float gl_FragDepth;\nvoid main() {\n  vec3 camPos =\n    vec3(20, 0, 10) +\n    (-1.0 == iMouse.x\n      ? vec3(0)\n      : vec3(0, (iMouse / iResolution * 2.0 - 1.0) * 10.0));\n  mat4 modelView =\n    perspective(10.0, iResolution.x / iResolution.y, 0.1, 20.0) *\n    lookAt(camPos, vec3(0, 0, 1), vec3(0, 0, 1));\n  mat4 modelViewInverse = inverse(modelView);\n\n  vec3 light = normalize(vec3(-1.0, -2.0, -2));\n\n  vec3 a = vec3(coord * 2.0 - 1.0, -1.0);\n  vec3 b = vec3(coord * 2.0 - 1.0, 1.0);\n  vec3 aWC = transform(modelViewInverse, a);\n  vec3 bWC = transform(modelViewInverse, b);\n  vec3 lookDir1 = normalize(bWC - aWC);\n\n  RMResult hitWC = raymarching2(aWC, lookDir1);\n  vec3 hitn1 = sdfNormal1(hitWC.pos, hitWC.distance);\n  float dWC = distance(aWC, hitWC.pos);\n  vec3 hitNDC = transform(modelView, hitWC.pos);\n  vec3 p = hitWC.pos;\n  float inSun = softshadow(\n    hitWC.pos + hitn1 * 0.05,\n    -light,\n    0.0001,\n    300.0,\n    8.0\n  );\n  //    float inSun=1.;\n\n  vec3 material = hitWC.color.xyz;\n  if (dWC > 100.0) {\n    material = vec3(0.0, 0.0, 0.0);\n    //    } else if (p.z >= 0.001) {\n    //        material = vec3(0.2, 0.0, 0.0);\n    //    } else {\n    //        vec2 c = vec2(4.0, 2.0);\n    //        vec2 id = floor(((p.xy - c * 0.5) / c) );\n    //        material += .15 * cos(vec3(id.x, id.y + 2., id.x + id.y + 4.));\n  }\n\n  const vec3 sunlightColor = vec3(3.0);\n\n  float aOcc = ambientOcclusion(hitWC.pos, hitn1);\n\n  vec3 reflectionDirection = reflect(light, hitn1);\n\n  vec3 color = vec3(0.0);\n  color += material * aOcc;\n  color += inSun * sunlightColor * material * max(0.0, dot(-light, hitn1));\n  //    color = (hitn1);\n\n  vec3 eyeDirection = -lookDir1;\n  float uMaterialShininess = 256.0;\n  float specularLightWeighting = pow(\n    max(dot(reflectionDirection, eyeDirection), 0.0),\n    uMaterialShininess\n  );\n  color += specularLightWeighting;\n  //    float lightIntensity = 0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.);\n  //    float lightIntensity =\n  //        0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.) + 0.3*specularLightWeighting;\n  //    fragColor = visualize(blue, red, mix(0.5, 1.0, inSun) * lightIntensity);\n  //    fragColor = mix(hitWC.color, colorBackground, mix(0.5, 1.0, inSun) * clamp(lightIntensity, 0., 1.));\n  color = pow(color, vec3(1.0 / 2.2)); // gamma correction\n  fragColor = vec4(color, 1.0);\n}\n",t={version:3,sources:["/home/runner/work/workshop/workshop/src/noises/sphereOpenSimplex.frag","/home/runner/work/workshop/workshop/src/common/banded.glsl","/home/runner/work/workshop/workshop/src/common/constants.glsl","/home/runner/work/workshop/workshop/src/common/matrices.glsl","/home/runner/work/workshop/workshop/src/common/max3.glsl","/home/runner/work/workshop/workshop/src/common/visualize.glsl","/home/runner/work/workshop/workshop/src/common/unmix.glsl","/home/runner/work/workshop/workshop/src/common/fromPolar.glsl","/home/runner/work/workshop/workshop/src/common/toPolar.glsl","/home/runner/work/workshop/workshop/src/common/polar.glsl","/home/runner/work/workshop/workshop/src/common/ungamma.glsl","/home/runner/work/workshop/workshop/src/common/transform.glsl","/home/runner/work/workshop/workshop/src/common/OpenSimplex2.glsl","/home/runner/work/workshop/workshop/src/common/checkerboardGrad.glsl","/home/runner/work/workshop/workshop/src/common/colors.glsl","/home/runner/work/workshop/workshop/src/common/sdf3d/sdIcosahedron.glsl","/home/runner/work/workshop/workshop/src/common/sdf3d/sdDodecahedron.glsl","/home/runner/work/workshop/workshop/src/common/sdf3d/sdCylinder.glsl","/home/runner/work/workshop/workshop/src/common/sdf3d/sdTube.glsl","/home/runner/work/workshop/workshop/src/common/sdf3d/sdBox.glsl","/home/runner/work/workshop/workshop/src/common/sdf3d/sdLego.glsl","/home/runner/work/workshop/workshop/src/common/sdf3d/sdOctahedron.glsl","/home/runner/work/workshop/workshop/src/common/sdf3d/sdCone.glsl","/home/runner/work/workshop/workshop/src/common/sdf3d/sdArrow.glsl","/home/runner/work/workshop/workshop/src/common/sdf3d/sdCapsule.glsl","/home/runner/work/workshop/workshop/src/common/sdf3d/sdTetrahedron.glsl"],names:[],mappings:"AAAA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC/GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC3IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AzB3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"}},6965:(A,n,e)=>{"use strict";e.r(n),e.d(n,{default:()=>o,sourceMap:()=>t});const o="#version 300 es\nprecision mediump float;\n\n// START ../common/banded.glsl\nfloat banded(float bandCount, float t) {\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\n}\nfloat banded(int bandCount, float t) {\n  return banded(float(bandCount), t);\n}\n\n// #pragma glslify: export(banded)\n\n\n// END ../common/banded.glsl\n// START ../common/between.glsl\nbool between(float min, float max, float value) {\n  return min <= value && value <= max;\n}\n\n// #pragma glslify: export(between)\n\n\n// END ../common/between.glsl\n// START ../common/hexFns.glsl\n// START ./max3.glsl\nfloat max3(float a, float b, float c) {\n  return max(a, max(b, c));\n}\nfloat max3(vec3 v) {\n  return max(v.x, max(v.y, v.z));\n}\n\n// #pragma glslify: export(max3)\n\n\n// END ./max3.glsl\n// START ./constants.glsl\nconst float SQRT1_2 = 0.7071067811865476;\nconst float SQRT1_3 = 0.57735026919;\nconst float SQRT2 = 1.4142135623730951;\nconst float SQRT3 = 1.732050807568877;\n// sqrt(3)/2 = sin(60*)\nconst float SQRT3_2 = 0.86602540378;\nconst float GOLDEN_RATIO = 1.61803398875;\nconst float PI = 3.141592653589793;\nconst float TAU = 6.28318530718;\n/**\n * One degree in radians. Use like `sin(30 * DEG)`.\n */\nconst float DEGREE = 0.017453292519943295;\n\n// END ./constants.glsl\n\nvec3 hexRound(vec3 hex) {\n  vec3 r = floor(hex + 0.5);\n  vec3 diff = abs(r - hex);\n\n  if (diff.x > diff.y && diff.x > diff.z) {\n    r.x = -(r.y + r.z);\n  } else if (diff.y > diff.z) {\n    r.y = -(r.x + r.z);\n  } else {\n    r.z = -(r.x + r.y);\n  }\n\n  return r;\n}\nvec2 hex2Ra(vec3 hex) {\n  float y = hex.t * SQRT3_2;\n  float x = hex.s + hex.t / 2.0;\n  return vec2(x, y);\n}\n\nfloat hexSdf(vec3 hex) {\n  return max3(abs(hex.yzx + hex.zxy / 2.0));\n}\nvec3 ra2Hex(vec2 xy) {\n  float hex_t = xy.y / SQRT3_2;\n  float hex_s = xy.x - hex_t / 2.0;\n  return vec3(hex_s, hex_t, -(hex_s + hex_t));\n}\n\n// END ../common/hexFns.glsl\n// START ../common/matrices.glsl\n\nmat2 rot2(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat2(c, s, -s, c);\n}\nmat3 rotX(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\n}\nmat3 rotY(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\n}\nmat3 rotZ(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\n}\n/**\n * Returns a matrix that puts the camera at the eye point `ex, ey, ez` looking\n * toward the center point `cx, cy, cz` with an up direction of `ux, uy, uz`.\n * This emulates the OpenGL function `gluLookAt()`.\n */\nmat4 lookAt(vec3 eye, vec3 focus, vec3 up) {\n  vec3 f = normalize(eye - focus);\n  vec3 s = normalize(cross(up, f));\n  vec3 t = normalize(cross(f, s));\n\n  return mat4(\n    vec4(s.x, t.x, f.x, 0.0),\n    vec4(s.y, t.y, f.y, 0.0),\n    vec4(s.z, t.z, f.z, 0.0),\n    vec4(-dot(s, eye), -dot(t, eye), -dot(f, eye), 1)\n  );\n}\n\n// the OpenGL function `glFrustum()`.\nmat4 frustum(\n  float left,\n  float right,\n  float bottom,\n  float top,\n  float near,\n  float far\n) {\n  return mat4(\n    vec4(2.0 * near / (right - left), 0.0, 0.0, 0.0),\n    vec4(0, 2.0 * near / (top - bottom), 0.0, 0.0),\n    vec4(\n      (right + left) / (right - left),\n      (top + bottom) / (top - bottom),\n      -(far + near) / (far - near),\n      -1\n    ),\n    vec4(0.0, 0.0, -2.0 * far * near / (far - near), 0.0)\n  );\n}\n\nmat4 perspective(float fovDegrees, float aspect, float near, float far) {\n  float y = tan(fovDegrees * DEGREE / 2.0) * near;\n  float x = y * aspect;\n  return frustum(-x, x, -y, y, near, far);\n}\nmat4 ortho(\n  float left,\n  float right,\n  float bottom,\n  float top,\n  float near,\n  float far\n) {\n  return mat4(\n    vec4(2.0 / (right - left), 0.0, 0.0, 0.0),\n    vec4(0.0, 2.0 / (top - bottom), 0.0, 0.0),\n    vec4(0.0, 0.0, -2.0 / (far - near), 0.0),\n    vec4(\n      -(right + left) / (right - left),\n      -(top + bottom) / (top - bottom),\n      -(far + near) / (far - near),\n      1.0\n    )\n  );\n}\n\n// END ../common/matrices.glsl\n// START ../common/perlin2DTexture.glsl\nuniform sampler2D gradients;\n/* Create random direction vector\n */\nvec2 randomGradient(vec2 i) {\n  // Random float. No precomputed gradients mean this works for any number of grid coordinates\n  float random =\n    2920.0 *\n    sin(float(i.x) * 2.1942 + float(i.y) * 1.71324 + 8.912) *\n    cos(float(i.x) * 2.3157 * float(i.y) * 2.17832 + 9.758);\n  //    random = (i.x + 1667.) * (i.x + 2083.) * (i.y + 2659.) * (i.y * 50.77 + .3769);\n  //    random = sin(SQRT2 * i.x) + cos(GOLDEN_RATIO * i.y) + tan((i.x + i.y) * SQRT3);\n  return vec2(cos(random), sin(random));\n}\nfloat dotGridGradient(vec2 cell, vec2 pos) {\n  vec2 d = cell - pos;\n\n  //  vec2 gradient = texelFetch(gradients, ivec2(cell), 0).xy;\n  vec2 gradient = randomGradient(vec2(cell));\n\n  return dot(gradient, d);\n}\n\nfloat mixx(float a, float b, float t) {\n  return mix(a, b, smoothstep(0.0, 1.0, t));\n  //    return mix(a, b, t);\n}\n\n// resulting range is [-0.68, 0.68]. Use unmix to normalize if necessary.\nfloat perlin2D(vec2 xy) {\n  float x0 = floor(xy.x);\n  float x1 = x0 + 1.0;\n  float y0 = floor(xy.y);\n  float y1 = y0 + 1.0;\n\n  // Interpolate between grid point gradients\n  float n00 = dotGridGradient(vec2(x0, y0), xy);\n  float n10 = dotGridGradient(vec2(x1, y0), xy);\n  float ny0 = mixx(n00, n10, xy.x - x0);\n\n  float n01 = dotGridGradient(vec2(x0, y1), xy);\n  float n11 = dotGridGradient(vec2(x1, y1), xy);\n  float ny1 = mixx(n01, n11, xy.x - x0);\n\n  return mixx(ny0, ny1, xy.y - y0);\n}\n\n// #pragma glslify: export(perlin2D)\n\n\n// END ../common/perlin2DTexture.glsl\n// START ../common/remix.glsl\n// START ./unmix.glsl\nfloat unmix(float a, float b, float value) {\n  return (value - a) / (b - a);\n}\n\n// #pragma glslify: export(unmix)\n\n\n// END ./unmix.glsl\n\nfloat remix(float fromA, float fromB, float toA, float toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\nvec4 remix(float fromA, float fromB, vec4 toA, vec4 toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\n// #pragma glslify: export(remix)\n\n\n// END ../common/remix.glsl\n// START ../common/transform.glsl\nvec3 transform(mat4 pm, vec3 p) {\n  vec4 pStar = pm * vec4(p, 1);\n  return pStar.xyz / pStar.w;\n}\n\nvec2 transform(mat4 pm, vec2 p) {\n  vec4 pStar = pm * vec4(p, 0, 1);\n  return pStar.xy / pStar.w;\n}\n\n// END ../common/transform.glsl\n// START ../common/visualize.glsl\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\n  float isLow = float(t < 0.0);\n  float isHigh = float(t > 1.0);\n  float isMid = 1.0 - isLow - isHigh;\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\n}\n\nvec4 visualize(float t) {\n  const vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\n  const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\n  return visualize(BLUE, RED, t);\n}\n\n// #pragma glslify: export(visualize)\n\n\n// END ../common/visualize.glsl\n// START ../common/waves.glsl\nfloat waves(vec4 color, vec2 position, vec2 direction, float highResTimeStamp) {\n  return sin(\n    dot(position, direction / pow(length(direction), 2.0)) +\n      float(highResTimeStamp) / 200.0\n  );\n}\n\n// #pragma glslify: export(waves)\n\n\n// END ../common/waves.glsl\n\nin float n;\nin vec2 coord;\nout vec4 fragColor;\nuniform float a;\nuniform int bandCount;\nuniform mat4 viewModel;\nuniform sampler2D texture;\nuniform vec2 iResolution;\nuniform vec4 colorBackground;\nuniform vec4 colorPrimary;\nuniform vec4 colorSecondary;\n\nfloat perlin01(vec2 pos) {\n  return unmix(-0.68, 0.68, perlin2D(pos));\n}\n\nvoid main() {\n  vec2 fragCoord = transform(viewModel, coord * iResolution);\n  fragCoord *= 0.01;\n  vec3 hex_pos = ra2Hex(fragCoord);\n  vec3 hex_center = hexRound(hex_pos);\n  vec2 center = hex2Ra(hex_center);\n  float centerPerl = unmix(-0.68, 0.68, perlin2D(center / 20.0));\n  float isTop = float(centerPerl > a + 0.05);\n  float isBottom = float(centerPerl < a - 0.05);\n  vec4 hexColor =\n    isTop * colorPrimary +\n    isBottom * colorSecondary +\n    (1.0 - isTop - isBottom) * colorBackground;\n\n  hexColor = mix(colorBackground, colorPrimary, banded(bandCount, centerPerl));\n\n  vec3 hex_d = hex_pos - hex_center;\n  float d = hexSdf(hex_d);\n  float isHex = smoothstep(-0.42, -0.38, -d);\n  fragColor = mix(colorBackground, hexColor, isHex);\n}\n",t={version:3,sources:["/home/runner/work/workshop/workshop/src/noises/test.frag","/home/runner/work/workshop/workshop/src/common/banded.glsl","/home/runner/work/workshop/workshop/src/common/between.glsl","/home/runner/work/workshop/workshop/src/common/max3.glsl","/home/runner/work/workshop/workshop/src/common/constants.glsl","/home/runner/work/workshop/workshop/src/common/hexFns.glsl","/home/runner/work/workshop/workshop/src/common/matrices.glsl","/home/runner/work/workshop/workshop/src/common/perlin2DTexture.glsl","/home/runner/work/workshop/workshop/src/common/unmix.glsl","/home/runner/work/workshop/workshop/src/common/remix.glsl","/home/runner/work/workshop/workshop/src/common/transform.glsl","/home/runner/work/workshop/workshop/src/common/visualize.glsl","/home/runner/work/workshop/workshop/src/common/waves.glsl"],names:[],mappings:"AAAA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AZIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"}},3257:(A,n,e)=>{"use strict";e.r(n),e.d(n,{default:()=>o,sourceMap:()=>t});const o="#version 300 es\nprecision mediump float;\n\n// START ../common/banded.glsl\nfloat banded(float bandCount, float t) {\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\n}\nfloat banded(int bandCount, float t) {\n  return banded(float(bandCount), t);\n}\n\n// #pragma glslify: export(banded)\n\n\n// END ../common/banded.glsl\n// START ../common/between.glsl\nbool between(float min, float max, float value) {\n  return min <= value && value <= max;\n}\n\n// #pragma glslify: export(between)\n\n\n// END ../common/between.glsl\n// START ../common/colors.glsl\nconst vec3 INDIAN_RED = vec3(0.804, 0.361, 0.361);\nconst vec3 LIGHT_CORAL = vec3(0.941, 0.502, 0.502);\nconst vec3 SALMON = vec3(0.98, 0.502, 0.447);\nconst vec3 DARK_SALMON = vec3(0.914, 0.588, 0.478);\nconst vec3 LIGHT_SALMON = vec3(1.0, 0.627, 0.478);\nconst vec3 CRIMSON = vec3(0.863, 0.078, 0.235);\nconst vec3 RED = vec3(1.0, 0.0, 0.0);\nconst vec3 FIRE_BRICK = vec3(0.698, 0.133, 0.133);\nconst vec3 DARK_RED = vec3(0.545, 0.0, 0.0);\nconst vec3 PINK = vec3(1.0, 0.753, 0.796);\nconst vec3 LIGHT_PINK = vec3(1.0, 0.714, 0.757);\nconst vec3 HOT_PINK = vec3(1.0, 0.412, 0.706);\nconst vec3 DEEP_PINK = vec3(1.0, 0.078, 0.576);\nconst vec3 MEDIUM_VIOLET_RED = vec3(0.78, 0.082, 0.522);\nconst vec3 PALE_VIOLET_RED = vec3(0.859, 0.439, 0.576);\nconst vec3 CORAL = vec3(1.0, 0.498, 0.314);\nconst vec3 TOMATO = vec3(1.0, 0.388, 0.278);\nconst vec3 ORANGE_RED = vec3(1.0, 0.271, 0.0);\nconst vec3 DARK_ORANGE = vec3(1.0, 0.549, 0.0);\nconst vec3 ORANGE = vec3(1.0, 0.647, 0.0);\nconst vec3 GOLD = vec3(1.0, 0.843, 0.0);\nconst vec3 YELLOW = vec3(1.0, 1.0, 0.0);\nconst vec3 LIGHT_YELLOW = vec3(1.0, 1.0, 0.878);\nconst vec3 LEMON_CHION = vec3(1.0, 0.98, 0.804);\nconst vec3 LIGHT_GOLDENROD_YELLOW = vec3(0.98, 0.98, 0.824);\nconst vec3 PAPAYA_WHIP = vec3(1.0, 0.937, 0.835);\nconst vec3 MOCCASIN = vec3(1.0, 0.894, 0.71);\nconst vec3 PEACH_PU = vec3(1.0, 0.855, 0.725);\nconst vec3 PALE_GOLDENROD = vec3(0.933, 0.91, 0.667);\nconst vec3 KHAKI = vec3(0.941, 0.902, 0.549);\nconst vec3 DARK_KHAKI = vec3(0.741, 0.718, 0.42);\nconst vec3 LAVENDER = vec3(0.902, 0.902, 0.98);\nconst vec3 THISTLE = vec3(0.847, 0.749, 0.847);\nconst vec3 PLUM = vec3(0.867, 0.627, 0.867);\nconst vec3 VIOLET = vec3(0.933, 0.51, 0.933);\nconst vec3 ORCHID = vec3(0.855, 0.439, 0.839);\nconst vec3 FUCHSIA = vec3(1.0, 0.0, 1.0);\nconst vec3 MAGENTA = vec3(1.0, 0.0, 1.0);\nconst vec3 MEDIUM_ORCHID = vec3(0.729, 0.333, 0.827);\nconst vec3 MEDIUM_PURPLE = vec3(0.576, 0.439, 0.859);\nconst vec3 BLUE_VIOLET = vec3(0.541, 0.169, 0.886);\nconst vec3 DARK_VIOLET = vec3(0.58, 0.0, 0.827);\nconst vec3 DARK_ORCHID = vec3(0.6, 0.196, 0.8);\nconst vec3 DARK_MAGENTA = vec3(0.545, 0.0, 0.545);\nconst vec3 PURPLE = vec3(0.502, 0.0, 0.502);\nconst vec3 INDIGO = vec3(0.294, 0.0, 0.51);\nconst vec3 SLATE_BLUE = vec3(0.416, 0.353, 0.804);\nconst vec3 DARK_SLATE_BLUE = vec3(0.282, 0.239, 0.545);\nconst vec3 GREEN_YELLOW = vec3(0.678, 1.0, 0.184);\nconst vec3 CHARTREUSE = vec3(0.498, 1.0, 0.0);\nconst vec3 LAWN_GREEN = vec3(0.486, 0.988, 0.0);\nconst vec3 LIME = vec3(0.0, 1.0, 0.0);\nconst vec3 LIME_GREEN = vec3(0.196, 0.804, 0.196);\nconst vec3 PALE_GREEN = vec3(0.596, 0.984, 0.596);\nconst vec3 LIGHT_GREEN = vec3(0.565, 0.933, 0.565);\nconst vec3 MEDIUM_SPRING_GREEN = vec3(0.0, 0.98, 0.604);\nconst vec3 SPRING_GREEN = vec3(0.0, 1.0, 0.498);\nconst vec3 MEDIUM_SEA_GREEN = vec3(0.235, 0.702, 0.443);\nconst vec3 SEA_GREEN = vec3(0.18, 0.545, 0.341);\nconst vec3 FOREST_GREEN = vec3(0.133, 0.545, 0.133);\nconst vec3 GREEN = vec3(0.0, 0.502, 0.0);\nconst vec3 DARK_GREEN = vec3(0.0, 0.392, 0.0);\nconst vec3 YELLOW_GREEN = vec3(0.604, 0.804, 0.196);\nconst vec3 OLIVE_DRAB = vec3(0.42, 0.557, 0.137);\nconst vec3 OLIVE = vec3(0.502, 0.502, 0.0);\nconst vec3 DARK_OLIVE_GREEN = vec3(0.333, 0.42, 0.184);\nconst vec3 MEDIUM_AQUAMARINE = vec3(0.4, 0.804, 0.667);\nconst vec3 DARK_SEA_GREEN = vec3(0.561, 0.737, 0.561);\nconst vec3 LIGHT_SEA_GREEN = vec3(0.125, 0.698, 0.667);\nconst vec3 DARK_CYAN = vec3(0.0, 0.545, 0.545);\nconst vec3 TEAL = vec3(0.0, 0.502, 0.502);\nconst vec3 AQUA = vec3(0.0, 1.0, 1.0);\nconst vec3 CYAN = vec3(0.0, 1.0, 1.0);\nconst vec3 LIGHT_CYAN = vec3(0.878, 1.0, 1.0);\nconst vec3 PALE_TURQUOISE = vec3(0.686, 0.933, 0.933);\nconst vec3 AQUAMARINE = vec3(0.498, 1.0, 0.831);\nconst vec3 TURQUOISE = vec3(0.251, 0.878, 0.816);\nconst vec3 MEDIUM_TURQUOISE = vec3(0.282, 0.82, 0.8);\nconst vec3 DARK_TURQUOISE = vec3(0.0, 0.808, 0.82);\nconst vec3 CADET_BLUE = vec3(0.373, 0.62, 0.627);\nconst vec3 STEEL_BLUE = vec3(0.275, 0.51, 0.706);\nconst vec3 LIGHT_STEEL_BLUE = vec3(0.69, 0.769, 0.871);\nconst vec3 POWDER_BLUE = vec3(0.69, 0.878, 0.902);\nconst vec3 LIGHT_BLUE = vec3(0.678, 0.847, 0.902);\nconst vec3 SKY_BLUE = vec3(0.529, 0.808, 0.922);\nconst vec3 LIGHT_SKY_BLUE = vec3(0.529, 0.808, 0.98);\nconst vec3 DEEP_SKY_BLUE = vec3(0.0, 0.749, 1.0);\nconst vec3 DODGER_BLUE = vec3(0.118, 0.565, 1.0);\nconst vec3 CORNLOWER_BLUE = vec3(0.392, 0.584, 0.929);\nconst vec3 MEDIUM_SLATE_BLUE = vec3(0.482, 0.408, 0.933);\nconst vec3 ROYAL_BLUE = vec3(0.255, 0.412, 0.882);\nconst vec3 BLUE = vec3(0.0, 0.0, 1.0);\nconst vec3 MEDIUM_BLUE = vec3(0.0, 0.0, 0.804);\nconst vec3 DARK_BLUE = vec3(0.0, 0.0, 0.545);\nconst vec3 NAVY = vec3(0.0, 0.0, 0.502);\nconst vec3 MIDNIGHT_BLUE = vec3(0.098, 0.098, 0.439);\nconst vec3 CORNSILK = vec3(1.0, 0.973, 0.863);\nconst vec3 BLANCHED_ALMOND = vec3(1.0, 0.922, 0.804);\nconst vec3 BISQUE = vec3(1.0, 0.894, 0.769);\nconst vec3 NAVAJO_WHITE = vec3(1.0, 0.871, 0.678);\nconst vec3 WHEAT = vec3(0.961, 0.871, 0.702);\nconst vec3 BURLY_WOOD = vec3(0.871, 0.722, 0.529);\nconst vec3 TAN = vec3(0.824, 0.706, 0.549);\nconst vec3 ROSY_BROWN = vec3(0.737, 0.561, 0.561);\nconst vec3 SANDY_BROWN = vec3(0.957, 0.643, 0.376);\nconst vec3 GOLDENROD = vec3(0.855, 0.647, 0.125);\nconst vec3 DARK_GOLDENROD = vec3(0.722, 0.525, 0.043);\nconst vec3 PERU = vec3(0.804, 0.522, 0.247);\nconst vec3 CHOCOLATE = vec3(0.824, 0.412, 0.118);\nconst vec3 SADDLE_BROWN = vec3(0.545, 0.271, 0.075);\nconst vec3 SIENNA = vec3(0.627, 0.322, 0.176);\nconst vec3 BROWN = vec3(0.647, 0.165, 0.165);\nconst vec3 MAROON = vec3(0.502, 0.0, 0.0);\nconst vec3 WHITE = vec3(1.0, 1.0, 1.0);\nconst vec3 SNOW = vec3(1.0, 0.98, 0.98);\nconst vec3 HONEYDEW = vec3(0.941, 1.0, 0.941);\nconst vec3 MINT_CREAM = vec3(0.961, 1.0, 0.98);\nconst vec3 AZURE = vec3(0.941, 1.0, 1.0);\nconst vec3 ALICE_BLUE = vec3(0.941, 0.973, 1.0);\nconst vec3 GHOST_WHITE = vec3(0.973, 0.973, 1.0);\nconst vec3 WHITE_SMOKE = vec3(0.961, 0.961, 0.961);\nconst vec3 SEASHELL = vec3(1.0, 0.961, 0.933);\nconst vec3 BEIGE = vec3(0.961, 0.961, 0.863);\nconst vec3 OLD_LACE = vec3(0.992, 0.961, 0.902);\nconst vec3 FLORAL_WHITE = vec3(1.0, 0.98, 0.941);\nconst vec3 IVORY = vec3(1.0, 1.0, 0.941);\nconst vec3 ANTIQUE_WHITE = vec3(0.98, 0.922, 0.843);\nconst vec3 LINEN = vec3(0.98, 0.941, 0.902);\nconst vec3 LAVENDER_BLUSH = vec3(1.0, 0.941, 0.961);\nconst vec3 MISTY_ROSE = vec3(1.0, 0.894, 0.882);\nconst vec3 GAINSBORO = vec3(0.863, 0.863, 0.863);\nconst vec3 LIGHT_GREY = vec3(0.827, 0.827, 0.827);\nconst vec3 SILVER = vec3(0.753, 0.753, 0.753);\nconst vec3 DARK_GRAY = vec3(0.663, 0.663, 0.663);\nconst vec3 GRAY = vec3(0.502, 0.502, 0.502);\nconst vec3 DIM_GRAY = vec3(0.412, 0.412, 0.412);\nconst vec3 LIGHT_SLATE_GRAY = vec3(0.467, 0.533, 0.6);\nconst vec3 SLATE_GRAY = vec3(0.439, 0.502, 0.565);\nconst vec3 DARK_SLATE_GRAY = vec3(0.184, 0.31, 0.31);\nconst vec3 BLACK = vec3(0.0, 0.0, 0.0);\n\n// END ../common/colors.glsl\n// START ../common/hexFns.glsl\n// START ./max3.glsl\nfloat max3(float a, float b, float c) {\n  return max(a, max(b, c));\n}\nfloat max3(vec3 v) {\n  return max(v.x, max(v.y, v.z));\n}\n\n// #pragma glslify: export(max3)\n\n\n// END ./max3.glsl\n// START ./constants.glsl\nconst float SQRT1_2 = 0.7071067811865476;\nconst float SQRT1_3 = 0.57735026919;\nconst float SQRT2 = 1.4142135623730951;\nconst float SQRT3 = 1.732050807568877;\n// sqrt(3)/2 = sin(60*)\nconst float SQRT3_2 = 0.86602540378;\nconst float GOLDEN_RATIO = 1.61803398875;\nconst float PI = 3.141592653589793;\nconst float TAU = 6.28318530718;\n/**\n * One degree in radians. Use like `sin(30 * DEG)`.\n */\nconst float DEGREE = 0.017453292519943295;\n\n// END ./constants.glsl\n\nvec3 hexRound(vec3 hex) {\n  vec3 r = floor(hex + 0.5);\n  vec3 diff = abs(r - hex);\n\n  if (diff.x > diff.y && diff.x > diff.z) {\n    r.x = -(r.y + r.z);\n  } else if (diff.y > diff.z) {\n    r.y = -(r.x + r.z);\n  } else {\n    r.z = -(r.x + r.y);\n  }\n\n  return r;\n}\nvec2 hex2Ra(vec3 hex) {\n  float y = hex.t * SQRT3_2;\n  float x = hex.s + hex.t / 2.0;\n  return vec2(x, y);\n}\n\nfloat hexSdf(vec3 hex) {\n  return max3(abs(hex.yzx + hex.zxy / 2.0));\n}\nvec3 ra2Hex(vec2 xy) {\n  float hex_t = xy.y / SQRT3_2;\n  float hex_s = xy.x - hex_t / 2.0;\n  return vec3(hex_s, hex_t, -(hex_s + hex_t));\n}\n\n// END ../common/hexFns.glsl\n// START ../common/matrices.glsl\n\nmat2 rot2(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat2(c, s, -s, c);\n}\nmat3 rotX(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\n}\nmat3 rotY(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\n}\nmat3 rotZ(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\n}\n/**\n * Returns a matrix that puts the camera at the eye point `ex, ey, ez` looking\n * toward the center point `cx, cy, cz` with an up direction of `ux, uy, uz`.\n * This emulates the OpenGL function `gluLookAt()`.\n */\nmat4 lookAt(vec3 eye, vec3 focus, vec3 up) {\n  vec3 f = normalize(eye - focus);\n  vec3 s = normalize(cross(up, f));\n  vec3 t = normalize(cross(f, s));\n\n  return mat4(\n    vec4(s.x, t.x, f.x, 0.0),\n    vec4(s.y, t.y, f.y, 0.0),\n    vec4(s.z, t.z, f.z, 0.0),\n    vec4(-dot(s, eye), -dot(t, eye), -dot(f, eye), 1)\n  );\n}\n\n// the OpenGL function `glFrustum()`.\nmat4 frustum(\n  float left,\n  float right,\n  float bottom,\n  float top,\n  float near,\n  float far\n) {\n  return mat4(\n    vec4(2.0 * near / (right - left), 0.0, 0.0, 0.0),\n    vec4(0, 2.0 * near / (top - bottom), 0.0, 0.0),\n    vec4(\n      (right + left) / (right - left),\n      (top + bottom) / (top - bottom),\n      -(far + near) / (far - near),\n      -1\n    ),\n    vec4(0.0, 0.0, -2.0 * far * near / (far - near), 0.0)\n  );\n}\n\nmat4 perspective(float fovDegrees, float aspect, float near, float far) {\n  float y = tan(fovDegrees * DEGREE / 2.0) * near;\n  float x = y * aspect;\n  return frustum(-x, x, -y, y, near, far);\n}\nmat4 ortho(\n  float left,\n  float right,\n  float bottom,\n  float top,\n  float near,\n  float far\n) {\n  return mat4(\n    vec4(2.0 / (right - left), 0.0, 0.0, 0.0),\n    vec4(0.0, 2.0 / (top - bottom), 0.0, 0.0),\n    vec4(0.0, 0.0, -2.0 / (far - near), 0.0),\n    vec4(\n      -(right + left) / (right - left),\n      -(top + bottom) / (top - bottom),\n      -(far + near) / (far - near),\n      1.0\n    )\n  );\n}\n\n// END ../common/matrices.glsl\n// START ../common/perlin2DTexture.glsl\nuniform sampler2D gradients;\n/* Create random direction vector\n */\nvec2 randomGradient(vec2 i) {\n  // Random float. No precomputed gradients mean this works for any number of grid coordinates\n  float random =\n    2920.0 *\n    sin(float(i.x) * 2.1942 + float(i.y) * 1.71324 + 8.912) *\n    cos(float(i.x) * 2.3157 * float(i.y) * 2.17832 + 9.758);\n  //    random = (i.x + 1667.) * (i.x + 2083.) * (i.y + 2659.) * (i.y * 50.77 + .3769);\n  //    random = sin(SQRT2 * i.x) + cos(GOLDEN_RATIO * i.y) + tan((i.x + i.y) * SQRT3);\n  return vec2(cos(random), sin(random));\n}\nfloat dotGridGradient(vec2 cell, vec2 pos) {\n  vec2 d = cell - pos;\n\n  //  vec2 gradient = texelFetch(gradients, ivec2(cell), 0).xy;\n  vec2 gradient = randomGradient(vec2(cell));\n\n  return dot(gradient, d);\n}\n\nfloat mixx(float a, float b, float t) {\n  return mix(a, b, smoothstep(0.0, 1.0, t));\n  //    return mix(a, b, t);\n}\n\n// resulting range is [-0.68, 0.68]. Use unmix to normalize if necessary.\nfloat perlin2D(vec2 xy) {\n  float x0 = floor(xy.x);\n  float x1 = x0 + 1.0;\n  float y0 = floor(xy.y);\n  float y1 = y0 + 1.0;\n\n  // Interpolate between grid point gradients\n  float n00 = dotGridGradient(vec2(x0, y0), xy);\n  float n10 = dotGridGradient(vec2(x1, y0), xy);\n  float ny0 = mixx(n00, n10, xy.x - x0);\n\n  float n01 = dotGridGradient(vec2(x0, y1), xy);\n  float n11 = dotGridGradient(vec2(x1, y1), xy);\n  float ny1 = mixx(n01, n11, xy.x - x0);\n\n  return mixx(ny0, ny1, xy.y - y0);\n}\n\n// #pragma glslify: export(perlin2D)\n\n\n// END ../common/perlin2DTexture.glsl\n// START ../common/remix.glsl\n// START ./unmix.glsl\nfloat unmix(float a, float b, float value) {\n  return (value - a) / (b - a);\n}\n\n// #pragma glslify: export(unmix)\n\n\n// END ./unmix.glsl\n\nfloat remix(float fromA, float fromB, float toA, float toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\nvec4 remix(float fromA, float fromB, vec4 toA, vec4 toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\n// #pragma glslify: export(remix)\n\n\n// END ../common/remix.glsl\n// START ../common/transform.glsl\nvec3 transform(mat4 pm, vec3 p) {\n  vec4 pStar = pm * vec4(p, 1);\n  return pStar.xyz / pStar.w;\n}\n\nvec2 transform(mat4 pm, vec2 p) {\n  vec4 pStar = pm * vec4(p, 0, 1);\n  return pStar.xy / pStar.w;\n}\n\n// END ../common/transform.glsl\n// START ../common/triFns.glsl\n\n// (x, y) -> (u, v, R)\n// where u is horizontal, v is south-west to north-east\n// and R is wether the it is in the right triangle\nvec3 xy2tri(vec2 xy) {\n  float v = xy.y / SQRT3_2;\n  float u = xy.x - v / 2.0;\n  float R = float(\n    mod(u + v, 2.0) > 1.0 != (mod(floor(u) + floor(v), 2.0) == 1.0)\n  );\n  return vec3(u, v, R);\n}\nvec3 triCenter(vec3 uvR) {\n  vec3 base = floor(uvR);\n  vec2 centerOffset = mix(vec2(1.0 / 3.0), vec2(2.0 / 3.0), uvR.z);\n  return base + vec3(centerOffset, 0.0);\n}\nvec2 tri2xy(vec3 uvR) {\n  float y = uvR.t * SQRT3_2;\n  float x = uvR.s + uvR.t / 2.0;\n  return vec2(x, y);\n}\nvec2 tri2xy(vec2 uv) {\n  float y = uv.t * SQRT3_2;\n  float x = uv.s + uv.t / 2.0;\n  return vec2(x, y);\n}\nfloat triSdf(vec2 uv) {\n  vec3 hex = vec3(uv.x, uv.y, -uv.x - uv.y);\n  return max3(hex);\n}\n\n// END ../common/triFns.glsl\n// START ../common/visualize.glsl\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\n  float isLow = float(t < 0.0);\n  float isHigh = float(t > 1.0);\n  float isMid = 1.0 - isLow - isHigh;\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\n}\n\nvec4 visualize(float t) {\n  const vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\n  const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\n  return visualize(BLUE, RED, t);\n}\n\n// #pragma glslify: export(visualize)\n\n\n// END ../common/visualize.glsl\n// START ../common/waves.glsl\nfloat waves(vec4 color, vec2 position, vec2 direction, float highResTimeStamp) {\n  return sin(\n    dot(position, direction / pow(length(direction), 2.0)) +\n      float(highResTimeStamp) / 200.0\n  );\n}\n\n// #pragma glslify: export(waves)\n\n\n// END ../common/waves.glsl\n\nin float n;\nin vec2 coord;\nout vec4 fragColor;\nuniform float a;\nuniform float iTime;\nuniform int bandCount;\nuniform mat4 viewModel;\nuniform sampler2D texture;\nuniform vec2 iResolution;\nuniform vec4 colorBackground;\nuniform vec4 colorPrimary;\nuniform vec4 colorSecondary;\n\nfloat perlin01(vec2 pos) {\n  return unmix(-0.68, 0.68, perlin2D(pos));\n}\nvoid main() {\n  vec2 fragCoord = transform(viewModel, coord * iResolution);\n  fragCoord *= 0.01;\n  vec3 uvR = xy2tri(fragCoord);\n  vec3 triCenter = triCenter(uvR);\n  vec2 centerXY = tri2xy(triCenter);\n\n  vec2 d2 = fragCoord - centerXY;\n\n  float d = triSdf(\n    xy2tri(rot2(iTime * mix(-1.0, 1.0, uvR.z)) * d2).xy * mix(-1.0, 1.0, uvR.z)\n  );\n  float isHex = float(between(0.15, 0.2, d));\n  fragColor = mix(\n    colorBackground,\n    colorPrimary,\n    isHex * banded(bandCount, perlin01(centerXY / 20.0))\n  );\n\n  //fragColor = visualize(blue, red, mod(floor(sheared.x) + floor(sheared.y), 2.0));\n\n}\n\n",t={version:3,sources:["/home/runner/work/workshop/workshop/src/noises/test2.frag","/home/runner/work/workshop/workshop/src/common/banded.glsl","/home/runner/work/workshop/workshop/src/common/between.glsl","/home/runner/work/workshop/workshop/src/common/colors.glsl","/home/runner/work/workshop/workshop/src/common/max3.glsl","/home/runner/work/workshop/workshop/src/common/constants.glsl","/home/runner/work/workshop/workshop/src/common/hexFns.glsl","/home/runner/work/workshop/workshop/src/common/matrices.glsl","/home/runner/work/workshop/workshop/src/common/perlin2DTexture.glsl","/home/runner/work/workshop/workshop/src/common/unmix.glsl","/home/runner/work/workshop/workshop/src/common/remix.glsl","/home/runner/work/workshop/workshop/src/common/transform.glsl","/home/runner/work/workshop/workshop/src/common/triFns.glsl","/home/runner/work/workshop/workshop/src/common/visualize.glsl","/home/runner/work/workshop/workshop/src/common/waves.glsl"],names:[],mappings:"AAAA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC5IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AdOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"}},3055:(A,n,e)=>{"use strict";e.r(n),e.d(n,{default:()=>o,sourceMap:()=>t});const o="#version 300 es\nprecision mediump float;\n\n// START ../common/banded.glsl\nfloat banded(float bandCount, float t) {\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\n}\nfloat banded(int bandCount, float t) {\n  return banded(float(bandCount), t);\n}\n\n// #pragma glslify: export(banded)\n\n\n// END ../common/banded.glsl\n// START ../common/between.glsl\nbool between(float min, float max, float value) {\n  return min <= value && value <= max;\n}\n\n// #pragma glslify: export(between)\n\n\n// END ../common/between.glsl\n// START ../common/perlin2DTexture.glsl\nuniform sampler2D gradients;\n/* Create random direction vector\n */\nvec2 randomGradient(vec2 i) {\n  // Random float. No precomputed gradients mean this works for any number of grid coordinates\n  float random =\n    2920.0 *\n    sin(float(i.x) * 2.1942 + float(i.y) * 1.71324 + 8.912) *\n    cos(float(i.x) * 2.3157 * float(i.y) * 2.17832 + 9.758);\n  //    random = (i.x + 1667.) * (i.x + 2083.) * (i.y + 2659.) * (i.y * 50.77 + .3769);\n  //    random = sin(SQRT2 * i.x) + cos(GOLDEN_RATIO * i.y) + tan((i.x + i.y) * SQRT3);\n  return vec2(cos(random), sin(random));\n}\nfloat dotGridGradient(vec2 cell, vec2 pos) {\n  vec2 d = cell - pos;\n\n  //  vec2 gradient = texelFetch(gradients, ivec2(cell), 0).xy;\n  vec2 gradient = randomGradient(vec2(cell));\n\n  return dot(gradient, d);\n}\n\nfloat mixx(float a, float b, float t) {\n  return mix(a, b, smoothstep(0.0, 1.0, t));\n  //    return mix(a, b, t);\n}\n\n// resulting range is [-0.68, 0.68]. Use unmix to normalize if necessary.\nfloat perlin2D(vec2 xy) {\n  float x0 = floor(xy.x);\n  float x1 = x0 + 1.0;\n  float y0 = floor(xy.y);\n  float y1 = y0 + 1.0;\n\n  // Interpolate between grid point gradients\n  float n00 = dotGridGradient(vec2(x0, y0), xy);\n  float n10 = dotGridGradient(vec2(x1, y0), xy);\n  float ny0 = mixx(n00, n10, xy.x - x0);\n\n  float n01 = dotGridGradient(vec2(x0, y1), xy);\n  float n11 = dotGridGradient(vec2(x1, y1), xy);\n  float ny1 = mixx(n01, n11, xy.x - x0);\n\n  return mixx(ny0, ny1, xy.y - y0);\n}\n\n// #pragma glslify: export(perlin2D)\n\n\n// END ../common/perlin2DTexture.glsl\n// START ../common/remix.glsl\n// START ./unmix.glsl\nfloat unmix(float a, float b, float value) {\n  return (value - a) / (b - a);\n}\n\n// #pragma glslify: export(unmix)\n\n\n// END ./unmix.glsl\n\nfloat remix(float fromA, float fromB, float toA, float toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\nvec4 remix(float fromA, float fromB, vec4 toA, vec4 toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\n// #pragma glslify: export(remix)\n\n\n// END ../common/remix.glsl\n// START ../common/transform.glsl\nvec3 transform(mat4 pm, vec3 p) {\n  vec4 pStar = pm * vec4(p, 1);\n  return pStar.xyz / pStar.w;\n}\n\nvec2 transform(mat4 pm, vec2 p) {\n  vec4 pStar = pm * vec4(p, 0, 1);\n  return pStar.xy / pStar.w;\n}\n\n// END ../common/transform.glsl\n// START ../common/waves.glsl\nfloat waves(vec4 color, vec2 position, vec2 direction, float highResTimeStamp) {\n  return sin(\n    dot(position, direction / pow(length(direction), 2.0)) +\n      float(highResTimeStamp) / 200.0\n  );\n}\n\n// #pragma glslify: export(waves)\n\n\n// END ../common/waves.glsl\n// START ../common/visualize.glsl\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\n  float isLow = float(t < 0.0);\n  float isHigh = float(t > 1.0);\n  float isMid = 1.0 - isLow - isHigh;\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\n}\n\nvec4 visualize(float t) {\n  const vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\n  const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\n  return visualize(BLUE, RED, t);\n}\n\n// #pragma glslify: export(visualize)\n\n\n// END ../common/visualize.glsl\n// START ../common/hexFns.glsl\n// START ./max3.glsl\nfloat max3(float a, float b, float c) {\n  return max(a, max(b, c));\n}\nfloat max3(vec3 v) {\n  return max(v.x, max(v.y, v.z));\n}\n\n// #pragma glslify: export(max3)\n\n\n// END ./max3.glsl\n// START ./constants.glsl\nconst float SQRT1_2 = 0.7071067811865476;\nconst float SQRT1_3 = 0.57735026919;\nconst float SQRT2 = 1.4142135623730951;\nconst float SQRT3 = 1.732050807568877;\n// sqrt(3)/2 = sin(60*)\nconst float SQRT3_2 = 0.86602540378;\nconst float GOLDEN_RATIO = 1.61803398875;\nconst float PI = 3.141592653589793;\nconst float TAU = 6.28318530718;\n/**\n * One degree in radians. Use like `sin(30 * DEG)`.\n */\nconst float DEGREE = 0.017453292519943295;\n\n// END ./constants.glsl\n\nvec3 hexRound(vec3 hex) {\n  vec3 r = floor(hex + 0.5);\n  vec3 diff = abs(r - hex);\n\n  if (diff.x > diff.y && diff.x > diff.z) {\n    r.x = -(r.y + r.z);\n  } else if (diff.y > diff.z) {\n    r.y = -(r.x + r.z);\n  } else {\n    r.z = -(r.x + r.y);\n  }\n\n  return r;\n}\nvec2 hex2Ra(vec3 hex) {\n  float y = hex.t * SQRT3_2;\n  float x = hex.s + hex.t / 2.0;\n  return vec2(x, y);\n}\n\nfloat hexSdf(vec3 hex) {\n  return max3(abs(hex.yzx + hex.zxy / 2.0));\n}\nvec3 ra2Hex(vec2 xy) {\n  float hex_t = xy.y / SQRT3_2;\n  float hex_s = xy.x - hex_t / 2.0;\n  return vec3(hex_s, hex_t, -(hex_s + hex_t));\n}\n\n// END ../common/hexFns.glsl\n\nin vec2 coord;\nout vec4 fragColor;\nuniform float a;\nuniform float highResTimeStamp;\nuniform float iTime;\nuniform int bandCount;\nuniform mat4 viewModel;\nuniform sampler2D texture;\nuniform vec2 iResolution;\nuniform vec4 colorBackground;\nuniform vec4 colorPrimary;\nuniform vec4 colorSecondary;\n\nfloat perlin01(vec2 pos) {\n  return unmix(-0.68, 0.68, perlin2D(pos));\n}\n\nvoid main() {\n  vec2 fragCoord = transform(viewModel, coord * iResolution);\n  fragCoord *= 0.01;\n  vec4 waves1 = mix(\n    colorBackground,\n    colorPrimary,\n    float(\n      waves(colorPrimary, fragCoord, vec2(0.2, 0.05), iTime * 1000.0) >= 0.7\n    )\n  );\n  vec4 waves2 = mix(\n    colorSecondary,\n    colorBackground,\n    float(\n      waves(colorPrimary, fragCoord, vec2(0.002, 0.1), iTime * 1000.0) >= 0.7\n    )\n  );\n\n  float perl = perlin2D(fragCoord);\n  float perl01 = unmix(-0.68, 0.68, perl);\n  float band = banded(3.0, perl01);\n  float isTop = float(band == 1.0);\n  float isBottom = float(band == 0.0);\n  fragColor =\n    waves2 * isTop +\n    waves1 * isBottom +\n    (1.0 - isTop - isBottom) *\n      mix(\n        colorBackground,\n        colorPrimary,\n        banded(float(bandCount), unmix(0.333, 0.666, perl01))\n      );\n  //        + vec4(0.0, 0.0, 0.0, 1.0) * float(between(0.0, 0.3, perl));\n  // fragColor = mix(colorBackground, colorPrimary, banded(float(bandCount), perl01));\n  // fragColor = visualize(blue, red, perl01);\n\n  //    fragColor = mix(colorBackground, colorPrimary, unmix(-0.5, 0.5, perl));\n  //fragColor = texelFetch(gradients, ivec2(coord), 0);\n}\n",t={version:3,sources:["/home/runner/work/workshop/workshop/src/noises/test3.frag","/home/runner/work/workshop/workshop/src/common/banded.glsl","/home/runner/work/workshop/workshop/src/common/between.glsl","/home/runner/work/workshop/workshop/src/common/perlin2DTexture.glsl","/home/runner/work/workshop/workshop/src/common/unmix.glsl","/home/runner/work/workshop/workshop/src/common/remix.glsl","/home/runner/work/workshop/workshop/src/common/transform.glsl","/home/runner/work/workshop/workshop/src/common/waves.glsl","/home/runner/work/workshop/workshop/src/common/visualize.glsl","/home/runner/work/workshop/workshop/src/common/max3.glsl","/home/runner/work/workshop/workshop/src/common/constants.glsl","/home/runner/work/workshop/workshop/src/common/hexFns.glsl"],names:[],mappings:"AAAA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AXnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"}},5406:(A,n,e)=>{"use strict";e.r(n),e.d(n,{default:()=>o,sourceMap:()=>t});const o="#version 300 es\n\nprecision highp float;\n\n// START ../common/banded.glsl\nfloat banded(float bandCount, float t) {\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\n}\nfloat banded(int bandCount, float t) {\n  return banded(float(bandCount), t);\n}\n\n// #pragma glslify: export(banded)\n\n\n// END ../common/banded.glsl\n// START ../common/matrices.glsl\n// START ./constants.glsl\nconst float SQRT1_2 = 0.7071067811865476;\nconst float SQRT1_3 = 0.57735026919;\nconst float SQRT2 = 1.4142135623730951;\nconst float SQRT3 = 1.732050807568877;\n// sqrt(3)/2 = sin(60*)\nconst float SQRT3_2 = 0.86602540378;\nconst float GOLDEN_RATIO = 1.61803398875;\nconst float PI = 3.141592653589793;\nconst float TAU = 6.28318530718;\n/**\n * One degree in radians. Use like `sin(30 * DEG)`.\n */\nconst float DEGREE = 0.017453292519943295;\n\n// END ./constants.glsl\n\nmat2 rot2(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat2(c, s, -s, c);\n}\nmat3 rotX(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\n}\nmat3 rotY(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\n}\nmat3 rotZ(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\n}\n/**\n * Returns a matrix that puts the camera at the eye point `ex, ey, ez` looking\n * toward the center point `cx, cy, cz` with an up direction of `ux, uy, uz`.\n * This emulates the OpenGL function `gluLookAt()`.\n */\nmat4 lookAt(vec3 eye, vec3 focus, vec3 up) {\n  vec3 f = normalize(eye - focus);\n  vec3 s = normalize(cross(up, f));\n  vec3 t = normalize(cross(f, s));\n\n  return mat4(\n    vec4(s.x, t.x, f.x, 0.0),\n    vec4(s.y, t.y, f.y, 0.0),\n    vec4(s.z, t.z, f.z, 0.0),\n    vec4(-dot(s, eye), -dot(t, eye), -dot(f, eye), 1)\n  );\n}\n\n// the OpenGL function `glFrustum()`.\nmat4 frustum(\n  float left,\n  float right,\n  float bottom,\n  float top,\n  float near,\n  float far\n) {\n  return mat4(\n    vec4(2.0 * near / (right - left), 0.0, 0.0, 0.0),\n    vec4(0, 2.0 * near / (top - bottom), 0.0, 0.0),\n    vec4(\n      (right + left) / (right - left),\n      (top + bottom) / (top - bottom),\n      -(far + near) / (far - near),\n      -1\n    ),\n    vec4(0.0, 0.0, -2.0 * far * near / (far - near), 0.0)\n  );\n}\n\nmat4 perspective(float fovDegrees, float aspect, float near, float far) {\n  float y = tan(fovDegrees * DEGREE / 2.0) * near;\n  float x = y * aspect;\n  return frustum(-x, x, -y, y, near, far);\n}\nmat4 ortho(\n  float left,\n  float right,\n  float bottom,\n  float top,\n  float near,\n  float far\n) {\n  return mat4(\n    vec4(2.0 / (right - left), 0.0, 0.0, 0.0),\n    vec4(0.0, 2.0 / (top - bottom), 0.0, 0.0),\n    vec4(0.0, 0.0, -2.0 / (far - near), 0.0),\n    vec4(\n      -(right + left) / (right - left),\n      -(top + bottom) / (top - bottom),\n      -(far + near) / (far - near),\n      1.0\n    )\n  );\n}\n\n// END ../common/matrices.glsl\n// START ../common/max3.glsl\nfloat max3(float a, float b, float c) {\n  return max(a, max(b, c));\n}\nfloat max3(vec3 v) {\n  return max(v.x, max(v.y, v.z));\n}\n\n// #pragma glslify: export(max3)\n\n\n// END ../common/max3.glsl\n// START ../common/visualize.glsl\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\n  float isLow = float(t < 0.0);\n  float isHigh = float(t > 1.0);\n  float isMid = 1.0 - isLow - isHigh;\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\n}\n\nvec4 visualize(float t) {\n  const vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\n  const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\n  return visualize(BLUE, RED, t);\n}\n\n// #pragma glslify: export(visualize)\n\n\n// END ../common/visualize.glsl\n// START ../common/polar.glsl\n// START ../common/fromPolar.glsl\n// START ./unmix.glsl\nfloat unmix(float a, float b, float value) {\n  return (value - a) / (b - a);\n}\n\n// #pragma glslify: export(unmix)\n\n\n// END ./unmix.glsl\n\nvec3 fromPolar(float radius, float phi, float z) {\n  return vec3(radius * cos(phi), radius * sin(phi), z);\n}\n\nvec2 fromPolar(float radius, float phi) {\n  return vec2(radius * cos(phi), radius * sin(phi));\n}\n\nvec2 fromPolar(vec2 polar) {\n  return fromPolar(polar.x, polar.y);\n}\n\n// #pragma glslify: export(fromPolar)\n\n\n// END ../common/fromPolar.glsl\n// START ../common/toPolar.glsl\n\nvec2 toPolar(vec2 xy) {\n  return vec2(length(xy), atan(xy.y, xy.x));\n}\n\nmat2 toPolarDerivate(vec2 xy) {\n  return mat2(xy.x * xy.x, xy.y * xy.y, -xy.y, xy.x) / dot(xy, xy);\n}\n\n// #pragma glslify: export(toPolar)\n\n\n// END ../common/toPolar.glsl\n\n// END ../common/polar.glsl\n// START ../common/ungamma.glsl\nvec3 ungamma(vec4 col) {\n  return pow(col.rgb, vec3(2.2));\n}\nvec3 ungamma(vec3 col) {\n  return pow(col, vec3(2.2));\n}\n\n// END ../common/ungamma.glsl\n// START ../common/transform.glsl\nvec3 transform(mat4 pm, vec3 p) {\n  vec4 pStar = pm * vec4(p, 1);\n  return pStar.xyz / pStar.w;\n}\n\nvec2 transform(mat4 pm, vec2 p) {\n  vec4 pStar = pm * vec4(p, 0, 1);\n  return pStar.xy / pStar.w;\n}\n\n// END ../common/transform.glsl\n// START ../common/squareWave.glsl\nfloat squareWave(float x) {\n  return floor(2.0 * fract(0.5 * x));\n}\n\n// END ../common/squareWave.glsl\n// START ../common/OpenSimplex2.glsl\n//////////////// K.jpg's Re-oriented 4-Point BCC Noise (OpenSimplex2) ////////////////\n////////////////////// Output: vec4(dF/dx, dF/dy, dF/dz, value) //////////////////////\n\n// Inspired by Stefan Gustavson's noise\nvec4 permute(vec4 t) {\n  return t * (t * 34.0 + 133.0);\n}\n\n// Gradient set is a normalized expanded rhombic dodecahedron\nvec3 grad(float hash) {\n  // Random vertex of a cube, +/- 1 each\n  vec3 cube = mod(floor(hash / vec3(1.0, 2.0, 4.0)), 2.0) * 2.0 - 1.0;\n\n  // Random edge of the three edges connected to that vertex\n  // Also a cuboctahedral vertex\n  // And corresponds to the face of its dual, the rhombic dodecahedron\n  vec3 cuboct = cube;\n  cuboct[int(hash / 16.0)] = 0.0;\n\n  // In a funky way, pick one of the four points on the rhombic face\n  float type = mod(floor(hash / 8.0), 2.0);\n  vec3 rhomb = (1.0 - type) * cube + type * (cuboct + cross(cube, cuboct));\n\n  // Expand it so that the new edges are the same length\n  // as the existing ones\n  vec3 grad = cuboct * 1.22474487139 + rhomb;\n\n  // To make all gradients the same length, we only need to shorten the\n  // second type of vector. We also put in the whole noise scale constant.\n  // The compiler should reduce it into the existing floats. I think.\n  grad *= (1.0 - 0.042942436724648037 * type) * 32.80201376986577;\n\n  return grad;\n}\n\n// BCC lattice split up into 2 cube lattices\nvec4 openSimplex2Base(vec3 X) {\n  // First half-lattice, closest edge\n  vec3 v1 = round(X);\n  vec3 d1 = X - v1;\n  vec3 score1 = abs(d1);\n  vec3 dir1 = step(max(score1.yzx, score1.zxy), score1);\n  vec3 v2 = v1 + dir1 * sign(d1);\n  vec3 d2 = X - v2;\n\n  // Second half-lattice, closest edge\n  vec3 X2 = X + 144.5;\n  vec3 v3 = round(X2);\n  vec3 d3 = X2 - v3;\n  vec3 score2 = abs(d3);\n  vec3 dir2 = step(max(score2.yzx, score2.zxy), score2);\n  vec3 v4 = v3 + dir2 * sign(d3);\n  vec3 d4 = X2 - v4;\n\n  // Gradient hashes for the four points, two from each half-lattice\n  vec4 hashes = permute(mod(vec4(v1.x, v2.x, v3.x, v4.x), 289.0));\n  hashes = permute(mod(hashes + vec4(v1.y, v2.y, v3.y, v4.y), 289.0));\n  hashes = mod(\n    permute(mod(hashes + vec4(v1.z, v2.z, v3.z, v4.z), 289.0)),\n    48.0\n  );\n\n  // Gradient extrapolations & kernel function\n  vec4 a = max(\n    0.5 - vec4(dot(d1, d1), dot(d2, d2), dot(d3, d3), dot(d4, d4)),\n    0.0\n  );\n  vec4 aa = a * a;\n  vec4 aaaa = aa * aa;\n  vec3 g1 = grad(hashes.x);\n  vec3 g2 = grad(hashes.y);\n  vec3 g3 = grad(hashes.z);\n  vec3 g4 = grad(hashes.w);\n  vec4 extrapolations = vec4(\n    dot(d1, g1),\n    dot(d2, g2),\n    dot(d3, g3),\n    dot(d4, g4)\n  );\n\n  // Derivatives of the noise\n  vec3 derivative =\n    -8.0 * mat4x3(d1, d2, d3, d4) * (aa * a * extrapolations) +\n    mat4x3(g1, g2, g3, g4) * aaaa;\n\n  // Return it all as a vec4\n  return vec4(derivative, dot(aaaa, extrapolations));\n}\n\n// Use this if you don't want Z to look different from X and Y\nvec4 openSimplex2_Conventional(vec3 X) {\n  // Rotate around the main diagonal. Not a skew transform.\n  vec4 result = openSimplex2Base(dot(X, vec3(2.0 / 3.0)) - X);\n  return vec4(dot(result.xyz, vec3(2.0 / 3.0)) - result.xyz, result.w);\n}\n\n// Use this if you want to show X and Y in a plane, then use Z for time, vertical, etc.\nvec4 openSimplex2_ImproveXY(vec3 X) {\n  // Rotate so Z points down the main diagonal. Not a skew transform.\n  mat3 orthonormalMap = mat3(\n    vec3(0.788675134594813, -0.211324865405187, -0.577350269189626),\n    vec3(-0.211324865405187, 0.788675134594813, -0.577350269189626),\n    vec3(0.577350269189626, 0.577350269189626, 0.577350269189626)\n  );\n\n  vec4 result = openSimplex2Base(orthonormalMap * X);\n  return vec4(result.xyz * orthonormalMap, result.w);\n}\n\n//////////////////////////////// End noise code ////////////////////////////////\n\n\n// END ../common/OpenSimplex2.glsl\n// START ../common/checkerboardGrad.glsl\n//https://iquilezles.org/articles/checkerfiltering/\nfloat tri(float x) {\n  float h = fract(x * 0.5) - 0.5;\n  return 1.0 - 2.0 * abs(h);\n}\nvec2 tri(vec2 x) {\n  vec2 h = fract(x * 0.5) - 0.5;\n  return 1.0 - 2.0 * abs(h);\n}\n\nfloat checkerboardGrad(vec2 uv) {\n  vec2 w = max(abs(dFdx(uv)), abs(dFdy(uv))) + 0.01; // filter kernel\n  vec2 i = (tri(uv + 0.5 * w) - tri(uv - 0.5 * w)) / w; // analytical integral (box filter)\n  return 0.5 - 0.5 * i.x * i.y; // xor pattern\n}\n\n// END ../common/checkerboardGrad.glsl\n// START ../common/colors.glsl\nconst vec3 INDIAN_RED = vec3(0.804, 0.361, 0.361);\nconst vec3 LIGHT_CORAL = vec3(0.941, 0.502, 0.502);\nconst vec3 SALMON = vec3(0.98, 0.502, 0.447);\nconst vec3 DARK_SALMON = vec3(0.914, 0.588, 0.478);\nconst vec3 LIGHT_SALMON = vec3(1.0, 0.627, 0.478);\nconst vec3 CRIMSON = vec3(0.863, 0.078, 0.235);\nconst vec3 RED = vec3(1.0, 0.0, 0.0);\nconst vec3 FIRE_BRICK = vec3(0.698, 0.133, 0.133);\nconst vec3 DARK_RED = vec3(0.545, 0.0, 0.0);\nconst vec3 PINK = vec3(1.0, 0.753, 0.796);\nconst vec3 LIGHT_PINK = vec3(1.0, 0.714, 0.757);\nconst vec3 HOT_PINK = vec3(1.0, 0.412, 0.706);\nconst vec3 DEEP_PINK = vec3(1.0, 0.078, 0.576);\nconst vec3 MEDIUM_VIOLET_RED = vec3(0.78, 0.082, 0.522);\nconst vec3 PALE_VIOLET_RED = vec3(0.859, 0.439, 0.576);\nconst vec3 CORAL = vec3(1.0, 0.498, 0.314);\nconst vec3 TOMATO = vec3(1.0, 0.388, 0.278);\nconst vec3 ORANGE_RED = vec3(1.0, 0.271, 0.0);\nconst vec3 DARK_ORANGE = vec3(1.0, 0.549, 0.0);\nconst vec3 ORANGE = vec3(1.0, 0.647, 0.0);\nconst vec3 GOLD = vec3(1.0, 0.843, 0.0);\nconst vec3 YELLOW = vec3(1.0, 1.0, 0.0);\nconst vec3 LIGHT_YELLOW = vec3(1.0, 1.0, 0.878);\nconst vec3 LEMON_CHION = vec3(1.0, 0.98, 0.804);\nconst vec3 LIGHT_GOLDENROD_YELLOW = vec3(0.98, 0.98, 0.824);\nconst vec3 PAPAYA_WHIP = vec3(1.0, 0.937, 0.835);\nconst vec3 MOCCASIN = vec3(1.0, 0.894, 0.71);\nconst vec3 PEACH_PU = vec3(1.0, 0.855, 0.725);\nconst vec3 PALE_GOLDENROD = vec3(0.933, 0.91, 0.667);\nconst vec3 KHAKI = vec3(0.941, 0.902, 0.549);\nconst vec3 DARK_KHAKI = vec3(0.741, 0.718, 0.42);\nconst vec3 LAVENDER = vec3(0.902, 0.902, 0.98);\nconst vec3 THISTLE = vec3(0.847, 0.749, 0.847);\nconst vec3 PLUM = vec3(0.867, 0.627, 0.867);\nconst vec3 VIOLET = vec3(0.933, 0.51, 0.933);\nconst vec3 ORCHID = vec3(0.855, 0.439, 0.839);\nconst vec3 FUCHSIA = vec3(1.0, 0.0, 1.0);\nconst vec3 MAGENTA = vec3(1.0, 0.0, 1.0);\nconst vec3 MEDIUM_ORCHID = vec3(0.729, 0.333, 0.827);\nconst vec3 MEDIUM_PURPLE = vec3(0.576, 0.439, 0.859);\nconst vec3 BLUE_VIOLET = vec3(0.541, 0.169, 0.886);\nconst vec3 DARK_VIOLET = vec3(0.58, 0.0, 0.827);\nconst vec3 DARK_ORCHID = vec3(0.6, 0.196, 0.8);\nconst vec3 DARK_MAGENTA = vec3(0.545, 0.0, 0.545);\nconst vec3 PURPLE = vec3(0.502, 0.0, 0.502);\nconst vec3 INDIGO = vec3(0.294, 0.0, 0.51);\nconst vec3 SLATE_BLUE = vec3(0.416, 0.353, 0.804);\nconst vec3 DARK_SLATE_BLUE = vec3(0.282, 0.239, 0.545);\nconst vec3 GREEN_YELLOW = vec3(0.678, 1.0, 0.184);\nconst vec3 CHARTREUSE = vec3(0.498, 1.0, 0.0);\nconst vec3 LAWN_GREEN = vec3(0.486, 0.988, 0.0);\nconst vec3 LIME = vec3(0.0, 1.0, 0.0);\nconst vec3 LIME_GREEN = vec3(0.196, 0.804, 0.196);\nconst vec3 PALE_GREEN = vec3(0.596, 0.984, 0.596);\nconst vec3 LIGHT_GREEN = vec3(0.565, 0.933, 0.565);\nconst vec3 MEDIUM_SPRING_GREEN = vec3(0.0, 0.98, 0.604);\nconst vec3 SPRING_GREEN = vec3(0.0, 1.0, 0.498);\nconst vec3 MEDIUM_SEA_GREEN = vec3(0.235, 0.702, 0.443);\nconst vec3 SEA_GREEN = vec3(0.18, 0.545, 0.341);\nconst vec3 FOREST_GREEN = vec3(0.133, 0.545, 0.133);\nconst vec3 GREEN = vec3(0.0, 0.502, 0.0);\nconst vec3 DARK_GREEN = vec3(0.0, 0.392, 0.0);\nconst vec3 YELLOW_GREEN = vec3(0.604, 0.804, 0.196);\nconst vec3 OLIVE_DRAB = vec3(0.42, 0.557, 0.137);\nconst vec3 OLIVE = vec3(0.502, 0.502, 0.0);\nconst vec3 DARK_OLIVE_GREEN = vec3(0.333, 0.42, 0.184);\nconst vec3 MEDIUM_AQUAMARINE = vec3(0.4, 0.804, 0.667);\nconst vec3 DARK_SEA_GREEN = vec3(0.561, 0.737, 0.561);\nconst vec3 LIGHT_SEA_GREEN = vec3(0.125, 0.698, 0.667);\nconst vec3 DARK_CYAN = vec3(0.0, 0.545, 0.545);\nconst vec3 TEAL = vec3(0.0, 0.502, 0.502);\nconst vec3 AQUA = vec3(0.0, 1.0, 1.0);\nconst vec3 CYAN = vec3(0.0, 1.0, 1.0);\nconst vec3 LIGHT_CYAN = vec3(0.878, 1.0, 1.0);\nconst vec3 PALE_TURQUOISE = vec3(0.686, 0.933, 0.933);\nconst vec3 AQUAMARINE = vec3(0.498, 1.0, 0.831);\nconst vec3 TURQUOISE = vec3(0.251, 0.878, 0.816);\nconst vec3 MEDIUM_TURQUOISE = vec3(0.282, 0.82, 0.8);\nconst vec3 DARK_TURQUOISE = vec3(0.0, 0.808, 0.82);\nconst vec3 CADET_BLUE = vec3(0.373, 0.62, 0.627);\nconst vec3 STEEL_BLUE = vec3(0.275, 0.51, 0.706);\nconst vec3 LIGHT_STEEL_BLUE = vec3(0.69, 0.769, 0.871);\nconst vec3 POWDER_BLUE = vec3(0.69, 0.878, 0.902);\nconst vec3 LIGHT_BLUE = vec3(0.678, 0.847, 0.902);\nconst vec3 SKY_BLUE = vec3(0.529, 0.808, 0.922);\nconst vec3 LIGHT_SKY_BLUE = vec3(0.529, 0.808, 0.98);\nconst vec3 DEEP_SKY_BLUE = vec3(0.0, 0.749, 1.0);\nconst vec3 DODGER_BLUE = vec3(0.118, 0.565, 1.0);\nconst vec3 CORNLOWER_BLUE = vec3(0.392, 0.584, 0.929);\nconst vec3 MEDIUM_SLATE_BLUE = vec3(0.482, 0.408, 0.933);\nconst vec3 ROYAL_BLUE = vec3(0.255, 0.412, 0.882);\nconst vec3 BLUE = vec3(0.0, 0.0, 1.0);\nconst vec3 MEDIUM_BLUE = vec3(0.0, 0.0, 0.804);\nconst vec3 DARK_BLUE = vec3(0.0, 0.0, 0.545);\nconst vec3 NAVY = vec3(0.0, 0.0, 0.502);\nconst vec3 MIDNIGHT_BLUE = vec3(0.098, 0.098, 0.439);\nconst vec3 CORNSILK = vec3(1.0, 0.973, 0.863);\nconst vec3 BLANCHED_ALMOND = vec3(1.0, 0.922, 0.804);\nconst vec3 BISQUE = vec3(1.0, 0.894, 0.769);\nconst vec3 NAVAJO_WHITE = vec3(1.0, 0.871, 0.678);\nconst vec3 WHEAT = vec3(0.961, 0.871, 0.702);\nconst vec3 BURLY_WOOD = vec3(0.871, 0.722, 0.529);\nconst vec3 TAN = vec3(0.824, 0.706, 0.549);\nconst vec3 ROSY_BROWN = vec3(0.737, 0.561, 0.561);\nconst vec3 SANDY_BROWN = vec3(0.957, 0.643, 0.376);\nconst vec3 GOLDENROD = vec3(0.855, 0.647, 0.125);\nconst vec3 DARK_GOLDENROD = vec3(0.722, 0.525, 0.043);\nconst vec3 PERU = vec3(0.804, 0.522, 0.247);\nconst vec3 CHOCOLATE = vec3(0.824, 0.412, 0.118);\nconst vec3 SADDLE_BROWN = vec3(0.545, 0.271, 0.075);\nconst vec3 SIENNA = vec3(0.627, 0.322, 0.176);\nconst vec3 BROWN = vec3(0.647, 0.165, 0.165);\nconst vec3 MAROON = vec3(0.502, 0.0, 0.0);\nconst vec3 WHITE = vec3(1.0, 1.0, 1.0);\nconst vec3 SNOW = vec3(1.0, 0.98, 0.98);\nconst vec3 HONEYDEW = vec3(0.941, 1.0, 0.941);\nconst vec3 MINT_CREAM = vec3(0.961, 1.0, 0.98);\nconst vec3 AZURE = vec3(0.941, 1.0, 1.0);\nconst vec3 ALICE_BLUE = vec3(0.941, 0.973, 1.0);\nconst vec3 GHOST_WHITE = vec3(0.973, 0.973, 1.0);\nconst vec3 WHITE_SMOKE = vec3(0.961, 0.961, 0.961);\nconst vec3 SEASHELL = vec3(1.0, 0.961, 0.933);\nconst vec3 BEIGE = vec3(0.961, 0.961, 0.863);\nconst vec3 OLD_LACE = vec3(0.992, 0.961, 0.902);\nconst vec3 FLORAL_WHITE = vec3(1.0, 0.98, 0.941);\nconst vec3 IVORY = vec3(1.0, 1.0, 0.941);\nconst vec3 ANTIQUE_WHITE = vec3(0.98, 0.922, 0.843);\nconst vec3 LINEN = vec3(0.98, 0.941, 0.902);\nconst vec3 LAVENDER_BLUSH = vec3(1.0, 0.941, 0.961);\nconst vec3 MISTY_ROSE = vec3(1.0, 0.894, 0.882);\nconst vec3 GAINSBORO = vec3(0.863, 0.863, 0.863);\nconst vec3 LIGHT_GREY = vec3(0.827, 0.827, 0.827);\nconst vec3 SILVER = vec3(0.753, 0.753, 0.753);\nconst vec3 DARK_GRAY = vec3(0.663, 0.663, 0.663);\nconst vec3 GRAY = vec3(0.502, 0.502, 0.502);\nconst vec3 DIM_GRAY = vec3(0.412, 0.412, 0.412);\nconst vec3 LIGHT_SLATE_GRAY = vec3(0.467, 0.533, 0.6);\nconst vec3 SLATE_GRAY = vec3(0.439, 0.502, 0.565);\nconst vec3 DARK_SLATE_GRAY = vec3(0.184, 0.31, 0.31);\nconst vec3 BLACK = vec3(0.0, 0.0, 0.0);\n\n// END ../common/colors.glsl\n// START ../common/sdf3d/sdIcosahedron.glsl\n\n// signed distance function for icosahedron\n// cf. https://en.wikipedia.org/wiki/Regular_icosahedron\n// s: edge length\n// p: point to evaluate function for\nfloat sdIcosahedron(float s, vec3 p) {\n  // NN = 1/GOLDEN_RATIO = GOLDEN_RATIO - 1\n  const float K = GOLDEN_RATIO * 0.5;\n  // the three vertices of the icosahedron triangle which\n  // is fully inside the +++ octant. (edge length = 1)\n  const vec3 a = vec3(0.5, K, 0.0);\n  const vec3 b = vec3(0.0, 0.5, K);\n  const vec3 c = vec3(K, 0.0, 0.5);\n  const vec3 ab1 = b - a; // values chosen so edge length is 1\n  const vec3 n1 = normalize(cross(a, b));\n  const vec3 n2 = normalize(cross(b, c));\n  const vec3 n3 = normalize(cross(c, a));\n  const vec3 xyz1 = normalize(vec3(1.0));\n  // for edge-length 1\n  const float INSCRIBED_SPHERE_RADIUS = 0.7557613141;\n\n  // we use a rotation where the icosahedron is symmetric\n  // in all three coordinate planes, and reduce the problem\n  // to the +++ octant\n  p = abs(p);\n\n  // there is one complete triangle in the +++ octant\n  // mirror on planes which go through origin and the\n  // complete triangles sides.\n  if (dot(p, n1) < 0.0) {\n    p += -2.0 * dot(p, n1) * n1;\n  }\n  if (dot(p, n2) < 0.0) {\n    p += -2.0 * dot(p, n2) * n2;\n  }\n  if (dot(p, n3) < 0.0) {\n    p += -2.0 * dot(p, n3) * n3;\n  }\n\n  // rotate space around (1,1,1) vector so that all sides of the triangle\n  // end up mapped on the ab side.\n  vec3 dirs = vec3(-dot(n1, p), -dot(n2, p), -dot(n3, p));\n  if (dirs.y > dirs.x && dirs.y > dirs.z) {\n    p = p.yzx;\n  } else if (dirs.z > dirs.x && dirs.z > dirs.y) {\n    p = p.zxy;\n  }\n\n  // check if the point is directly (perpendicular) above the triangle.\n  // as we have rotated the space, we only need to check if it is\n  // inside one edge.\n  vec3 midAB = (a + b) / 2.0;\n  vec3 pn = normalize(c - midAB);\n  float w = dot(midAB, pn);\n  if (dot(p, pn) > w * s) {\n    // if not, return the distance to the plane the triangle is in\n    return dot(xyz1, p) - INSCRIBED_SPHERE_RADIUS * s;\n  }\n\n  // project the point onto segment ab, and return the distance to it\n  float d3 = dot(ab1, p);\n  d3 = clamp(d3, -0.5 * s, 0.5 * s);\n  vec3 closestp = midAB * s + d3 * ab1;\n  return distance(closestp, p);\n}\n// #pragma glslify: export(sdIcosahedron)\n\n// END ../common/sdf3d/sdIcosahedron.glsl\n// START ../common/sdf3d/sdDodecahedron.glsl\n\nfloat sdDodecahedron(float s, vec3 p, out vec3 color) {\n  const float PHI = GOLDEN_RATIO;\n  color = vec3(0.2);\n  if (p != abs(p)) {\n    p = abs(p);\n    if (color == vec3(0.2)) color = RED;\n  }\n  p = abs(p);\n  const vec3 fv =\n    vec3(1.0 / PHI, 0, PHI) + 2.0 * vec3(1, 0, 1) + 2.0 * vec3(PHI, 0, 0);\n  const vec3 fv2 =\n    vec3(PHI, 1.0 / PHI, 0) + 2.0 * vec3(1, 1, 0) + 2.0 * vec3(0, PHI, 0);\n  const vec3 fv3 =\n    vec3(0, PHI, 1.0 / PHI) + 2.0 * vec3(0, 1, 1) + 2.0 * vec3(0, 0, PHI);\n  return max3(\n    dot(normalize(fv), p),\n    dot(normalize(fv2), p),\n    dot(normalize(fv3), p)\n  ) -\n  s;\n  //  float m = p.x + p.y + p.z - s;\n  //  vec3 q;\n  //  if (3.0 * p.x < m) q = p.xyz;\n  //  else if (3.0 * p.y < m) q = p.yzx;\n  //  else if (3.0 * p.z < m) q = p.zxy;\n  //  else return m * 0.57735027;\n  //\n  //  float k = clamp(0.5 * (q.z - q.y + s), 0.0, s);\n  //  return length(vec3(q.x, q.y - s + k, q.z - k));\n}\nfloat sdDodecahedron(float s, vec3 p) {\n  vec3 c;\n  return sdDodecahedron(s, p, c);\n}\n\n// END ../common/sdf3d/sdDodecahedron.glsl\n// START ../common/sdf3d/sdCylinder.glsl\nfloat sdCylinder(float radius, float z, vec3 p) {\n  vec2 d = vec2(length(p.xy), abs(p.z)) - vec2(radius, z);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// #pragma glslify: export(sdCylinder)\n\n\n// END ../common/sdf3d/sdCylinder.glsl\n// START ../common/sdf3d/sdLego.glsl\n// START ./sdTube.glsl\nfloat sdTube(float radius, float r2, float z, vec3 p) {\n  vec2 d = vec2(length(p.xy), abs(p.z)) - vec2(radius, z);\n  d.x = abs(d.x) - r2;\n  vec2 closest = vec2(abs(d.x - radius) - r2, clamp(d.y, 0.0, z));\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// END ./sdTube.glsl\n// START ./sdBox.glsl\n\nfloat sdBox(vec3 r, vec3 p) {\n  vec3 q = abs(p) - r;\n  return length(max(q, 0.0)) + min(max3(q), 0.0);\n}\n\nfloat sdBox(vec3 r, float r2, vec3 p) {\n  return sdBox(r - r2, p) - r2;\n}\n\n// #pragma glslify: export(sdBox)\n\n\n// END ./sdBox.glsl\n\nfloat sdLego(vec3 p) {\n  const float IWALLT = 0.04;\n  p.xy = abs(p.xy);\n  vec2 c = vec2(4.0, 2.0);\n  //    p.xy = mod(p.xy + c * 0.5, c) - c * 0.5;\n  p -= vec3(0.0, 0.0, 0.6);\n  float d;\n  const float cr = 0.02;\n  d = sdBox(vec3(2.0, 1.0, 0.6), cr, p);\n  if (d > 0.5) {\n    return d;\n  }\n  //    top studs\n  vec3 p8 = vec3(abs(p.xy - vec2(1.0, 0.0)), p.z) - vec3(0.5, 0.5, 0.6);\n  float dStuds = sdCylinder(0.35 - 0.04, 0.2, p8) - 0.04;\n  d = min(d, dStuds);\n  // little holes in bottom of studs\n  float dStudHoles = sdCylinder(0.2 - 0.04, 0.3, p8 - vec3(0, 0, -0.4)) - 0.04;\n  d = max(d, -dStudHoles);\n  // TODO use sdf texture to add LEGO or custom logo to studs\n\n  // hole in the bottom\n  const float WALLT = 4.0 * IWALLT;\n  float dBottom = sdBox(\n    vec3(2.0 - WALLT, 1.0 - WALLT, 0.6),\n    p - vec3(0, 0, -WALLT)\n  );\n  d = max(d, -dBottom);\n\n  // 12 indentations on inside.\n  vec3 pa = p;\n  // 3. move by 1 in X dir\n  pa.x -= 1.0;\n  // 2. mirror across XY axis\n  if (pa.x > pa.y) pa.xy = pa.yx;\n  // 1. mirror across Y axis\n  pa.x = abs(pa.x);\n  float k = sdBox(vec3(0.5 * IWALLT, 0.05, 0.6), pa - vec3(0.5, 0.8, 0));\n  d = min(d, k);\n\n  // center bar\n  p = vec3(abs(p.xy), p.z);\n  d = min(d, sdBox(vec3(0.5 * IWALLT, 0.3, 0.5), p - vec3(0, 0.65, 0.1)));\n\n  // 3 tubes\n  vec3 pTube = p;\n  if (pTube.x > 0.5) pTube.x -= 1.0;\n  pTube.x = abs(pTube.x);\n  d = min(d, sdTube(0.35 + 0.5 * IWALLT, 0.5 * IWALLT, 0.6, pTube));\n  return d;\n}\n\n// END ../common/sdf3d/sdLego.glsl\n// START ../common/sdf3d/sdOctahedron.glsl\nfloat sdOctahedron(float s, vec3 p) {\n  p = abs(p);\n  float m = p.x + p.y + p.z - s;\n  vec3 q;\n  if (3.0 * p.x < m) q = p.xyz;\n  else if (3.0 * p.y < m) q = p.yzx;\n  else if (3.0 * p.z < m) q = p.zxy;\n  else return m * 0.57735027;\n\n  float k = clamp(0.5 * (q.z - q.y + s), 0.0, s);\n  return length(vec3(q.x, q.y - s + k, q.z - k));\n}\n// #pragma glslify: export(sdOctahedron)\n\nfloat sdOctahedron(vec3 p, float s) {\n  p = abs(p);\n\n  float m = p.x + p.y + p.z - s;\n  //find point on octohedron surf nearest to p\n  vec3 projPoint = p - vec3(0.333333 * m); //project onto surface plane\n  //now push projected point, if outside triangle edge, perpendicular to edge, to edge\n  vec3 toMove = min(projPoint, 0.0); //if projpoint.x<0 move along (1.0,-0.5,-0.5) , etc\n  float toMoveSum = dot(toMove, vec3(1.0)); //which is basically along (1.5,0,0) then vec3(-0.5)\n\n  vec3 movedPoint = projPoint + toMove * vec3(-1.5) + toMoveSum * vec3(0.5); //better to multiply toMove by a matrix (1s diagonal, 0.5 other)?\n\n  movedPoint = max(movedPoint, 0.0); //cap x,y,z to 0 then\n  movedPoint *= s / dot(movedPoint, vec3(1.0)); //scale about 0,0,0\n\n  return length(p - movedPoint);\n}\n\n// END ../common/sdf3d/sdOctahedron.glsl\n// START ../common/sdf3d/sdArrow.glsl\n// START ./sdCone.glsl\n\n/**\n * Signed distance function (SDF) of a cone. The tip of the cone is at the\n * origin and points towards +Z. q is a point on the rim of the cone.\n */\nfloat sdCone(vec2 c, float h, vec3 p) {\n  vec2 q = h * vec2(c.x / c.y, -1.0);\n  vec2 w = vec2(length(p.xz), p.y);\n  vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);\n  vec2 b = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0);\n  float k = sign(q.y);\n  float d = min(dot(a, a), dot(b, b));\n  float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));\n  return sqrt(d) * sign(s);\n}\n// #pragma glslify: export(sdBox)\n\nfloat sdConeB(vec2 c, float h, vec3 p) {\n  float q = length(p.xz);\n  return max(dot(c.xy, vec2(q, p.y)), -h - p.y);\n}\n\n// END ./sdCone.glsl\nvec3 perpendicularVector(vec3 a) {\n  return cross(a, abs(a.z) > abs(a.x) ? vec3(0, 0, 1) : vec3(0, 1, 0));\n}\n/**\n * Signed distance function (SDF) of an arrow. The arrow goes along the X axis.\n * The shaft of the arrow has thickness TODO. The tip of the arrow has 30Â°\n * angle, length of TODO, with the widest point being.\n */\nfloat sdArrow(float length, vec3 p) {\n  float r = 0.01;\n  return min(\n    sdCylinder(\n      0.02 - r,\n      0.5 * (length - 0.1) - r,\n      p.yzx - vec3(0, 0, 0.5 * (length - 0.1))\n    ) -\n      r,\n    sdCone(\n      vec2(sin(15.0 * DEGREE), cos(15.0 * DEGREE)),\n      0.15 - r,\n      p.zxy - vec3(0, length - r, 0)\n    ) -\n      r\n  );\n}\nfloat sdArrow(vec3 a, vec3 b, vec3 p) {\n  vec3 x = normalize(b - a);\n  vec3 y = normalize(perpendicularVector(x));\n  vec3 z = cross(x, y);\n  return sdArrow(length(b - a), inverse(mat3(x, y, z)) * (p - a));\n}\n\n// END ../common/sdf3d/sdArrow.glsl\n// START ../common/sdf3d/sdTetrahedron.glsl\n// START ./sdCapsule.glsl\nfloat sdCapsule(vec3 a, vec3 b, float r, vec3 p) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h) - r;\n}\n// #pragma glslify: export(sdCapsule)\n\n// END ./sdCapsule.glsl\n\n/**\n * Signed distance function (SDF) of a tetrahedron centered at the origin with\n * side length `2s`.\n *\n * The corners are at `a/b = (+-1,0,sqrt(1/2))` and `c/d = (0,+-1,-sqrt(1/2))`.\n *\n * The side length is `||`\n *\n * The outscribed sphere has a radius of `sqrt(3/2)`.\n *\n * The inscribed sphere has a radius of `sqrt(1/6)`. This is calculated using\n * the fact that the triangle defined by `mid(a,b) = (0,0,sqrt(1/2))`, `c` and\n * `mid(c,d) = (0,0,-sqrt(1/2))` is similar to the triangle `mid(a,b)`, `q`, and\n * `O`.\n *\n * For rounded edges, use TODO.\n *\n * ```\n *           ^ Z\n *           |(+-1, sqrt(1/2))\n *          /\\_\n *        /    \\.q = closest point to center on face\n *      /    .   \\__> Y\n *    /            \\_\n *  /________________\\_(0,-1,sqrt(1/2))\n * (0,-1,-sqrt(1/2))\n * ```\n */\nfloat sdTetrahedron(float s, vec3 p) {\n  const vec3 a = vec3(1, 0, SQRT1_2);\n  const vec3 b = vec3(-1, 0, SQRT1_2);\n  const vec3 c = vec3(0, 1, -SQRT1_2);\n  const vec3 d = vec3(0, -1, -SQRT1_2);\n  const vec3 midBC = 0.5 * (b + c);\n  const vec3 mirror = normalize(cross(midBC - d, midBC - a));\n\n  // Tetra is symmetric in X and Y axes. RED surface in image.\n  p.xy = abs(p.xy);\n  // The part z < 0 is symmetric if we rotate it by 90Â°. BLUE surface in image.\n  if (p.z < 0.0) {\n    p = vec3(p.y, p.x, -p.z);\n  }\n  // Points below the plane through a, d and mid(b,c) are mirrored through it.\n  // GREEN surface in image.\n  p -= 2.0 * mirror * min(dot(p, mirror), 0.0);\n  // After mirror some points are negative, abs again:\n  p.xy = abs(p.xy);\n\n  // Points are now either above the white surface, or above the positive ab segment.\n  // We shift the coordinate system so that a is now at the origin.\n  p -= vec3(1, 0, SQRT1_2) * s;\n  // Finally, we move points which are directely above the face parallel along\n  // it to a/origin. We can then calculate the sdf as length(p).\n  p.x = max(p.x, 0.0);\n  vec3 midABToC1 = normalize(vec3(0, 1, -SQRT2));\n\n  p -= max(dot(midABToC1, p), 0.0) * midABToC1;\n  return sign(p.z) * length(p);\n}\n\n// Same function but also outputs color for explanation image:\n//float sdTetrahedron(float s, vec3 p, out vec3 color) {\n//  //  return distance(vec3(1), p) - 0.2;\n//  const vec3 a = vec3(0, -1, -SQRT1_2);\n//  const vec3 b = vec3(0, 1, -SQRT1_2);\n//  const vec3 c = vec3(1, 0, SQRT1_2);\n//  const vec3 d = vec3(-1, 0, SQRT1_2);\n//  const vec3 x = 0.5 * (b + d);\n//  const vec3 mirror = normalize(cross(x - a, x - c));\n//\n//  color = WHITE;\n//  if (p.xy != abs(p.xy)) {\n//    p.xy = abs(p.xy);\n//    if (color == WHITE) color = RED;\n//  }\n//  if (p.z < 0.0) {\n//    p = vec3(p.y, p.x, -p.z);\n//    if (color == WHITE) color = BLUE;\n//  }\n//  if (dot(p, mirror) < 0.0) {\n//    if (color == WHITE) color = GREEN;\n//    p -= 2.0 * mirror * min(dot(p, mirror), 0.0);\n//  }\n//  p.xy = abs(p.xy);\n//  p -= vec3(1, 0, SQRT1_2);\n//  p.x = max(p.x, 0.0);\n//  vec3 fgh = normalize(vec3(0, 1, -SQRT2));\n//\n//  p -= max(dot(fgh, p), 0.0) * fgh;\n//  return sign(p.z) * length(p);\n//}\n\n\n// END ../common/sdf3d/sdTetrahedron.glsl\n\nuniform sampler2D texture;\nuniform float iTime;\nuniform vec4 colorPrimary;\nuniform vec4 colorSecondary;\nuniform vec4 colorBackground;\nuniform float a;\nuniform float b;\nuniform float c;\nuniform float d;\nuniform int bandCount;\nuniform vec2 iResolution;\nuniform vec2 iMouse;\nin float n;\nin vec2 coord;\nout vec4 fragColor;\n\n\nstruct Hit {\n  float distance;\n  vec4 color;\n};\nHit mixa(Hit a, Hit b, float t) {\n  return Hit(mix(a.distance, b.distance, t), mix(a.color, b.color, t));\n}\nfloat skybox(vec3 p) {\n  return 32.0 - max3(abs(p));\n}\n\nHit add(Hit a, Hit b) {\n  //    return a.distance < b.distance\n  //        ? Hit(a.distance, a.color)\n  //        : Hit(b.distance, b.color);\n  return mixa(a, b, float(b.distance < a.distance));\n}\n\nHit addFillet(float r, Hit a, Hit b) {\n  if (a.distance < r && b.distance < r) {\n    return Hit(\n      r - distance(vec2(a.distance, b.distance), vec2(r)),\n      mix(a.color, b.color, (a.distance - b.distance) / r * 0.5 + 0.5)\n    );\n  } else {\n    return add(a, b);\n  }\n}\n\nHit addFillet(float r, Hit a, Hit b, vec4 tilletColor) {\n  if (a.distance < r && b.distance < r) {\n    return Hit(\n      r - distance(vec2(a.distance, b.distance), vec2(r)),\n      tilletColor\n    );\n  } else {\n    return add(a, b);\n  }\n}\nHit addFillet2(float r, Hit a, Hit b) {\n  float h = smoothstep(-r, r, a.distance - b.distance);\n  return Hit(\n    mix(a.distance, b.distance, h) - r * h * (1.0 - h),\n    mix(a.color, b.color, h)\n  );\n}\n\nHit neg(Hit a) {\n  return Hit(-a.distance, a.color);\n}\nHit sub(Hit from, Hit what) {\n  Hit whatNeg = neg(what);\n  return mixa(from, whatNeg, float(whatNeg.distance > from.distance));\n}\n\nvec3 modv(vec3 v, vec3 dir1, float y) {\n  float t = dot(v, dir1);\n  return v - floor(t / y) * y * dir1;\n}\nvec3 modRotZ(vec3 p, float count) {\n  vec2 polarXY = toPolar(p.xy);\n  return fromPolar(polarXY.x, mod(polarXY.y, TAU / count), p.z);\n}\n\nfloat sin01(float x) {\n  return 0.5 + 0.5 * sin(x);\n}\nfloat cos01(float x) {\n  return 0.5 + 0.5 * cos(x);\n}\n\nfloat smoothmin(float r, float a, float b) {\n  float h = smoothstep(-r, r, a - b);\n  return mix(a, b, h) - r * h * (1.0 - h);\n}\n\nvec2 project(vec2 a, vec2 onto1) {\n  return onto1 * (dot(a, onto1) / dot(onto1, onto1));\n}\n\nvec3 reject(vec3 a, vec3 b1) {\n  return a - b1 * dot(a, b1);\n}\nfloat wavy(float x) {\n  return fract(x);\n}\nfloat wood(vec3 p) {\n  return distance(p.xy, vec3(0).xy) +\n  // narrower near top:\n  0.01 * p.z +\n  0.05 * openSimplex2_Conventional(p).w +\n  0.01 * openSimplex2_Conventional(2.0 * p).w;\n}\nHit sdf(vec3 p) {\n  float scale = 2.0;\n  float ds = sdCylinder(1.0, 1.0, p - vec3(0, -1.2, 1));\n  ds = min(ds, sdBox(vec3(1.0), p - vec3(0, 1.2, 1)));\n  if (ds > 1.0) {\n    //    ds *= 0.1;\n  }\n  float dg = p.z;\n  if (ds < dg) {\n    float k = wood(p - vec3(0, -1.2, 0));\n\n    vec3 color = mix(ungamma(SANDY_BROWN), ungamma(BROWN), wavy(k * 10.0));\n    //    color = ungamma(colorPrimary);\n    //        vec3 color = vec3(f);\n\n    return Hit(ds, vec4(color, 1));\n  } else {\n    float f = checkerboardGrad(p.xy);\n\n    vec3 color = mix(ungamma(colorBackground), ungamma(colorSecondary), f);\n    return Hit(dg, vec4(color, 1));\n  }\n}\nfloat sdff(vec3 p) {\n  return sdf(p).distance;\n}\nfloat ambientOcclusion(vec3 pWC, vec3 n1WC) {\n  float k = 1.0;\n  float distance = sdff(pWC + n1WC * k);\n  return clamp(distance / k, 0.0, 1.0);\n}\n\nstruct RMResult {\n  float distance;\n  vec3 pos;\n  vec4 color;\n};\nRMResult raymarching2(vec3 start, vec3 dir1) {\n  vec3 pos = start;\n  Hit hit;\n  for (int i = 0; i < 100; i++) {\n    hit = sdf(pos);\n    if (hit.distance < 0.0001) break;\n    pos = pos + dir1 * hit.distance;\n  }\n  return RMResult(hit.distance, pos, hit.color);\n}\n\nfloat softshadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {\n  float res = 1.0;\n  float t = 0.1;\n  for (int i = 0; i < 1000 && t < maxt; i++) {\n    float h = sdff(ro + rd * t);\n    if (h < 0.001) return 0.0;\n    res = min(res, k * h / t);\n    t += h;\n  }\n  return res;\n}\n\nconst float eps = 1e-4;\nvec3 sdfNormal1(vec3 p, float d) {\n  return normalize(\n    vec3(\n      sdff(p + vec3(eps, 0.0, 0.0)),\n      sdff(p + vec3(0.0, eps, 0.0)),\n      sdff(p + vec3(0.0, 0.0, eps))\n    ) -\n      vec3(sdff(p))\n  );\n}\n\n//layout (depth_greater) out float gl_FragDepth;\nvoid main() {\n  vec3 camPos =\n    vec3(20, 0, 10) +\n    (-1.0 == iMouse.x\n      ? vec3(0)\n      : vec3(0, (iMouse / iResolution * 2.0 - 1.0) * 10.0));\n  mat4 modelView =\n    perspective(10.0, iResolution.x / iResolution.y, 0.1, 20.0) *\n    lookAt(camPos, vec3(0, 0, 1), vec3(0, 0, 1));\n  mat4 modelViewInverse = inverse(modelView);\n\n  vec3 light = normalize(vec3(-1.0, -2.0, -2));\n\n  vec3 a = vec3(coord * 2.0 - 1.0, -1.0);\n  vec3 b = vec3(coord * 2.0 - 1.0, 1.0);\n  vec3 aWC = transform(modelViewInverse, a);\n  vec3 bWC = transform(modelViewInverse, b);\n  vec3 lookDir1 = normalize(bWC - aWC);\n\n  RMResult hitWC = raymarching2(aWC, lookDir1);\n  vec3 hitn1 = sdfNormal1(hitWC.pos, hitWC.distance);\n  float dWC = distance(aWC, hitWC.pos);\n  vec3 hitNDC = transform(modelView, hitWC.pos);\n  vec3 p = hitWC.pos;\n  float inSun = softshadow(\n    hitWC.pos + hitn1 * 0.05,\n    -light,\n    0.0001,\n    300.0,\n    8.0\n  );\n  //    float inSun=1.;\n\n  vec3 material = hitWC.color.xyz;\n  if (dWC > 100.0) {\n    material = vec3(0.0, 0.0, 0.0);\n    //    } else if (p.z >= 0.001) {\n    //        material = vec3(0.2, 0.0, 0.0);\n    //    } else {\n    //        vec2 c = vec2(4.0, 2.0);\n    //        vec2 id = floor(((p.xy - c * 0.5) / c) );\n    //        material += .15 * cos(vec3(id.x, id.y + 2., id.x + id.y + 4.));\n  }\n\n  const vec3 sunlightColor = vec3(3.0);\n\n  float aOcc = ambientOcclusion(hitWC.pos, hitn1);\n\n  vec3 reflectionDirection = reflect(light, hitn1);\n\n  vec3 color = vec3(0.0);\n  color += material * aOcc;\n  color += inSun * sunlightColor * material * max(0.0, dot(-light, hitn1));\n  //    color = (hitn1);\n\n  vec3 eyeDirection = -lookDir1;\n  float uMaterialShininess = 256.0;\n  float specularLightWeighting = pow(\n    max(dot(reflectionDirection, eyeDirection), 0.0),\n    uMaterialShininess\n  );\n  color += specularLightWeighting;\n  //    float lightIntensity = 0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.);\n  //    float lightIntensity =\n  //        0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.) + 0.3*specularLightWeighting;\n  //    fragColor = visualize(blue, red, mix(0.5, 1.0, inSun) * lightIntensity);\n  //    fragColor = mix(hitWC.color, colorBackground, mix(0.5, 1.0, inSun) * clamp(lightIntensity, 0., 1.));\n  color = pow(color, vec3(1.0 / 2.2)); // gamma correction\n  fragColor = vec4(color, 1.0);\n}\n",t={version:3,sources:["/home/runner/work/workshop/workshop/src/noises/tree.frag","/home/runner/work/workshop/workshop/src/common/banded.glsl","/home/runner/work/workshop/workshop/src/common/constants.glsl","/home/runner/work/workshop/workshop/src/common/matrices.glsl","/home/runner/work/workshop/workshop/src/common/max3.glsl","/home/runner/work/workshop/workshop/src/common/visualize.glsl","/home/runner/work/workshop/workshop/src/common/unmix.glsl","/home/runner/work/workshop/workshop/src/common/fromPolar.glsl","/home/runner/work/workshop/workshop/src/common/toPolar.glsl","/home/runner/work/workshop/workshop/src/common/polar.glsl","/home/runner/work/workshop/workshop/src/common/ungamma.glsl","/home/runner/work/workshop/workshop/src/common/transform.glsl","/home/runner/work/workshop/workshop/src/common/squareWave.glsl","/home/runner/work/workshop/workshop/src/common/OpenSimplex2.glsl","/home/runner/work/workshop/workshop/src/common/checkerboardGrad.glsl","/home/runner/work/workshop/workshop/src/common/colors.glsl","/home/runner/work/workshop/workshop/src/common/sdf3d/sdIcosahedron.glsl","/home/runner/work/workshop/workshop/src/common/sdf3d/sdDodecahedron.glsl","/home/runner/work/workshop/workshop/src/common/sdf3d/sdCylinder.glsl","/home/runner/work/workshop/workshop/src/common/sdf3d/sdTube.glsl","/home/runner/work/workshop/workshop/src/common/sdf3d/sdBox.glsl","/home/runner/work/workshop/workshop/src/common/sdf3d/sdLego.glsl","/home/runner/work/workshop/workshop/src/common/sdf3d/sdOctahedron.glsl","/home/runner/work/workshop/workshop/src/common/sdf3d/sdCone.glsl","/home/runner/work/workshop/workshop/src/common/sdf3d/sdArrow.glsl","/home/runner/work/workshop/workshop/src/common/sdf3d/sdCapsule.glsl","/home/runner/work/workshop/workshop/src/common/sdf3d/sdTetrahedron.glsl"],names:[],mappings:"AAAA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC/GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC3IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A1BzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"}},6466:(A,n,e)=>{var o={"./julia.frag":1105,"./magic.frag":728,"./magic2.frag":3869,"./mengerSlices.frag":1429,"./simplex.frag":9066,"./sphereOpenSimplex.frag":6622,"./test.frag":6965,"./test2.frag":3257,"./test3.frag":3055,"./tree.frag":5406};function t(A){var n=c(A);return e(n)}function c(A){if(!e.o(o,A)){var n=new Error("Cannot find module '"+A+"'");throw n.code="MODULE_NOT_FOUND",n}return o[A]}t.keys=function(){return Object.keys(o)},t.resolve=c,A.exports=t,t.id=6466}}]);
//# sourceMappingURL=noises-index.js.map