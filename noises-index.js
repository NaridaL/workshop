"use strict";(self.webpackChunkworkshop=self.webpackChunkworkshop||[]).push([[388],{9764:(n,e,t)=>{t.d(e,{V:()=>a});var o=t(3121),c=t(9526);function a({state:n,prop:e,setStatePartial:t,...a}){return c.createElement(o.Z,{variant:"outlined",size:"small",type:"number",value:n[e],onChange:n=>t({[e]:+n.target.value}),label:e,...a})}},9248:(n,e,t)=>{t.d(e,{q:()=>o});class o{__init(){this.count=0}__init2(){this.lastTime=performance.now()}constructor(n,e=10){this.notify=n,this.window=e,o.prototype.__init.call(this),o.prototype.__init2.call(this)}tick(n=performance.now()){const e=this.window;if(this.count=(this.count+1)%e,0===this.count){const t=Math.floor(1e3*e/(n-this.lastTime));this.notify(t),this.lastTime=n}}}},9874:(n,e,t)=>{t.d(e,{q:()=>f});var o=t(6897),c=t.n(o),a=t(508),r=t.n(a),s=t(9526);const i=n=>"#"+Object.entries(n).map((([n,e])=>encodeURIComponent(n)+"="+encodeURIComponent(e))).join("&"),l=n=>r()(n,(n=>"true"===n||"false"!==n&&("NaN"===n?NaN:"undefined"===n?void 0:"null"===n?null:""===n?"":isNaN(+n)?n:+n))),v=n=>r()(n,(n=>""+n));function f(n,{deserialize:e=l,serialize:t=v,wait:o=1e3}={}){const a=(0,s.useCallback)((()=>{const o="function"==typeof n?n():n,c=e(Object.assign(t(o),(a=document.location.hash)?a.substring(1).split("&").map((n=>{const[e,t]=n.split("=");return[decodeURIComponent(e),decodeURIComponent(t)]})).reduce(((n,[e,t])=>(n[e]=t,n)),{}):{}));var a;return history.pushState(void 0,document.title,i(t(c))),c}),[e,n,t]),[r,f]=(0,s.useState)(a),m=(0,s.useRef)();return m.current||(m.current=c()((function(n){history.pushState(void 0,document.title,i(t(n)))}),o)),(0,s.useEffect)((()=>m.current(r)),[r]),(0,s.useEffect)((()=>{const n=()=>{f(a())};return window.addEventListener("hashchange",n),()=>{window.removeEventListener("hashchange",n)}}),[a]),[r,f]}},7271:(n,e,t)=>{t.r(e),t.d(e,{band:()=>x,default:()=>p});var o,c=t(5069),a=t(4854),r=t(871),s=t(3409),i=t(9526),l=t(2182),v=(t(2004),t(9764)),f=t(9874),m=t(3192);function u(n){let e,t=n[0],o=1;for(;o<n.length;){const c=n[o],a=n[o+1];if(o+=2,("optionalAccess"===c||"optionalCall"===c)&&null==t)return;"access"===c||"optionalAccess"===c?(e=t,t=a(t)):"call"!==c&&"optionalCall"!==c||(t=a(((...n)=>t.call(e,...n))),e=void 0)}return t}class d{__init(){this.lastPos=l.V3.O}__init2(){this.pressedKeys={}}__init3(){this.pauseCam=!1}reset(){l.M4.identity(this.state),u([this,"access",n=>n.onChange,"optionalCall",n=>n(this.state)])}constructor(n,e,t){this.state=n,this.onChange=e,this.lockUp=t,d.prototype.__init.call(this),d.prototype.__init2.call(this),d.prototype.__init3.call(this),d.prototype.__init4.call(this),d.prototype.__init5.call(this),d.prototype.__init6.call(this),d.prototype.__init7.call(this),d.prototype.__init8.call(this)}__init4(){this.setState=n=>{n!==this.state&&l.M4.copy(n,this.state)}}registerListeners(n,e=n){return u([this,"access",n=>n.unregister,"optionalCall",n=>n()]),n.addEventListener("wheel",this.wheel),n.addEventListener("mousemove",this.mousemove),e.addEventListener("keydown",this.keydown),e.addEventListener("keyup",this.keyup),this.unregister=()=>{n.removeEventListener("wheel",this.wheel),n.removeEventListener("mousemove",this.mousemove),e.removeEventListener("keydown",this.keydown),e.removeEventListener("keyup",this.keyup)}}unregisterListeners(){u([this,"access",n=>n.unregister,"optionalCall",n=>n()])}tick(){const n=new l.V3(+!!this.pressedKeys.a-+!!this.pressedKeys.d,+!!this.pressedKeys.s-+!!this.pressedKeys.w,0);n.likeO()||(this.state=this.state.translate(n.times(10)),u([this,"access",n=>n.onChange,"optionalCall",n=>n(this.state)]))}__init5(){this.wheel=n=>{const e=n.currentTarget,{width:t,height:o}=e.getBoundingClientRect(),c=Math.pow(1.1,-Math.sign(n.deltaY)),a=new l.V3(e.width*(n.offsetX/t),e.height*(1-n.offsetY/o),0);this.state=this.state.translate(a.negated()).scale(l.V3.XYZ.times(c)).translate(a),u([this,"access",n=>n.onChange,"optionalCall",n=>n(this.state)]),n.preventDefault(),n.stopPropagation()}}__init6(){this.mousemove=n=>{const e=n.currentTarget,{width:t,height:o}=e.getBoundingClientRect(),c=(0,l.V)(n.pageX,n.pageY),a=this.lastPos.to(c);1&n.buttons&&!this.pauseCam&&(this.state=this.state.translate(e.width*(a.x/t),e.height*(-a.y/o),0),u([this,"access",n=>n.onChange,"optionalCall",n=>n(this.state)])),this.lastPos=c}}__init7(){this.keydown=n=>{"r"===n.key?this.reset():this.pressedKeys[n.key]=!0,n.preventDefault()}}__init8(){this.keyup=n=>{this.pressedKeys[n.key]=void 0,n.preventDefault()}}getTransform(){return this.state}static toShortString(n,e=1){const t=n.getTranslation(),o=n.m[0];return Math.round(t.x*e)+"~"+Math.round(t.y*e)+"~"+Math.round(Math.log(o)/Math.log(1.1))}static fromShortString(n,e=1){const[t,o,c]=n.split("~");return l.M4.translate(new l.V3(+t/e,+o/e,0)).scale(Math.pow(1.1,+c))}}(0,l.Nv)(512,(()=>l.V3.polar(1,2*(Math.random()-.5)*Math.PI)));const h={bandCount:2,a:.5,b:.5,cam:"0~0~0"},x=(n,e,t,o)=>(0,l.t7)(n,e,Math.floor(4*(0,l.kL)(n,e,o))/3),p=()=>{const[n,e]=(0,f.q)(h),u=(0,i.useCallback)((n=>e((e=>({...e,...n})))),[e]),x=(0,i.useCallback)((({cam:n})=>{const e=d.fromShortString(n);u({cam:d.toShortString(e)})}),[u]),p=(0,i.useCallback)(class extends m.A0{constructor(n,e){super((()=>t(4721).Z),n,e)}},[]),g=(0,i.useCallback)((o=class extends m.A0{__init(){this.panController=new d(l.M4.identity(),(n=>u({cam:d.toShortString(n)})))}constructor(n,e){super((()=>t(6275).Z),n,e),o.prototype.__init.call(this),this.panController.registerListeners(n),n.tabIndex=0,0!==n.clientWidth&&this.gl.fixCanvasRes()}uniforms(){return{mmm:this.panController.getTransform(),mmmi:this.panController.getTransform().inversed()}}setCam(n){this.panController.setState(n)}render(n){this.panController.tick(),super.render(n)}},o),[x]),y=(0,i.useRef)();return(0,i.useEffect)((()=>{n.cam&&function(n){let e,t=n[0],o=1;for(;o<n.length;){const c=n[o],a=n[o+1];if(o+=2,("optionalAccess"===c||"optionalCall"===c)&&null==t)return;"access"===c||"optionalAccess"===c?(e=t,t=a(t)):"call"!==c&&"optionalCall"!==c||(t=a(((...n)=>t.call(e,...n))),e=void 0)}}([y,"access",n=>n.current,"optionalAccess",n=>n.setCam,"call",e=>e(d.fromShortString(n.cam))])}),[]),i.createElement(r.ZP,{container:!0,style:{height:"99%"},spacing:2,padding:2},i.createElement(r.ZP,{item:!0,xs:12},i.createElement(m.XM,{sx:{height:400},animate:!0,state:n,Renderer:g,focusable:!0,rendererRef:y})),i.createElement(r.ZP,{item:!0,xs:12},i.createElement(m.XM,{animate:!0,sx:{height:400},state:n,Renderer:p})),i.createElement(r.ZP,{item:!0,xs:12,md:3,sx:{display:"flex",flexDirection:"column",width:"100%",padding:2,alignItems:"stretch",gap:2}},i.createElement(c.Z,null,i.createElement(a.Z,null,"Test with various noise generation functions.")),i.createElement(v.V,{state:n,setStatePartial:u,prop:"bandCount"}),i.createElement("div",null,i.createElement(s.ZP,{value:n.a,onChange:(n,e)=>u({a:e}),min:0,max:1,step:.01})),i.createElement("div",null,i.createElement(s.ZP,{value:n.b,onChange:(n,e)=>u({b:e}),min:0,max:1,step:.01})),n.a))}},3671:(n,e,t)=>{t.d(e,{PM:()=>a,Qn:()=>i,X$:()=>r,XJ:()=>s,YQ:()=>p,_x:()=>f,hv:()=>m,kC:()=>u,li:()=>d,nl:()=>x,oe:()=>v,q3:()=>l,t1:()=>h});var o=t(9526),c=t(2182);const a=25.4,r=n=>(0,c.At)(n/c.Co,-1)+"Â°",s=(n,e)=>e/2/Math.sin(c.gc/n/2),i=(n,e)=>2*e*Math.sin(c.gc/n/2),l=(n,e)=>e/2/Math.tan(c.gc/n/2),v=(n,e)=>e/Math.cos(c.gc/n/2),f=(n,e)=>2*e*Math.tan(c.gc/n/2);function m({sides:n,radius:e,startAngle:t=0,sideLength:a,...r}){if(void 0!==a==(void 0!==e))throw new Error("must set either sideLength or radius");void 0===e&&(e=s(n,a));const{x:i,y:l}=c.V3.polar(e,t);return o.createElement("path",{d:x`
        M${i},${l}
        ${(0,c.hS)(0,n).map((o=>x`L${c.V3.polar(e,t+o*(c.gc/n))}`))}Z`,...r})}function u({id:n,children:e,count:t,stepDeg:a}){return o.createElement(o.Fragment,null,o.createElement("g",{id:n},e),(0,c.hS)(0,t-1).map((e=>o.createElement("use",{key:e,href:"#"+n,transform:`rotate(${(e+1)*a} 0 0)`}))))}const d=[[841,1189,"A0"],[594,841,"A1"],[420,594,"A2"],[297,420,"A3"],[210,297,"A4"],[148,210,"A5"],[105,148,"A6"],[74,105,"A7"],[52,74,"A8"],[37,52,"A9"],[26,37,"A10"],[150,150,"Origami 15cm"],[100,100,"Origami 10cm"],[75,75,"Origami 7.5cm"],[215.9,279.4,"Letter"],[215.9,355.6,"Legal"]],h=d.find((([,,n])=>n.includes("A4")));function x(n,...e){const t=n=>"number"==typeof n?""+n:"string"==typeof n?n:Array.isArray(n)?n.map(t).join(" "):n.x+","+n.y;let o=n[0];for(let c=0;c<e.length;c++)o+=t(e[c]),o+=n[c+1];return o}const p=n=>{const e=window.open(n,"_blank","noopener,noreferrer");e&&(e.opener=null)}},3192:(n,e,t)=>{t.d(e,{XM:()=>y,tz:()=>E,A0:()=>R});var o=t(4625),c=t(8356),a=t(5069),r=t(4353),s=t(3120),i=t(8105),l=t(9309),v=t(897),f=t(8051),m=t(7392),u=t(9526),d=t(5583),h=t(2004),x=t(9248),p=t(3671);function g(n){let e,t=n[0],o=1;for(;o<n.length;){const c=n[o],a=n[o+1];if(o+=2,("optionalAccess"===c||"optionalCall"===c)&&null==t)return;"access"===c||"optionalAccess"===c?(e=t,t=a(t)):"call"!==c&&"optionalCall"!==c||(t=a(((...n)=>t.call(e,...n))),e=void 0)}return t}function y({sx:n,animate:e,state:t,Renderer:f,focusable:m,rendererRef:d}){const h=(0,u.useRef)(),[x,g]=(0,u.useState)(),[y,R]=(0,u.useState)(),_=(0,u.useCallback)((async n=>{const e=n.currentTarget.dataset.dim.split("x").map((n=>+n));if(g(void 0),h.current)try{const n=URL.createObjectURL(await h.current.renderImage(e,R));R(void 0),(0,p.YQ)(n)}catch(n){console.error(n)}}),[]);(0,u.useEffect)((()=>{d&&(d.current=h.current)}),[d]);const A=(0,u.useCallback)((n=>g(n.currentTarget)),[]),T=(0,u.useCallback)((()=>g(void 0)),[]);return u.createElement(a.Z,{sx:{...n,position:"relative"}},u.createElement(l.Z,{open:!!x,anchorEl:x,onClose:T},u.createElement(v.Z,{"data-dim":"1920x1080",onClick:_},"Render HD"),u.createElement(v.Z,{"data-dim":"3840x2160 ",onClick:_},"Render 4K")),u.createElement(c.Z,{sx:{position:"absolute",margin:1,right:0}},void 0!==y?u.createElement(s.Z,{variant:"determinate",value:100*y}):u.createElement(i.Z,{size:"small",onClick:A},u.createElement(o.Z,null))),u.createElement(r.Z,{component:E,Renderer:f,animate:e,state:t,rendererRef:h,focusable:m,sx:{width:"100%",height:"100%"}}))}const E=({Renderer:n,onFps:e,animate:t,state:o,rendererRef:c,focusable:a})=>{const r=(0,u.useRef)(null),s=(0,u.useRef)();(0,u.useEffect)((()=>(r.current&&(s.current=new n(r.current,e),s.current.start(),c&&(c.current=s.current)),()=>{s.current&&s.current.destroy()})),[n,e,c]);const i=(0,f.Z)();return(0,u.useEffect)((()=>{s.current&&Object.assign(s.current.dyn,{colorBackground:m.iv(i.palette.background.default).gl(),colorPrimary:m.iv(i.palette.primary.main).gl(),colorSecondary:m.iv(i.palette.secondary.main).gl()})}),[i.palette]),(0,u.useEffect)((()=>{s.current&&(s.current.animate=t)}),[t]),(0,u.useEffect)((()=>{s.current&&Object.assign(s.current.dyn,o)}),[o]),u.createElement("canvas",{ref:r,style:{width:"100%",height:"100%"}})};class R{__init(){this.mousePos=[-1,-1]}__init2(){this.dyn={}}__init3(){this.animate=!0}constructor(n,e,t){this.fragShader=n,this.canvas=e,R.prototype.__init.call(this),R.prototype.__init2.call(this),R.prototype.__init3.call(this),R.prototype.__init4.call(this);const o=h.ZG.create({canvas:e,alpha:!0,premultipliedAlpha:!0});this.gl=o,console.log("this.canvas.clientWidth",this.canvas.clientWidth),0!==this.canvas.clientWidth&&o.fixCanvasRes(1),o.canvas.addEventListener("mouseleave",(n=>{this.mousePos=[-1,-1]})),o.canvas.addEventListener("mousemove",(n=>{const e=n.currentTarget,{width:t,height:o}=e.getBoundingClientRect();this.mousePos=[e.width*(n.offsetX/t),e.height*(1-n.offsetY/o)]})),this.planeMesh=h.Kj.plane({startX:-1,startY:-1,width:2,height:2}),this.planeMesh.compile(o),this.fpsController=t&&new x.q(t),this.updateShader()}updateShader(){this.buildShader(t(7962).Z,this.fragShader())}__init4(){this.buildShader=function(n){let e,t=[];return function(...o){return(t.length!==o.length||t.some(((n,e)=>n!==o[e])))&&(t=o,e=n(...o)),e}}(((n,e)=>{try{this.shader&&this.gl.deleteProgram(this.shader.program),this.shader=h.ex.create(n,e)}catch(n){if(console.clear(),console.error(n),!this.shader)throw n}}))}start(){this.gl.animate(this.render.bind(this))}render(n){this.gl.makeCurrent(),this.updateShader(),g([this,"access",n=>n.fpsController,"optionalAccess",n=>n.tick,"call",e=>e(n)]),this.shader&&this.shader.uniforms({iResolution:[this.gl.canvas.width,this.gl.canvas.height],iMouse:this.mousePos,iTime:this.animate?n/1e3:0}).uniforms(this.dyn).uniforms(this.uniforms()).draw(this.planeMesh)}destroy(){}async renderImage([n,e],t){g([t,"optionalCall",n=>n(0)]),await(0,d.Z)(10);const o=document.createElement("canvas");o.width=n,o.height=e;const c=new this.constructor(o);Object.assign(c.dyn,this.dyn);const a=256,r=c.gl;r.enable(r.SCISSOR_TEST);let s=0;for(let o=0;o<n;o+=a)for(let i=0;i<e;i+=a){const l=Math.min(a,n-o),v=Math.min(a,e-i);r.scissor(o,i,l,v),c.render(0),await(0,d.Z)(0),s+=l*v,g([t,"optionalCall",t=>t(s/(n*e))])}return new Promise(((n,e)=>o.toBlob((t=>t?n(t):e("error creating png from canvas")),"png")))}uniforms(){return{}}}},7962:(n,e,t)=>{t.d(e,{Z:()=>o});const o="#version 300 es\nprecision highp float;\n\nin vec4 ts_Vertex;\nin vec2 ts_TexCoord;\nout vec2 coord;\nvoid main() {\n  gl_Position = ts_Vertex;\n  coord = ts_TexCoord;\n}\n"},4721:(n,e,t)=>{t.d(e,{Z:()=>o});const o="#version 300 es\nprecision highp float;\n// START ../common/banded.glsl\nfloat banded(float bandCount, float t) {\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\n}\nfloat banded(int bandCount, float t) {\n  return banded(float(bandCount), t);\n}\n\n// #pragma glslify: export(banded)\n\n\n// START ../common/between.glsl\nbool between(float min, float max, float value) {\n  return min <= value && value <= max;\n}\n\n// #pragma glslify: export(between)\n\n\n// START ../common/constants.glsl\nconst float SQRT1_2 = 0.7071067811865476;\nconst float SQRT1_3 = 0.57735026919;\nconst float SQRT2 = 1.4142135623730951;\nconst float SQRT3 = 1.732050807568877;\n// sqrt(3)/2 = sin(60*)\nconst float SQRT3_2 = 0.86602540378;\nconst float GOLDEN_RATIO = 1.61803398875;\nconst float PI = 3.141592653589793;\nconst float TAU = 6.28318530718;\n/**\n * One degree in radians. Use like `sin(30 * DEG)`.\n */\nconst float DEGREE = 0.017453292519943295;\n\n// START ../common/complex.glsl\n// START ./polar.glsl\n// START ../common/fromPolar.glsl\n// START ./unmix.glsl\nfloat unmix(float a, float b, float value) {\n  return (value - a) / (b - a);\n}\n\n// #pragma glslify: export(unmix)\n\n\n\nvec3 fromPolar(float radius, float phi, float z) {\n  return vec3(radius * cos(phi), radius * sin(phi), z);\n}\n\nvec2 fromPolar(float radius, float phi) {\n  return vec2(radius * cos(phi), radius * sin(phi));\n}\n\nvec2 fromPolar(vec2 polar) {\n  return fromPolar(polar.x, polar.y);\n}\n\n// #pragma glslify: export(fromPolar)\n\n\n// START ../common/toPolar.glsl\n\n\nvec2 toPolar(vec2 xy) {\n  return vec2(length(xy), atan(xy.y, xy.x));\n}\n\nmat2 toPolarDerivate(vec2 xy) {\n  return mat2(xy.x * xy.x, xy.y * xy.y, -xy.y, xy.x) / dot(xy, xy);\n}\n\n// #pragma glslify: export(toPolar)\n\n\n\n\nvec2 complexConj(vec2 z) {\n  return vec2(z.x, -z.y);\n}\n\nvec2 complexMul(vec2 a, vec2 b) {\n  return vec2(a.x * b.x - a.y * b.y, a.y * b.x + a.x * b.y);\n}\n\nvec2 complexDiv(vec2 a, vec2 b) {\n  vec2 bConj = vec2(b.x, -b.y);\n  float divisor = complexMul(b, bConj).x;\n  return complexMul(a, bConj) / divisor;\n}\n\n// return e^z\nvec2 complexPow(vec2 z) {\n  // e^(re + i * im)\n  // = e^re * e^(i * im)\n  return fromPolar(exp(z.x), z.y);\n}\n\n// return w^z\nvec2 complexPow(vec2 w, float z) {\n  // w = r * e ^ (i * phi)\n  // ln(w) = ln(r) + i * phi\n  // w^z = e^(z * log(w)) = e^(z * (ln(r) + i * (phi))\n  vec2 wPolar = toPolar(w);\n  vec2 eExp = z * vec2(log(wPolar.x), wPolar.y);\n  return complexPow(eExp);\n}\n\n// START ../common/colors.glsl\nconst vec3 INDIAN_RED = vec3(0.804, 0.361, 0.361);\nconst vec3 LIGHT_CORAL = vec3(0.941, 0.502, 0.502);\nconst vec3 SALMON = vec3(0.98, 0.502, 0.447);\nconst vec3 DARK_SALMON = vec3(0.914, 0.588, 0.478);\nconst vec3 LIGHT_SALMON = vec3(1.0, 0.627, 0.478);\nconst vec3 CRIMSON = vec3(0.863, 0.078, 0.235);\nconst vec3 RED = vec3(1.0, 0.0, 0.0);\nconst vec3 FIRE_BRICK = vec3(0.698, 0.133, 0.133);\nconst vec3 DARK_RED = vec3(0.545, 0.0, 0.0);\nconst vec3 PINK = vec3(1.0, 0.753, 0.796);\nconst vec3 LIGHT_PINK = vec3(1.0, 0.714, 0.757);\nconst vec3 HOT_PINK = vec3(1.0, 0.412, 0.706);\nconst vec3 DEEP_PINK = vec3(1.0, 0.078, 0.576);\nconst vec3 MEDIUM_VIOLET_RED = vec3(0.78, 0.082, 0.522);\nconst vec3 PALE_VIOLET_RED = vec3(0.859, 0.439, 0.576);\nconst vec3 CORAL = vec3(1.0, 0.498, 0.314);\nconst vec3 TOMATO = vec3(1.0, 0.388, 0.278);\nconst vec3 ORANGE_RED = vec3(1.0, 0.271, 0.0);\nconst vec3 DARK_ORANGE = vec3(1.0, 0.549, 0.0);\nconst vec3 ORANGE = vec3(1.0, 0.647, 0.0);\nconst vec3 GOLD = vec3(1.0, 0.843, 0.0);\nconst vec3 YELLOW = vec3(1.0, 1.0, 0.0);\nconst vec3 LIGHT_YELLOW = vec3(1.0, 1.0, 0.878);\nconst vec3 LEMON_CHION = vec3(1.0, 0.98, 0.804);\nconst vec3 LIGHT_GOLDENROD_YELLOW = vec3(0.98, 0.98, 0.824);\nconst vec3 PAPAYA_WHIP = vec3(1.0, 0.937, 0.835);\nconst vec3 MOCCASIN = vec3(1.0, 0.894, 0.71);\nconst vec3 PEACH_PU = vec3(1.0, 0.855, 0.725);\nconst vec3 PALE_GOLDENROD = vec3(0.933, 0.91, 0.667);\nconst vec3 KHAKI = vec3(0.941, 0.902, 0.549);\nconst vec3 DARK_KHAKI = vec3(0.741, 0.718, 0.42);\nconst vec3 LAVENDER = vec3(0.902, 0.902, 0.98);\nconst vec3 THISTLE = vec3(0.847, 0.749, 0.847);\nconst vec3 PLUM = vec3(0.867, 0.627, 0.867);\nconst vec3 VIOLET = vec3(0.933, 0.51, 0.933);\nconst vec3 ORCHID = vec3(0.855, 0.439, 0.839);\nconst vec3 FUCHSIA = vec3(1.0, 0.0, 1.0);\nconst vec3 MAGENTA = vec3(1.0, 0.0, 1.0);\nconst vec3 MEDIUM_ORCHID = vec3(0.729, 0.333, 0.827);\nconst vec3 MEDIUM_PURPLE = vec3(0.576, 0.439, 0.859);\nconst vec3 BLUE_VIOLET = vec3(0.541, 0.169, 0.886);\nconst vec3 DARK_VIOLET = vec3(0.58, 0.0, 0.827);\nconst vec3 DARK_ORCHID = vec3(0.6, 0.196, 0.8);\nconst vec3 DARK_MAGENTA = vec3(0.545, 0.0, 0.545);\nconst vec3 PURPLE = vec3(0.502, 0.0, 0.502);\nconst vec3 INDIGO = vec3(0.294, 0.0, 0.51);\nconst vec3 SLATE_BLUE = vec3(0.416, 0.353, 0.804);\nconst vec3 DARK_SLATE_BLUE = vec3(0.282, 0.239, 0.545);\nconst vec3 GREEN_YELLOW = vec3(0.678, 1.0, 0.184);\nconst vec3 CHARTREUSE = vec3(0.498, 1.0, 0.0);\nconst vec3 LAWN_GREEN = vec3(0.486, 0.988, 0.0);\nconst vec3 LIME = vec3(0.0, 1.0, 0.0);\nconst vec3 LIME_GREEN = vec3(0.196, 0.804, 0.196);\nconst vec3 PALE_GREEN = vec3(0.596, 0.984, 0.596);\nconst vec3 LIGHT_GREEN = vec3(0.565, 0.933, 0.565);\nconst vec3 MEDIUM_SPRING_GREEN = vec3(0.0, 0.98, 0.604);\nconst vec3 SPRING_GREEN = vec3(0.0, 1.0, 0.498);\nconst vec3 MEDIUM_SEA_GREEN = vec3(0.235, 0.702, 0.443);\nconst vec3 SEA_GREEN = vec3(0.18, 0.545, 0.341);\nconst vec3 FOREST_GREEN = vec3(0.133, 0.545, 0.133);\nconst vec3 GREEN = vec3(0.0, 0.502, 0.0);\nconst vec3 DARK_GREEN = vec3(0.0, 0.392, 0.0);\nconst vec3 YELLOW_GREEN = vec3(0.604, 0.804, 0.196);\nconst vec3 OLIVE_DRAB = vec3(0.42, 0.557, 0.137);\nconst vec3 OLIVE = vec3(0.502, 0.502, 0.0);\nconst vec3 DARK_OLIVE_GREEN = vec3(0.333, 0.42, 0.184);\nconst vec3 MEDIUM_AQUAMARINE = vec3(0.4, 0.804, 0.667);\nconst vec3 DARK_SEA_GREEN = vec3(0.561, 0.737, 0.561);\nconst vec3 LIGHT_SEA_GREEN = vec3(0.125, 0.698, 0.667);\nconst vec3 DARK_CYAN = vec3(0.0, 0.545, 0.545);\nconst vec3 TEAL = vec3(0.0, 0.502, 0.502);\nconst vec3 AQUA = vec3(0.0, 1.0, 1.0);\nconst vec3 CYAN = vec3(0.0, 1.0, 1.0);\nconst vec3 LIGHT_CYAN = vec3(0.878, 1.0, 1.0);\nconst vec3 PALE_TURQUOISE = vec3(0.686, 0.933, 0.933);\nconst vec3 AQUAMARINE = vec3(0.498, 1.0, 0.831);\nconst vec3 TURQUOISE = vec3(0.251, 0.878, 0.816);\nconst vec3 MEDIUM_TURQUOISE = vec3(0.282, 0.82, 0.8);\nconst vec3 DARK_TURQUOISE = vec3(0.0, 0.808, 0.82);\nconst vec3 CADET_BLUE = vec3(0.373, 0.62, 0.627);\nconst vec3 STEEL_BLUE = vec3(0.275, 0.51, 0.706);\nconst vec3 LIGHT_STEEL_BLUE = vec3(0.69, 0.769, 0.871);\nconst vec3 POWDER_BLUE = vec3(0.69, 0.878, 0.902);\nconst vec3 LIGHT_BLUE = vec3(0.678, 0.847, 0.902);\nconst vec3 SKY_BLUE = vec3(0.529, 0.808, 0.922);\nconst vec3 LIGHT_SKY_BLUE = vec3(0.529, 0.808, 0.98);\nconst vec3 DEEP_SKY_BLUE = vec3(0.0, 0.749, 1.0);\nconst vec3 DODGER_BLUE = vec3(0.118, 0.565, 1.0);\nconst vec3 CORNLOWER_BLUE = vec3(0.392, 0.584, 0.929);\nconst vec3 MEDIUM_SLATE_BLUE = vec3(0.482, 0.408, 0.933);\nconst vec3 ROYAL_BLUE = vec3(0.255, 0.412, 0.882);\nconst vec3 BLUE = vec3(0.0, 0.0, 1.0);\nconst vec3 MEDIUM_BLUE = vec3(0.0, 0.0, 0.804);\nconst vec3 DARK_BLUE = vec3(0.0, 0.0, 0.545);\nconst vec3 NAVY = vec3(0.0, 0.0, 0.502);\nconst vec3 MIDNIGHT_BLUE = vec3(0.098, 0.098, 0.439);\nconst vec3 CORNSILK = vec3(1.0, 0.973, 0.863);\nconst vec3 BLANCHED_ALMOND = vec3(1.0, 0.922, 0.804);\nconst vec3 BISQUE = vec3(1.0, 0.894, 0.769);\nconst vec3 NAVAJO_WHITE = vec3(1.0, 0.871, 0.678);\nconst vec3 WHEAT = vec3(0.961, 0.871, 0.702);\nconst vec3 BURLY_WOOD = vec3(0.871, 0.722, 0.529);\nconst vec3 TAN = vec3(0.824, 0.706, 0.549);\nconst vec3 ROSY_BROWN = vec3(0.737, 0.561, 0.561);\nconst vec3 SANDY_BROWN = vec3(0.957, 0.643, 0.376);\nconst vec3 GOLDENROD = vec3(0.855, 0.647, 0.125);\nconst vec3 DARK_GOLDENROD = vec3(0.722, 0.525, 0.043);\nconst vec3 PERU = vec3(0.804, 0.522, 0.247);\nconst vec3 CHOCOLATE = vec3(0.824, 0.412, 0.118);\nconst vec3 SADDLE_BROWN = vec3(0.545, 0.271, 0.075);\nconst vec3 SIENNA = vec3(0.627, 0.322, 0.176);\nconst vec3 BROWN = vec3(0.647, 0.165, 0.165);\nconst vec3 MAROON = vec3(0.502, 0.0, 0.0);\nconst vec3 WHITE = vec3(1.0, 1.0, 1.0);\nconst vec3 SNOW = vec3(1.0, 0.98, 0.98);\nconst vec3 HONEYDEW = vec3(0.941, 1.0, 0.941);\nconst vec3 MINT_CREAM = vec3(0.961, 1.0, 0.98);\nconst vec3 AZURE = vec3(0.941, 1.0, 1.0);\nconst vec3 ALICE_BLUE = vec3(0.941, 0.973, 1.0);\nconst vec3 GHOST_WHITE = vec3(0.973, 0.973, 1.0);\nconst vec3 WHITE_SMOKE = vec3(0.961, 0.961, 0.961);\nconst vec3 SEASHELL = vec3(1.0, 0.961, 0.933);\nconst vec3 BEIGE = vec3(0.961, 0.961, 0.863);\nconst vec3 OLD_LACE = vec3(0.992, 0.961, 0.902);\nconst vec3 FLORAL_WHITE = vec3(1.0, 0.98, 0.941);\nconst vec3 IVORY = vec3(1.0, 1.0, 0.941);\nconst vec3 ANTIQUE_WHITE = vec3(0.98, 0.922, 0.843);\nconst vec3 LINEN = vec3(0.98, 0.941, 0.902);\nconst vec3 LAVENDER_BLUSH = vec3(1.0, 0.941, 0.961);\nconst vec3 MISTY_ROSE = vec3(1.0, 0.894, 0.882);\nconst vec3 GAINSBORO = vec3(0.863, 0.863, 0.863);\nconst vec3 LIGHT_GREY = vec3(0.827, 0.827, 0.827);\nconst vec3 SILVER = vec3(0.753, 0.753, 0.753);\nconst vec3 DARK_GRAY = vec3(0.663, 0.663, 0.663);\nconst vec3 GRAY = vec3(0.502, 0.502, 0.502);\nconst vec3 DIM_GRAY = vec3(0.412, 0.412, 0.412);\nconst vec3 LIGHT_SLATE_GRAY = vec3(0.467, 0.533, 0.6);\nconst vec3 SLATE_GRAY = vec3(0.439, 0.502, 0.565);\nconst vec3 DARK_SLATE_GRAY = vec3(0.184, 0.31, 0.31);\nconst vec3 BLACK = vec3(0.0, 0.0, 0.0);\n\n// START ../common/hex2Ra.glsl\nvec2 hex2Ra(vec3 hex) {\n  float y = hex.t * 0.866;\n  float x = hex.s + hex.t / 2.0;\n  return vec2(x, y);\n}\n\n// #pragma glslify: export(hex2Ra)\n\n\n// START ../common/hexRound.glsl\nvec3 hexRound(vec3 hex) {\n  vec3 r = floor(hex + 0.5);\n  vec3 diff = abs(r - hex);\n\n  if (diff.x > diff.y && diff.x > diff.z) {\n    r.x = -(r.y + r.z);\n  } else if (diff.y > diff.z) {\n    r.y = -(r.x + r.z);\n  } else {\n    r.z = -(r.x + r.y);\n  }\n\n  return r;\n}\n\n// #pragma glslify: export(hexRound)\n\n\n// START ../common/hexSdf.glsl\n// START ./max3.glsl\nfloat max3(float a, float b, float c) {\n  return max(a, max(b, c));\n}\nfloat max3(vec3 v) {\n  return max(v.x, max(v.y, v.z));\n}\n\n// #pragma glslify: export(max3)\n\n\n\nfloat hexSdf(vec3 hex) {\n  return max3(abs(hex.yzx + hex.zxy / 2.0));\n}\n\n// #pragma glslify: export(hexSdf)\n\n\n// START ../common/matrices.glsl\n\n\nmat2 rot2(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat2(c, -s, s, c);\n}\nmat3 rotX(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\n}\nmat3 rotY(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\n}\nmat3 rotZ(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\n}\n/**\n * Returns a matrix that puts the camera at the eye point `ex, ey, ez` looking\n * toward the center point `cx, cy, cz` with an up direction of `ux, uy, uz`.\n * This emulates the OpenGL function `gluLookAt()`.\n */\nmat4 lookAt(vec3 eye, vec3 focus, vec3 up) {\n  vec3 f = normalize(eye - focus);\n  vec3 s = normalize(cross(up, f));\n  vec3 t = normalize(cross(f, s));\n\n  return mat4(\n    vec4(s.x, t.x, f.x, 0.0),\n    vec4(s.y, t.y, f.y, 0.0),\n    vec4(s.z, t.z, f.z, 0.0),\n    vec4(-dot(s, eye), -dot(t, eye), -dot(f, eye), 1)\n  );\n}\n\n// the OpenGL function `glFrustum()`.\nmat4 frustum(\n  float left,\n  float right,\n  float bottom,\n  float top,\n  float near,\n  float far\n) {\n  return mat4(\n    vec4(2.0 * near / (right - left), 0.0, 0.0, 0.0),\n    vec4(0, 2.0 * near / (top - bottom), 0.0, 0.0),\n    vec4(\n      (right + left) / (right - left),\n      (top + bottom) / (top - bottom),\n      -(far + near) / (far - near),\n      -1\n    ),\n    vec4(0.0, 0.0, -2.0 * far * near / (far - near), 0.0)\n  );\n}\n\nmat4 perspective(float fovDegrees, float aspect, float near, float far) {\n  float y = tan(fovDegrees * DEGREE / 2.0) * near;\n  float x = y * aspect;\n  return frustum(-x, x, -y, y, near, far);\n}\n\n\n// START ../common/ra2Hex.glsl\nvec3 raToHex(vec2 xy) {\n  float hex_t = xy.y / 0.866;\n  float hex_s = xy.x - hex_t / 2.0;\n  return vec3(hex_s, hex_t, -(hex_s + hex_t));\n}\n\n// #pragma glslify: export(raToHex)\n\n\n// START ../common/remix.glsl\n\n\nfloat remix(float fromA, float fromB, float toA, float toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\nvec4 remix(float fromA, float fromB, vec4 toA, vec4 toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\n// #pragma glslify: export(remix)\n\n\n// START ../common/simplex2DTexture.glsl\n\n\nuniform sampler2D gradients;\n\nvec3 xy2tri(vec2 xy) {\n  float v = xy.y / 0.866;\n  float u = xy.x - v / 2.0;\n  float R = float(mod(u, 1.0) + mod(v, 1.0) > 1.0);\n  return vec3(u, v, R);\n}\nvec3 triCenter(vec3 uvR) {\n  vec3 base = floor(uvR);\n  vec2 centerOffset = mix(vec2(1.0 / 3.0), vec2(2.0 / 3.0), uvR.z);\n  return base + vec3(centerOffset, 0.0);\n}\nvec2 tri2xy(vec3 uvR) {\n  float y = uvR.t * 0.866;\n  float x = uvR.s + uvR.t / 2.0;\n  return vec2(x, y);\n}\nvec2 tri2xy(vec2 uv) {\n  float y = uv.t * 0.866;\n  float x = uv.s + uv.t / 2.0;\n  return vec2(x, y);\n}\n/* Create random direction vector\n */\nvec2 randomGradient(vec2 i) {\n  // Random float. No precomputed gradients mean this works for any number of grid coordinates\n  float random =\n    2920.0 *\n    sin(float(i.x) * 2.1942 + float(i.y) * 1.71324 + 8.912) *\n    cos(float(i.x) * 2.3157 * float(i.y) * 2.17832 + 9.758);\n  //    random = (i.x + 1667.) * (i.x + 2083.) * (i.y + 2659.) * (i.y * 50.77 + .3769);\n  //    random = sin(SQRT2 * i.x) + cos(GOLDEN_RATIO * i.y) + tan((i.x + i.y) * SQRT3);\n  return vec2(cos(random), sin(random));\n}\n\nfloat dotGridGradient2(vec2 cell, vec2 pos) {\n  vec2 xy_d = cell - pos;\n  if (length(xy_d) > 0.4) return 0.0;\n  float r = 1.0;\n  float part = pow(max(0.0, 0.999 - dot(xy_d, xy_d)), 4.0);\n  //    vec2 gradient = texelFetch(gradients, ivec2(cell), 0).xy;\n  vec2 gradient = randomGradient(cell);\n  return part * dot(gradient, xy_d);\n}\n\n// resulting range is [-0.68, 0.68]. Use unmix to normalize if necessary.\nfloat simplex2D(vec2 xy) {\n  vec3 uvR = xy2tri(xy);\n  ivec2 baseUV = ivec2(uvR.xy);\n\n  float a = dotGridGradient2(tri2xy(vec2(baseUV)), xy);\n  float b = dotGridGradient2(tri2xy(vec2(baseUV + ivec2(1, 0))), xy);\n  float c = dotGridGradient2(tri2xy(vec2(baseUV + ivec2(0, 1))), xy);\n  float d = dotGridGradient2(tri2xy(vec2(baseUV + ivec2(1, 1))), xy);\n\n  return b + c + mix(a, d, uvR.z);\n}\n\n// #pragma glslify: export(simplex2D)\n\n\n\n// START ../common/visualize.glsl\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\n  float isLow = float(t < 0.0);\n  float isHigh = float(t > 1.0);\n  float isMid = 1.0 - isLow - isHigh;\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\n}\n\nvec4 visualize(float t) {\n  const vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\n  const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\n  return visualize(BLUE, RED, t);\n}\n\n// #pragma glslify: export(visualize)\n\n\n// START ../common/waves.glsl\nfloat waves(vec4 color, vec2 position, vec2 direction, float highResTimeStamp) {\n  return sin(\n    dot(position, direction / pow(length(direction), 2.0)) +\n      float(highResTimeStamp) / 200.0\n  );\n}\n\n// #pragma glslify: export(waves)\n\n\n\nuniform sampler2D texture;\nuniform vec4 colorPrimary;\nuniform vec4 colorSecondary;\nuniform vec4 colorBackground;\nuniform float a;\nuniform float b;\nuniform int bandCount;\nuniform float iTime;\nuniform vec2 iMouse;\nuniform vec2 iResolution;\nin vec2 coord;\nout vec4 fragColor;\n\nvec2 f(vec2 z) {\n  //  const vec2 c = vec2(-0.4, 0.6);\n  //  vec2 c = fromPolar(0.7885, (a + b / 50.0) * 6.0);\n  //  vec2 c = fromPolar(0.7885, iTime / 2.0);\n  //  vec2 c = fromPolar(0.7885, 4.0);\n  vec2 c = 0.01 * (iMouse - 0.5 * iResolution);\n  return complexMul(z, z) + c;\n}\n\nvec2 complexSqr(vec2 z) {\n  return complexMul(z, z);\n}\nvec2 f2(vec2 z) {\n  const float n = 8.0;\n  return complexDiv(\n    1.0 + (n - 1.0) * complexPow(z, n),\n    n * complexPow(z, n - 1.0)\n  );\n}\n\nvec2 f3(vec2 z) {\n  vec2 z2 = complexMul(z, z);\n  vec2 z3 = complexMul(z2, z);\n  return complexDiv(vec2(1.0, 0.0) + 2.0 * z3, 3.0 * z2);\n}\nvec2 flf(vec2 z) {\n  vec2 z2 = complexMul(z, z);\n  vec2 z3 = complexMul(z2, z);\n  return complexDiv(vec2(1.0, 0.0) - z3 / 6.0, complexSqr(z - z2 / 2.0)) +\n  vec2(-a, b);\n}\n// START ../common/juliaIteration.glsl\n#define JULIA_ITERATION(NAME, F, R, MAXIT)                                     \\\n  vec3 NAME(vec2 start) {                                                      \\\n    const float rSqr = (R) * (R);                                              \\\n    vec2 p = start;                                                            \\\n    for (uint i = uint(0); i < (MAXIT); i++) {                                 \\\n      p = F(p);                                                                \\\n      if (dot(p, p) > rSqr) {                                                  \\\n        return vec3(p, float(i));                                              \\\n      }                                                                        \\\n    }                                                                          \\\n    return vec3(p, float(MAXIT));                                              \\\n  }\n\n\nJULIA_ITERATION(julia, f, 2., 20u)\n\nvoid main() {\n  vec2 fragCoord = (coord - 0.5) * iResolution * 0.005;\n  vec3 res = julia(fragCoord);\n  float f = res.z / 20.0;\n\n  //    fragColor = mix(colorBackground, colorPrimary, banded(bandCount, unmix(-.35, .35, f2)));\n  fragColor = mix(\n    colorBackground,\n    colorPrimary,\n    min(banded(bandCount, f), 1.0)\n  );\n  fragColor = vec4(res, 1.0);\n  //    fragColor = visualize(f);\n  //    fragColor = visualize(float(i == 1000u));\n}\n"},6275:(n,e,t)=>{t.d(e,{Z:()=>o});const o="#version 300 es\nprecision mediump float;\n// START ../common/banded.glsl\nfloat banded(float bandCount, float t) {\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\n}\nfloat banded(int bandCount, float t) {\n  return banded(float(bandCount), t);\n}\n\n// #pragma glslify: export(banded)\n\n\n// START ../common/between.glsl\nbool between(float min, float max, float value) {\n  return min <= value && value <= max;\n}\n\n// #pragma glslify: export(between)\n\n\n// START ../common/hex2Ra.glsl\nvec2 hex2Ra(vec3 hex) {\n  float y = hex.t * 0.866;\n  float x = hex.s + hex.t / 2.0;\n  return vec2(x, y);\n}\n\n// #pragma glslify: export(hex2Ra)\n\n\n// START ../common/hexRound.glsl\nvec3 hexRound(vec3 hex) {\n  vec3 r = floor(hex + 0.5);\n  vec3 diff = abs(r - hex);\n\n  if (diff.x > diff.y && diff.x > diff.z) {\n    r.x = -(r.y + r.z);\n  } else if (diff.y > diff.z) {\n    r.y = -(r.x + r.z);\n  } else {\n    r.z = -(r.x + r.y);\n  }\n\n  return r;\n}\n\n// #pragma glslify: export(hexRound)\n\n\n// START ../common/hexSdf.glsl\n// START ./max3.glsl\nfloat max3(float a, float b, float c) {\n  return max(a, max(b, c));\n}\nfloat max3(vec3 v) {\n  return max(v.x, max(v.y, v.z));\n}\n\n// #pragma glslify: export(max3)\n\n\n\nfloat hexSdf(vec3 hex) {\n  return max3(abs(hex.yzx + hex.zxy / 2.0));\n}\n\n// #pragma glslify: export(hexSdf)\n\n\n// START ../common/ra2Hex.glsl\nvec3 raToHex(vec2 xy) {\n  float hex_t = xy.y / 0.866;\n  float hex_s = xy.x - hex_t / 2.0;\n  return vec3(hex_s, hex_t, -(hex_s + hex_t));\n}\n\n// #pragma glslify: export(raToHex)\n\n\n// START ../common/remix.glsl\n// START ./unmix.glsl\nfloat unmix(float a, float b, float value) {\n  return (value - a) / (b - a);\n}\n\n// #pragma glslify: export(unmix)\n\n\n\nfloat remix(float fromA, float fromB, float toA, float toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\nvec4 remix(float fromA, float fromB, vec4 toA, vec4 toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\n// #pragma glslify: export(remix)\n\n\n// START ../common/simplex2DTexture.glsl\n// START ./constants.glsl\nconst float SQRT1_2 = 0.7071067811865476;\nconst float SQRT1_3 = 0.57735026919;\nconst float SQRT2 = 1.4142135623730951;\nconst float SQRT3 = 1.732050807568877;\n// sqrt(3)/2 = sin(60*)\nconst float SQRT3_2 = 0.86602540378;\nconst float GOLDEN_RATIO = 1.61803398875;\nconst float PI = 3.141592653589793;\nconst float TAU = 6.28318530718;\n/**\n * One degree in radians. Use like `sin(30 * DEG)`.\n */\nconst float DEGREE = 0.017453292519943295;\n\n\nuniform sampler2D gradients;\n\nvec3 xy2tri(vec2 xy) {\n  float v = xy.y / 0.866;\n  float u = xy.x - v / 2.0;\n  float R = float(mod(u, 1.0) + mod(v, 1.0) > 1.0);\n  return vec3(u, v, R);\n}\nvec3 triCenter(vec3 uvR) {\n  vec3 base = floor(uvR);\n  vec2 centerOffset = mix(vec2(1.0 / 3.0), vec2(2.0 / 3.0), uvR.z);\n  return base + vec3(centerOffset, 0.0);\n}\nvec2 tri2xy(vec3 uvR) {\n  float y = uvR.t * 0.866;\n  float x = uvR.s + uvR.t / 2.0;\n  return vec2(x, y);\n}\nvec2 tri2xy(vec2 uv) {\n  float y = uv.t * 0.866;\n  float x = uv.s + uv.t / 2.0;\n  return vec2(x, y);\n}\n/* Create random direction vector\n */\nvec2 randomGradient(vec2 i) {\n  // Random float. No precomputed gradients mean this works for any number of grid coordinates\n  float random =\n    2920.0 *\n    sin(float(i.x) * 2.1942 + float(i.y) * 1.71324 + 8.912) *\n    cos(float(i.x) * 2.3157 * float(i.y) * 2.17832 + 9.758);\n  //    random = (i.x + 1667.) * (i.x + 2083.) * (i.y + 2659.) * (i.y * 50.77 + .3769);\n  //    random = sin(SQRT2 * i.x) + cos(GOLDEN_RATIO * i.y) + tan((i.x + i.y) * SQRT3);\n  return vec2(cos(random), sin(random));\n}\n\nfloat dotGridGradient2(vec2 cell, vec2 pos) {\n  vec2 xy_d = cell - pos;\n  if (length(xy_d) > 0.4) return 0.0;\n  float r = 1.0;\n  float part = pow(max(0.0, 0.999 - dot(xy_d, xy_d)), 4.0);\n  //    vec2 gradient = texelFetch(gradients, ivec2(cell), 0).xy;\n  vec2 gradient = randomGradient(cell);\n  return part * dot(gradient, xy_d);\n}\n\n// resulting range is [-0.68, 0.68]. Use unmix to normalize if necessary.\nfloat simplex2D(vec2 xy) {\n  vec3 uvR = xy2tri(xy);\n  ivec2 baseUV = ivec2(uvR.xy);\n\n  float a = dotGridGradient2(tri2xy(vec2(baseUV)), xy);\n  float b = dotGridGradient2(tri2xy(vec2(baseUV + ivec2(1, 0))), xy);\n  float c = dotGridGradient2(tri2xy(vec2(baseUV + ivec2(0, 1))), xy);\n  float d = dotGridGradient2(tri2xy(vec2(baseUV + ivec2(1, 1))), xy);\n\n  return b + c + mix(a, d, uvR.z);\n}\n\n// #pragma glslify: export(simplex2D)\n\n\n// START ../common/transform.glsl\nvec3 transform(mat4 pm, vec3 p) {\n  vec4 pStar = pm * vec4(p, 1);\n  return pStar.xyz / pStar.w;\n}\n\nvec2 transform(mat4 pm, vec2 p) {\n  vec4 pStar = pm * vec4(p, 0, 1);\n  return pStar.xy / pStar.w;\n}\n\n\n// START ../common/visualize.glsl\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\n  float isLow = float(t < 0.0);\n  float isHigh = float(t > 1.0);\n  float isMid = 1.0 - isLow - isHigh;\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\n}\n\nvec4 visualize(float t) {\n  const vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\n  const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\n  return visualize(BLUE, RED, t);\n}\n\n// #pragma glslify: export(visualize)\n\n\n// START ../common/waves.glsl\nfloat waves(vec4 color, vec2 position, vec2 direction, float highResTimeStamp) {\n  return sin(\n    dot(position, direction / pow(length(direction), 2.0)) +\n      float(highResTimeStamp) / 200.0\n  );\n}\n\n// #pragma glslify: export(waves)\n\n\n\nin float n;\nin vec2 coord;\nout vec4 fragColor;\nuniform float a;\nuniform int bandCount;\nuniform mat4 mmmi;\nuniform sampler2D texture;\nuniform vec2 iResolution;\nuniform vec4 colorBackground;\nuniform vec4 colorPrimary;\nuniform vec4 colorSecondary;\n\nfloat simplex01(vec2 pos) {\n  return unmix(-0.68, 0.68, simplex2D(pos));\n}\n\nvoid main() {\n  vec2 fragCoord = coord;\n  fragCoord *= iResolution;\n\n  fragCoord = transform(mmmi, fragCoord);\n  fragCoord *= 0.01;\n  //  fragCoord = coord;\n  float f = mix(simplex2D(fragCoord), simplex2D(fragCoord * 4.0), a);\n  float f2 = simplex2D(fragCoord);\n\n  fragColor = mix(\n    colorBackground,\n    colorPrimary,\n    banded(bandCount, unmix(-0.35, 0.35, f2))\n  );\n  //    fragColor = mix(fragColor, colorSecondary, float(between(0.0, 1., f)));\n}\n"}}]);