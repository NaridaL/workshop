{"version":3,"file":"182.js","mappings":"mZAKaA,EA8CXC,cA1CA,KAACC,OAAOC,aAAsB,MA2C5BC,KAAKC,KAAO,IAAIC,IAChBF,KAAKG,MAAQ,C,CA1CfC,WACE,MACE,IACAC,MAAMC,KAAKN,KAAKO,YACbC,KAAI,EAAGC,MAAKC,WAAYD,EAAM,IAAMC,IACpCC,KAAK,MACR,G,CAIJC,QACEC,EACAC,GAEA,IAAK,MAAMC,KAAUf,KAAKC,KAAKe,SAC7B,IAAK,MAAM,IAAEP,EAAG,MAAEC,KAAWK,EAC3BF,EAAWI,KAAKH,EAASJ,EAAOD,EAAKT,K,CAK3C,QACE,IAAK,MAAMe,KAAUf,KAAKC,KAAKe,SAC7B,IAAK,MAAM,IAAEP,KAASM,QACdN,C,CAKZ,UACE,IAAK,MAAMM,KAAUf,KAAKC,KAAKe,SAC7B,IAAK,MAAM,MAAEN,KAAWK,QAChBL,C,CAaZ,CAACZ,OAAOoB,YACN,OAAOlB,KAAKmB,S,CAGdC,IAAIX,EAAQC,GAEV,OADAV,KAAKqB,KAAKZ,EAAKC,GACRV,I,CAOTqB,KAAKZ,EAAQa,GACX,MAAMC,EAAWd,EAAIc,WACnBR,EAASf,KAAKC,KAAKuB,IAAID,GAEzB,GAAIR,EAAQ,CACV,MAAMU,EAAYV,EAAOW,WAAWC,GAASA,EAAKlB,IAAImB,OAAOnB,KAC7D,IAAK,GAAKgB,EAIR,OADAV,EAAOU,GAAWf,MAAQY,GACnB,EAHPP,EAAOc,KAAK,CAAEpB,IAAKA,EAAKC,MAAOY,G,MAMjCtB,KAAKC,KAAKmB,IAAIG,EAAU,CAAC,CAAEd,IAAKA,EAAKC,MAAOY,KAG9C,OADAtB,KAAKG,SACE,C,CAGT2B,IAAIrB,GACF,MAAMc,EAAWd,EAAIc,WACnBR,EAASf,KAAKC,KAAKuB,IAAID,GAEzB,YAAOQ,IAAchB,GAAUA,EAAOiB,MAAML,GAASA,EAAKlB,IAAImB,OAAOnB,I,CAGvEe,IAAIf,GACF,MAAMc,EAAWd,EAAIc,WACnBR,EAASf,KAAKC,KAAKuB,IAAID,GACvBI,EAAOZ,GAAUA,EAAOkB,MAAMN,GAASA,EAAKlB,IAAImB,OAAOnB,KACzD,OAAOkB,GAAQA,EAAKjB,K,CAGtBwB,QAAQzB,GACN,IAAK,MAAMc,KAAYd,EAAI0B,YAAc,CACvC,MAAMpB,EAASf,KAAKC,KAAKuB,IAAID,GACvBa,EAAWrB,GAAUA,EAAOkB,MAAMI,GAAMA,EAAE5B,IAAI6B,KAAM7B,KAC1D,GAAI2B,EAAU,OAAOA,C,EAIzBG,QAAQ9B,EAAQa,GACd,OAAQtB,KAAKkC,QAAQzB,IAAQT,KAAKoB,IAAIX,EAAKa,E,CAG7CkB,OAAO/B,GACL,MAAMc,EAAWd,EAAIc,WACnBR,EAASf,KAAKC,KAAKuB,IAAID,GACzB,GAAIR,EAAQ,CACV,MAAM0B,EAAQ1B,EAAOW,WAAWW,GAAMA,EAAE5B,IAAImB,OAAOnB,KACnD,IAAK,GAAKgC,EAOR,OANI,GAAK1B,EAAO2B,OACd1C,KAAKC,KAAKuC,OAAOjB,GAEjBR,EAAO4B,OAAOF,EAAO,GAEvBzC,KAAKG,SACE,C,CAGX,OAAO,C,CAGTyC,WAAWnC,GACT,IAAK,MAAMc,KAAYd,EAAI0B,YAAc,CACvC,MAAMpB,EAASf,KAAKC,KAAKuB,IAAID,GAC7B,GAAIR,EAAQ,CACV,MAAM0B,EAAQ1B,EAAOW,WAAWW,GAAMA,EAAE5B,IAAI6B,KAAM7B,KAClD,IAAK,GAAKgC,EAAO,CACf,MAAMI,EAAU9B,EAAO0B,GAOvB,OANI,GAAK1B,EAAO2B,OACd1C,KAAKC,KAAKuC,OAAOjB,GAEjBR,EAAO4B,OAAOF,EAAO,GAEvBzC,KAAKG,QACE0C,C,IAMf,YACE,IAAK,MAAM9B,KAAUf,KAAKC,KAAKe,eACtBD,C,CAIX,WACE,IAAK,MAAMA,KAAUf,KAAKC,KAAKe,SAC7B,IAAK,MAAM,IAAEP,EAAG,MAAEC,KAAWK,OACrB,CAACN,EAAKC,E,CAKlBoC,QACE9C,KAAKC,KAAK6C,QACV9C,KAAKG,MAAQ,C,CAGX4C,WACF,OAAO/C,KAAKG,K,ECtKhB,MAAM6C,EAAiB,sZAcjBC,EAAa,YACHC,EAASC,EAAQC,EAAS,GACxC,cAAeD,GACb,IAAK,YACH,MAAO,YACT,IAAK,WACH,OAAOA,EAAE/C,WACX,IAAK,SACL,IAAK,UACH,MAAO,GAAK+C,EACd,IAAK,SACH,OAAOE,KAAKC,UAAUH,GACxB,IAAK,SACH,OAAI,MAAQA,EACH,OAEAA,EAAEI,IAEb,QACE,MAAUC,aAAaL,GAAAA,CAG7B,SAASM,EACPC,EACAC,GAEKD,EAAME,UAAUV,UACnBW,OAAOC,eAAeJ,EAAME,UAAW,WAAY,CACjDlD,MAAOiD,EACPI,UAAS,EACTC,cAAa,EACbC,YAAW,GAAC,CAKlBR,EAA6BS,QAASA,QAAQN,UAAUxD,UACxDqD,EAA6BU,SAAUA,SAASP,UAAUxD,UAC1DqD,EAA6BW,OAAQA,OAAOR,UAAUxD,UACtDqD,EAA6BY,OAAQA,OAAOT,UAAUxD,UACtDqD,EAA6Ba,MAAK,WAChC,MAAO,YAActE,KAAKuE,UAAY,OAExCd,EAA6Be,QAAO,WAClC,OAAOnB,KAAKC,UAAUtD,KAAAA,IAExByD,EAA6BpD,OAAM,WACjC,GAAI4C,EAAKwB,SAASzE,MAChB,MAAO,qBAETiD,EAAKpB,KAAK7B,MACV,IAAI0E,EAAS,IACb,IAAK,IAAIC,EAAI,EAAGA,EAAI3E,KAAK0C,OAAQiC,IAC/BD,GAAU,OAASxB,EAASlD,KAAK2E,IAAIC,QAAQ,cAAe,QACxDD,IAAM3E,KAAK0C,OAAS,IACtBgC,GAAU,KAKd,OAFAA,GAAU,IAAM1E,KAAK0C,OAAS,IAAM,MACpCO,EAAK4B,MACEH,CAAAA,IAETjB,EAA6BI,QAAO,WAClC,GAAIZ,EAAKwB,SAASzE,MAChB,MAAO,qBAETiD,EAAKpB,KAAK7B,MACV,IAAI0E,EAAS,IACb,MAAMI,EAAOjB,OAAOiB,KAAK9E,MAAM+E,OAC/B,IAAK,IAAIJ,EAAI,EAAGA,EAAIG,EAAKpC,OAAQiC,IAAK,CACpC,MAAMK,EAAIF,EAAKH,GACfD,GACE,QA3EG,yBAAyBO,KADRxE,EA6EFuE,KA5EwBhC,EAAeiC,KAAKxE,GA4EvCuE,EAAI3B,KAAKC,UAAU0B,IAC1C,KACA9B,EAAUlD,KAAagF,IAAIJ,QAAQ,cAAe,QAChDD,IAAMG,EAAKpC,OAAS,IACtBgC,GAAU,KAjFhB,IAA0BjE,EAsFxB,OAFAiE,GAAU,IAAMI,EAAKpC,OAAS,IAAM,MACpCO,EAAK4B,MACEH,CAAAA,IAAAA,MCnGIQ,EAAKC,KAAKD,GACVE,EAAM,EAAIF,EAUVG,GAAoC,EACpCC,EAAgB,GAAK,GAAK,IAmBNC,SAGjBC,EAAcC,KAAsCC,GAAAA,IAAAA,EAAAA,EAClE,GAAIL,EACF,IAAK,IAAIV,EAAI,EAAGA,EAAIe,EAAKhD,OAAQiC,IAC/B,KAAMe,EAAKf,aAAcc,GACvB,MAAUjC,MACR,mBACEmB,EACA,cACAc,EAAK7B,UAAU+B,KACf,0BACCD,EAAKf,UAAAA,IAAAA,OAAAA,EAAAA,EAAY9E,mBAAAA,IAAAA,OAAAA,EAAAA,EAAa8F,MAC/BD,EAAKf,IAKf,OAAM,CAAC,UAGOiB,KAAiBC,GAC/B,GAAIR,EACF,IAAK,IAAIV,EAAI,EAAGA,EAAIkB,EAAQnD,OAAQiC,IAClC,GAAI,iBAAoBkB,EAAQlB,GAC9B,MAAUnB,MACR,2BAA2BmB,8BAA8BkB,EACvDlB,gBACakB,EAAQlB,KAAAA,CAAAA,SAOjBmB,KAAcD,GAC5B,GAAIR,EACF,IAAK,IAAIV,EAAI,EAAGA,EAAIkB,EAAQnD,OAAQiC,IAClC,GAAI,iBAAoBkB,EAAQlB,IAAMkB,EAAQlB,GAAK,GAAM,EACvD,MAAUnB,MACR,2BAA2BmB,4BAA4BkB,EACrDlB,gBACakB,EAAQlB,KAAAA,CAa0BtC,SAM3C0D,EACdrF,KACGsF,GAEH,GAAIX,IAAc3E,EAChB,MAAU8C,MACR,kBACEwC,EACGxF,KAAKyF,GACJ,mBAAsBA,EAAUA,IAAYA,GAAW,KAExDtF,KAAK,OAGd,OAAM,CAAC,CAISD,SAGFwF,EAAQC,KAAiBH,GACvC,GAAIX,IAAcc,IAChB,MAAU3C,MACR,mBACE2C,EAAE/F,WACF4F,EACGxF,KAAKyF,GACJ,mBAAsBA,EAAUA,IAAYA,GAAW,KAExDtF,KAAK,OAagDsF,SAKhDG,EAAKC,EAAWC,EAAWC,GACzC,OAAOF,GAAK,EAAIE,GAAKD,EAAIC,CAAAA,CAAAA,SAGXC,EAAQH,EAAWC,EAAWC,GAC5C,OAAQA,EAAIF,IAAMC,EAAID,EAAAA,CAGxB,MAAMI,EAAyBrC,OAAOR,UAAUxD,SAChDgE,OAAOR,UAAUxD,SAAW,SAAUsG,GACpC,OAAIxB,GAAMlF,KACD,KAEFyG,EAAuBxF,KAAKjB,KAAM0G,EAAAA,EAAAA,MAG9BC,EAAM,CAACtE,EAAWuE,EAActB,IAC3CH,KAAK0B,IAAIxE,IAAMuE,EACJE,EAAK,CAChBzE,EACA0E,EACAH,EAActB,IACFH,KAAK0B,IAAIxE,EAAI0E,IAAMH,EACpBI,EAAK,CAChB3E,EACA0E,EACAH,EAActB,IACFjD,EAAI0E,GAAKH,EA0CvB,SAASK,EACPd,EACAzF,EACAwG,GAGA,YAAWA,GAAgC,IAARA,EACjC,OAAOf,EAAEzF,GAKX,GAFAwG,GAAOA,EAEHC,MAHJzG,GAASA,IAG4B,iBAARwG,GAAoBA,EAAM,GAAM,EAC3D,OAAOE,IAGT,IAAIC,EAAK3G,EAAMN,WAAWkH,MAAM,KAIhC,OADAD,GAFA3G,EAAQyF,IAAIkB,EAAG,GAAK,KAAOA,EAAG,IAAMA,EAAG,GAAKH,GAAOA,MAExC9G,WAAWkH,MAAM,OACnBD,EAAG,GAAK,KAAOA,EAAG,IAAMA,EAAG,GAAKH,EAAMA,GAAAA,CAAAA,MAGpCK,EAGCN,EAAcO,UAAK,EAAWrC,KAAKsC,OAUpCC,GANCT,EAAcO,UAAK,EAAWrC,KAAKwC,OAInCV,EAAcO,UAAK,EAAWrC,KAAKyC,MAErB,mBAGHtB,SAGTuB,EAAMvG,EAAawG,EAAaC,GAE9C,OADAnC,EAActE,EAAKwG,EAAKC,GACjB5C,KAAK4C,IAAID,EAAK3C,KAAK2C,IAAIC,EAAKzG,GAAAA,CA2DbN,SAGRgH,EACdC,EACAC,KACGC,GAEHtE,OAAOuE,oBAAoBF,GAAOtH,SAASH,IAEpC0H,EAAQ1D,SAAShE,KAChBwH,EAAOI,eAAe5H,IACxB6H,QAAQC,KACN,UACAN,EACA,yBACAxH,EACAwH,EAAOxH,IAGXoD,OAAOC,eACLmE,EACAxH,EACAoD,OAAO2E,yBAAyBN,EAAOzH,IAAAA,GAAAA,CAAAA,IAMpCgI,EAAwBpG,GAAcA,EAIL,MAG/BqG,EAAQ,CAACrC,EAAWC,IAAcD,EAAIC,EAAAA,SAEnCqC,EAAcxC,GAC5B,SAAUA,GAAK,GAAK,IAAI,CA6BjBE,MAIIuC,EAAM,oBA4PiBC,SASpBC,EACdzC,EACAC,EACAyC,EACAC,GAEA,GAAIrC,EAAIN,GACN,OAAIM,EAAIL,GACC,EAAE0C,EAAID,GArCV1G,SAWiB4G,EAAWC,GAEnC,MAAMC,EAAkBF,EAAIA,EAAK,EAAIC,EACrC,GAAIC,GAAkB7D,EACpB,MAAO,GACF,GAAI6D,GAAkB7D,EAC3B,MAAO,EAAE2D,EAAI,GACR,CACL,MAAMJ,EAAO1D,KAAKiE,KAAKD,GACvB,MAAO,EAAEF,EAAI,EAAIJ,GAAOI,EAAI,EAAIJ,EAAAA,CAAAA,CAmBvBQ,CAAUN,EAAIzC,EAAG0C,EAAI1C,GAGhC,MAAMgD,EAAUjD,EAChBA,EAAIC,EAAIgD,EAGR,MACEC,GADS,GAFXjD,EAAIyC,EAAIO,GAEWjD,EAAIA,GAAK,EACd,EACZmD,EAAYD,EAAQA,EAAQA,EAC5BL,GAAK,EAAI7C,EAAIA,EAAIA,EAAI,EAAIA,EAAIC,EAAI,IAJnCyC,EAAIC,EAAIM,IAIqC,GAC3CG,EAAQP,EAAI,EACZQ,EAAeD,EAAQA,EAAQD,EAEjC,GAAIE,GAAgBpE,EAAgB,EAAG,CACrC,MAAMqE,EAAIxE,KAAKiE,MAAMI,GACnBjD,GAAK2C,GAAK,EAAIS,GAEdC,EAAMzE,KAAK0E,KADFtD,GAAK,GAAK,EAAIA,EAAI,EAAI,EAAIA,GAEnCuD,EAAK,EAAI3E,KAAK4E,KAAKJ,GAIrB,MAAO,CAHIG,EAAK3E,KAAK6E,IAAIJ,EAAM,GAAKvD,EAAI,EAC7ByD,EAAK3E,KAAK6E,KAAKJ,EAAM,EAAIzE,KAAKD,IAAM,GAAKmB,EAAI,EAC7CyD,EAAK3E,KAAK6E,KAAKJ,EAAM,EAAIzE,KAAKD,IAAM,GAAKmB,EAAI,GAEnD,GAAIqD,GAAgBpE,EAAgB,EAAG,CAC5C,GAAI,GAAKmE,EAEP,MAAO,EAAEpD,EAAI,GAEf,MAAM4D,EAAKR,EAAQ,EAAItE,KAAK4E,MAAMN,IAAUtE,KAAK4E,KAAKN,GAGtD,MAAO,CAFI,EAAIQ,EAAK5D,EAAI,GACZ4D,EAAK5D,EAAI,GAEhB,CACL,MAAM6D,EAAK/E,KAAKiE,KAAKM,GAGrB,MAAO,CAFIvE,KAAK4E,MAAMN,EAAQS,GACnB/E,KAAK4E,KAAKN,EAAQS,GACX7D,EAAI,EAAE,CAAF,CA8CN,SAGJ8D,EAAWxE,KAAiByE,GAC1C,OAAOzE,EAAO,IAAMyE,EAAO5J,IAAI0C,GAAUvC,KAAK,KAAO,GAAG,CCrqBxD,SAGc0J,KAAiBC,GAC/B,GAAIjF,EACF,IAAK,IAAIV,EAAI,EAAGA,EAAI4F,UAAU7H,OAAQiC,IACpC,KAAM4F,UAAU5F,aAAc6F,GAAMD,UAAU5F,aAAc8F,IAC1D,MAAUjH,MACR,2BACEmB,EACA,6BACO4F,UAAU5F,GACjB,cACA4F,UAAU5F,IAKpB,OAAM,CAAC,CAmKAtC,SAeOqI,EACdvE,EACAwE,EACAC,EAAgB,EAChBC,EAA4C,MAE5C,GAAI,iBAAoBA,EAAS,CAC/B,IAAIxI,EAAIsI,EAER,IAAK,IAAIhG,EAAI,EAAGA,EAAIiG,EAAOjG,IAAK,CAC9B,MAAMmG,EAAK3E,EAAE9D,GAGbA,GAAQyI,IAFM3E,EAAE9D,EAAIwI,GAAWC,GAAMD,EAAAA,CAIvC,OAAOxI,CAAAA,CAEP,OAAqDwI,SAKvD1E,EACAwE,EACAC,EAAgB,EAChBG,GAEA,IAAI1I,EAAIsI,EACR,IAAK,IAAIhG,EAAI,EAAGA,EAAIiG,EAAOjG,IAAK,CAC9B,MAAMmG,EAAK3E,EAAE9D,GACP2I,EAAOD,EAAG1I,IACZ8E,MAAM2D,IAAO3D,MAAM6D,KACrB1C,QAAQ2C,MAGV5I,GAAQyI,EAAKE,EACT7D,MAAM2D,IACRxC,QAAQ2C,KAAK,CAIjB,OAAO5I,CAAAA,CAxBE6I,CAA4B/E,EAAGwE,EAAQC,EAAOC,EAAAA,CA8LhDM,SCrdOC,EAAUC,EAAY1G,EAAQ2G,GAC5C,MAAMC,EAAOF,EAAI1G,GACjB0G,EAAI1G,GAAK0G,EAAIC,GACbD,EAAIC,GAAKC,CAAAA,CAAAA,SAQKC,EACdC,EACAC,EACAC,EACAC,EACAlJ,GAKA,IAHAoD,EAAW4F,EAAQE,EAAQlJ,GAC3BkJ,GAAUlJ,EACVA,GAAUgJ,EACHhJ,KAAWgJ,GAChBC,IAAMC,GAAUH,EAAI/I,GAEtB,OAAOiJ,CAAAA,CAAAA,SAeOE,EACdJ,EACAC,EACAI,EACAH,EACAC,EACAG,EACAC,GAEA,IAAIC,EAAWP,EAASM,EAAQF,EAC5BI,EAASN,EAASI,EAAQD,EAC9B,KAAOE,EAAWP,GAChBC,EAAKO,GAAUH,GAAUN,EAAKQ,GAAYH,EAAAA,CA6BkBK,SAIhDC,EACdC,EACAC,EACAC,EAAY,GAEZ3G,EAAcyG,EAAgBE,GAE9B,MAAMC,EAAYrH,KAAKyC,MAAM0E,EAAeD,GAAkBE,GACxD7H,EAAarE,MAAMmM,GAEzB,IACE,IAAI7H,EAAI0H,EAAgB5J,EAAQ,EAChCA,EAAQ+J,EACR7H,GAAK4H,EAAM9J,IAEXiC,EAAOjC,GAASkC,EAElB,OAAOD,CAAAA,CAW0D,SA2BnD+H,EACd/J,EACAyD,GAEAP,EAAclD,GACdqD,EAAO,mBAAqBI,GAC5B,MAAME,EAAQhG,MAAMqC,GACpB,IAAIgK,EAAUhK,EACd,KAAOgK,KACLrG,EAAEqG,GAAWvG,EAAEuG,EAAShK,GAE1B,OAAO2D,CAAAA,CAAAA,SAUOsG,EACdtB,EACAlF,GAEA,IACEzB,EADEC,EAAI0G,EAAI3I,OAEVkK,GAAAA,IACF,KAAOjI,KAAK,CACV,MAAMkI,EAAKxB,EAAI1G,GACbrD,EAAM6E,EAAE0G,EAAIlI,EAAG0G,GACb/J,EAAMsL,IACRA,EAAStL,EACToD,EAASmI,EAAAA,CAGb,OAAOnI,CAAAA,CA0IAqD,SAGOA,EAAIsD,GAElB,IAAI1G,EAAI0G,EAAI3I,OACVqF,GAAAA,IACF,KAAOpD,KAAK,CACV,MAAMrD,EAAM+J,EAAI1G,GACZoD,EAAMzG,IAAKyG,EAAMzG,EAAAA,CAEvB,OAAOyG,CAAAA,CA2CI,SAGG+E,EAAUzB,GACxB,MAAM0B,EAAY,IAAIC,IAAO3B,GAC7B,OAAOhL,MAAMC,KAAKyM,EAAAA,CAeXrI,SAGOuI,EAAkB5B,EAAU1G,GAC1C,MAAMD,EAAS2G,EAAI1G,GAMnB,OALIA,GAAK0G,EAAI3I,OAAS,EACpB2I,EAAIxG,MAEJwG,EAAI1G,GAAK0G,EAAIxG,MAERH,CAAAA,CA4HuBpD,SAGhB4L,EAAiB7B,EAAU8B,GAEzC,GADAA,EAAQpI,MAAK,CAACsB,EAAGC,IAAMD,EAAIC,IACvB,IAAM6G,EAAQzK,OAAQ,OAAO2I,EACjC,GAAI,IAAM8B,EAAQzK,OAEhB,OADA2I,EAAI1I,OAAOwK,EAAQ,GAAI,GAChB9B,EAET,IAAI+B,EAASD,EAAQ,GACjBE,EAAWF,EAAQ,GACnBG,EAAa,EACjB,IAAK,IAAIC,EAASJ,EAAQ,GAAII,EAASlC,EAAI3I,OAAQ6K,IACjD,GAAIA,IAAWF,EACbhC,EAAI+B,KAAY/B,EAAIkC,OACf,CAEL,GADAD,MACIA,EAAaH,EAAQzK,QAIvB,OADA2I,EAAI1I,OAAOyK,EAAQG,EAAS,EAAIH,GACzB/B,EAHPgC,EAAWF,EAAQG,EAAAA,CAOzB,MAAU9J,MAAM,gBAAgB,CFWlCK,OAAOrD,IAAM,SACX2C,EACAgD,EACAqH,GAEA,MAAM9I,EAAS,CAAC,EAChB,IAAK,MAAMjE,KAAO0C,EAChBuB,EAAOjE,GAAO0F,EAAElF,KAAKuM,EAASrK,EAAE1C,GAAMA,EAAK0C,GAE7C,OAAOuB,CAAAA,EAqBTF,OAAOZ,UAAU6J,sBAAwB,WACvC,OAAOzN,KAAK0N,OAAO,GAAGC,cAAgB3N,KAAK4N,MAAM,EAAE,EAErDpJ,OAAOZ,UAAUhC,OAAS,SAAUS,GAClC,OAAOrC,MAAQqC,CAAAA,EAOjBwB,OAAOC,eAAeD,OAAOD,UAAW,MAAO,CAC7CpC,IAAK,WACH,OAAOxB,KAAKkD,UAAU,EAExBc,cAAa,IExDG,MCnhBLwG,EAiBXqD,YAAqBxL,EAAoB0E,EAAoB+G,GAAxC9N,KAAAA,EAAAqC,EAAoBrC,KAAAA,EAAA+G,EAAoB/G,KAAAA,EAAA8N,EAC3DlI,EAAcvD,EAAG0E,EAAG+G,EAAAA,CAGtBD,gBACE,OAAO,IAAIrD,EAAGrF,KAAK4I,SAAU5I,KAAK4I,SAAU5I,KAAK4I,SAAS,CAG5DF,gBAAgBxH,EAAOC,GACrB,OAAOD,EAAE2H,IAAI1H,GAAKD,EAAE3D,SAAW4D,EAAE5D,QAAQ,CAW3CmL,oBACE,MAAMI,EAA4B,EAAhB9I,KAAK4I,SAAe5I,KAAKD,GACrC4I,EAAoB,EAAhB3I,KAAK4I,SAAe,EACxBG,EAAU/I,KAAKiE,KAAK,EAAIjE,KAAAA,IAAA2I,EAAK,IACnC,OAAO,IAAItD,EACT0D,EAAU/I,KAAK6E,IAAIiE,GACnBC,EAAU/I,KAAKgJ,IAAIF,GACnBH,EAAAA,CAMJD,kBAAkBO,EAAexE,GAC/B,MAAUpG,OAAO,CAGnBqK,oBAAoB1H,GAClB,OAAO,IAAIqE,EAAGrE,EAAE,GAAIA,EAAE,GAAIA,EAAE,GAAG,CAGjC0H,WAAWxH,EAAOC,GAChB,OAAO,IAAIkE,EAAGrF,KAAK2C,IAAIzB,EAAEhE,EAAGiE,EAAEjE,GAAI8C,KAAK2C,IAAIzB,EAAEU,EAAGT,EAAES,GAAI5B,KAAK2C,IAAIzB,EAAEyH,EAAGxH,EAAEwH,GAAG,CAG3ED,WAAWxH,EAAOC,GAChB,OAAO,IAAIkE,EAAGrF,KAAK4C,IAAI1B,EAAEhE,EAAGiE,EAAEjE,GAAI8C,KAAK4C,IAAI1B,EAAEU,EAAGT,EAAES,GAAI5B,KAAK4C,IAAI1B,EAAEyH,EAAGxH,EAAEwH,GAAG,CAG3ED,YAAYxH,EAAOC,EAAOC,GACxB,OAAO,IAAIiE,EACTnE,EAAEhE,GAAK,EAAIkE,GAAKD,EAAEjE,EAAIkE,EACtBF,EAAEU,GAAK,EAAIR,GAAKD,EAAES,EAAIR,EACtBF,EAAEyH,GAAK,EAAIvH,GAAKD,EAAEwH,EAAIvH,EAAAA,CAI1BsH,iBAAiBxH,GACf,OAAO,IAAImE,EAAGnE,EAAE,GAAIA,EAAE,GAAIA,EAAE,GAAG,CAGjCwH,oBAAoBxH,EAAOC,GACzB,OAAOD,EAAEgI,QAAQ/H,EAAAA,CAGnBuH,WAAW1H,KAAqCmI,GAE9C,OADAvI,EAAOI,aAAahC,UACb,IAAIqG,EACTrE,EAAEoI,WAAM,EAEND,EAAK9N,KAAK6B,GAAMA,EAAEA,KAEpB8D,EAAEoI,WAAM,EAEND,EAAK9N,KAAK6B,GAAMA,EAAE0E,KAEpBZ,EAAEoI,WAAM,EAEND,EAAK9N,KAAK6B,GAAMA,EAAEyL,KAAAA,CAKxBD,sBAAsBxH,EAAOC,EAAOyC,GAElC,OADAsB,EAAchE,EAAGC,EAAGyC,GACb1C,EAAEmI,GAAGlI,GAAGmI,MAAMpI,EAAEmI,GAAGzF,GAAAA,CAG5B8E,cAAcxG,GACZgD,KAAiBhD,GACjB,IAAIhF,EAAI,EACN0E,EAAI,EACJ+G,EAAI,EACFnJ,EAAI0C,EAAG3E,OACX,KAAOiC,KACLtC,GAAKgF,EAAG1C,GAAGtC,EACX0E,GAAKM,EAAG1C,GAAGoC,EACX+G,GAAKzG,EAAG1C,GAAGmJ,EAEb,OAAO,IAAItD,EAAGnI,EAAG0E,EAAG+G,EAAAA,CAGtBD,cAAcxG,GACZgD,KAAiBhD,GACjB,IAAIhF,EAAIgF,EAAG,GAAGhF,EACZ0E,EAAIM,EAAG,GAAGN,EACV+G,EAAIzG,EAAG,GAAGyG,EACRnJ,EAAI0C,EAAG3E,OACX,KAAOiC,KACLtC,GAAKgF,EAAG1C,GAAGtC,EACX0E,GAAKM,EAAG1C,GAAGoC,EACX+G,GAAKzG,EAAG1C,GAAGmJ,EAEb,OAAO,IAAItD,EAAGnI,EAAG0E,EAAG+G,EAAAA,CActBD,YACEa,EACAC,EACAC,EAAmB,EACnBC,EAAoB,EACpBC,EAAkBJ,EAAMhM,OAASkM,GAGjC,MAAMlK,EAASiK,GAAS,IAAII,aAAa,EAAID,GAC7C/I,EACErB,EAAOhC,OAASmM,GAAuB,EAAVC,EAC7B,yCACApK,EAAOhC,OACPmM,EACU,EAAVC,GAGF,IAAInK,EAAImK,EACN7C,EAAW2C,EACXI,EAAYH,EACd,KAAOlK,KAAK,CACV,MAAMsK,EAAIP,EAAMzC,KAChBvH,EAAOsK,KAAeC,EAAE5M,EACxBqC,EAAOsK,KAAeC,EAAElI,EACxBrC,EAAOsK,KAAeC,EAAEnB,CAAC,CAE3B,OAAOpJ,CAAAA,CAGTmJ,cACEqB,EACAP,EACAC,EAAmB,EACnBC,EAAoB,EACpBC,GAAmBI,EAAYxM,OAASkM,GAAY,GAIpD7I,GADA4I,EAAOA,GAAYtO,MAAMyO,IAElBpM,OAASmM,GAAaC,EAC3B,sCAGF,IAAInK,EAAImK,EACN7C,EAAW2C,EACXI,EAAYH,EACd,KAAOlK,KACLgK,EAAKK,KAAe,IAAIxE,EACtB0E,EAAYjD,KACZiD,EAAYjD,KACZiD,EAAYjD,MAGhB,OAAO0C,CAAAA,CAGTd,cACEa,EACAC,EACAC,EAAmB,EACnBC,EAAoB,EACpBC,EAAkBJ,EAAMhM,OAASkM,GAGjC,MAAMlK,EAASiK,GAAS,IAAII,aAAa,EAAID,GAC7C/I,EACErB,EAAOhC,OAASmM,GAAaC,EAC7B,sCAGF,IAAInK,EAAImK,EACN7C,EAAW2C,EACXI,EAAYH,EACd,KAAOlK,KAAK,CACV,MAAMsK,EAAIP,EAAMzC,KAChBvH,EAAOsK,KAAeC,EAAE5M,EACxBqC,EAAOsK,KAAeC,EAAElI,CAAC,CAE3B,OAAOrC,CAAAA,CAGTmJ,gBACEpC,EACAkD,EACAC,EAAgB,EAChBC,EAAiB,EACjBC,EAAe3J,KAAK2C,IAAI2D,EAAI/I,OAAS,EAAIiM,GAAQA,EAAKjM,QAAWyM,KAC/DN,GAIF9I,GADA4I,EAAOA,GAAYtO,MAAMyO,IAElBpM,OAASmM,GAAaC,EAC3B,sCAEF/I,EACE0F,EAAI/I,OAASkM,GAAsB,EAAVE,EACzB,sCAGF,IAAInK,EAAImK,EACN7C,EAAW2C,EACXI,EAAYH,EACd,KAAOlK,KACLgK,EAAKK,KAAe,IAAIxE,EAAGiB,EAAIQ,KAAaR,EAAIQ,KAAa,GAE/D,OAAO0C,CAAAA,CAGTd,iBAAiBoB,EAAOG,GACtB,OAAOH,EAAEI,UAAUD,EAAAA,CAGrBvB,aAAayB,EAAgB1F,EAAYkE,EAAY,GACnD,OAAO,IAAItD,EAAG8E,EAASnK,KAAK6E,IAAIJ,GAAM0F,EAASnK,KAAKgJ,IAAIvE,GAAMkE,EAAAA,CAOhED,cAAc0B,EAAkBC,EAAiB9M,EAAS,GACxD,OAAO,IAAI8H,EACT9H,EAASyC,KAAK6E,IAAIwF,GAAYrK,KAAK6E,IAAIuF,GACvC7M,EAASyC,KAAK6E,IAAIwF,GAAYrK,KAAKgJ,IAAIoB,GACvC7M,EAASyC,KAAKgJ,IAAIqB,GAAAA,CAItB3B,mBAAmBxH,EAAOC,EAAOjE,GAC/B,MAAMoN,EAAKpJ,EAAEmI,GAAGlI,GAChB,OAAOD,EAAEmI,GAAGnM,GAAG2L,IAAIyB,GAAMA,EAAGC,SAAS,CAGnC,QACF,OAAO1P,KAAKqC,CAAC,CAEX,QACF,OAAOrC,KAAK+G,CAAC,CAEX,QACF,OAAO/G,KAAK8N,CAAC,CAGX6B,QACF,OAAO3P,KAAKqC,CAAC,CAEX4M,QACF,OAAOjP,KAAK+G,CAAC,CAGf8G,UAAUuB,EAAgC,GAAhB9J,GACxB,OAAOtF,KAAKQ,KAAK6B,GAAMA,GAAK8C,KAAK4I,SAAW,IAAOqB,GAAAA,CAGrDvB,EAAE/N,OAAOoB,kBACDlB,KAAKqC,QACLrC,KAAK+G,QACL/G,KAAK8N,CAAC,CAGdD,EAAEpL,GAEA,OADAsD,EAAOtD,GAAS,GAAKA,EAAQ,GACtB,GAAKA,EAAQzC,KAAKqC,EAAI,GAAKI,EAAQzC,KAAK+G,EAAI/G,KAAK8N,CAAC,CAG3DD,UACE,OAAO,IAAIrD,GAAIxK,KAAKqC,GAAIrC,KAAK+G,GAAI/G,KAAK8N,EAAE,CAG1CD,MACE,OAAO,IAAIrD,EAAGrF,KAAK0B,IAAI7G,KAAKqC,GAAI8C,KAAK0B,IAAI7G,KAAK+G,GAAI5B,KAAK0B,IAAI7G,KAAK8N,GAAG,CAGrED,KAAKxH,GAEH,OADAgE,EAAchE,GACP,IAAImE,EAAGxK,KAAKqC,EAAIgE,EAAEhE,EAAGrC,KAAK+G,EAAIV,EAAEU,EAAG/G,KAAK8N,EAAIzH,EAAEyH,EAAE,CAQzDD,MAAMxH,GACJ,OAAO,IAAImE,EAAGxK,KAAKqC,EAAIgE,EAAEhE,EAAGrC,KAAK+G,EAAIV,EAAEU,EAAG/G,KAAK8N,EAAIzH,EAAEyH,EAAE,CAIzDD,KAAKxH,GACH,OAAO,IAAImE,EAAGxK,KAAKqC,EAAIgE,EAAEhE,EAAGrC,KAAK+G,EAAIV,EAAEU,EAAG/G,KAAK8N,EAAIzH,EAAEyH,EAAE,CAIzDD,MAAMxH,GAEJ,OADAgE,EAAchE,GACP,IAAImE,EAAGxK,KAAKqC,EAAIgE,EAAEhE,EAAGrC,KAAK+G,EAAIV,EAAEU,EAAG/G,KAAK8N,EAAIzH,EAAEyH,EAAE,CAGzDD,GAAGxH,GAED,OADAgE,EAAchE,GACPA,EAAEuJ,MAAM5P,KAAK,CAGtB6N,MAAMgC,GAEJ,OADAjK,EAAciK,GACP,IAAIrF,EAAGxK,KAAKqC,EAAIwN,EAAQ7P,KAAK+G,EAAI8I,EAAQ7P,KAAK8N,EAAI+B,EAAAA,CAG3DhC,IAAIxH,GAEF,OADAT,EAAcS,GACP,IAAImE,EAAGxK,KAAKqC,EAAIgE,EAAGrG,KAAK+G,EAAIV,EAAGrG,KAAK8N,EAAIzH,EAAAA,CAQjDwH,IAAIxH,GAEF,OADAb,EAAWgF,EAAInE,GACRrG,KAAKqC,EAAIgE,EAAEhE,EAAIrC,KAAK+G,EAAIV,EAAEU,EAAI/G,KAAK8N,EAAIzH,EAAEyH,CAAC,CAInDD,KAAKvH,EAAOC,GAGV,OAFA8D,EAAc/D,GACdV,EAAcW,GACPiE,EAAGpE,KAAKpG,KAAMsG,EAAGC,EAAAA,CAG1BsH,UACE,OAAO7N,KAAKgO,IAAIhO,KAAK,CAGvB6N,WAAWxH,GAGT,OAFAgE,EAAchE,GAEPlB,KAAK2K,MAAM9P,KAAKqC,EAAIgE,EAAEhE,EAAGrC,KAAK+G,EAAIV,EAAEU,EAAG/G,KAAK8N,EAAIzH,EAAEyH,EAAE,CAG7DD,kBAAkBxH,GAEhB,OADAgE,EAAchE,GACPrG,KAAK4P,MAAMvJ,GAAGqJ,SAAS,CA4BhC7B,WACE,OAAOrD,EAAGuF,QAAQvO,IAAIxB,OAASA,KAAKI,UAAU,CAGhDyN,oBACE,MAAMhH,EAAM7G,KAAK6G,MACjB,OAAIA,EAAIxE,GAAKwE,EAAIE,GAAKF,EAAIxE,GAAKwE,EAAIiH,EAC1BtD,EAAGwF,EACDnJ,EAAIE,GAAKF,EAAIxE,GAAKwE,EAAIE,GAAKF,EAAIiH,EACjCtD,EAAGyF,EAEHzF,EAAG0F,CAAC,CAIfrC,MAAMvH,EAAOC,GACX8D,EAAc/D,GACdV,EAAcW,GACd,MAAM4H,EAAMhJ,KAAKgJ,IACXgC,EAAQnQ,KAAKqO,QAAQ/H,GAC3B,OAAOtG,KAAKoQ,MAAMjC,GAAK,EAAI5H,GAAK4J,GAAShC,EAAIgC,IAAQE,KACnD/J,EAAE8J,MAAMjC,EAAI5H,EAAI4J,GAAShC,EAAIgC,IAAAA,CAIjCtC,IAAIvH,GACF,OAAO,IAAIkE,EACTrF,KAAK2C,IAAI9H,KAAKqC,EAAGiE,EAAEjE,GACnB8C,KAAK2C,IAAI9H,KAAK+G,EAAGT,EAAES,GACnB5B,KAAK2C,IAAI9H,KAAK8N,EAAGxH,EAAEwH,GAAAA,CAIvBD,IAAIvH,GACF,OAAO,IAAIkE,EACTrF,KAAK4C,IAAI/H,KAAKqC,EAAGiE,EAAEjE,GACnB8C,KAAK4C,IAAI/H,KAAK+G,EAAGT,EAAES,GACnB5B,KAAK4C,IAAI/H,KAAK8N,EAAGxH,EAAEwH,GAAAA,CAIvBD,OAAOoB,GACL,OAAOjP,MAAQiP,GAAMjP,KAAKqC,GAAK4M,EAAE5M,GAAKrC,KAAK+G,GAAKkI,EAAElI,GAAK/G,KAAK8N,GAAKmB,EAAEnB,CAAC,CAYtED,MAAMoB,GACJ,OAAO,IAAIzE,EACTxK,KAAK+G,EAAIkI,EAAEnB,EAAI9N,KAAK8N,EAAImB,EAAElI,EAC1B/G,KAAK8N,EAAImB,EAAE5M,EAAIrC,KAAKqC,EAAI4M,EAAEnB,EAC1B9N,KAAKqC,EAAI4M,EAAElI,EAAI/G,KAAK+G,EAAIkI,EAAE5M,EAAAA,CAI9BwL,aACE,OAAO1I,KAAK2C,IAAI9H,KAAKqC,EAAGrC,KAAK+G,EAAG/G,KAAK8N,EAAE,CAGzCD,aACE,OAAO1I,KAAK4C,IAAI/H,KAAKqC,EAAGrC,KAAK+G,EAAG/G,KAAK8N,EAAE,CAGzCD,QAAQyC,EAAS,GACf,MAAO,CAACtQ,KAAKqC,EAAGrC,KAAK+G,EAAG/G,KAAK8N,GAAGF,MAAM,EAAG0C,EAAAA,CAQ3CzC,mBACE,GAAIlH,EAAI3G,KAAKqC,IAAMsE,EAAI3G,KAAK+G,GAAI,CAC9B,GAAIJ,EAAI3G,KAAK8N,GACX,MAAUtK,MAAM,eAGlB,OAAOgH,EAAGyF,CAAC,CAEb,OAAO,IAAIzF,GAAIxK,KAAK+G,EAAG/G,KAAKqC,EAAG,EAAE,CAInCwL,MACE,OAAO,CAAC,CAGVA,MACE,MAAO,CAAC7N,KAAKqC,EAAGrC,KAAK+G,EAAG/G,KAAK8N,EAAE,CAGjCD,UACE,OAAO1I,KAAKoL,MAAMvQ,KAAK+G,EAAG/G,KAAKqC,EAAE,CAGnCwL,WACE,OAAO1I,KAAK2K,MAAM9P,KAAKqC,EAAGrC,KAAK+G,EAAE,CAInC8G,YACE,OAAO7N,KAAKqC,EAAIrC,KAAKqC,EAAIrC,KAAK+G,EAAI/G,KAAK+G,CAAC,CAG1C8G,KACE,OAAO,IAAIrD,EAAGxK,KAAKqC,EAAGrC,KAAK+G,EAAG,EAAE,CAQlC8G,IAAI1H,GACF,OAAO,IAAIqE,EAAGrE,EAAEnG,KAAKqC,EAAG,KAAM8D,EAAEnG,KAAK+G,EAAG,KAAMZ,EAAEnG,KAAK8N,EAAG,KAAK,CAG/DD,SAAS2C,GAEP,OADAA,EAAgBA,GAAiB/H,EAE/B+B,EAAGuF,QAAQvO,IAAIxB,OACf,KAAO,CAACA,KAAKqC,EAAGrC,KAAK+G,EAAG/G,KAAK8N,GAAGtN,IAAIgQ,GAAe7P,KAAK,MAAQ,GAAG,CAIvEkN,QAAQvH,GAKN,OAJAP,EAAO,GAAKwE,UAAU7H,QACtB2H,EAAc/D,GACdP,GAAQ/F,KAAKyQ,SACb1K,GAAQO,EAAEmK,SACHtL,KAAK0E,KAAK1E,KAAK2C,IAAI,EAAG9H,KAAKgO,IAAI1H,GAAKtG,KAAK0C,SAAW4D,EAAE5D,UAAU,CASzEmL,oBAAoB6C,EAAYC,GAO9B,OANA5K,EAAO,GAAKwE,UAAU7H,QACtB2H,EAAcqG,EAAQC,GACtBzK,GAAAA,IAAcyK,EAAQC,UAAU,KAIzBzL,KAAKoL,MAAMvQ,KAAKyO,MAAMiC,GAAQ1C,IAAI2C,GAAU3Q,KAAKgO,IAAI0C,GAAAA,CAS9D7C,aAAa6C,GACXrG,EAAcqG,GACd3K,GAAQ/F,KAAKyQ,SACb1K,GAAQ2K,EAAOD,SAGf,MAAMzC,EAAMhO,KAAKgO,IAAI0C,GACrB,OAAO5J,EAAG9G,KAAK0P,UAAYgB,EAAOhB,UAAW1B,EAAMA,EAAAA,CAGrDH,kBAAkB6C,GAIhB,OAHArG,EAAcqG,GACd3K,GAAQ/F,KAAKyQ,QAAS,iBACtB1K,GAAQ2K,EAAOD,QAAS,mBACjB9J,EAAI3G,KAAKgO,IAAI0C,GAAAA,CAGtB7C,eAAegD,GACbxG,EAAcwG,GACd9K,GAAQ/F,KAAKyQ,SACb1K,GAAQ8K,EAAMJ,SAGd,MAAMzC,EAAMhO,KAAKgO,IAAI6C,GACrB,OAAO/J,EAAG3B,KAAKiE,KAAKpJ,KAAK0P,UAAYmB,EAAMnB,WAAY1B,EAAAA,CASzDH,SACE,OAAO1I,KAAK2K,MAAM9P,KAAKqC,EAAGrC,KAAK+G,EAAG/G,KAAK8N,EAAE,CAK3CD,QACE,OAAO7N,KAAKsC,KAAKkI,EAAGsG,EAAE,CAQxBjD,KAAKkD,GACH,OAAIA,IAAQ/Q,MACN+Q,aAAevG,GACd1D,EAAG9G,KAAKqC,EAAG0O,EAAI1O,IAAMyE,EAAG9G,KAAK+G,EAAGgK,EAAIhK,IAAMD,EAAG9G,KAAK8N,EAAGiD,EAAIjD,EAAE,CAIpED,eAAeoB,GACb,OAAOnI,EAAG3B,KAAK0B,IAAI7G,KAAKgO,IAAIiB,IAAK9J,KAAKiE,KAAKpJ,KAAK0P,UAAYT,EAAES,WAAW,CAO3E7B,OAEE,OADA9H,GAAQ/F,KAAKyQ,QAAS,gCACfzQ,KAAKgR,IAAIhR,KAAK0C,SAAS,CAIhCmL,aACE,MAAUrK,MAAM,kCAAkC,CAQpDqK,SAASoD,GAEP,OADArL,EAAcqL,GACPjR,KAAKoQ,MAAMa,EAAYjR,KAAK0C,SAAS,CAY9CmL,YAAYvH,GAGV,OAFA+D,EAAc/D,GAEPA,EAAE8J,MAAMpQ,KAAKgO,IAAI1H,GAAKA,EAAE0H,IAAI1H,GAAAA,CAGrCuH,aAAavH,GAGX,OAFA+D,EAAc/D,GAEPtG,KAAK4P,MAAMtJ,EAAE8J,MAAMpQ,KAAKgO,IAAI1H,GAAKA,EAAE0H,IAAI1H,IAAAA,CAGhDuH,cAAcqD,GAIZ,OAHA7G,EAAc6G,GACdnL,EAAOmL,EAAGN,UAAU,IAEb5Q,KAAK4P,MAAMsB,EAAGd,MAAMpQ,KAAKgO,IAAIkD,IAAAA,CAUtCrD,eAAevH,GAEb,OADA+D,EAAc/D,GACPnB,KAAKiE,KAAKpJ,KAAKgO,IAAIhO,MAAQmF,KAAAA,IAAAnF,KAAKgO,IAAI1H,GAAM,GAAIA,EAAE0H,IAAI1H,GAAAA,CAU7DuH,gBAAgBqD,GAGd,OAFA7G,EAAc6G,GACdnL,EAAOmL,EAAGN,UAAU,IACbzL,KAAKiE,KAAKpJ,KAAKgO,IAAIhO,MAAQmF,KAAAA,IAAAnF,KAAKgO,IAAIkD,GAAO,IAYpDrD,UAAUnL,GAER,OADAkD,EAAclD,GACPoE,EAAGpE,EAAQ1C,KAAK0C,SAAS,CAOlCmL,SACE,OAAO1I,KAAK0B,IAAI7G,KAAKqC,GAAK8C,KAAK0B,IAAI7G,KAAK+G,GAAK5B,KAAK0B,IAAI7G,KAAK8N,EAAE,CAI/DD,gBACE,OAAO1I,KAAK2C,IAAI3C,KAAK0B,IAAI7G,KAAKqC,GAAI8C,KAAK0B,IAAI7G,KAAK+G,GAAI5B,KAAK2C,IAAI9H,KAAK8N,GAAG,CAIvED,gBACE,OAAO1I,KAAK4C,IAAI5C,KAAK0B,IAAI7G,KAAKqC,GAAI8C,KAAK0B,IAAI7G,KAAK+G,GAAI5B,KAAK0B,IAAI7G,KAAK8N,GAAG,CAGvED,YACE,MAAMsD,EAAOhM,KAAK0B,IAAI7G,KAAKqC,GACzB+O,EAAOjM,KAAK0B,IAAI7G,KAAK+G,GACrBsK,EAAOlM,KAAK0B,IAAI7G,KAAK8N,GACvB,OAAOqD,GAAQC,EAAQD,GAAQE,EAAO,EAAI,EAAKD,GAAQC,EAAO,EAAI,CAAC,CAGrExD,YACE,MAAMsD,EAAOhM,KAAK0B,IAAI7G,KAAKqC,GACzB+O,EAAOjM,KAAK0B,IAAI7G,KAAK+G,GACrBsK,EAAOlM,KAAK0B,IAAI7G,KAAK8N,GACvB,OAAOqD,EAAOC,EAAQD,EAAOE,EAAO,EAAI,EAAKD,EAAOC,EAAO,EAAI,CAAC,CAGlExD,YAAYyD,EAAsBzE,GAGhC,OAFA9G,EAAO,CAAC,IAAK,IAAK,KAAKtB,SAAS6M,GAAM,GAAKA,GAC3C1L,EAAciH,GACV,KAAOyE,EACF,IAAI9G,EAAGqC,EAAI7M,KAAK+G,EAAG/G,KAAK8N,GAE7B,KAAOwD,EACF,IAAI9G,EAAGxK,KAAKqC,EAAGwK,EAAI7M,KAAK8N,GAE1B,IAAItD,EAAGxK,KAAKqC,EAAGrC,KAAK+G,EAAG8F,EAAAA,CAGhCgB,WACE,SAASlF,EAAcxC,GACrB,SAAUA,GAAK,GAAK,IAAI,CAG1B,SACyD,IAA9B,GAAxBwC,EAAc3I,KAAKqC,GAAUsG,EAAc3I,KAAK+G,IACjD4B,EAAc3I,KAAK8N,GAAAA,CAIvBD,YAUE,MAGE0D,KAA2B,IAAZ,MAHFvR,KAAKqC,GAAK,GAAK,IAAM,OACzBrC,KAAK+G,GAAK,GAAK,IAAM,QACrB/G,KAAK8N,GAAK,GAAK,IAAM,KAEhC,MAAO,GACHyD,KACCA,EAAK,QACLA,EAAK,OACLA,EAAK,GAAK,QACVA,EAAK,MACLA,EAAK,EAAI,QACTA,EAAK,EAAI,OACTA,EAAK,EAAI,GAAK,MAerB1D,UAAUgD,GACR,OAAI7Q,KAAKqC,GAAKwO,EAAMxO,EACXrC,KAAKqC,EAAIwO,EAAMxO,EACbrC,KAAK+G,GAAK8J,EAAM9J,EAClB/G,KAAK+G,EAAI8J,EAAM9J,EAEf/G,KAAK8N,EAAI+C,EAAM/C,CAAC,CAI3BD,WAAWgD,EAAWW,EAAclM,GAClC,OAAKwB,EAAG9G,KAAKqC,EAAGwO,EAAMxO,EAAGmP,GAEb1K,EAAG9G,KAAK+G,EAAG8J,EAAM9J,EAAGyK,GAEpB1K,EAAG9G,KAAK8N,EAAG+C,EAAM/C,EAAG0D,GAGvB,EAFAxR,KAAK8N,EAAI+C,EAAM/C,EAFf9N,KAAK+G,EAAI8J,EAAM9J,EAFf/G,KAAKqC,EAAIwO,EAAMxO,CAAC,CAU3BwL,WACE,MAAO,CACLO,MAAOjJ,KAAKoL,MAAMvQ,KAAK+G,EAAG/G,KAAKqC,GAC/BuH,IAAKzE,KAAKsM,KAAKzR,KAAK8N,EAAI9N,KAAK0C,UAAAA,EAAAA,SAmBnBgP,EAAErL,EAAQC,EAASyC,GACjC,GAAwB,GAApBwB,UAAU7H,OACZ,OAAO,IAAI8H,EAAGmH,WAAWtL,GAAIsL,WAAWrL,GAAIqL,WAAW5I,IAClD,GAAwB,GAApBwB,UAAU7H,OACnB,OAAO,IAAI8H,EAAGmH,WAAWtL,GAAIsL,WAAWrL,GAAI,GACvC,GAAwB,GAApBiE,UAAU7H,QACH,iBAAL2D,EAAe,CACxB,GAAIA,aAAamE,EAEf,OAAOnE,EACF,GACLA,aAAahG,OACbgG,aAAa0I,cACb1I,aAAauL,aACb,CACA,GAAI,GAAKvL,EAAE3D,OACT,OAAO,IAAI8H,EAAGmH,WAAWtL,EAAE,IAAKsL,WAAWtL,EAAE,IAAK,GAC7C,GAAI,GAAKA,EAAE3D,OAChB,OAAO,IAAI8H,EAAGmH,WAAWtL,EAAE,IAAKsL,WAAWtL,EAAE,IAAKsL,WAAWtL,EAAE,IAAI,MAEhE,GAAI,MAAOA,GAAK,MAAOA,EAC5B,OAAO,IAAImE,EACTmH,WAAWtL,EAAEhE,GACbsP,WAAWtL,EAAEU,GACb,MAAOV,EAAIsL,WAAWtL,EAAEyH,GAAK,GAKrC,MAAUtK,MAAM,oBAAsB+G,UAAU,CA53BhCC,EAAAA,EAAQ,IAAIA,EAAG,EAAG,EAAG,GACrBA,EAAAA,EAAQ,IAAIA,EAAG,EAAG,EAAG,GACrBA,EAAAA,EAAQ,IAAIA,EAAG,EAAG,EAAG,GACrBA,EAAAA,EAAQ,IAAIA,EAAG,EAAG,EAAG,GACrBA,EAAAA,GAAS,IAAIA,EAAG,EAAG,EAAG,GACtBA,EAAAA,IAAU,IAAIA,EAAG,EAAG,EAAG,GACvBA,EAAAA,IAAU,IAAIA,EAAG2E,IAAUA,IAAUA,KACrC3E,EAAAA,MAAc,CAACA,EAAGwF,EAAGxF,EAAGyF,EAAGzF,EAAG0F,GAC9B1F,EAAAA,SAAAA,IAAcqH,GAC3BzQ,IAAIoJ,EAAGsG,EAAG,QACV1P,IAAIoJ,EAAGwF,EAAG,QACV5O,IAAIoJ,EAAGyF,EAAG,QACV7O,IAAIoJ,EAAG0F,EAAG,QACV9O,IAAIoJ,EAAGsH,IAAK,UACZ1Q,IAAIoJ,EAAGuH,IAAK,gBC/BJC,EAAO,CAAErB,QAASnG,EAAGwF,EAAGiC,EAAG,GAC3BC,EAAO,CAAEvB,QAASnG,EAAGyF,EAAGgC,EAAG,GAC3BE,EAAO,CAAExB,QAASnG,EAAG0F,EAAG+B,EAAG,SAElBG,EACpBvE,OAAOwE,GACL,OAAOrS,KAAKsS,UAAUC,GAAGC,OAAOH,GAAAA,CAGlCxE,YACE,OAAO7N,KAAKwS,OAAOR,EAAAA,CAGrBnE,UACE,OAAO7N,KAAKwS,OAAON,EAAAA,CAGrBrE,UACE,OAAO7N,KAAKwS,OAAOL,EAAAA,CAGrBtE,QAAQwE,GACN,OAAOrS,KAAKsS,UAAUC,GAAGE,QAAQJ,GAAAA,CAGnCxE,YACE,OAAO7N,KAAKsS,UAAUC,GAAGE,QAAQN,GAAAA,CAGnCtE,YACE,OAAO7N,KAAKsS,UAAUC,GAAGE,QAAQT,GAAAA,CAGnCnE,YACE,OAAO7N,KAAKsS,UAAUC,GAAGE,QAAQP,GAAAA,CAKnCrE,aAAaS,GACX,OAAOtO,KAAKsS,UACVC,GAAGG,UAAUnE,WAAM,EAAWD,GAC9BnE,EAA2B,gBAAiBmE,GAAAA,CAMhDT,SAASS,GACP,OAAOtO,KAAKsS,UACVC,GAAGI,MAAMpE,WAAM,EAAWD,GAC1BnE,EAA2B,YAAamE,GAAAA,CAI5CT,QAAQ+E,GACN,OAAO5S,KAAKsS,UAAUC,GAAGM,QAAQD,GAAU,YAAYA,KAAAA,CAGzD/E,QAAQ+E,GACN,OAAO5S,KAAKsS,UAAUC,GAAGO,QAAQF,GAAU,YAAYA,KAAAA,CAGzD/E,QAAQ+E,GACN,OAAO5S,KAAKsS,UAAUC,GAAGQ,QAAQH,GAAU,YAAYA,KAAAA,CAGzD/E,OAAOmF,EAAoBC,EAAkBL,GAC3C,OAAO5S,KAAKsS,UACVC,GAAGW,WAAWF,EAAgBC,EAAcL,GAC5CzI,EAAW,UAAW6I,EAAgBC,EAAcL,GAAAA,CAIxD/E,SAASvN,EAAUkO,GACjB,OAAOxO,KAAKsS,UACVC,GAAGY,SAAS7S,EAAMkO,GAClBrE,EAAW,YAAa7J,EAAMkO,GAAAA,CAIlCX,SAASuF,EAAcC,EAAaC,GAClC,MAAU9P,OAAO,CAInBqK,OAAO9G,EAAW+G,GAEhB,OAAO9N,KAAKsS,UAAU,IAAIC,GAAG,CAC3B,EAAGxL,EAAG+G,EAAG,EACT,EAAG,EAAG,EAAG,EACT,EAAG,EAAG,EAAG,EACT,EAAG,EAAG,EAAG,IAAI,CAGjBD,MACE,OAAO7N,KAAKsS,UAAUC,GAAGgB,IAAI,CAG/B1F,SACE,OAAO7N,KAAKsS,UAAUC,GAAGiB,QAAQ,CA8BnC3F,MACE4F,KACGnF,GAEH,IAAIoF,EAAQ7P,OAAO8P,eAAe3T,MAElC,MACGyT,EAAQpL,eAAeqL,EAAM7T,YAAY8F,OAC1C+N,IAAUtB,EAAcxO,WAExB8P,EAAQ7P,OAAO8P,eAAeD,GAEhC,GAAID,EAAQpL,eAAeqL,EAAM7T,YAAY8F,MAC3C,OAAO8N,EAAQC,EAAM7T,YAAY8F,MAAM4I,MAAMvO,KAAMsO,GAEnD,MAAU9K,MAAM,yBAA2BxD,KAAKH,YAAY8F,KAAK,EAALA,MC1HrDiO,EACX/F,YACSgG,EACAC,EACSC,GAFT/T,KAAAA,MAAA6T,EACA7T,KAAAA,OAAA8T,EACS9T,KAAAA,EAAA+T,EAEhBjO,EAAW+N,EAAOC,GAClB5N,GAAAA,IAAc,EAAI2N,IAClB3N,GAAAA,IAAc,EAAI4N,IAClB/N,EACE8N,EAAQC,GAAUC,EAAErR,OACpB,6BACAmR,EACAC,EACAC,EAAErR,OAAAA,CAINmL,cAAcgG,EAAYC,GACxB,OAAOF,EAAOI,aAAaH,EAAOC,GAAAA,IAAc3O,KAAK4I,UAAAA,CAGvDF,oBACEgG,EACAC,EACA3N,GAEA,MAAM4N,EAAI,IAAInC,aAAakC,EAASD,GACpC,IAAInH,EAAUoH,EAASD,EACvB,KAAOnH,KACLqH,EAAErH,GAAWvG,EAAEhB,KAAKwC,MAAM+E,EAAUmH,GAAQnH,EAAUmH,EAAOnH,GAE/D,OAAO,IAAIkH,EAAOC,EAAOC,EAAQC,EAAAA,CAGnClG,iBAAiByD,GACfxL,EAAWwL,GACX,MAAMyC,EAAI,IAAInC,aAAaN,EAAMA,GAEjC,IAAI5E,EAAU4E,GAAOA,EAAM,GAC3B,KAAO5E,GACLA,GAAW4E,EAAM,EACjByC,EAAErH,GAAW,EAEf,OAAO,IAAIkH,EAAOtC,EAAKA,EAAKyC,EAAAA,CAO9BlG,mBAAmByD,EAAU3M,EAAQK,GACnCc,EAAWwL,EAAK3M,EAAGK,GACnBkB,GAAAA,IAAc,GAAKvB,GAAKA,EAAI2M,IAC5BpL,GAAAA,IAAc,GAAKlB,GAAKA,EAAIsM,IAC5B,MAAMyC,EAAI,IAAInC,aAAaN,EAAMA,GAEjC,IAAI5E,EAAU4E,GAAOA,EAAM,GAC3B,KAAO5E,GACLA,GAAW4E,EAAM,EACjByC,EAAErH,GAAW,EAMf,OAJAqH,EAAEpP,EAAI2M,EAAM3M,GAAK,EACjBoP,EAAE/O,EAAIsM,EAAMtM,GAAK,EACjB+O,EAAEpP,EAAI2M,EAAMtM,GAAK,EACjB+O,EAAE/O,EAAIsM,EAAM3M,GAAK,EACV,IAAIiP,EAAOtC,EAAKA,EAAKyC,EAAAA,CAG9BlG,wBAAwBoG,GACtB,GAAI,GAAKA,EAAUvR,OACjB,MAAUc,MAAM,wBAElB,MAAMsQ,EAASG,EAAUvR,OACnBmR,EAAQI,EAAU,GAAGvR,OACrBqR,EAAI,IAAInC,aAAakC,EAASD,GACpCrI,EAAUyI,EAAU,GAAI,EAAGF,EAAG,EAAGF,GACjC,IAAK,IAAIK,EAAW,EAAGA,EAAWJ,EAAQI,IAAY,CACpD,GAAID,EAAUC,GAAUxR,QAAUmR,EAChC,MAAUrQ,MAAM,0CAElBgI,EAAUyI,EAAUC,GAAW,EAAGH,EAAGG,EAAWL,EAAOA,EAAAA,CAEzD,OAAO7T,KAAKmU,IAAIN,EAAOC,EAAQC,EAAAA,CAGjClG,sBAAsBuG,GACpB,OAAOR,EAAOS,iBAAiBD,EAAW5T,KAAKyO,GAAMA,EAAEA,IAAAA,CAGzDpB,sBAAsBgG,EAAYC,GAChC,OAAO,IAAIF,EAAOC,EAAOC,EAAQ,IAAIlC,aAAaiC,EAAQC,GAAAA,CAG5DjG,wBAAwByG,GACtB,GAAI,GAAKA,EAAU5R,OACjB,MAAUc,MAAM,wBAElB,MAAMqQ,EAAQS,EAAU5R,OAClBoR,EAASQ,EAAU,GAAG5R,OACtBqR,EAAI,IAAInC,aAAakC,EAASD,GACpChI,EAAcyI,EAAU,GAAI,EAAG,EAAGP,EAAG,EAAGF,EAAOC,GAC/C,IAAK,IAAIS,EAAW,EAAGA,EAAWV,EAAOU,IAAY,CACnD,GAAID,EAAUC,GAAU7R,QAAUoR,EAChC,MAAUtQ,MAAM,0CAElBqI,EAAcyI,EAAUC,GAAW,EAAG,EAAGR,EAAGQ,EAAUV,EAAOC,EAAAA,CAE/D,OAAO9T,KAAKmU,IAAIN,EAAOC,EAAQC,EAAAA,CAKjClG,kBAAkBS,GAChB,MAAOkG,EAAI9P,GAA0CrE,MAAMoU,QAAQnG,EAAK,IACpE,CAACA,EAAK,GAAIA,EAAK,IACf,CAACA,OAAAA,GACL,GAAI,GAAKkG,EAAG9R,OAAQ,MAAUc,MAAM,4BACpC,OAAI,GAAKgR,EAAG9R,OAAekR,EAAOc,KAAKF,EAAG,GAAI9P,GACvCkP,EAAOc,KACZF,EAAGG,QAAO,CAACtO,EAAGC,IAAMD,EAAE+J,MAAM9J,KAC5B5B,EAAAA,CAYJmJ,cACE1H,EACAyO,EACAC,EAAyB1O,EAAEyO,GAC3BE,EAAkB,MAElB,MAAMC,EAASnB,EAAOoB,eAAeJ,EAAGlS,OAAQmS,EAAInS,QACpD,IAAK,IAAI6R,EAAW,EAAGA,EAAWK,EAAGlS,OAAQ6R,IAAY,CACvDK,EAAGL,IAAaO,EAChB,MAAMhK,EAAK3E,EAAEyO,GACb,IAAK,IAAIV,EAAW,EAAGA,EAAWW,EAAInS,OAAQwR,IAAY,CACxD,MAAMxT,GAASoK,EAAGoJ,GAAYW,EAAIX,IAAaY,EAC/CC,EAAOE,MAAMf,EAAUK,EAAU7T,EAAAA,CAEnCkU,EAAGL,IAAaO,CAAAA,CAElB,OAAOC,CAAAA,CAGTlH,YAA8BpC,EAAQ/G,EAAY+G,EAAI0I,OACpD3O,EAAWoO,EAAQnI,EAAK/G,GACxBqB,EAAO0F,EAAIoI,OAASnP,EAAOmP,OAC3B9N,EAAO0F,EAAIqI,QAAUpP,EAAOoP,QAC5B/N,EAAOrB,GAAU+G,EAAK,iBACtB,MAAMyJ,EAAIzJ,EAAIsI,EACZ/K,EAAItE,EAAOqP,EACb,IAAIpP,EAAIuQ,EAAExS,OACV,KAAOiC,KACLqE,EAAErE,GAAKuQ,EAAEvQ,GAEX,OAAOD,CAAC,CAGAmJ,WAAWgG,EAAYC,EAAaC,GAC5C,OAAO,IAAIH,EAAOC,EAAOC,EAAQC,EAAAA,CAGnClG,OACE,OAAO+F,EAAOc,KAAW1U,KAAK,CAGhC6N,EAAEqG,EAAkBK,GAUlB,OATAzO,EAAWoO,EAAUK,GACrBxO,EACE,GAAKmO,GAAYA,EAAWlU,KAAK8T,OACjC,0BAA4BI,GAE9BnO,EACE,GAAKwO,GAAYA,EAAWvU,KAAK6T,MACjC,0BAA4BU,GAEvBvU,KAAK+T,EAAEG,EAAWlU,KAAK6T,MAAQU,EAAAA,CAGxC1G,MAAMqG,EAAkBK,EAAkBjT,GACxCwE,EAAWoO,EAAUK,GACrBxO,EACE,GAAKmO,GAAYA,EAAWlU,KAAK8T,OACjC,0BAA4BI,GAE9BnO,EACE,GAAKwO,GAAYA,EAAWvU,KAAK6T,MACjC,0BAA4BU,GAE9B3O,EAActE,GACdtB,KAAK+T,EAAEG,EAAWlU,KAAK6T,MAAQU,GAAYjT,CAAAA,CAG7CuM,KAAKkG,GACHhO,EAAO/F,KAAK6T,OAASE,EAAEF,OACvB9N,EAAO/F,KAAK8T,QAAUC,EAAED,QACxB,MAAMnK,EAAI3J,KAAKmU,MACf,IAAIxP,EAAI3E,KAAK+T,EAAErR,OACf,KAAOiC,KAAKgF,EAAEoK,EAAEpP,GAAK3E,KAAK+T,EAAEpP,GAAKoP,EAAEA,EAAEpP,GACrC,OAAOgF,CAAC,CAGVkE,MAAMkG,GACJhO,EAAO/F,KAAK6T,OAASE,EAAEF,OACvB9N,EAAO/F,KAAK8T,QAAUC,EAAED,QACxB,MAAMnK,EAAI3J,KAAKmU,MACf,IAAIxP,EAAI3E,KAAK+T,EAAErR,OACf,KAAOiC,KAAKgF,EAAEoK,EAAEpP,GAAK3E,KAAK+T,EAAEpP,GAAKoP,EAAEA,EAAEpP,GACrC,OAAOgF,CAAC,CAGVkE,UAAUsH,GACRvP,EAAcuP,GACd,MAAMxL,EAAI3J,KAAKmU,MACf,IAAIxP,EAAI3E,KAAK+T,EAAErR,OACf,KAAOiC,KAAKgF,EAAEoK,EAAEpP,GAAK3E,KAAK+T,EAAEpP,GAAKwQ,EACjC,OAAOxL,CAAC,CAGVkE,UAAUsH,GACRvP,EAAcuP,GACd,MAAMxL,EAAI3J,KAAKmU,MACf,IAAIxP,EAAI3E,KAAK+T,EAAErR,OACf,KAAOiC,KAAKgF,EAAEoK,EAAEpP,GAAK3E,KAAK+T,EAAEpP,GAAKwQ,EACjC,OAAOxL,CAAC,CAGVkE,MACE,OAAO,IAAI+F,EACT5T,KAAK6T,MACL7T,KAAK8T,OACL,IAAIlC,aAAa5R,KAAK6T,MAAQ7T,KAAK8T,QAAAA,CAIvCjG,SACE1H,EACAiP,EACAC,GAGAtP,EAAsB,iBADtBI,EAAIA,GAAAA,CAAO8I,GAAMA,EAAEqG,QAAQ,KACX,UAA4BnP,EAAE,IAC9CJ,GAAQqP,GAAYA,EAAS1S,QAAU1C,KAAK6T,OAC5C9N,GAAQsP,GAAYA,EAAS3S,QAAU1C,KAAK8T,QAC5C,MAAMyB,EAAoBlV,MAAMC,KAAKN,KAAK+T,GAAGvT,IAAI2F,GAC3CqP,EAAO/I,EAAkBzM,KAAK8T,QAASI,GAC3CqB,EAAQ3H,MAAMsG,EAAWlU,KAAK6T,OAAQK,EAAW,GAAKlU,KAAK6T,SAEzDuB,GACFI,EAAKC,QAAQpV,MAAMC,KAAK8U,IAEtBC,GACFG,EAAK5U,SAAQ,CAAC8U,EAAKxB,IACjBwB,EAAID,QAAQJ,EAASnB,GAAYkB,EAAW,EAAI,KAAO,MAG3D,MAAMO,EAAYlJ,EAAkBzM,KAAK6T,OAAQU,GAC/CxM,EAAIyN,EAAKhV,KAAKkV,GAAQA,EAAInB,GAAU7R,YAEtC,OAAO8S,EACJhV,KAAI,CAACkV,EAAKxB,IACTwB,EACGlV,KAAI,CAAC6B,EAAGkS,KAGQ,GAAZL,GAAiBkB,GAA0B,GAAZb,GAAiBc,EAC7C7Q,OAAOZ,UAAUgS,OACjBpR,OAAOZ,UAAUiS,UACT5U,KAAKoB,EAAGsT,EAAUpB,MAEjC5T,KAAK,QAETH,KAAK6B,GAAMA,EAAI,OACf1B,KAAK,GAAG,CAGbkN,IAAIqG,GACFpO,EAAWoO,GACXnO,EACE,GAAKmO,GAAYA,EAAWlU,KAAK8T,OACjC,0BAA4BI,GAE9B,MAAMjF,EAAI,IAAI2C,aAAa5R,KAAK6T,OAEhC,OADArI,EAAUxL,KAAK+T,EAAGG,EAAWlU,KAAK6T,MAAO5E,EAAG,EAAGjP,KAAK6T,OAC7C,IAAIpJ,GAAOwE,EAAAA,CAGpBpB,IAAI0G,GACFzO,EAAWyO,GACXxO,EACE,GAAKwO,GAAYA,EAAWvU,KAAK6T,MACjC,0BAA4BU,GAE9B,MAAMtF,EAAI,IAAI2C,aAAa5R,KAAK8T,QAEhC,OADAjI,EAAc7L,KAAK+T,EAAGQ,EAAUvU,KAAK6T,MAAO5E,EAAG,EAAG,EAAGjP,KAAK8T,QACnD,IAAIrJ,GAAOwE,EAAAA,CAGpBpB,MACE,MAAO,CAAEgG,MAAO7T,KAAK6T,MAAOC,OAAQ9T,KAAK8T,OAAAA,CAG3CjG,YACE,OAAO7N,KAAK6T,MAAQ,IAAM7T,KAAK8T,MAAM,CAGvCjG,OAAOkD,GACL,GAAIA,EAAIlR,aAAeG,KAAKH,YAAa,OAAM,EAC/C,GAAIG,KAAK6T,OAAS9C,EAAI8C,OAAS7T,KAAK8T,QAAU/C,EAAI+C,OAAQ,OAAM,EAChE,IAAIpH,EAAU1M,KAAK+T,EAAErR,OACrB,KAAOgK,KACL,GAAI1M,KAAK+T,EAAErH,IAAYqE,EAAIgD,EAAErH,GAAU,OAAM,EAE/C,OAAM,CAAC,CAGTmB,aAAaiI,EAAgBC,EAAoBzQ,GAE/C,GADAE,EAAWoO,EAAQkC,GACf9V,KAAK6T,OAASiC,EAAOjC,OAAS7T,KAAK8T,QAAUgC,EAAOhC,OAAQ,OAAM,EACtE,IAAIpH,EAAU1M,KAAK+T,EAAErR,OACrB,KAAOgK,KACL,GAAIvH,KAAK0B,IAAI7G,KAAK+T,EAAErH,GAAWoJ,EAAO/B,EAAErH,IAAYqJ,EAClD,OAAM,EAEV,OAAM,CAAC,CAGTlI,WACE,IAAInJ,EAAS,EACTgI,EAAU1M,KAAK+T,EAAErR,OACrB,KAAOgK,KACLhI,EAAkB,GAATA,EAAciE,EAAc3I,KAAK+T,EAAErH,IAE9C,OAAOhI,CAAAA,CAITmJ,SACE,IAAInB,EAAU1M,KAAK+T,EAAErR,OACrB,KAAOgK,KACL,IAAK/F,EAAI3G,KAAK+T,EAAErH,IACd,OAAM,EAGV,OAAM,CAAC,CAGTmB,eACE,OACE7N,KAAKgW,YACLhW,KAAKiW,aAAa7F,MAAMpQ,MAAMkW,aAAatC,EAAOuC,UAAUnW,KAAK6T,OAAO,CAK5EhG,kBACE,MAAMgG,EAAQ7T,KAAK6T,MACbC,EAAS9T,KAAK8T,OACdsC,EAAapW,KAAKqW,YAAYzE,cAC9B0E,EAAa7J,EAAkBqH,GAAAA,IAAc,IAAIlC,aAAakC,KAC9DyC,EAAa3C,EAAOuC,UAAUrC,GAAQuC,YAAYzE,cACxD,IAAI4E,EAAkB,EACtB,IAAK,IAAIjC,EAAW,EAAGA,EAAWV,EAAOU,IAAY,CACnDiC,EAAkBjC,EAElB,IAAIkC,EAAc,EAChBC,GAAiB,EACjBC,EAAsB,EACxB,IAAK,IAAIzC,EAAWsC,EAAiBtC,EAAWJ,EAAQI,IAAY,CAClE,MAAMrH,EAAKuJ,EAAWlC,GAAUK,GAChCoC,KAAyB,GAAK9J,GAC1B1H,KAAK0B,IAAIgG,GAAM4J,IACjBA,EAActR,KAAK0B,IAAIgG,GACvB6J,EAAgBxC,EAAAA,CAIpB,GAAI,GAAKuC,IAIT1Q,GAAQ,IAAM2Q,GAEdtL,EAAUgL,EAAYI,EAAiBE,GACvCtL,EAAUkL,EAAYE,EAAiBE,GACvCtL,EAAUmL,EAAYC,EAAiBE,GACvCJ,EAAWE,GAAiBjC,GAAY,EAEpC,EAAIoC,GAEN,IACE,IAAIzC,EAAWsC,EAAkB,EACjCtC,EAAWJ,EACXI,IACA,CACA,MAAM0C,EACJR,EAAWlC,GAAUK,GACrB6B,EAAWI,GAAiBjC,GAC9B+B,EAAWpC,GAAUK,GAAYqC,EAEjC,IAAK,IAAIC,EAAYtC,EAAUsC,EAAYhD,EAAOgD,IAChDT,EAAWlC,GAAU2C,IACnBD,EAAIR,EAAWI,GAAiBK,EAAAA,CAAAA,CAM1C,MAAO,CACLC,EAAGlD,EAAOmD,iBAAiBT,GAC3BU,EAAGpD,EAAOmD,iBAAiBX,GAC3Ba,EAAGrD,EAAOmD,iBAAiBR,GAAAA,CAI/B1I,gCAUE,MAAMqJ,EAAIlX,KAAK0U,OAEf,SAASyC,EAAY7F,EAAU3M,EAAQK,EAAQ+D,EAAWmM,GACxD,MAAMnB,EAAIH,EAAOuC,UAAU7E,GAK3B,OAJAyC,EAAEkB,MAAMtQ,EAAGA,EAAGoE,GACdgL,EAAEkB,MAAMjQ,EAAGA,EAAG+D,GACdgL,EAAEkB,MAAMtQ,EAAGK,EAAGkQ,GACdnB,EAAEkB,MAAMjQ,EAAGL,GAAIuQ,GACRnB,CAAAA,CAGT,IAAIqD,EAAcxD,EAAOuC,UAAUnW,KAAK8T,QACxC,IAAK,IAAIS,EAAW,EAAGA,EAAWvU,KAAK6T,MAAOU,IAE5C,IAAK,IAAIL,EAAWK,EAAW,EAAGL,EAAWlU,KAAK8T,OAAQI,IAAY,CAEpE,MAAMmD,EAAKH,EAAEI,EAAE/C,EAAUA,GACnBgD,EAAKL,EAAEI,EAAEpD,EAAUK,GACzB,GAAU,GAANgD,EACF,SAEF,MAAM5N,EAAIxE,KAAK2K,MAAMuH,EAAIE,GACnBxO,EAAIsO,EAAK1N,EACTuL,EAAIqC,EAAK5N,EAGf,IAAK,IAAI6N,EAAOjD,EAAUiD,EAAOxX,KAAK6T,MAAO2D,IAAQ,CACnD,MAAMC,EAAKP,EAAEI,EAAE/C,EAAUiD,GAAQzO,EAAImO,EAAEI,EAAEpD,EAAUsD,GAAQtC,EACrDwC,EAAKR,EAAEI,EAAEpD,EAAUsD,GAAQzO,EAAImO,EAAEI,EAAE/C,EAAUiD,GAAQtC,EAC3DgC,EAAEjC,MAAMV,EAAUiD,EAAMC,GACxBP,EAAEjC,MAAMf,EAAUsD,EAAME,EAAAA,CAI1BN,EAAcD,EAAYnX,KAAK8T,OAAQS,EAAUL,EAAUnL,EAAGmM,GAAG9E,MAC/DgH,EAAAA,CAMN,MAAO,CAAEO,EAAGP,EAAYnB,aAAciB,EAAAA,EAAAA,CAGxCrJ,gBACE,SAAK7N,KAAKgW,YACNhW,KAAK+T,EAAE/R,MAAMtB,IAAWiG,EAAIjG,KAAWoG,EAAG,EAAGpG,MAEpCV,KAAKqW,YAAYhW,OAEvB2B,MACF0T,GAAoE,GAA3DA,EAAiBkC,QAAQlX,GAAUoG,EAAG,EAAGpG,KAAQgC,UAKlD1C,KAAK6X,YAAYxX,OACjB2B,MACV8V,GAAoE,GAA3DA,EAAiBF,QAAQlX,GAAUoG,EAAG,EAAGpG,KAAQgC,SAAAA,CAI/DmL,WAAWkI,GACT,IAAIpR,EAAI3E,KAAK+T,EAAErR,OACf,KAAOiC,KACL,GAAI,GAAMA,GAAK3E,KAAK6T,MAAQ,KAAOlN,EAAI3G,KAAK+T,EAAEpP,GAAIoR,GAAY,OAAM,EAEtE,OAAM,CAAC,CAGTlI,WAAWkI,GACT,OACE/V,KAAK+X,qBAAqBhC,IAAc/V,KAAKgY,kBAAkBjC,EAAAA,CAcnElI,kBAAkBkI,GAChB,OAAO/V,KAAKgW,YAAchW,KAAKiY,mBAAmBlC,EAAAA,CAGpDlI,mBAAmBkI,EAAoBzQ,GACrC,IAAK,IAAI4O,EAAW,EAAGA,EAAWlU,KAAK8T,OAAQI,IAC7C,IAAK,IAAIK,EAAW,EAAGA,EAAWL,EAAUK,IAC1C,IAAK5N,EAAI3G,KAAK+T,EAAEG,EAAWlU,KAAK6T,MAAQU,GAAWwB,GACjD,OAAM,EAIZ,OAAM,CAAC,CAGTlI,YAAYkI,EAAYzQ,GACtB,IAAKtF,KAAKgW,WAAY,OAAM,EAC5B,IAAK,IAAI9B,EAAW,EAAGA,EAAWlU,KAAK8T,OAAS,EAAGI,IACjD,IAAK,IAAIK,EAAWL,EAAW,EAAGK,EAAWvU,KAAK6T,MAAOU,IAAY,CACnE,MAAMlO,EAAIrG,KAAK+T,EAAEG,EAAWlU,KAAK6T,MAAQU,GACnCjO,EAAItG,KAAK+T,EAAEQ,EAAWvU,KAAK6T,MAAQK,GACzC,IAAKpN,EAAGT,EAAGC,EAAGyP,GACZ,OAAM,CAAC,CAIb,OAAM,CAAC,CAOTlI,kBAAkBvH,GAChBd,EAAWiF,GAAQnE,GACnB,MAAMwQ,EAAEA,EAACE,EAAEA,EAACC,EAAEA,GAAMjX,KAAKkY,kBACnBnR,EAAI+P,EAAEqB,cAAclB,EAAEmB,YAAY9R,IACxC,OAAO0Q,EAAEqB,eAAetR,EAAAA,CAG1B8G,qBAAqBkI,EAAoBzQ,GACvC,IAAKtF,KAAKgW,WAAY,OAAM,EAC5B,IAAK,IAAI9B,EAAW,EAAGA,EAAWlU,KAAK8T,OAAS,EAAGI,IACjD,IAAK,IAAIK,EAAWL,EAAUK,EAAWvU,KAAK6T,MAAOU,IAAY,CAC/D,MAAM1H,EAAK7M,KAAK+T,EAAEG,EAAWlU,KAAK6T,MAAQU,GAC1C,GACEL,GAAYK,GAAYzN,EAAG,EAAG+F,EAAIkJ,IAAcpP,EAAIkG,EAAIkJ,GAExD,OAAM,CAAC,CAIb,OAAM,CAAC,CAGTlI,kBAAkBkI,GAChB,OAAO/V,KAAKgW,YAAchW,KAAKsY,mBAAmBvC,EAAAA,CAGpDlI,mBAAmBkI,EAAoBzQ,GACrC,IAAK,IAAI4O,EAAW,EAAGA,EAAWlU,KAAK8T,OAAS,EAAGI,IACjD,IAAK,IAAIK,EAAWL,EAAW,EAAGK,EAAWvU,KAAK6T,MAAOU,IACvD,IAAK5N,EAAI3G,KAAK+T,EAAEG,EAAWlU,KAAK6T,MAAQU,GAAWwB,GACjD,OAAM,EAIZ,OAAM,CAAC,CAGTlI,eAAexL,GACbgI,EAAchI,GACd0D,EAAO/F,KAAK8T,QAAUzR,EAAEiP,MAAO,0BAC/BvL,EACE/F,KAAKgY,oBACL,6BAA+BhY,KAAKI,YAEtC,MAAM6O,EAAI,IAAI2C,aAAa5R,KAAK6T,OAChC,IAAIK,EAAWlU,KAAK8T,OACpB,KAAOI,KAAY,CACjB,IAAI3I,EAAOlJ,EAAE4M,EAAEiF,GACf,IAAK,IAAIK,EAAWL,EAAW,EAAGK,EAAWvU,KAAK6T,MAAOU,IACvDhJ,GAAQ0D,EAAEsF,GAAYvU,KAAKsX,EAAEpD,EAAUK,GAEzCtF,EAAEiF,GAAY3I,EAAOvL,KAAKsX,EAAEpD,EAAUA,EAAAA,CAExC,OAAO,IAAIzJ,GAAOwE,EAAAA,CAGpBpB,qBAAqBiI,GACnB,MAAM1B,EAAiB/T,MAAMyV,EAAOjC,OACpC,IAAIlP,EAAImR,EAAOjC,MACf,KAAOlP,KACLyP,EAAWzP,GAAK3E,KAAKqY,eAAevC,EAAOgC,IAAInT,IAEjD,OAAOiP,EAAO2E,eAAenE,EAAAA,CAG/BvG,oBAAoBiI,GAClB,MAAM1B,EAAiB/T,MAAMyV,EAAOjC,OACpC,IAAIlP,EAAImR,EAAOjC,MACf,KAAOlP,KACLyP,EAAWzP,GAAK3E,KAAKmY,cAAcrC,EAAOgC,IAAInT,IAEhD,OAAOiP,EAAO2E,eAAenE,EAAAA,CAG/BvG,cAAcxL,GACZgI,EAAchI,GACd0D,EAAO/F,KAAK8T,QAAUzR,EAAEiP,MAAO,0BAC/BpL,GAAAA,IAAclG,KAAKwY,qBAAqBxY,KAAKI,YAC7C,MAAM6O,EAAI,IAAI2C,aAAa5R,KAAK6T,OAChC,IAAK,IAAIK,EAAW,EAAGA,EAAWlU,KAAK8T,OAAQI,IAAY,CACzD,IAAI3I,EAAOlJ,EAAE4M,EAAEiF,GACf,IAAK,IAAIK,EAAW,EAAGA,EAAWL,EAAUK,IAC1ChJ,GAAQ0D,EAAEsF,GAAYvU,KAAKsX,EAAEpD,EAAUK,GAEzCtF,EAAEiF,GAAY3I,EAAOvL,KAAKsX,EAAEpD,EAAUA,EAAAA,CAExC,OAAO,IAAIzJ,GAAOwE,EAAAA,CAQpBpB,OACE,MAAMmJ,EAAIhX,KAAKkY,kBAAkBlB,EACjC,IAAI9C,EAAWlU,KAAK8T,OAChB2E,EAAOzY,KAAK8T,OAChB,KAAOI,KACLuE,IAASzB,EAAEtB,IAAIxB,GAAUwE,SAE3B,OAAOD,CAAAA,CAGT5K,kBACE,OAAO7N,KAAK8T,QAAU9T,KAAKyY,MAAM,CAGnC5K,kBACE,OAAO7N,KAAK6T,OAAS7T,KAAKyY,MAAM,CAGlC5K,YACE8K,EAA2C/G,cAE3C,OAAOnF,EAAkBzM,KAAK8T,QAASI,GACrClU,KAAK4Y,SAAS1E,EAAUyE,IAAAA,CAI5B9K,YACE8K,EAA2C/G,cAE3C,OAAOnF,EAAkBzM,KAAK6T,OAAQU,GACpCvU,KAAK6Y,SAAStE,EAAUoE,IAAAA,CAI5B9K,SACEqG,EACAyE,EAA2C/G,cAE3C,MAAMlN,EAAS,IAAIiU,EAAiB3Y,KAAK6T,OACzC,OAAOrI,EAAUxL,KAAK+T,EAAGG,EAAWlU,KAAK6T,MAAOnP,EAAQ,EAAG1E,KAAK6T,MAAM,CAGxEhG,SACE0G,EACAoE,EAA2C/G,cAE3C,MAAMlN,EAAS,IAAIiU,EAAiB3Y,KAAK6T,OAEzC,OADAhI,EAAc7L,KAAK+T,EAAGQ,EAAUvU,KAAK8T,OAAQpP,EAAQ,EAAG,EAAG1E,KAAK8T,QACzDpP,CAAAA,CAGTmJ,UACEiL,EACAC,EACAC,EACAC,GAEAlT,EACE,EAAI+S,GAAiB,EAAIC,GAAY,EAAIC,GAAiB,EAAIC,GAEhElT,EACE+S,EAAgBC,GAAY/Y,KAAK6T,OAC/BmF,EAAgBC,GAAajZ,KAAK8T,QAEtC,MAAMC,EAAI,IAAInC,aAAamH,EAAWE,GAWtC,OHrrB0CnN,SAmB5CL,EACAC,EACAI,EACAH,EACAC,EACAG,EACAI,EACA+M,GAEA,IAAK,IAAIvU,EAAI,EAAGA,EAAIuU,EAAYvU,IAC9B6G,EAAUC,EAAKC,EAASI,EAAQnH,EAAGgH,EGmpBjC,EHnpB+CI,EAAQpH,EAAGwH,EAAAA,CG8oB5DgN,CACEnZ,KAAK+T,EACL+E,EACA9Y,KAAK6T,MACLE,EACA,EACAgF,EACAE,EACAF,GAEK,IAAInF,EAAOmF,EAAUE,EAAWlF,EAAAA,CAGzClG,IACEuL,GAEA,OAAO,IAAIxF,EAAO5T,KAAK6T,MAAO7T,KAAK8T,OAAQ9T,KAAK+T,EAAEvT,IAAI4Y,GAAAA,CAGxDvL,UAAUiI,GAER,OADAtQ,EAAWoO,EAAQkC,GACZ9V,KAAK6T,OAASiC,EAAOjC,OAAS7T,KAAK8T,QAAUgC,EAAOhC,MAAM,CAGnEjG,WACE,GAAI7N,KAAKgW,WAAY,CACnB,GAAI,GAAKhW,KAAK6T,MAAO,OAAO7T,KAAKqZ,YACjC,GAAI,GAAKrZ,KAAK6T,MAAO,OAAO7T,KAAKsZ,YACjC,GAAI,GAAKtZ,KAAK6T,MAAO,OAAO7T,KAAKuZ,WAAW,CAE9C,MAAMzC,EAAEA,EAACE,EAAEA,EAACC,EAAEA,GAAMjX,KAAKkY,kBACnBnR,EAAI+P,EAAE0C,oBAAoBvC,GAChC,OAAOD,EAAEyC,qBAAqB1S,EAAAA,CAGhC8G,YACE3H,GAAAA,IAAc,GAAKlG,KAAK6T,OAAS,GAAK7T,KAAK8T,SAC3C,MAAMpP,EAASkP,EAAOoB,eAAe,EAAG,GACtCjB,EAAI/T,KAAK+T,EACTpK,EAAIjF,EAAOqP,EAEP2F,EAAM3F,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKpK,EAAE,GAQnC,OANAA,EAAE,GAAKoK,EAAE,GAAK2F,EACd/P,EAAE,IAAMoK,EAAE,GAAK2F,EAEf/P,EAAE,IAAMoK,EAAE,GAAK2F,EACf/P,EAAE,GAAKoK,EAAE,GAAK2F,EAEPhV,CAAAA,CAGTmJ,UAAUnJ,EAASkP,EAAOoB,eAAe,EAAG,IAC1CxP,EAAWoO,EAAQlP,GACnBwB,GAAAA,IAAc,GAAKlG,KAAK6T,OAAS,GAAK7T,KAAK8T,SAC3C5N,GAAAA,IAAc,GAAKxB,EAAOmP,OAAS,GAAKnP,EAAOoP,SAC/C/N,GAAAA,IAAa/F,MAAQ0E,IACrB,MAAMqP,EAAI/T,KAAK+T,EACbpK,EAAIjF,EAAOqP,EAEbpK,EAAE,GAAKoK,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAC9BpK,EAAE,IAAMoK,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAC/BpK,EAAE,GAAKoK,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAE9BpK,EAAE,IAAMoK,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAC/BpK,EAAE,GAAKoK,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAC9BpK,EAAE,IAAMoK,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAE/BpK,EAAE,GAAKoK,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAC9BpK,EAAE,IAAMoK,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAC/BpK,EAAE,GAAKoK,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAE9B,MAAM2F,EAAM3F,EAAE,GAAKpK,EAAE,GAAKoK,EAAE,GAAKpK,EAAE,GAAKoK,EAAE,GAAKpK,EAAE,GACjD,IAAIhF,EAAI,EACR,KAAOA,KACLgF,EAAEhF,IAAM+U,EAGV,OAAOhV,CAAAA,CAITmJ,UAAUnJ,EAAiBkP,EAAOoB,eAAe,EAAG,IAClDxP,EAAWoO,EAAQlP,GACnBwB,GAAAA,IAAc,GAAKlG,KAAK6T,OAAS,GAAK7T,KAAK8T,SAC3C5N,GAAAA,IAAc,GAAKxB,EAAOmP,OAAS,GAAKnP,EAAOoP,SAC/C/N,GAAAA,IAAa/F,MAAQ0E,IACrB,MAAMqP,EAAI/T,KAAK+T,EACbpK,EAAIjF,EAAOqP,EAKbpK,EAAE,GAAKoK,EAAE,GAAKA,EAAE,IAAMA,EAAE,IAAMA,EAAE,GAAKA,EAAE,IAAMA,EAAE,IAAMA,EAAE,GAAKA,EAAE,GAAKA,EAAE,IACjEA,EAAE,GAAKA,EAAE,IAAMA,EAAE,IAAMA,EAAE,GAAKA,EAAE,GAAKA,EAAE,IAAMA,EAAE,GAAKA,EAAE,IAAMA,EAAE,IAClEpK,EAAE,IAAMoK,EAAE,GAAKA,EAAE,IAAMA,EAAE,IAAMA,EAAE,GAAKA,EAAE,IAAMA,EAAE,IAAMA,EAAE,GAAKA,EAAE,GAAKA,EAAE,IAClEA,EAAE,GAAKA,EAAE,IAAMA,EAAE,IAAMA,EAAE,GAAKA,EAAE,GAAKA,EAAE,IAAMA,EAAE,GAAKA,EAAE,IAAMA,EAAE,IAClEpK,EAAE,GAAKoK,EAAE,GAAKA,EAAE,GAAKA,EAAE,IAAMA,EAAE,GAAKA,EAAE,IAAMA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,IAC/DA,EAAE,GAAKA,EAAE,IAAMA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,IAAMA,EAAE,GAAKA,EAAE,IAAMA,EAAE,GACjEpK,EAAE,IAAMoK,EAAE,GAAKA,EAAE,GAAKA,EAAE,IAAMA,EAAE,GAAKA,EAAE,IAAMA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,IAChEA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,IAAMA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAG/DpK,EAAE,IAAMoK,EAAE,GAAKA,EAAE,IAAMA,EAAE,IAAMA,EAAE,GAAKA,EAAE,IAAMA,EAAE,IAAMA,EAAE,GAAKA,EAAE,GAAKA,EAAE,IAClEA,EAAE,GAAKA,EAAE,IAAMA,EAAE,IAAMA,EAAE,GAAKA,EAAE,GAAKA,EAAE,IAAMA,EAAE,GAAKA,EAAE,IAAMA,EAAE,IAClEpK,EAAE,GAAKoK,EAAE,GAAKA,EAAE,IAAMA,EAAE,IAAMA,EAAE,GAAKA,EAAE,IAAMA,EAAE,IAAMA,EAAE,GAAKA,EAAE,GAAKA,EAAE,IACjEA,EAAE,GAAKA,EAAE,IAAMA,EAAE,IAAMA,EAAE,GAAKA,EAAE,GAAKA,EAAE,IAAMA,EAAE,GAAKA,EAAE,IAAMA,EAAE,IAClEpK,EAAE,IAAMoK,EAAE,GAAKA,EAAE,GAAKA,EAAE,IAAMA,EAAE,GAAKA,EAAE,IAAMA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,IAChEA,EAAE,GAAKA,EAAE,IAAMA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,IAAMA,EAAE,GAAKA,EAAE,IAAMA,EAAE,GACjEpK,EAAE,GAAKoK,EAAE,GAAKA,EAAE,GAAKA,EAAE,IAAMA,EAAE,GAAKA,EAAE,IAAMA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,IAC/DA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,IAAMA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAG/DpK,EAAE,GAAKoK,EAAE,GAAKA,EAAE,GAAKA,EAAE,IAAMA,EAAE,GAAKA,EAAE,IAAMA,EAAE,IAAMA,EAAE,GAAKA,EAAE,GAAKA,EAAE,IAChEA,EAAE,GAAKA,EAAE,IAAMA,EAAE,IAAMA,EAAE,GAAKA,EAAE,GAAKA,EAAE,IAAMA,EAAE,GAAKA,EAAE,IAAMA,EAAE,GAClEpK,EAAE,IAAMoK,EAAE,GAAKA,EAAE,GAAKA,EAAE,IAAMA,EAAE,GAAKA,EAAE,IAAMA,EAAE,IAAMA,EAAE,GAAKA,EAAE,GAAKA,EAAE,IACjEA,EAAE,GAAKA,EAAE,IAAMA,EAAE,IAAMA,EAAE,GAAKA,EAAE,GAAKA,EAAE,IAAMA,EAAE,GAAKA,EAAE,IAAMA,EAAE,GAClEpK,EAAE,IAAMoK,EAAE,GAAKA,EAAE,GAAKA,EAAE,IAAMA,EAAE,GAAKA,EAAE,IAAMA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,IAChEA,EAAE,GAAKA,EAAE,IAAMA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,IAAMA,EAAE,GAAKA,EAAE,IAAMA,EAAE,GACjEpK,EAAE,KAAOoK,EAAE,GAAKA,EAAE,GAAKA,EAAE,IAAMA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,IAChEA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAG9DpK,EAAE,KAAOoK,EAAE,GAAKA,EAAE,GAAKA,EAAE,IAAMA,EAAE,GAAKA,EAAE,IAAMA,EAAE,IAAMA,EAAE,GAAKA,EAAE,GAAKA,EAAE,IAClEA,EAAE,GAAKA,EAAE,IAAMA,EAAE,IAAMA,EAAE,GAAKA,EAAE,GAAKA,EAAE,IAAMA,EAAE,GAAKA,EAAE,IAAMA,EAAE,GAClEpK,EAAE,IAAMoK,EAAE,GAAKA,EAAE,GAAKA,EAAE,IAAMA,EAAE,GAAKA,EAAE,IAAMA,EAAE,IAAMA,EAAE,GAAKA,EAAE,GAAKA,EAAE,IACjEA,EAAE,GAAKA,EAAE,IAAMA,EAAE,IAAMA,EAAE,GAAKA,EAAE,GAAKA,EAAE,IAAMA,EAAE,GAAKA,EAAE,IAAMA,EAAE,GAClEpK,EAAE,KAAOoK,EAAE,GAAKA,EAAE,GAAKA,EAAE,IAAMA,EAAE,GAAKA,EAAE,IAAMA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,IACjEA,EAAE,GAAKA,EAAE,IAAMA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,IAAMA,EAAE,GAAKA,EAAE,IAAMA,EAAE,GACjEpK,EAAE,IAAMoK,EAAE,GAAKA,EAAE,GAAKA,EAAE,IAAMA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,IAC/DA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAI9D,MAAM2F,EAAM3F,EAAE,GAAKpK,EAAE,GAAKoK,EAAE,GAAKpK,EAAE,GAAKoK,EAAE,GAAKpK,EAAE,GAAKoK,EAAE,GAAKpK,EAAE,IAE/D,IAAIhF,EAAI,GACR,KAAOA,KACLgF,EAAEhF,IAAM+U,EAEV,OAAOhV,CAAAA,CAGTmJ,YAAYiI,GAEV,OADAtQ,EAAWoO,EAAQkC,GACZ9V,KAAK6T,OAASiC,EAAOhC,MAAM,CAGpCjG,MAAMiI,GACJtQ,EAAWoO,EAAQkC,GACnB/P,EACE/F,KAAK2Z,YAAY7D,GACjB,wBAAwB9V,KAAK4Z,yBAAyB9D,EAAO8D,eAE/D,MAAMC,EAAS/D,EAAOjC,MACpBiG,EAAU9Z,KAAK8T,OACfxD,EAAItQ,KAAK6T,MACLkG,EAAK,IAAInI,aAAaiI,EAASC,GACrC,IAAIE,EAAYF,EAChB,KAAOE,KAAa,CAClB,IAAIC,EAAYJ,EAChB,KAAOI,KAAa,CAClB,IAAIvV,EAAS,EACTC,EAAI2L,EACR,KAAO3L,KACLD,GAAU1E,KAAK+T,EAAEiG,EAAY1J,EAAI3L,GAAKmR,EAAO/B,EAAEpP,EAAIkV,EAASI,GAE9DF,EAAGC,EAAYH,EAASI,GAAavV,CAAAA,CAAAA,CAGzC,OAAO,IAAIkP,EAAOiG,EAAQC,EAASC,EAAAA,CAGrClM,YAAYoB,GACV5E,EAAc4E,GACdlJ,EAAO/F,KAAK6T,OAAS5E,EAAEqC,OACvB,MAAMwI,EAAU9Z,KAAK8T,OACnBxD,EAAItQ,KAAK6T,MACLkG,EAAK,IAAInI,aAAakI,GAC5B,IAAIE,EAAYF,EAChB,KAAOE,KAAa,CAClB,IAAItV,EAAS,EACTC,EAAI2L,EACR,KAAO3L,KACLD,GAAU1E,KAAK+T,EAAEiG,EAAY1J,EAAI3L,GAAKsK,EAAEA,EAAEtK,GAE5CoV,EAAGC,GAAatV,CAAC,CAEnB,OAAO,IAAI+F,GAAOsP,EAAAA,CAGpBlM,aACE,MAAMqM,EAASla,KAAK8T,OAClBqG,EAAUna,KAAK6T,MACXuG,EAAK,IAAIxI,aAAasI,EAASC,GACrC,IAAIE,EAAYF,EAChB,KAAOE,KAAa,CAClB,IAAIC,EAAYJ,EAChB,KAAOI,KACLF,EAAGC,EAAYH,EAASI,GAAata,KAAK+T,EACxCuG,EAAYH,EAAUE,EAAAA,CAI5B,OAAO,IAAIzG,EAAOsG,EAAQC,EAASC,EAAAA,CAIrCvM,YACE,MAAM0M,EAAIva,KAAK8T,OACb7B,EAAIjS,KAAK6T,MACTuG,EAAKpa,KAAK+T,EACZ,IAAIsG,EAAYE,EAChB,KAAOF,KAAa,CAClB,IAAIC,EAAYnV,KAAK2C,IAAIuS,EAAWpI,GACpC,KAAOqI,KAAa,CAClB,MAAM/O,EAAO6O,EAAGC,EAAYpI,EAAIqI,GAChCF,EAAGC,EAAYpI,EAAIqI,GAAaF,EAAGE,EAAYC,EAAIF,GACnDD,EAAGE,EAAYC,EAAIF,GAAa9O,CAAAA,CAAAA,CAGpCvL,KAAK6T,MAAQ0G,EACbva,KAAK8T,OAAS7B,CAAAA,CAGhBpE,WACE,OAAO7N,KAAK8T,QAAU9T,KAAK6T,KAAK,CAGlChG,WACE,IAAK7N,KAAKgW,WACR,MAAUxS,MAAM,MAElB,MAAMyL,EAAI,IAAI2C,aAAa5R,KAAK6T,OAChC,IAAInH,EAAU1M,KAAK6T,OAAS7T,KAAK6T,MAAQ,GACrC2G,EAASxa,KAAK6T,MAClB,KAAO2G,KACL9N,GAAW1M,KAAK6T,MAAQ,EACxB5E,EAAEuL,GAAUxa,KAAK+T,EAAErH,GAErB,OAAO,IAAIjC,GAAOwE,EAAAA,CAGpBpB,QACE,OAAO9F,EAAI/H,KAAK+T,EAAE,CAGpBlG,QACE,OHvqBsCxC,SAGnBA,GACrB,IAAI1G,EAAI0G,EAAI3I,OACVqF,EAAMoH,IACR,KAAOxK,KAAK,CACV,MAAMrD,EAAM+J,EAAI1G,GACZoD,EAAMzG,IAAKyG,EAAMzG,EAAAA,CAEvB,OAAOyG,CAAAA,CG6pBED,CAAI9H,KAAK+T,EAAE,CAIpBlG,eACE,IAAInJ,EAAS,EACT6P,EAAWvU,KAAK6T,MACpB,KAAOU,KAAY,CACjB,IAAIkG,EAAS,EACTvG,EAAWlU,KAAK8T,OACpB,KAAOI,KACLuG,GAAUtV,KAAK0B,IAAI7G,KAAK+T,EAAEG,EAAWlU,KAAK6T,MAAQU,IAEpD7P,EAASS,KAAK4C,IAAIrD,EAAQ+V,EAAAA,CAE5B,OAAO/V,CAAAA,CAITmJ,eACE,IAAInJ,EAAS,EACTwP,EAAWlU,KAAK8T,OACpB,KAAOI,KAAY,CACjB,IAAIuG,EAAS,EACTlG,EAAWvU,KAAK6T,MACpB,KAAOU,KACLkG,GAAUtV,KAAK0B,IAAI7G,KAAK+T,EAAEG,EAAWlU,KAAK6T,MAAQU,IAEpD7P,EAASS,KAAK4C,IAAIrD,EAAQ+V,EAAAA,CAE5B,OAAO/V,CAAAA,CAGTmJ,2BACE9H,EACE/F,KAAKgY,qBAAuBhY,KAAKwY,oBACjC,2BAGF,IAAIkC,EAAU,EACVhO,EAAU1M,KAAK6T,OAAS7T,KAAK6T,MAAQ,GACzC,KAAOnH,GACLA,GAAW1M,KAAK6T,MAAQ,EACxB6G,GAAW1a,KAAK+T,EAAErH,GAEpB,OAAOgO,CAAAA,CAOT7M,iBAME,OAAO7N,KAAKkY,kBAAkBlB,EAAE2D,0BAA0B,CAG5D9M,cACE,OAAO1I,KAAK2C,IAAI9H,KAAK6T,MAAO7T,KAAK8T,SAAW9T,KAAKyY,MAAM,CAGzD5K,wBACE3H,GAAAA,IAAclG,KAAK4a,kBACnB,MAAMlW,EAAarE,MAAML,KAAK8T,QAC9B,IAAInP,EAAI3E,KAAK8T,OACb,KAAOnP,KAAK,CACV,MAAMkW,EAAmBlW,EAAI3E,KAAK6T,MAClC,IAAIiH,EAAcD,EAClB,KAAO7a,KAAK+T,EAAE+G,GAAe,IAAKA,IAClCpW,EAAOC,GAAKmW,EAAcD,CAAAA,CAE5B,OAAOnW,CAAAA,CAGTmJ,uBACEkN,EAA6C/a,KAAKkY,mBAElD,MAAMpB,EAAEA,EAACE,EAAEA,EAACC,EAAEA,GAAM8D,EAEdC,EAAiB3a,MAAML,KAAK8T,QAClC,IAAImH,EAAYjb,KAAK8T,OACrB,KAAOmH,KACQjE,EAAEtB,IAAIuF,GACVvY,SAAW4C,GAClB0V,EAAWC,IAAAA,EAMf,IAAIC,EAAYlb,KAAK8T,OACrB,KAAOoH,KACL,GAAIF,EAAWE,GAAY,CACzB,IAAIC,EAAYhW,KAAK2C,IAAIoT,EAAWlb,KAAK6T,OACzC,KAAOsH,KACD,IAAMrE,EAAEQ,EAAE4D,EAAWC,KACvBH,EAAWG,IAAAA,EAAa,CAKhC7S,QAAQ2C,IACN,MACAjL,KAAKI,UAAUiC,GAAM,GAAKA,KAE5BiG,QAAQ2C,IACN,MACA6L,EAAE1W,UAAUiC,GAAM,GAAKA,KAEzBiG,QAAQ2C,IACN,MACA+L,EAAE5W,UAAUiC,GAAM,GAAKA,KAEzBiG,QAAQ2C,IACN,MACAgM,EAAE7W,UAAUiC,GAAM,GAAKA,KAGzB,MAAM+Y,EAAWnE,EAAEoE,wBACnB,OAAOL,EACJxa,KAAI,CAAC8F,EAAG7D,IAAU6D,GAAK8U,EAAS3Y,KAChCmV,QAAQvV,GAAWN,MAALM,GAAAA,CAGnBwL,KAAKvH,EAAWC,EAAW7B,EAAS1E,KAAKmU,OACvC3O,EAAWoO,EAAQtN,EAAG5B,GACtBkB,EAAcW,GACdR,EAAO/F,KAAK6T,OAASvN,EAAEuN,OAAS7T,KAAK8T,QAAUxN,EAAEwN,QACjD,MAAMoB,EAAI,EAAI3O,EACd,IAAI5B,EAAI3E,KAAK+T,EAAErR,OACf,KAAOiC,KACLD,EAAOqP,EAAEpP,GAAKuQ,EAAIlV,KAAK+T,EAAEpP,GAAK4B,EAAID,EAAEyN,EAAEpP,GAExC,OAAOD,CAAAA,ECpkCX,SAAQQ,EAAE2B,IAAEA,IAAQ1B,KAAAA,MAGPoN,WAAWqB,EAuDtB/F,eAAeyN,GACb,IAAIvH,EACJ,GAAI,GAAKuH,EAAS5Y,OAChBqR,EAAI,IAAInC,aAAa,QAChB,CACL,MAAM2J,EJiN0BC,SAGNnQ,GAC9B,OAAOhL,MAAMuD,UAAU6X,OAAOlN,MAAM,GAAIlD,EAAAA,CIrNlBqQ,CAAaJ,GAC/BvV,EACsB,IAApBwV,EAAU7Y,OACV,0BAA4B6Y,EAAU7Y,QAExCqR,EAAI,IAAInC,aAAa2J,EAAAA,CAEvBI,MAAM,EAAG,EAAG5H,EAAAA,CASdlG,eAAeiI,EAAYpR,EAAa,IAAI6N,IAC1C,OAAOuD,EAAOyD,UAAU7U,EAAAA,CAO1BmJ,oBAAoBlJ,EAAQK,EAAQN,EAAS,IAAI6N,IAC/CzM,EAAWnB,EAAGK,GACdkB,GAAAA,IAAc,GAAKvB,GAAKA,EAAI,IAC5BuB,GAAAA,IAAc,GAAKlB,GAAKA,EAAI,IAC5B,MAAM+O,EAAIrP,EAAOqP,EAMjB,OALAxB,GAAGqJ,SAASlX,GACZqP,EAAM,EAAJpP,EAAQA,GAAK,EACfoP,EAAM,EAAJ/O,EAAQA,GAAK,EACf+O,EAAM,EAAJpP,EAAQK,GAAK,EACf+O,EAAM,EAAJ/O,EAAQL,GAAK,EACRD,CAAAA,CAOTmJ,iBAAiBiI,EAAYpR,EAAa,IAAI6N,IAC5C/M,EAAW+M,GAAIuD,GACftQ,EAAW+M,GAAI7N,GACfqB,EAAO+P,GAAUpR,EAAQ,oBACzB,MAAMqP,EAAI+B,EAAO/B,EACfpK,EAAIjF,EAAOqP,EAiBb,OAhBApK,EAAE,GAAKoK,EAAE,GACTpK,EAAE,GAAKoK,EAAE,GACTpK,EAAE,GAAKoK,EAAE,GACTpK,EAAE,GAAKoK,EAAE,IACTpK,EAAE,GAAKoK,EAAE,GACTpK,EAAE,GAAKoK,EAAE,GACTpK,EAAE,GAAKoK,EAAE,GACTpK,EAAE,GAAKoK,EAAE,IACTpK,EAAE,GAAKoK,EAAE,GACTpK,EAAE,GAAKoK,EAAE,GACTpK,EAAE,IAAMoK,EAAE,IACVpK,EAAE,IAAMoK,EAAE,IACVpK,EAAE,IAAMoK,EAAE,GACVpK,EAAE,IAAMoK,EAAE,GACVpK,EAAE,IAAMoK,EAAE,IACVpK,EAAE,IAAMoK,EAAE,IACHrP,CAAC,CAIVmJ,gBAAgBgO,EAAUC,EAAWpX,EAAa,IAAI6N,IACpD/M,EAAW+M,GAAIsJ,EAAMC,GACrBtW,EAAW+M,GAAI7N,GACfqB,EAAO8V,GAAQnX,EAAQ,kBACvBqB,EAAO+V,GAASpX,EAAQ,mBACxB,MAAM2B,EAAIwV,EAAK9H,EACbzN,EAAIwV,EAAM/H,EACVpK,EAAIjF,EAAOqP,EAsBb,OApBApK,EAAE,GAAKtD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,IAAMD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,KAC3DqD,EAAE,GAAKtD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,IAAMD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,KAC3DqD,EAAE,GAAKtD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,IAAMD,EAAE,GAAKC,EAAE,IAAMD,EAAE,GAAKC,EAAE,KAC5DqD,EAAE,GAAKtD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,IAAMD,EAAE,GAAKC,EAAE,IAAMD,EAAE,GAAKC,EAAE,KAE5DqD,EAAE,GAAKtD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,IAAMD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,KAC3DqD,EAAE,GAAKtD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,IAAMD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,KAC3DqD,EAAE,GAAKtD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,IAAMD,EAAE,GAAKC,EAAE,IAAMD,EAAE,GAAKC,EAAE,KAC5DqD,EAAE,GAAKtD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,IAAMD,EAAE,GAAKC,EAAE,IAAMD,EAAE,GAAKC,EAAE,KAE5DqD,EAAE,GAAKtD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,IAAMD,EAAE,IAAMC,EAAE,GAAKD,EAAE,IAAMC,EAAE,KAC7DqD,EAAE,GAAKtD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,IAAMD,EAAE,IAAMC,EAAE,GAAKD,EAAE,IAAMC,EAAE,KAC7DqD,EAAE,IAAMtD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,IAAMD,EAAE,IAAMC,EAAE,IAAMD,EAAE,IAAMC,EAAE,KAC/DqD,EAAE,IAAMtD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,IAAMD,EAAE,IAAMC,EAAE,IAAMD,EAAE,IAAMC,EAAE,KAE/DqD,EAAE,IAAMtD,EAAE,IAAMC,EAAE,GAAKD,EAAE,IAAMC,EAAE,IAAMD,EAAE,IAAMC,EAAE,GAAKD,EAAE,IAAMC,EAAE,KAChEqD,EAAE,IAAMtD,EAAE,IAAMC,EAAE,GAAKD,EAAE,IAAMC,EAAE,IAAMD,EAAE,IAAMC,EAAE,GAAKD,EAAE,IAAMC,EAAE,KAChEqD,EAAE,IAAMtD,EAAE,IAAMC,EAAE,GAAKD,EAAE,IAAMC,EAAE,IAAMD,EAAE,IAAMC,EAAE,IAAMD,EAAE,IAAMC,EAAE,KACjEqD,EAAE,IAAMtD,EAAE,IAAMC,EAAE,GAAKD,EAAE,IAAMC,EAAE,IAAMD,EAAE,IAAMC,EAAE,IAAMD,EAAE,IAAMC,EAAE,KAE1D5B,CAAAA,CAKTmJ,kBAAkBS,GAChB,MAAOyN,EAAKrX,GAAsBrE,MAAMoU,QAAQnG,EAAK,IACjD,CAACA,EAAK,GAAIA,EAAK,IACf,CAACA,EAAM,IAAIiE,IACf,GAAI,GAAKwJ,EAAIrZ,OAAQ,OAAO6P,GAAGqJ,SAASlX,GACxC,GAAI,GAAKqX,EAAIrZ,OAAQ,OAAO6P,GAAGmC,KAAKqH,EAAI,GAAIrX,GAC5C,GAAI,GAAKqX,EAAIrZ,OAAQ,OAAO6P,GAAGyJ,SAASD,EAAI,GAAIA,EAAI,GAAIrX,GACxD,IAAI2B,EAAIkM,GAAG0J,MACT3V,EAAIiM,GAAG2J,MACT3J,GAAGyJ,SAASD,EAAI,GAAIA,EAAI,GAAI1V,GAC5B,IAAK,IAAI1B,EAAI,EAAGA,EAAIoX,EAAIrZ,OAAS,EAAGiC,IAClC4N,GAAGyJ,SAAS3V,EAAG0V,EAAIpX,GAAI2B,IACrBD,EAAGC,GAAK,CAACA,EAAGD,GAEhB,OAAOkM,GAAGyJ,SAAS3V,EJoTb,SAGiBgF,GACzB,OAAOA,EAAIA,EAAI3I,OAAS,EAAE,CIxTFyZ,CAAQJ,GAAMrX,EAAAA,CAGtCmJ,cAAcuO,EAAQC,EAAQC,EAASF,EAAG3N,MAAM4N,GAAKE,EAAa/R,EAAGsG,GAGnE,OAFAzG,EAAc+R,EAAIC,EAAIC,EAAIC,GAEnB,IAAIhK,GACT6J,EAAG/Z,EAAGga,EAAGha,EAAGia,EAAGja,EAAGka,EAAOla,EACzB+Z,EAAGrV,EAAGsV,EAAGtV,EAAGuV,EAAGvV,EAAGwV,EAAOxV,EACzBqV,EAAGtO,EAAGuO,EAAGvO,EAAGwO,EAAGxO,EAAGyO,EAAOzO,EACzB,EAAG,EAAG,EAAG,GAIbD,eAAe2O,EAAQC,EAAQC,EAAQC,EAASnS,EAAGsG,GAGjD,OAFAzG,EAAcmS,EAAIC,EAAIC,EAAIC,GAEnB,IAAIpK,GACTiK,EAAGna,EAAGma,EAAGzV,EAAGyV,EAAG1O,EAAG,EAClB2O,EAAGpa,EAAGoa,EAAG1V,EAAG0V,EAAG3O,EAAG,EAClB4O,EAAGra,EAAGqa,EAAG3V,EAAG2V,EAAG5O,EAAG,EAClB6O,EAAGta,EAAGsa,EAAG5V,EAAG4V,EAAG7O,EAAG,EAAE,CAUxBD,gBAAgBnJ,EAAa,IAAI6N,IAC/B/M,EAAW+M,GAAI7N,GACf,MAAMqP,EAAIrP,EAAOqP,EAIjB,OAHAA,EAAE,GAAKA,EAAE,GAAKA,EAAE,IAAMA,EAAE,IAAM,EAC9BA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,IAAMA,EAAE,IAAMA,EAAE,IAAMA,EAAE,IAAM,EAEjFrP,CAAAA,CAUTmJ,qBACE1H,EACAzB,EAAa,IAAI6N,IAEjBxM,EAAmB,mBAALI,GACdX,EAAW+M,GAAI7N,GACf,MAAMqP,EAAIrP,EAAOqP,EACjB,IAAIpP,EAAI,GACR,KAAOA,KACLoP,EAAEpP,GAAKwB,EAAEhB,KAAKwC,MAAMhD,EAAI,GAAIA,EAAI,EAAGA,GAErC,OAAOD,CAAC,CAiBVmJ,mBACE+O,EACAC,EACAC,EACAC,EACArY,EAAa,IAAI6N,IAEjB,OAAOA,GAAGyK,eAAeJ,EAAahU,EAAKiU,EAAQC,EAAMC,EAAKrY,EAAAA,CAGhEmJ,sBACEoP,EACAJ,EACAC,EACAC,EACArY,EAAa,IAAI6N,IAEjB/M,EAAW+M,GAAI7N,GACfkB,EAAcqX,EAAKJ,EAAQC,EAAMC,GACjC,MAAMhW,EAAI5B,KAAK+X,IAAID,EAAM,GAAKH,EACxBza,EAAI0E,EAAI8V,EACd,OAAOtK,GAAG4K,SAAS9a,EAAGA,GAAI0E,EAAGA,EAAG+V,EAAMC,EAAKrY,EAAAA,CAG7CmJ,wBACEuP,EACA1Y,EAAa,IAAI6N,IAEjB/M,EAAW+M,GAAI7N,GACf,MAAMqP,EAAIrP,EAAOqP,EAqBjB,OApBAA,EAAE,GAAK,EACPA,EAAE,GAAK,EACPA,EAAE,GAAK,EACPA,EAAE,GAAK,EAEPA,EAAE,GAAK,EACPA,EAAE,GAAK,EACPA,EAAE,GAAK,EACPA,EAAE,GAAK,EAEPA,EAAE,GAAK,EACPA,EAAE,GAAK,EACPA,EAAE,IAAM,EACRA,EAAE,IAAM,EAERA,EAAE,IAAMqJ,EAAezM,QAAQtO,EAC/B0R,EAAE,IAAMqJ,EAAezM,QAAQ5J,EAC/BgN,EAAE,IAAMqJ,EAAezM,QAAQ7C,EAC/BiG,EAAE,KAAOqJ,EAAenL,EAEjBvN,CAAC,CAIVmJ,eACEgO,EACAC,EACAuB,EACAC,EACAR,EACAC,EACArY,EAAa,IAAI6N,IAEjB3M,EAAciW,EAAMC,EAAOuB,EAAQC,EAAKR,EAAMC,GAC9ChX,EAAO,EAAI+W,EAAM,YACjB/W,EAAO+W,EAAOC,EAAK,cACnBvX,EAAW+M,GAAI7N,GACf,MAAMqP,EAAIrP,EAAOqP,EAsBjB,OApBAA,EAAE,GAAM,EAAI+I,GAAShB,EAAQD,GAC7B9H,EAAE,GAAK,EACPA,EAAE,IAAM+H,EAAQD,IAASC,EAAQD,GACjC9H,EAAE,GAAK,EAEPA,EAAE,GAAK,EACPA,EAAE,GAAM,EAAI+I,GAASQ,EAAMD,GAC3BtJ,EAAE,IAAMuJ,EAAMD,IAAWC,EAAMD,GAC/BtJ,EAAE,GAAK,EAEPA,EAAE,GAAK,EACPA,EAAE,GAAK,EACPA,EAAE,MAAQgJ,EAAMD,IAASC,EAAMD,GAC/B/I,EAAE,KAAQ,EAAIgJ,EAAMD,GAASC,EAAMD,GAEnC/I,EAAE,IAAM,EACRA,EAAE,IAAM,EACRA,EAAE,KAAO,EACTA,EAAE,IAAM,EAEDrP,CAAAA,CAITmJ,yBACE5E,EACAoJ,EACA3N,EAAa,IAAI6N,IAEjBlI,EAAcpB,EAAGoJ,EAAM1B,SACvBnL,EAAW+M,GAAI7N,GACf,MAAMqP,EAAIrP,EAAOqP,EACXzD,EAAI+B,EAAM1B,QACdsB,EAAII,EAAMJ,EACNsL,EAAKjN,EAAEtC,IAAI/E,GAsBjB,OApBA8K,EAAE,GAAK9K,EAAE5G,EAAIiO,EAAEjO,EAAI4P,EAAIsL,EACvBxJ,EAAE,GAAK9K,EAAE5G,EAAIiO,EAAEvJ,EACfgN,EAAE,GAAK9K,EAAE5G,EAAIiO,EAAExC,EACfiG,EAAE,IAAM9B,EAAIhJ,EAAE5G,EAEd0R,EAAE,GAAK9K,EAAElC,EAAIuJ,EAAEjO,EACf0R,EAAE,GAAK9K,EAAElC,EAAIuJ,EAAEvJ,EAAIkL,EAAIsL,EACvBxJ,EAAE,GAAK9K,EAAElC,EAAIuJ,EAAExC,EACfiG,EAAE,IAAM9B,EAAIhJ,EAAElC,EAEdgN,EAAE,GAAK9K,EAAE6E,EAAIwC,EAAEjO,EACf0R,EAAE,GAAK9K,EAAE6E,EAAIwC,EAAEvJ,EACfgN,EAAE,IAAM9K,EAAE6E,EAAIwC,EAAExC,EAAImE,EAAIsL,EACxBxJ,EAAE,KAAO9B,EAAIhJ,EAAE6E,EAEfiG,EAAE,IAAMzD,EAAEjO,EACV0R,EAAE,IAAMzD,EAAEvJ,EACVgN,EAAE,IAAMzD,EAAExC,EACViG,EAAE,KAAOwJ,EAEF7Y,CAAAA,CAQTmJ,aACEgO,EACAC,EACAuB,EACAC,EACAR,EACAC,EACArY,EAAa,IAAI6N,IAEjB3M,EAAciW,EAAMC,EAAOuB,EAAQC,EAAKR,EAAMC,GAC9CvX,EAAW+M,GAAI7N,GACf,MAAMqP,EAAIrP,EAAOqP,EAsBjB,OApBAA,EAAE,GAAK,GAAK+H,EAAQD,GACpB9H,EAAE,GAAK,EACPA,EAAE,GAAK,EACPA,EAAE,KAAO+H,EAAQD,IAASC,EAAQD,GAElC9H,EAAE,GAAK,EACPA,EAAE,GAAK,GAAKuJ,EAAMD,GAClBtJ,EAAE,GAAK,EACPA,EAAE,KAAOuJ,EAAMD,IAAWC,EAAMD,GAEhCtJ,EAAE,GAAK,EACPA,EAAE,GAAK,EACPA,EAAE,KAAO,GAAKgJ,EAAMD,GACpB/I,EAAE,MAAQgJ,EAAMD,IAASC,EAAMD,GAE/B/I,EAAE,IAAM,EACRA,EAAE,IAAM,EACRA,EAAE,IAAM,EACRA,EAAE,IAAM,EAEDrP,CAAAA,CAaTmJ,gBAAgBS,GACd,IAAIjM,EAAW0E,EAAW+G,EAAWpJ,EACjC4J,EAAK,aAAc9D,GACrBzE,EAAOuI,EAAK5L,QAAU,KAClBL,EAAAA,EAAG0E,EAAAA,EAAG+G,EAAAA,GAAMQ,EAAK,IACrB5J,EAAS4J,EAAK,IACL,iBAAmBA,EAAK,IACjCjM,EAAI0E,EAAI+G,EAAIQ,EAAK,GACjB5J,EAAS4J,EAAK,KAEdvI,EAAOuI,EAAK5L,QAAU,GACtBL,EAAIiM,EAAK,GACTvH,EAAIuH,EAAK,GACTR,EAAI/L,MAAauM,EAAK,GAAKA,EAAK,GAAK,EACrC5J,EAAS4J,EAAK,IAEhBvM,MAAa2C,IAAWA,EAAS,IAAI6N,IACrC/M,EAAW+M,GAAI7N,GACfkB,EAAcvD,EAAG0E,EAAG+G,GAEpB,MAAMiG,EAAIrP,EAAOqP,EAqBjB,OApBAA,EAAE,GAAK1R,EACP0R,EAAE,GAAK,EACPA,EAAE,GAAK,EACPA,EAAE,GAAK,EAEPA,EAAE,GAAK,EACPA,EAAE,GAAKhN,EACPgN,EAAE,GAAK,EACPA,EAAE,GAAK,EAEPA,EAAE,GAAK,EACPA,EAAE,GAAK,EACPA,EAAE,IAAMjG,EACRiG,EAAE,IAAM,EAERA,EAAE,IAAM,EACRA,EAAE,IAAM,EACRA,EAAE,IAAM,EACRA,EAAE,IAAM,EAEDrP,CAAAA,CAWTmJ,oBAAoBS,GAClB,IAAIjM,EAAG0E,EAAG+G,EAAGpJ,EACT4J,EAAK,aAAc9D,GACrBzE,EAAOuI,EAAK5L,QAAU,KAClBL,EAAAA,EAAG0E,EAAAA,EAAG+G,EAAAA,GAAMQ,EAAK,IACrB5J,EAAS4J,EAAK,KAEdvI,EAAOuI,EAAK5L,QAAU,GACtBL,EAAIiM,EAAK,GACTvH,EAAIhF,MAAauM,EAAK,GAAKA,EAAK,GAAK,EACrCR,EAAI/L,MAAauM,EAAK,GAAKA,EAAK,GAAK,EACrC5J,EAAS4J,EAAK,IAEhBvM,MAAa2C,IAAWA,EAAS,IAAI6N,IACrC/M,EAAW+M,GAAI7N,GACfkB,EAAcvD,EAAG0E,EAAG+G,GAEpB,MAAMiG,EAAIrP,EAAOqP,EAsBjB,OApBAA,EAAE,GAAK,EACPA,EAAE,GAAK,EACPA,EAAE,GAAK,EACPA,EAAE,GAAK1R,EAEP0R,EAAE,GAAK,EACPA,EAAE,GAAK,EACPA,EAAE,GAAK,EACPA,EAAE,GAAKhN,EAEPgN,EAAE,GAAK,EACPA,EAAE,GAAK,EACPA,EAAE,IAAM,EACRA,EAAE,IAAMjG,EAERiG,EAAE,IAAM,EACRA,EAAE,IAAM,EACRA,EAAE,IAAM,EACRA,EAAE,IAAM,EAEDrP,CAAAA,CASTmJ,cACE+E,EACA3D,EACAvK,GAEA3C,MAAa2C,IAAWA,EAAS,IAAI6N,IACrC/M,EAAW+M,GAAI7N,GACf,IAAIrC,EAAEA,EAAC0E,EAAEA,EAAC+G,EAAEA,GAAMmB,EAClBlJ,GAAQ,IAAIyE,EAAGnI,EAAG0E,EAAG+G,GAAG2C,QAAS,uBACjC,MAAMsD,EAAIrP,EAAOqP,EAEX/K,EAAI7D,KAAKiE,KAAK/G,EAAIA,EAAI0E,EAAIA,EAAI+G,EAAIA,GACxCzL,GAAK2G,EACLjC,GAAKiC,EACL8E,GAAK9E,EACL,MAAMgB,EAAM7E,KAAK6E,IAAI4I,GACnBzE,EAAMhJ,KAAKgJ,IAAIyE,GACfrM,EAAI,EAAIyD,EAsBV,OApBA+J,EAAE,GAAK1R,EAAIA,EAAIkE,EAAIyD,EACnB+J,EAAE,GAAK1R,EAAI0E,EAAIR,EAAIuH,EAAIK,EACvB4F,EAAE,GAAK1R,EAAIyL,EAAIvH,EAAIQ,EAAIoH,EACvB4F,EAAE,GAAK,EAEPA,EAAE,GAAKhN,EAAI1E,EAAIkE,EAAIuH,EAAIK,EACvB4F,EAAE,GAAKhN,EAAIA,EAAIR,EAAIyD,EACnB+J,EAAE,GAAKhN,EAAI+G,EAAIvH,EAAIlE,EAAI8L,EACvB4F,EAAE,GAAK,EAEPA,EAAE,GAAKjG,EAAIzL,EAAIkE,EAAIQ,EAAIoH,EACvB4F,EAAE,GAAKjG,EAAI/G,EAAIR,EAAIlE,EAAI8L,EACvB4F,EAAE,IAAMjG,EAAIA,EAAIvH,EAAIyD,EACpB+J,EAAE,IAAM,EAERA,EAAE,IAAM,EACRA,EAAE,IAAM,EACRA,EAAE,IAAM,EACRA,EAAE,IAAM,EAEDrP,CAAAA,CASTmJ,cAAc2P,EAASC,EAAWC,EAAQhZ,EAAa,IAAI6N,IACzDlI,EAAcmT,EAAKC,EAAOC,GAC1BlY,EAAW+M,GAAI7N,GAEf,MAAMqP,EAAIrP,EAAOqP,EAEX5N,EAAIqX,EAAI5N,MAAM6N,GAAOE,OACrBzI,EAAIwI,EAAGjP,MAAMtI,GAAGwX,OAChBpX,EAAIJ,EAAEsI,MAAMyG,GAAGyI,OAsBrB,OApBA5J,EAAE,GAAKmB,EAAE7S,EACT0R,EAAE,GAAKmB,EAAEnO,EACTgN,EAAE,GAAKmB,EAAEpH,EACTiG,EAAE,IAAMmB,EAAElH,IAAIwP,GAEdzJ,EAAE,GAAKxN,EAAElE,EACT0R,EAAE,GAAKxN,EAAEQ,EACTgN,EAAE,GAAKxN,EAAEuH,EACTiG,EAAE,IAAMxN,EAAEyH,IAAIwP,GAEdzJ,EAAE,GAAK5N,EAAE9D,EACT0R,EAAE,GAAK5N,EAAEY,EACTgN,EAAE,IAAM5N,EAAE2H,EACViG,EAAE,KAAO5N,EAAE6H,IAAIwP,GAEfzJ,EAAE,IAAM,EACRA,EAAE,IAAM,EACRA,EAAE,IAAM,EACRA,EAAE,IAAM,EAEDrP,CAAAA,CAITmJ,eAAe+E,GACbhN,EAAcgN,GACd,MAAMzE,EAAMhJ,KAAKgJ,IAAIyE,GACnB5I,EAAM7E,KAAK6E,IAAI4I,GAEjB,OAAO,IAAIL,GADC,CAAC,EAAG,EAAG,EAAG,EAAG,EAAGvI,GAAMmE,EAAK,EAAG,EAAGA,EAAKnE,EAAK,EAAG,EAAG,EAAG,EAAG,IAKrE6D,eAAe+E,GACb,MAAMzE,EAAMhJ,KAAKgJ,IAAIyE,GACnB5I,EAAM7E,KAAK6E,IAAI4I,GAEjB,OAAO,IAAIL,GADC,CAACvI,EAAK,EAAGmE,EAAK,EAAG,EAAG,EAAG,EAAG,GAAIA,EAAK,EAAGnE,EAAK,EAAG,EAAG,EAAG,EAAG,IAKrE6D,eAAe+E,GACb,MAAMzE,EAAMhJ,KAAKgJ,IAAIyE,GACnB5I,EAAM7E,KAAK6E,IAAI4I,GAEjB,OAAO,IAAIL,GADC,CAACvI,GAAMmE,EAAK,EAAG,EAAGA,EAAKnE,EAAK,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAQrE6D,gBAAgBxH,EAAOC,EAAO5B,EAAa,IAAI6N,IAE7ClI,EAAchE,EAAGC,GACjBd,EAAW+M,GAAI7N,GACf,MAAMuO,EAAe5M,EAAEoI,MAAMnI,GAC3BsX,EAAqB3K,EAAavQ,SACpC,GAAIiE,EAAIiX,GACN,OAAOrL,GAAGqJ,SAASlX,GAErB,MAAMkO,EAAUzN,KAAKoL,MAAMqN,EAAoBvX,EAAE2H,IAAI1H,IACrD,OAAOiM,GAAGW,WAAW1I,EAAGsG,EAAGmC,EAAcL,EAASlO,EAAAA,CAOpDmJ,kBACEgQ,EACA5K,EACAL,EACAlO,EAAa,IAAI6N,IAGjBlI,EAAcwT,EAAgB5K,GAC9BrN,EAAcgN,GACdpN,EAAW+M,GAAI7N,GACfuO,EAAeA,EAAa0K,OAE5B,MAAMG,EAAKD,EAAexb,EACxB0b,EAAKF,EAAe9W,EACpBiX,EAAKH,EAAe/P,EACpBmQ,EAAKhL,EAAa5Q,EAClB6b,EAAKjL,EAAalM,EAClBoX,EAAKlL,EAAanF,EACdiG,EAAIrP,EAAOqP,EACf/J,EAAM7E,KAAK6E,IAAI4I,GACfzE,EAAMhJ,KAAKgJ,IAAIyE,GA4BjB,OA1BAmB,EAAE,GAAKkK,EAAKA,GAAMC,EAAKA,EAAKC,EAAKA,GAAMnU,EACvC+J,EAAE,GAAKkK,EAAKC,GAAM,EAAIlU,GAAOmU,EAAKhQ,EAClC4F,EAAE,GAAKkK,EAAKE,GAAM,EAAInU,GAAOkU,EAAK/P,EAClC4F,EAAE,IACC+J,GAAMI,EAAKA,EAAKC,EAAKA,GAAMF,GAAMF,EAAKG,EAAKF,EAAKG,KAAQ,EAAInU,IAC5D+T,EAAKI,EAAKH,EAAKE,GAAM/P,EAExB4F,EAAE,GAAKkK,EAAKC,GAAM,EAAIlU,GAAOmU,EAAKhQ,EAClC4F,EAAE,GAAKmK,EAAKA,GAAMD,EAAKA,EAAKE,EAAKA,GAAMnU,EACvC+J,EAAE,GAAKmK,EAAKC,GAAM,EAAInU,GAAOiU,EAAK9P,EAClC4F,EAAE,IACCgK,GAAME,EAAKA,EAAKE,EAAKA,GAAMD,GAAMJ,EAAKG,EAAKD,EAAKG,KAAQ,EAAInU,IAC5DgU,EAAKC,EAAKH,EAAKK,GAAMhQ,EAExB4F,EAAE,GAAKkK,EAAKE,GAAM,EAAInU,GAAOkU,EAAK/P,EAClC4F,EAAE,GAAKmK,EAAKC,GAAM,EAAInU,GAAOiU,EAAK9P,EAClC4F,EAAE,IAAMoK,EAAKA,GAAMF,EAAKA,EAAKC,EAAKA,GAAMlU,EACxC+J,EAAE,KACCiK,GAAMC,EAAKA,EAAKC,EAAKA,GAAMC,GAAML,EAAKG,EAAKF,EAAKG,KAAQ,EAAIlU,IAC5D8T,EAAKI,EAAKH,EAAKE,GAAM9P,EAExB4F,EAAE,IAAM,EACRA,EAAE,IAAM,EACRA,EAAE,IAAM,EACRA,EAAE,IAAM,EAEDrP,CAAAA,CAITmJ,cAAcwE,EAAmC3N,EAAa,IAAI6N,IAChElI,EAAcgI,EAAM1B,SACpBnL,EAAW+M,GAAI7N,GACf,MAAO0Z,EAAIC,EAAIC,GAAMjM,EAAM1B,QACrBsB,EAAII,EAAMJ,EACV8B,EAAIrP,EAAOqP,EAqBjB,OAnBAA,EAAE,GAAK,EAAM,EAAMqK,EAAKA,EACxBrK,EAAE,IAAM,EAAMsK,EAAKD,EACnBrK,EAAE,IAAM,EAAMuK,EAAKF,EACnBrK,EAAE,GAAK,EAAMqK,EAAKnM,EAElB8B,EAAE,IAAM,EAAMqK,EAAKC,EACnBtK,EAAE,GAAK,EAAM,EAAMsK,EAAKA,EACxBtK,EAAE,IAAM,EAAMuK,EAAKD,EACnBtK,EAAE,GAAK,EAAMsK,EAAKpM,EAElB8B,EAAE,IAAM,EAAMqK,EAAKE,EACnBvK,EAAE,IAAM,EAAMsK,EAAKC,EACnBvK,EAAE,IAAM,EAAM,EAAMuK,EAAKA,EACzBvK,EAAE,IAAM,EAAMuK,EAAKrM,EAEnB8B,EAAE,IAAM,EACRA,EAAE,IAAM,EACRA,EAAE,IAAM,EACRA,EAAE,IAAM,EACDrP,CAAC,CASVmJ,eACEwE,EACAkM,EAAUlM,EAAM1B,QAChBjM,EAAa,IAAI6N,IAcjBlI,EAAckU,EAAKlM,EAAM1B,SACzBnL,EAAW+M,GAAI7N,GACf,MAAMuN,EAAII,EAAMJ,EACV8B,EAAIrP,EAAOqP,EACXyK,EAAKnM,EAAM1B,QAAQ3C,IAAIuQ,IACrBlc,EAAG+b,EAAIrX,EAAGsX,EAAIvQ,EAAGwQ,GAAOjM,EAAM1B,SAC9BtO,EAAG4b,EAAIlX,EAAGmX,EAAIpQ,EAAGqQ,GAAOI,EAAIvN,IAAIwN,GAgCxC,OApBAzK,EAAE,GAAK,EAAMqK,EAAKH,EAClBlK,EAAE,IAAMsK,EAAKJ,EACblK,EAAE,IAAMuK,EAAKL,EACblK,EAAE,GAAKkK,EAAKhM,EAEZ8B,EAAE,IAAMqK,EAAKF,EACbnK,EAAE,GAAK,EAAMsK,EAAKH,EAClBnK,EAAE,IAAMuK,EAAKJ,EACbnK,EAAE,GAAKmK,EAAKjM,EAEZ8B,EAAE,IAAMqK,EAAKD,EACbpK,EAAE,IAAMsK,EAAKF,EACbpK,EAAE,IAAM,EAAMuK,EAAKH,EACnBpK,EAAE,IAAMoK,EAAKlM,EAEb8B,EAAE,IAAM,EACRA,EAAE,IAAM,EACRA,EAAE,IAAM,EACRA,EAAE,IAAM,EAEDrP,CAAAA,CAGTmJ,sBACE4Q,EACA/Z,EAAa,IAAI6N,IAEjBlI,EAAcoU,EAAKC,OAAQD,EAAKE,MAChCnZ,EAAW+M,GAAI7N,GACf,MAAMoZ,EAAKW,EAAKC,OAAOrc,EACrB0b,EAAKU,EAAKC,OAAO3X,EACjBiX,EAAKS,EAAKC,OAAO5Q,EACbmQ,EAAKQ,EAAKE,KAAKtc,EACnB6b,EAAKO,EAAKE,KAAK5X,EACfoX,EAAKM,EAAKE,KAAK7Q,EACXiG,EAAIrP,EAAOqP,EAyBjB,OAnBAA,EAAE,GAAKkK,EAAKA,EACZlK,EAAE,GAAKkK,EAAKC,EACZnK,EAAE,GAAKkK,EAAKE,EACZpK,EAAE,GAAK+J,EAEP/J,EAAE,GAAKmK,EAAKD,EACZlK,EAAE,GAAKmK,EAAKA,EACZnK,EAAE,GAAKmK,EAAKC,EACZpK,EAAE,GAAKgK,EAEPhK,EAAE,GAAKoK,EAAKF,EACZlK,EAAE,GAAKoK,EAAKD,EACZnK,EAAE,IAAMoK,EAAKA,EACbpK,EAAE,IAAMiK,EAERjK,EAAE,IAAM,EACRA,EAAE,IAAM,EACRA,EAAE,IAAM,EACRA,EAAE,IAAM,EACDrP,CAAC,CAGVmJ,sBAAsB5E,EAAOvE,EAAa,IAAI6N,IAC5ClI,EAAcpB,GACdzD,EAAW+M,GAAI7N,GACf,MAAMqP,EAAIrP,EAAOqP,EAqBjB,OAnBAA,EAAE,IAAM,EACRA,EAAE,GAAK,EACPA,EAAE,GAAK,EACPA,EAAE,GAAK,EAAI9K,EAAE5G,EAEb0R,EAAE,GAAK,EACPA,EAAE,IAAM,EACRA,EAAE,GAAK,EACPA,EAAE,GAAK,EAAI9K,EAAElC,EAEbgN,EAAE,GAAK,EACPA,EAAE,GAAK,EACPA,EAAE,KAAO,EACTA,EAAE,IAAM,EAAI9K,EAAE6E,EAEdiG,EAAE,IAAM,EACRA,EAAE,IAAM,EACRA,EAAE,IAAM,EACRA,EAAE,IAAM,EACDrP,CAAC,CAGAmJ,WAAWgG,EAAYC,EAAaC,GAE5C,OADAhO,EAAO,GAAK8N,GAAS,GAAKC,GACnB,IAAIvB,MAAMwB,EAAAA,CAGf/D,QACF,OAAOhQ,KAAK4e,gBAAgBpU,EAAGwF,EAAE,CAG/BC,QACF,OAAOjQ,KAAK4e,gBAAgBpU,EAAGyF,EAAE,CAG/BC,QACF,OAAOlQ,KAAK4e,gBAAgBpU,EAAG0F,EAAE,CAG/BY,QACF,OAAO9Q,KAAK6e,gBAAgB,CAG9BhR,SAASkI,EAAYzQ,GACnB,MAAMyO,EAAI/T,KAAK+T,EACTqK,EAAKjZ,KAAKiE,MAAM,EAAI2K,EAAE,IAAM,GAC5BsK,EAAKlZ,KAAKiE,MAAM,EAAI2K,EAAE,IAAM,GAC5BuK,EAAKnZ,KAAKiE,MAAM,EAAI2K,EAAE,KAAO,GAEnC,OACEjN,EAAGiN,EAAE,IAAK,EAAMsK,EAAKD,EAAIrI,IACzBjP,EAAGiN,EAAE,IAAK,EAAMuK,EAAKF,EAAIrI,IACzBjP,EAAGiN,EAAE,IAAK,EAAMqK,EAAKC,EAAItI,IACzBjP,EAAGiN,EAAE,IAAK,EAAMuK,EAAKD,EAAItI,IACzBjP,EAAGiN,EAAE,IAAK,EAAMqK,EAAKE,EAAIvI,IACzBjP,EAAGiN,EAAE,IAAK,EAAMsK,EAAKC,EAAIvI,IACzBjP,EAAGiN,EAAE,IAAK,EAAGgC,IACbjP,EAAGiN,EAAE,IAAK,EAAGgC,IACbjP,EAAGiN,EAAE,IAAK,EAAGgC,IACbjP,EAAGiN,EAAE,IAAK,EAAGgC,IACbjP,EAAGiN,EAAE,GAAKsK,EAAItK,EAAE,GAAKqK,EAAIrI,IACzBjP,EAAGiN,EAAE,GAAKuK,EAAIvK,EAAE,IAAMsK,EAAItI,IAC1BjP,EAAGiN,EAAE,IAAMqK,EAAIrK,EAAE,GAAKuK,EAAIvI,EAAAA,CAW9BlI,SAASnJ,GACP,OAAO6N,GAAGuM,QAAQ9e,KAAM0E,EAAAA,CAI1BmJ,QACE,OAAO7N,KAAK+T,EAAE,GAAK/T,KAAK+T,EAAE,GAAK/T,KAAK+T,EAAE,IAAM/T,KAAK+T,EAAE,GAAG,CAGxDlG,MAAMnJ,GAEJ,MAAMqP,GADNrP,EAAS6N,GAAGmC,KAAS1U,KAAM0E,IACVqP,EAIjB,OAFAA,EAAE,GAAKA,EAAE,GAAKA,EAAE,IAAMA,EAAE,IAAMA,EAAE,IAAMA,EAAE,IAAM,EAC9CA,EAAE,IAAM,EACDrP,CAAAA,CAGTmJ,UAAUkR,GACR,OAAOA,EAAG3O,MAAMpQ,KAAK,CAGvB6N,mBACE,MAAMkG,EAAI/T,KAAK+T,EACfhO,EAAO,GAAKgO,EAAE,KAAO,GAAKA,EAAE,KAAO,GAAKA,EAAE,KAM1C,MAAO1N,EAAGC,EAAGyC,EAAAA,CAAKC,EAAGsO,EAAGnR,EAAAA,CAAK6Y,EAAGzE,EAAG5V,GAAKoP,EAGlCxN,EAAIF,EAAIiR,EAAI3S,EACZgL,GAAKtJ,EAAIiR,EAAIjR,EAAI1B,EAAI2B,EAAI0C,EAAID,EAAIiW,EAAI1H,EAAI3S,EAAIwB,EAAIoU,EACjDtI,EAAI5L,GAAKiR,EAAI3S,EAAIwB,EAAIoU,GAAKjU,GAAK0C,EAAIrE,EAAIwB,EAAI6Y,GAAKjW,GAAKC,EAAIuR,EAAIjD,EAAI0H,GAGvE,OADA1W,QAAQ2C,KALE,EAKK1E,EAAGoJ,EAAGsC,GACdnJ,GANG,EAMgBvC,EAAGoJ,EAAGsC,EAAAA,CAGlCpE,oBACE,MAAMoR,EAAcjf,KAAKkf,mBACnBC,EAAUnf,KAAKoQ,MAAMmC,GAAG6M,WAC9B9W,QAAQ2C,IAAIjL,KAAKI,YACjBkI,QAAQ2C,IAAIkU,EAAQ/e,YACpB,IAAIif,EAAOJ,EAAYze,KAAK8e,GAAO/M,GAAG6M,UAAUzM,OAAO2M,GAAIjP,KAAK8O,KAYhE,GAXA7W,QAAQ2C,IAAIoU,EAAK7e,KAAKuT,GAAMA,EAAEwL,kBAC9BjX,QAAQ2C,IAAIoU,EAAK7e,KAAKuT,GAAM,GAAKA,EAAE3T,UAAU6O,GAAM,GAAKA,MAAItO,KAAK,SACjE2H,QAAQ2C,IACNoU,EACG7e,KAAKuT,GAAM,GAAKA,EAAEmE,kBAAkBlB,EAAE5W,UAAU6O,GAAM,GAAKA,MAC3DtO,KAAK,SAEV2H,QAAQ2C,IACN,wBACAoU,EAAK7e,KAAKuT,GAAMA,EAAE0E,UAEhB,GAAKwG,EAAYvc,OAInB,OAHA4F,QAAQ2C,IAAIoU,EAAK,GAAGjf,YACpB8F,GAAAA,IAAc,GAAKmZ,EAAK,GAAG5G,SAEpBhM,EACL,GACCqL,GAAQ,IAAItN,EAAGxK,KAAK+T,EAAE+D,GAAM9X,KAAK+T,EAAE,EAAI+D,GAAM9X,KAAK+T,EAAE,EAAI+D,MAG7D,GAAI,GAAKmH,EAAYvc,OAAQ,CAEvB,GAAK2c,EAAK,GAAG5G,SACf4G,EAAO,CAACA,EAAK,GAAIA,EAAK,KAExBnZ,GAAAA,IAAc,GAAKmZ,EAAK,GAAG5G,SAC3BvS,GAAAA,IAAc,GAAKmZ,EAAK,GAAG5G,SAG3B,MAAM+G,EAASH,EAAK,GAAGnH,kBAAkBlB,EACnCyI,EAAeD,EAAO9J,IAAI,GAAGjH,MAAM+Q,EAAO9J,IAAI,IAAIlL,KAAKmT,OAEvD+B,EAAcL,EAAK,GAAGnH,kBAAkBlB,EAAEtB,IAAI,GAAGlL,KACjDmV,EAAeD,EAAYE,mBAAmBjC,OAC9CkC,EAAeJ,EAClBhR,MAAMkR,GACNG,aAAaJ,GAEhB,MAAO,CAACD,EAAcE,EAAcE,EAAAA,CAEtC,GAAI,GAAKZ,EAAYvc,OAInB,OAHA2c,EAAKze,SAAQ,CAACmf,EAAKpb,IAAMoB,EAAO,GAAKga,EAAItH,OAAQ9T,EAAI,KAAOob,EAAItH,UAGzD4G,EAAK7e,KAAKuf,IACf,MAAMhF,EAAQgF,EAAI7H,kBAAkBlB,EACpC,OAAO+D,EAAMrF,IAAI,GAAGjH,MAAMsM,EAAMrF,IAAI,IAAIlL,KAAKmT,MAAAA,IAGjD,MAAUna,MAAM,2CAA2C,CAU7DqK,OACE,SAASsJ,EAAYxS,EAAQK,EAAQ+D,EAAWmM,GAC9C,MAAMnB,EAAIxB,GAAGqJ,WAKb,OAJA7H,EAAEkB,MAAMtQ,EAAGA,EAAGoE,GACdgL,EAAEkB,MAAMjQ,EAAGA,EAAG+D,GACdgL,EAAEkB,MAAMtQ,EAAGK,EAAGkQ,GACdnB,EAAEkB,MAAMjQ,EAAGL,GAAIuQ,GACRnB,CAAAA,CAGT,MAAMiM,EAAIhgB,KAAKigB,QACf,IAAIC,EAAIF,EAAE/J,aAAa7F,MAAM4P,GAC3BtO,EAAIa,GAAGqJ,WACTtT,QAAQ2C,IAAIiV,EAAE9f,YACd,IAAK,IAAI+f,EAAK,EAAGA,EAAK,GAAIA,IAAM,CAC9B7X,QAAQ2C,IAAI,UAAWyG,EAAEtB,MAAM8P,GAAG9P,MAAMsB,EAAEuE,cAAc7V,YACxD2F,EACE2L,EAAEtB,MAAM8P,GAAG9P,MAAMsB,EAAEuE,cAAcmK,OAAOJ,EAAE/J,aAAa7F,MAAM4P,IAC7DtO,EAAEtB,MAAM8P,GAAG9P,MAAMsB,EAAEuE,cAAc7V,WACjC4f,EAAE/J,aAAa7F,MAAM4P,GAAG5f,YAE1B,IAAIigB,EAAiB,EACnBC,EAAsB,EACtBhV,EAAI,GACN,KAAOA,KAAK,CACV,MAAMhK,EAAM6D,KAAK0B,IAAIqZ,EAAEnM,EAAEzI,IACrBA,EAAI,GAAKnG,KAAKwC,MAAM2D,EAAI,IAAMhK,EAAM+e,IACtCA,EAAiB/e,EACjBgf,EAAsBhV,EAAAA,CAI1B,MAAM3G,EAAIQ,KAAKwC,MAAM2Y,EAAsB,GACzCtb,EAAIsb,EAAsB,EACtBC,EAAOL,EAAEnM,EAAE,EAAIpP,GACnB6b,EAAON,EAAEnM,EAAE,EAAI/O,GACfyb,EAAOP,EAAEnM,EAAEuM,GACP1W,EACJ2W,IAASC,EAAOtb,EAAK,EAAIC,KAAKub,KAAM,EAAID,GAASF,EAAOC,IAAS,EACnElY,QAAQ2C,IAAIqV,EAAqB3b,EAAGK,EAAG,MAAO4E,GAC9C,MAEM+W,EAAiBxJ,EAAYxS,EAAGK,EAF1BG,KAAK6E,IAAIJ,IACbzE,KAAKgJ,IAAIvE,IAEjB7D,EAAO4a,EAAe1K,aAAa7F,MAAMuQ,GAAgBC,gBACzDtY,QAAQ2C,IAAI0V,EAAevgB,YAC3BsR,EAAIA,EAAEtB,MAAMuQ,GACZT,EAAI3N,GAAGmI,QAAQiG,EAAe1K,aAAciK,EAAGS,GAC/CrY,QAAQ2C,IAAIiV,EAAE9f,WAAW,CAG3B,MAAMygB,EAAQX,EAAE1f,KAAI,CAACqM,EAAIH,IAAaA,EAAU,GAAK,EAAIvH,KAAKiE,KAAKyD,GAAM,IACzE,MAAO,CACLmK,EAAGzE,GAAGmI,QACJsF,EACAtO,EACAmP,EAAMrgB,KAAI,CAACqM,EAAIH,IAAaA,EAAU,GAAK,EAAI,EAAIG,EAAK,KAE1DiU,MAAOD,EACPE,MAAOrP,EAAEuE,aAAAA,CAIbpI,IAAIuL,GACF,OAAO7G,GAAGyO,eAAc,CAAC3e,EAAG0E,EAAGpC,IAAMyU,EAAGpZ,KAAK+T,EAAEpP,GAAIA,EAAG3E,KAAK+T,IAAAA,CAG7DlG,OAAOkR,GAEL,OADAvZ,EAAW+M,GAAIwM,GACR/e,KAAK+T,EAAEkN,OAAM,CAACpU,EAAIpK,IAAUqE,EAAG+F,EAAIkS,EAAGhL,EAAEtR,KAAAA,CAIjDoL,WAAWnJ,GACT,OAAO6N,GAAG2O,UAAUlhB,KAAM0E,EAAAA,CAI5BmJ,MAAMiI,GACJ,OAAOvD,GAAGyJ,SAAShc,KAAM8V,EAAAA,CAY3BjI,eAAe0Q,GACblU,EAAckU,GACd,MAAMxK,EAAI/T,KAAK+T,EACToN,EAAK5C,EAAIlc,EACb+e,EAAK7C,EAAIxX,EACTsa,EAAK9C,EAAIzQ,EACLmE,EAAIkP,EAAKpN,EAAE,IAAMqN,EAAKrN,EAAE,IAAMsN,EAAKtN,EAAE,IAC3C,GAAIpN,EAAIsL,GAAI,OACZ,MAAM5P,EAAI8e,EAAKpN,EAAE,GAAKqN,EAAKrN,EAAE,GAAKsN,EAAKtN,EAAE,GACnChN,EAAIoa,EAAKpN,EAAE,GAAKqN,EAAKrN,EAAE,GAAKsN,EAAKtN,EAAE,GACnCjG,EAAIqT,EAAKpN,EAAE,GAAKqN,EAAKrN,EAAE,GAAKsN,EAAKtN,EAAE,IACzC,OAAO,IAAIvJ,EAAGnI,EAAI4P,EAAGlL,EAAIkL,EAAGnE,EAAImE,EAAAA,CAOlCpE,eAAeoB,GACb5E,EAAc4E,GACd,MAAM8E,EAAI/T,KAAK+T,EACToN,EAAKlS,EAAE5M,EACX+e,EAAKnS,EAAElI,EACPsa,EAAKpS,EAAEnB,EACHzL,EAAI8e,EAAKpN,EAAE,GAAKqN,EAAKrN,EAAE,GAAKsN,EAAKtN,EAAE,GAAKA,EAAE,GAC1ChN,EAAIoa,EAAKpN,EAAE,GAAKqN,EAAKrN,EAAE,GAAKsN,EAAKtN,EAAE,GAAKA,EAAE,GAC1CjG,EAAIqT,EAAKpN,EAAE,GAAKqN,EAAKrN,EAAE,GAAKsN,EAAKtN,EAAE,IAAMA,EAAE,IAC3C9B,EAAIkP,EAAKpN,EAAE,IAAMqN,EAAKrN,EAAE,IAAMsN,EAAKtN,EAAE,IAAMA,EAAE,IAEnD,OAAO,IAAIvJ,EAAGnI,EAAI4P,EAAGlL,EAAIkL,EAAGnE,EAAImE,EAAAA,CASlCpE,gBAAgBoB,EAAOqS,GAAAA,GACrBjX,EAAc4E,GACd,MAAM8E,EAAI/T,KAAK+T,EACT9B,EAAIhD,EAAE5M,EAAI0R,EAAE,IAAM9E,EAAElI,EAAIgN,EAAE,IAAM9E,EAAEnB,EAAIiG,EAAE,IAS9C,OARAuN,GACEvb,EACEY,EAAIsL,IAAAA,IAEF,uDACAA,EACAjS,KAAKI,aAEJ,IAAIoK,EACTuJ,EAAE,GAAK9E,EAAE5M,EAAI0R,EAAE,GAAK9E,EAAElI,EAAIgN,EAAE,GAAK9E,EAAEnB,EACnCiG,EAAE,GAAK9E,EAAE5M,EAAI0R,EAAE,GAAK9E,EAAElI,EAAIgN,EAAE,GAAK9E,EAAEnB,EACnCiG,EAAE,GAAK9E,EAAE5M,EAAI0R,EAAE,GAAK9E,EAAElI,EAAIgN,EAAE,IAAM9E,EAAEnB,EAAAA,CAIxCD,iBAAiBoB,EAAOyP,GAItBrU,EAAc4E,EAAGyP,GACjB,MAAM6C,EAAoBvhB,KAAKoY,YAC7BoJ,GAAG9C,EAAOrc,EAAGqc,EAAO3X,EAAG2X,EAAO5Q,EAAG,IAE7B2T,EAAoBzhB,KAAKoY,YAAYoJ,GAAGvS,EAAE5M,EAAG4M,EAAElI,EAAGkI,EAAEnB,EAAG,IAC7D,OAAO2T,EACJrR,MAAMmR,EAAkBtP,GACxBrC,MAAM2R,EAAkBnR,MAAMqR,EAAkBxP,IAChDjB,IAAI7L,KAAAA,IAAAoc,EAAkBtP,EAAK,IAC3BzH,IAAI,CAGTqD,kBAAkBxG,GAChB,OAAOA,EAAG7G,KAAKyO,GAAMjP,KAAK0hB,eAAezS,IAAAA,CAG3CpB,mBAAmBxG,GACjB,OAAOA,EAAG7G,KAAKyO,GAAMjP,KAAK4e,gBAAgB3P,IAAAA,CAG5CpB,MACE,OAAO,IAAI0E,EAAAA,CAGb1E,YACE,OAAQlH,EAAI3G,KAAK2hB,cAAc,CAGjC9T,gBACE,MAAMkG,EAAI/T,KAAK+T,EACf,OACE,KAAOpN,EAAIoN,EAAE,OAAQpN,EAAIoN,EAAE,OAAQpN,EAAIoN,EAAE,KACzC,KAAOpN,EAAIoN,EAAE,OAAQpN,EAAIoN,EAAE,OAAQpN,EAAIoN,EAAE,KACzC,KAAOpN,EAAIoN,EAAE,OAAQpN,EAAIoN,EAAE,OAAQpN,EAAIoN,EAAE,IAAI,CAUjDlG,eAIE,OAFA0E,GAAG2O,UAAUlhB,KAAMuS,GAAG0J,OACtB1J,GAAGyJ,SAAShc,KAAMuS,GAAG0J,MAAO1J,GAAG2J,OACxB3J,GAAGqP,SAASxB,OAAO7N,GAAG2J,MAAM,CASrCrO,cAEE,OADA0E,GAAG2O,UAAUlhB,KAAMuS,GAAG0J,OACfjc,KAAKogB,OAAO7N,GAAG0J,MAAM,CAI9BpO,gBAAgBkI,GACd,OACEpP,EAAI3G,KAAK+T,EAAE,GAAIgC,IACfpP,EAAI3G,KAAK+T,EAAE,GAAIgC,IACfpP,EAAI3G,KAAK+T,EAAE,IAAKgC,IAChBpP,EAAI3G,KAAK+T,EAAE,IAAKgC,IAChBjP,EAAG9G,KAAK+T,EAAE,GAAI/T,KAAK+T,EAAE,GAAIgC,IACzBjP,EAAG9G,KAAK+T,EAAE,GAAI/T,KAAK+T,EAAE,GAAIgC,IACzBjP,EAAG9G,KAAK+T,EAAE,GAAI/T,KAAK+T,EAAE,IAAKgC,IAC1BjP,EAAG9G,KAAK+T,EAAE,GAAI/T,KAAK+T,EAAE,GAAIgC,IACzBjP,EAAG9G,KAAK+T,EAAE,GAAI/T,KAAK+T,EAAE,IAAKgC,IAC1BjP,EAAG9G,KAAK+T,EAAE,IAAK/T,KAAK+T,EAAE,IAAKgC,EAAAA,CAU/BlI,WAIE,OAHA0E,GAAG2O,UAAUlhB,KAAMuS,GAAG0J,OACtB1J,GAAGyJ,SAAShc,KAAMuS,GAAG0J,MAAO1J,GAAG2J,OAC/B3J,GAAGyJ,SAASzJ,GAAG0J,MAAOjc,KAAMuS,GAAGsP,OACxBtP,GAAG2J,MAAMkE,OAAO7N,GAAGsP,MAAM,CAWlChU,cAKE,MAAMiU,EAAI9hB,KAAK+T,EACb1N,EAAIyb,EAAE,GACNxb,EAAIwb,EAAE,GACN/Y,EAAI+Y,EAAE,GACN9Y,EAAI8Y,EAAE,GACNxK,EAAIwK,EAAE,GACN3b,EAAI2b,EAAE,GACN9C,EAAI8C,EAAE,GACNvH,EAAIuH,EAAE,GACNnd,EAAImd,EAAE,GACNxW,EAAIwW,EAAE,GACN9c,EAAI8c,EAAE,IACNlL,EAAIkL,EAAE,IACN/N,EAAI+N,EAAE,IACNxR,EAAIwR,EAAE,IACN3e,EAAI2e,EAAE,IACN7Y,EAAI6Y,EAAE,IACNC,EAAO/c,EAAIiE,EAAI2N,EAAIzT,EACnB6e,EAAO1W,EAAIrC,EAAI2N,EAAItG,EACnB2R,EAAO3W,EAAInI,EAAI6B,EAAIsL,EACnB4R,EAAOvd,EAAIsE,EAAI2N,EAAI7C,EACnBoO,EAAOxd,EAAIxB,EAAI6B,EAAI+O,EACnBqO,EAAOzd,EAAI2L,EAAIhF,EAAIyI,EACrB,OACE1N,GAAKF,EAAI4b,EAAO/C,EAAIgD,EAAOzH,EAAI0H,GAC/B3b,GAAKgR,EAAIyK,EAAO/C,EAAIkD,EAAO3H,EAAI4H,GAC/BpZ,GAAKuO,EAAI0K,EAAO7b,EAAI+b,EAAO3H,EAAI6H,GAC/BpZ,GAAKsO,EAAI2K,EAAO9b,EAAIgc,EAAOnD,EAAIoD,EAAAA,CAInCvU,eACE,MAAOxH,EAAGC,EAAGyC,EAAAA,CAAKC,EAAGsO,EAAGnR,EAAAA,CAAK6Y,EAAGzE,EAAG5V,GAAK3E,KAAK+T,EAC7C,OAAO1N,GAAKiR,EAAI3S,EAAIwB,EAAIoU,GAAKjU,GAAK0C,EAAIrE,EAAIwB,EAAI6Y,GAAKjW,GAAKC,EAAIuR,EAAIjD,EAAI0H,EAAAA,CAItEnR,cAaE,OAAO7N,KAAK2hB,cAAgB,CAAC,CAI/B9T,iBACE,MAAMkG,EAAI/T,KAAK+T,EACb9B,EAAI8B,EAAE,IACR,OAAO,IAAIvJ,EAAGuJ,EAAE,GAAK9B,EAAG8B,EAAE,GAAK9B,EAAG8B,EAAE,IAAM9B,EAAAA,CAQ5CpE,aACE,MAAMwU,EAASxb,GAAI7G,KAAK2hB,eACxB,OAAO,GAAKU,EAASriB,KAAOA,KAAKsiB,UAAUnd,KAAAA,IAAAkd,EAAU,MAIvDxU,cACE,MAAMmD,EAAMhR,KAAK+T,EAAE,IACnB,OAAO,GAAK/C,EAAMhR,KAAOA,KAAKsiB,UAAUtR,EAAAA,CAO1CnD,UACE,MAAMkG,EAAI/T,KAAK+T,EACf,OACEjN,EAAG,EAAGiN,EAAE,MACRpN,EAAIoN,EAAE,MACNpN,EAAIoN,EAAE,MACNpN,EAAIoN,EAAE,MACNpN,EAAIoN,EAAE,KACNpN,EAAIoN,EAAE,KACNpN,EAAIoN,EAAE,IAAI,CAIdlG,WACE,MAAMkG,EAAI/T,KAAK+T,EACf,OAAO,GAAKA,EAAE,KAAO,GAAKA,EAAE,KAAO,GAAKA,EAAE,KAAO,GAAKA,EAAE,GAAG,CAG7DlG,eACE,OAAO7N,KAAK+T,EAAEkN,OAAM,CAAC3f,EAAKqD,KACtBA,EAAI,EAAK,IAAMA,EAAI,EAAImC,EAAG,EAAGxF,GAAOqF,EAAIrF,IAAAA,CAI9CuM,aACE,OAAO7N,KAAK+T,EAAEkN,OAAM,CAAC3f,EAAKqD,KACtBA,EAAI,EAAK,IAAMA,EAAI,EAAI,GAAKrD,EAAM,GAAKA,GAAAA,CAI7CuM,SACE1H,EAAgC,CAAC8I,GAC/BA,EAAEqG,QAAQ,GAAG1Q,QAAQ,iBAAkB,OAEzCmB,EAAsB,iBAARI,EAAE,UAA4BA,EAAE,IAE9C,MAAMoP,EAAUlV,MAAMuD,UAAUgK,MAAM3M,KAAKjB,KAAK+T,GAAGvT,IAAI2F,GACjDwP,EAAY,CAAC,EAAG,EAAG,EAAG,GAAGnV,KAAK+T,GAClCxM,EJjtCkBrF,SAItB2I,EACAkX,EACAC,EACAjW,EACAkW,EAAY,GAEZ7c,EAAc2c,EAAOhW,GACrBgW,EAAQ,IAAMA,EAAQlX,EAAI3I,OAAS6f,GACnCC,GAAO,IAAMA,EAAMnX,EAAI3I,OAAS8f,GAChC,MAAME,EAAevd,KAAKyC,MAAM4a,EAAMD,GAAShW,GACzC7H,EAAarE,MAAMqiB,GAGzB,IAAIjgB,EAAQ,EACZ,IAAK,IAAIkC,EAAI4d,EAAO5d,EAAI6d,EAAK7d,GAAK4H,EAChC,IAAK,IAAIjB,EAAI3G,EAAG2G,EAAInG,KAAK2C,IAAInD,EAAI8d,EAAWD,GAAMlX,IAChD5G,EAAOjC,KAAW4I,EAAIC,GAI1B,OADAvF,EAAO2c,GAAgBjgB,GAChBiC,CAAAA,CIyrCCie,CAAUpN,EAAShB,EAAU,EAAG,GAAG/T,KAAK6B,GAAMA,EAAEK,YAEtD,MAAO,CAAC,EAAG,EAAG,EAAG,GACdlC,KAAK0T,GACJqB,EACG3H,MAAiB,EAAXsG,EAAyB,EAAXA,EAAe,GACnC1T,KAAI,CAAC6B,EAAGkS,IAAa,IAAIqO,OAAOjN,EAAUpB,GAAYlS,EAAEK,QAAUL,IAElE1B,KAAK,OAETA,KAAK,KAAK,CAWfkN,gBAQE,MALa,CACX,EAAG,EAAG,EAAG,EACT,EAAG,EAAG,EAAG,EACT,EAAG,EAAG,EAAG,EACT,EAAG,EAAG,EAAG,GACCoT,OAAM,CACf4B,EAAUpgB,IAAsB,GAAZogB,GAAiBA,GAAY7iB,KAAK+T,EAAEtR,IAAAA,CAY7DoL,YAOE,MALa,CACX,EAAG,EAAG,EAAG,EACT,EAAG,EAAG,EAAG,EACT,EAAG,EAAG,EAAG,EACT,EAAG,EAAG,EAAG,GACCoT,OAAM,CACf4B,EAAUpgB,IAAsB,GAAZogB,GAAiBA,GAAY7iB,KAAK+T,EAAEtR,IAAAA,CAI7DoL,cAOE,MALa,CACX,EAAG,EAAG,EAAG,EACT,EAAG,EAAG,EAAG,EACT,EAAG,EAAG,EAAG,EACT,EAAG,EAAG,EAAG,GAEJoT,OAAM,CACR4B,EAAUpgB,IAAsB,GAAZogB,GAAiBA,GAAY7iB,KAAK+T,EAAEtR,MAE3DqE,EAAG,EAAG3B,KAAAA,IAAAnF,KAAK+T,EAAE,GAAM,GAAI5O,KAAAA,IAAAnF,KAAK+T,EAAE,GAAM,KACpC/T,KAAK+T,EAAE,IAAM/T,KAAK+T,EAAE,IACpB/T,KAAK+T,EAAE,KAAO/T,KAAK+T,EAAE,EAAE,CAI3BlG,WACE,MAAMlI,EAAO4M,GAAGxC,QAAQvO,IAAIxB,MAC5B,GAAI2F,EACF,OAAOA,EACF,GAAI3F,KAAK8iB,gBACd,OAAO3Y,EAAW,eAAgBnK,KAAK8Q,GAClC,GAAI9Q,KAAK+iB,YACd,OAAO5Y,EAAW,WAAYnK,KAAK+T,EAAE,GAAI/T,KAAK+T,EAAE,GAAI/T,KAAK+T,EAAE,KACtD,GAAI/T,KAAKgjB,WACd,OAAQhjB,KAAK8Q,EAAElP,OAAO4I,EAAGsG,GAErB3G,EAAW,YAAanK,KAAKgQ,EAAGhQ,KAAKiQ,EAAGjQ,KAAKkQ,GAD7C/F,EAAW,YAAanK,KAAKgQ,EAAGhQ,KAAKiQ,EAAGjQ,KAAKkQ,EAAGlQ,KAAK8Q,GAEpD,GAAI9Q,KAAKijB,SAAS,GAAI,CAC3B,MAAMlP,EAAI/T,KAAK+T,EACTqK,EAAKjZ,KAAKiE,MAAM,EAAI2K,EAAE,IAAM,GAC5BsK,EAAKlZ,KAAKiE,MAAM,EAAI2K,EAAE,IAAM,GAC5BuK,EAAKnZ,KAAKiE,MAAM,EAAI2K,EAAE,KAAO,GAC7B9B,EAAI8B,EAAE,GAAK,EAAMqK,EACvB,OAAOjU,EAAW,YAAa,CAAEwG,QAAS,IAAInG,EAAG4T,EAAIC,EAAIC,GAAKrM,EAAAA,GAAAA,CACzD,CACL,MAAM8B,EAAI/T,KAAK+T,EACf,MACE,cACUA,EAAE,GAAK,MAAQA,EAAE,GAAK,MAAQA,EAAE,GAAK,MAAQA,EAAE,GADzD,QAEUA,EAAE,GAAK,MAAQA,EAAE,GAAK,MAAQA,EAAE,GAAK,MAAQA,EAAE,GAFzD,QAGUA,EAAE,GAAK,MAAQA,EAAE,GAAK,MAAQA,EAAE,IAAM,MAAQA,EAAE,IAH1D,QAIUA,EAAE,IAAM,MAAQA,EAAE,IAAM,MAAQA,EAAE,IAAM,MAAQA,EAAE,IAAM,GAAG,CAAH,CAKxElG,eACE,OAAO7N,KAAK4e,gBAAgBpU,EAAGwF,GAAGvB,MAAMzO,KAAK4e,gBAAgBpU,EAAGyF,IAAIvN,QAAQ,EAt9C9D6P,GAAAA,IAAM,IAAIA,GACxB,EAAK,EAAK,EAAM,EAChB,GAAK,GAAK,GAAK,GACf,IAAK,IAAK,IAAM,IAChB,EAAK,EAAK,EAAM,GAEFA,GAAAA,QAAUA,GAAGgB,IAAI2P,WACjB3Q,GAAAA,SAAWA,GAAGqJ,WAEdrJ,GAAAA,EAAI,IAAIA,GACtB,EAAG,EAAG,EAAG,EACT,EAAG,EAAG,EAAG,EACT,EAAG,EAAG,EAAG,EACT,EAAG,EAAG,EAAG,GAEKA,GAAAA,IAAMA,GAAG4Q,OAAO3Y,EAAGyF,EAAGzF,EAAG0F,EAAG1F,EAAGwF,GAC/BuC,GAAAA,IAAMA,GAAG4Q,OAAO3Y,EAAG0F,EAAG1F,EAAGwF,EAAGxF,EAAGyF,GAExCsC,GAAAA,UAAY,IAAIA,GACrB,EAAG,EAAG,EAAG,EACT,EAAG,EAAG,EAAG,EACT,EAAG,EAAG,EAAG,EACT,EAAG,EAAG,EAAG,GAEKA,GAAAA,MAAQ,IAAIA,GACZA,GAAAA,MAAQ,IAAIA,GACZA,GAAAA,MAAQ,IAAIA,GAEZA,GAAAA,SAAAA,IAAc3S,GAC3BwB,IAAImR,GAAG6M,UAAW,gBAClBhe,IAAImR,GAAGgB,IAAK,UACZnS,IAAImR,GAAGzB,EAAG,QACV1P,IAAImR,GAAGiB,QAAS,cAChBpS,IAAImR,GAAGqP,SAAU,eACjBxgB,IAAImR,GAAG6Q,IAAK,UACZhiB,IAAImR,GAAG8Q,IAAK,UAu7CjB9Q,GAAG3O,UAAUkQ,OAAS,EACtBvB,GAAG3O,UAAUiQ,MAAQ,EAIrB7L,EAAiBuK,GAAG3O,UAAWwO,EAAcxO,UAAW,qBCt/C3C6G,GACXoD,YAAqBoB,GAAAjP,KAAAA,EAAAiP,EACnBzJ,EAAWoM,aAAc3C,EAAAA,CAG3BpB,oBAAoByV,EAAWnd,GAC7BP,EAAc0d,GACd,MAAMhM,EAAI,IAAI1F,aAAa0R,GAC3B,IAAI3e,EAAI2e,EACR,KAAO3e,KACL2S,EAAE3S,GAAKwB,EAAExB,GAEX,OAAO,IAAI8F,GAAO6M,EAAAA,CAGpBzJ,cAAcyV,GACZ,OAAO7Y,GAAOuJ,aAAasP,GAAOC,GAAOpe,KAAK4I,UAAAA,CAKhDF,eAAeS,GAMb,OALAvI,EACEuI,EAAK,aAAcsD,cACjBtD,EAAK2S,OAAO5a,GAAM,iBAAmBA,IACvC,4EAEK,IAAIoE,GACT6D,EAAK,aAAcsD,aAAetD,EAAK,GAAKsD,aAAatR,KAAKgO,GAAAA,CAIlET,YAAYyV,GACV1d,EAAc0d,GACd,IAAI3e,EAAI,EACR,MAAM2L,EAAI,IAAIsB,aAAa0R,GAC3B,KAAO3e,KACL2L,EAAE3L,GAAK,EAET,OAAO,IAAI8F,GAAO6F,EAAE,CAGtBzC,YAAYyV,EAAW/E,GACrB3Y,EAAc0d,EAAM/E,GACpB,IAAI5Z,EAAI,EACR,MAAM2L,EAAI,IAAIsB,aAAa0R,GAC3B,KAAO3e,KACL2L,EAAE3L,KAAOA,GAAK4Z,GAEhB,OAAO,IAAI9T,GAAO6F,EAAAA,CAcpBzC,YACEvD,EACAqE,EACAC,EAAmB,EACnBC,EAAoB,EACpB2U,EAAsBlZ,EAAQ5H,OAASkM,GAGvC,MAAM0C,EAAMhH,EAAQ,GAAGgH,MACjB5M,EAASiK,GAAS,IAAII,aAAauC,EAAMkS,GAC/Czd,EACErB,EAAOhC,OAASmM,GAAa2U,EAAclS,EAC3C,yCACA5M,EAAOhC,OACPmM,EACc,EAAd2U,GAGF,IAAI7e,EAAI6e,EACNvX,EAAW2C,EACXI,EAAYH,EACd,KAAOlK,KAAK,CACV,MAAMsK,EAAI3E,EAAQ2B,KAClB,IAAK,IAAIjD,EAAI,EAAGA,EAAIsI,EAAKtI,IACvBtE,EAAOsK,KAAeC,EAAEA,EAAEjG,EAAAA,CAG9B,OAAOtE,CAAAA,CAGTmJ,YAAYxH,EAAWC,EAAWC,GAChCR,EAAOM,EAAEiL,OAAShL,EAAEgL,OACpB,MAAMhB,EAAI,IAAIsB,aAAavL,EAAE4I,EAAEvM,QAC/B,IAAIiC,EAAI0B,EAAE4I,EAAEvM,OACZ,KAAOiC,KACL2L,EAAE3L,GAAK0B,EAAE4I,EAAEtK,IAAM,EAAI4B,GAAKD,EAAE2I,EAAEtK,GAAK4B,EAErC,OAAO,IAAIkE,GAAO6F,EAAAA,CAGpBzC,cAAcxG,GACZ,MAAMiK,EAAMjK,EAAG,GAAG4H,EAAEvM,OACdgC,EAAS,IAAIkN,aAAaN,GAChC,IAAI3M,EAAI0C,EAAG3E,OACX,KAAOiC,KAAK,CACV,IAAIqE,EAAIsI,EACR,KAAOtI,KACLtE,EAAOsE,IAAM3B,EAAG1C,GAAGsK,EAAEjG,EAAAA,CAGzB,OAAO,IAAIyB,GAAO/F,EAAAA,CASpBmJ,uBAAuB4V,EAAQC,GAC7B,OAAO,IAAIjZ,GACT,IAAImH,aAAa,CAAC6R,EAAGphB,EAAIqhB,EAAQD,EAAG1c,EAAI2c,EAAQD,EAAG3V,EAAI4V,EAAQA,IAAAA,CAI/DrhB,QACF,OAAOrC,KAAKiP,EAAE,EAAE,CAEdlI,QACF,OAAO/G,KAAKiP,EAAE,EAAE,CAEdnB,QACF,OAAO9N,KAAKiP,EAAE,EAAE,CAEdgD,QACF,OAAOjS,KAAKiP,EAAE,EAAE,CAGlBpB,CAAC/N,OAAOoB,YACN,OAAOlB,KAAKiP,EAAEnP,OAAOoB,WAAW,CAGlC2M,MACE,OAAO7N,KAAKiP,EAAEvM,MAAM,CAGtBmL,EAAEpL,GACA,GAAI,EAAIA,GAASA,GAASzC,KAAKiP,EAAEvM,OAC/B,MAAUc,MAAM,6BAElB,OAAOxD,KAAKiP,EAAExM,EAAAA,CAGhBoL,KAAK6C,GACH,MAAMf,EAAI3P,KAAKiP,EACbA,EAAIyB,EAAOzB,EACPqB,EAAI,IAAIsB,aAAajC,EAAEjN,QAC7B,IAAIiC,EAAIgL,EAAEjN,OACV,KAAOiC,KACL2L,EAAE3L,GAAKgL,EAAEhL,GAAKsK,EAAEtK,GAElB,OAAO,IAAI8F,GAAO6F,EAAAA,CAGpBzC,MAAM6C,GACJ,MAAMf,EAAI3P,KAAKiP,EACbA,EAAIyB,EAAOzB,EACPqB,EAAI,IAAIsB,aAAajC,EAAEjN,QAC7B,IAAIiC,EAAIgL,EAAEjN,OACV,KAAOiC,KACL2L,EAAE3L,GAAKgL,EAAEhL,GAAKsK,EAAEtK,GAElB,OAAO,IAAI8F,GAAO6F,EAAAA,CAGpBzC,MAAMgC,GACJ,MAAMF,EAAI3P,KAAKiP,EACTqB,EAAI,IAAIsB,aAAajC,EAAEjN,QAC7B,IAAIiC,EAAIgL,EAAEjN,OACV,KAAOiC,KACL2L,EAAE3L,GAAKgL,EAAEhL,GAAKkL,EAEhB,OAAO,IAAIpF,GAAO6F,EAAE,CAGtBzC,IAAIvM,GACF,MAAMqO,EAAI3P,KAAKiP,EACTqB,EAAI,IAAIsB,aAAajC,EAAEjN,QAC7B,IAAIiC,EAAIgL,EAAEjN,OACV,KAAOiC,KACL2L,EAAE3L,GAAKgL,EAAEhL,GAAKrD,EAEhB,OAAO,IAAImJ,GAAO6F,EAAE,CAGtBzC,IAAI6C,GACF3K,EAAO/F,KAAKsR,KAAOZ,EAAOY,IAAK,wCAC/B,IAAI5M,EAAS,EACb,MAAMiL,EAAI3P,KAAKiP,EACbA,EAAIyB,EAAOzB,EACb,IAAItK,EAAIgL,EAAEjN,OACV,KAAOiC,KACLD,GAAUiL,EAAEhL,GAAKsK,EAAEtK,GAErB,OAAOD,CAAC,CAGVmJ,MAAM6C,GACJlL,EAAWiF,GAAQiG,GACnB,MAAMJ,EAAI,IAAIsB,aAAa,GAK3B,OAJAtB,EAAE,GAAKtQ,KAAKiP,EAAE,GAAKyB,EAAOzB,EAAE,GAAKjP,KAAKiP,EAAE,GAAKyB,EAAOzB,EAAE,GACtDqB,EAAE,GAAKtQ,KAAKiP,EAAE,GAAKyB,EAAOzB,EAAE,GAAKjP,KAAKiP,EAAE,GAAKyB,EAAOzB,EAAE,GACtDqB,EAAE,GAAKtQ,KAAKiP,EAAE,GAAKyB,EAAOzB,EAAE,GAAKjP,KAAKiP,EAAE,GAAKyB,EAAOzB,EAAE,GAE/C,IAAIxE,GAAO6F,EAAAA,CAGpBzC,MAAM6C,GACJlL,EAAWiF,GAAQiG,GACnB,MAAMf,EAAI3P,KAAKiP,EACbA,EAAIyB,EAAOzB,EACPqB,EAAI,IAAIsB,aAAajC,EAAEjN,QAC7B,IAAIiC,EAAIgL,EAAEjN,OACV,KAAOiC,KACL2L,EAAE3L,GAAKgL,EAAEhL,GAAKsK,EAAEtK,GAElB,OAAO,IAAI8F,GAAO6F,EAAAA,CAGpBzC,OAAOkD,GACL,GAAIA,IAAQ/Q,KAAM,OAAM,EACxB,GAAI+Q,EAAIlR,cAAgB4K,GAAQ,OAAM,EACtC,GAAIzK,KAAKiP,EAAEvM,QAAUqO,EAAI9B,EAAEvM,OAAQ,OAAM,EACzC,IAAIiC,EAAI3E,KAAKiP,EAAEvM,OACf,KAAOiC,KACL,GAAI3E,KAAKiP,EAAEtK,KAAOoM,EAAI9B,EAAEtK,GAAI,OAAM,EAEpC,OAAM,CAAC,CAGTkJ,KAAKkD,EAAUgF,GACb,GAAIhF,IAAQ/Q,KAAM,OAAM,EACxB,GAAI+Q,EAAIlR,cAAgB4K,GAAQ,OAAM,EACtC,GAAIzK,KAAKiP,EAAEvM,QAAUqO,EAAI9B,EAAEvM,OAAQ,OAAM,EACzC,IAAIiC,EAAI3E,KAAKiP,EAAEvM,OACf,KAAOiC,KACL,IAAKmC,EAAG9G,KAAKiP,EAAEtK,GAAIoM,EAAI9B,EAAEtK,GAAIoR,GAAY,OAAM,EAEjD,OAAM,CAAC,CAGTlI,IAAI1H,GACF,OAAO,IAAIsE,GAAOzK,KAAKiP,EAAEzO,IAAI2F,GAAAA,CAG/B0H,SAAS2C,GAEP,OADAA,EAAgBA,GAAAA,CAAmBvB,IAAOA,EAAEqG,QAAQ,IAC7C,UAAYtV,KAAKiP,EAAEzO,IAAIgQ,GAAe7P,KAAK,MAAQ,GAAG,CAG/DkN,WACE,OAAO1D,EAAW,QAASnK,KAAKiP,EAAE,CAGpCpB,QAAQ6C,GAIN,OAHAlL,EAAWiF,GAAQiG,GACnB3K,GAAQ/F,KAAK0Y,SAAU,iBACvB3S,GAAQ2K,EAAOgI,SAAU,mBAClBvT,KAAK0E,KACVhC,EAAM7H,KAAKgO,IAAI0C,GAAU1Q,KAAK0C,SAAWgO,EAAOhO,UAAW,EAAG,IASlEmL,aAAa6C,GAMX,OALAlL,EAAWiF,GAAQiG,GACnB3K,GAAQ/F,KAAK0Y,SAAU,iBACvB3S,GAAQ2K,EAAOgI,SAAU,mBAGlB5R,EACL3B,KAAKiE,KAAKpJ,KAAK2jB,gBAAkBjT,EAAOiT,iBACxCxe,KAAK0B,IAAI7G,KAAKgO,IAAI0C,IAAAA,CAItB7C,kBAAkB6C,GAIhB,OAHAlL,EAAWiF,GAAQiG,GACnB3K,GAAQ/F,KAAK0Y,SAAU,iBACvB3S,GAAQ2K,EAAOgI,SAAU,mBAClB/R,EAAI3G,KAAKgO,IAAI0C,GAAAA,CAOtB7C,SACE,OAAOlH,EAAI3G,KAAK0C,SAAS,CAI3BmL,SACE,OAAO1I,KAAK2K,MAAMvB,WAAM,EAAYvO,KAAKiP,EAAAA,CAI3CpB,gBACE,IAAInJ,EAAS,EACb,MAAMiL,EAAI3P,KAAKiP,EACf,IAAItK,EAAIgL,EAAEjN,OACV,KAAOiC,KACLD,GAAUiL,EAAEhL,GAAKgL,EAAEhL,GAErB,OAAOD,CAAAA,CAOTmJ,OACE,MAAMnL,EAAS1C,KAAK0C,SACpB,GAAIiE,EAAIjE,GACN,MAAUc,MAAM,gCAElB,OAAOxD,KAAKgR,IAAIhR,KAAK0C,SAAS,CAIhCmL,aACE,MAAUrK,MAAM,kCAAkC,CAGpDqK,cACE,OAAO,IAAI+F,EAAO5T,KAAKiP,EAAEvM,OAAQ,EAAG1C,KAAKiP,EAAE,CAG7CpB,cACE,OAAO,IAAI+F,EAAO,EAAG5T,KAAKiP,EAAEvM,OAAQ1C,KAAKiP,EAAE,CAa7CpB,YAAYvH,GAGV,OAFAd,EAAWiF,GAAQnE,GAEZA,EAAE8J,MAAMpQ,KAAKgO,IAAI1H,GAAKA,EAAE0H,IAAI1H,GAAAA,CAGrCuH,WAAWvH,GAGT,OAFAd,EAAWiF,GAAQnE,GAEZtG,KAAK4P,MAAMtJ,EAAE8J,MAAMpQ,KAAKgO,IAAI1H,GAAKA,EAAE0H,IAAI1H,IAAAA,CAGhDuH,GAAGxH,GACD,OAAOA,EAAEuJ,MAAM5P,KAAK,CAUtB6N,UAAUnL,GAER,OADAkD,EAAclD,GACPoE,EAAGpE,EAAQ1C,KAAK0C,SAAS,CAGlCmL,KAEE,OAAO,IAAIrD,EAAGxK,KAAKiP,EAAE,GAAIjP,KAAKiP,EAAE,GAAIjP,KAAKiP,EAAE,GAAG,CAIhDpB,KACE9H,EAAwB,GAAjB/F,KAAKiP,EAAEvM,QACd,MAAMuP,EAAIjS,KAAKiP,EAAE,GACjB,OAAO,IAAIzE,EAAGxK,KAAKiP,EAAE,GAAKgD,EAAGjS,KAAKiP,EAAE,GAAKgD,EAAGjS,KAAKiP,EAAE,GAAKgD,EAAAA,CAG1DpE,aACE,OAAO,IAAI+F,EAAO5T,KAAKiP,EAAEvM,OAAQ,EAAG1C,KAAKiP,EAAE,EAAFA,SAI7BuS,MAAMxgB,GACpB,OAAO,IAAIyJ,GAAO,IAAImH,aAAa5Q,GAAAA,CAmBJgI,MCzapB4a,WAAaxR,EACxBvE,YAAmB/F,EAAU0C,EAAGuH,IAAYhK,EAAUyC,EAAGuH,IAAI8R,WAC3DlI,QADiB3b,KAAAA,IAAA8H,EAAyB9H,KAAAA,IAAA+H,EAE1CsC,EAAcvC,EAAKC,EAAAA,CAGrB8F,cAAcxL,EAAW0E,EAAW+G,GAClC,OAAO,IAAI8V,GAAKpZ,EAAGsG,EAAG,IAAItG,EAAGnI,EAAG0E,EAAG+G,GAAAA,CAGrCD,gBAAgBiW,GACd,MAAMpf,EAAS,IAAIkf,GACnB,IAAK,MAAMG,KAAQD,EACjBpf,EAAOsf,QAAQD,GAEjB,OAAOrf,CAAC,CAGVmJ,SAAS5E,GAIP,OAHAoB,EAAcpB,GACdjJ,KAAK8H,IAAM9H,KAAK8H,IAAIA,IAAImB,GACxBjJ,KAAK+H,IAAM/H,KAAK+H,IAAIA,IAAIkB,GACjBjJ,IAAI,CAGb6N,UAAUoW,GAER,OADAA,EAAGrjB,SAASqI,GAAMjJ,KAAKkkB,SAASjb,KACzBjJ,IAAI,CAGb6N,QAAQkW,GAIN,OAHAve,EAAWoe,GAAMG,GACjB/jB,KAAKkkB,SAASH,EAAKjc,KACnB9H,KAAKkkB,SAASH,EAAKhc,KACZ/H,IAAI,CAQb6N,YAAYkW,GAEV,IAAIjc,EAAKC,EADTvC,EAAWoe,GAAMG,GAEjB,MAAMI,EAASnkB,KAAKmkB,SAClBphB,EAAO/C,KAAK+C,OACd,IAAIqhB,GAAAA,IACJ,IAAK,IAAIzf,EAAI,EAAGA,EAAI,EAAGA,IAAK,CAC1B,MAAM2M,EAAM,CAAC,IAAK,IAAK,KAAK3M,GACtB0f,EAAON,EAAKjc,IAAIwJ,GAAOtR,KAAK8H,IAAIwJ,GAAOtR,KAAK+H,IAAIuJ,GAAOyS,EAAKhc,IAAIuJ,GAChEgT,EAASD,EACXrkB,KAAK8H,IAAIwJ,GACTnM,KAAK4C,IAAI/H,KAAK8H,IAAIwJ,GAAMyS,EAAKhc,IAAIuJ,IAC/BiT,EAAUF,EAEZlf,KAAK2C,IAAI9H,KAAK+H,IAAIuJ,GAAMyS,EAAKjc,IAAIwJ,IADjCtR,KAAK+H,IAAIuJ,GAEPkT,GAAuBD,EAASD,GAAUH,EAAUphB,EAAKuO,GAC3DkT,EAAqBJ,IACvBA,EAAkBI,EAClB1c,EAAM9H,KAAK8H,IAAI2c,YAAYnT,EAAKgT,GAChCvc,EAAM/H,KAAK+H,IAAI0c,YAAYnT,EAAKiT,GAAAA,CAGpC,OAAO,IAAIX,GAAK9b,EAAKC,EAAAA,CAGvB8F,oBAAoBkW,GAElB,OADAve,EAAWoe,GAAMG,GACV,IAAIH,GAAK5jB,KAAK8H,IAAIC,IAAIgc,EAAKjc,KAAM9H,KAAK+H,IAAID,IAAIic,EAAKhc,KAAK,CAGjE8F,YAAYkW,GAEV,OADAve,EAAWoe,GAAMG,KAEf/jB,KAAK8H,IAAIzF,EAAI0hB,EAAKhc,IAAI1F,GACtBrC,KAAK+H,IAAI1F,EAAI0hB,EAAKjc,IAAIzF,GACtBrC,KAAK8H,IAAIf,EAAIgd,EAAKhc,IAAIhB,GACtB/G,KAAK+H,IAAIhB,EAAIgd,EAAKjc,IAAIf,GACtB/G,KAAK8H,IAAIgG,EAAIiW,EAAKhc,IAAI+F,GACtB9N,KAAK+H,IAAI+F,EAAIiW,EAAKjc,IAAIgG,EAAAA,CAI1BD,iBAAiBkW,EAAYW,EAAcpf,GAEzC,OADAE,EAAWoe,GAAMG,KAEf/c,EAAG+c,EAAKhc,IAAI1F,EAAGrC,KAAK8H,IAAIzF,EAAGqiB,IAC3B1d,EAAGhH,KAAK+H,IAAI1F,EAAG0hB,EAAKjc,IAAIzF,EAAGqiB,IAC3B1d,EAAG+c,EAAKhc,IAAIhB,EAAG/G,KAAK8H,IAAIf,EAAG2d,IAC3B1d,EAAGhH,KAAK+H,IAAIhB,EAAGgd,EAAKjc,IAAIf,EAAG2d,IAC3B1d,EAAG+c,EAAKhc,IAAI+F,EAAG9N,KAAK8H,IAAIgG,EAAG4W,IAC3B1d,EAAGhH,KAAK+H,IAAI+F,EAAGiW,EAAKjc,IAAIgG,EAAG4W,GAAAA,CAI/B7W,eAAekW,GAEb,OADAve,EAAWoe,GAAMG,KAEf/jB,KAAK8H,IAAIzF,GAAK0hB,EAAKhc,IAAI1F,GACvBrC,KAAK+H,IAAI1F,GAAK0hB,EAAKjc,IAAIzF,GACvBrC,KAAK8H,IAAIf,GAAKgd,EAAKhc,IAAIhB,GACvB/G,KAAK+H,IAAIhB,GAAKgd,EAAKjc,IAAIf,GACvB/G,KAAK8H,IAAIgG,GAAKiW,EAAKhc,IAAI+F,GACvB9N,KAAK+H,IAAI+F,GAAKiW,EAAKjc,IAAIgG,EAAAA,CAI3BD,iBAAiBkW,GAEf,OADAve,EAAWoe,GAAMG,KAEf/jB,KAAK8H,IAAIzF,GAAK0hB,EAAKhc,IAAI1F,GACvBrC,KAAK+H,IAAI1F,GAAK0hB,EAAKjc,IAAIzF,GACvBrC,KAAK8H,IAAIf,GAAKgd,EAAKhc,IAAIhB,GACvB/G,KAAK+H,IAAIhB,GAAKgd,EAAKjc,IAAIf,EAAAA,CAI3B8G,cAAc5E,GAEZ,OADAoB,EAAcpB,GAEZjJ,KAAK8H,IAAIzF,GAAK4G,EAAE5G,GAChBrC,KAAK8H,IAAIf,GAAKkC,EAAElC,GAChB/G,KAAK8H,IAAIgG,GAAK7E,EAAE6E,GAChB9N,KAAK+H,IAAI1F,GAAK4G,EAAE5G,GAChBrC,KAAK+H,IAAIhB,GAAKkC,EAAElC,GAChB/G,KAAK+H,IAAI+F,GAAK7E,EAAE6E,CAAC,CAIrBD,eAAe8W,EAAYrV,GAGzB,OAFAjF,EAAcsa,GACd/e,EAAc0J,GACPtP,KAAK4kB,gBAAgBD,GAAUrV,CAAC,CAGzCzB,iBAAiB8W,EAAYrV,GAG3B,OAFAjF,EAAcsa,GACd/e,EAAc0J,GACPtP,KAAK4kB,gBAAgBD,IAAWrV,CAAC,CAG1CzB,gBAAgB5E,GACdoB,EAAcpB,GACd,MAAM5G,EAAI4G,EAAE5G,EACV0E,EAAIkC,EAAElC,EACN+G,EAAI7E,EAAE6E,EACFhG,EAAM9H,KAAK8H,IACfC,EAAM/H,KAAK+H,IACb,OAAI/H,KAAK6kB,cAAc5b,GACd9D,KAAK4C,IACVD,EAAIzF,EAAIA,EACRA,EAAI0F,EAAI1F,EACRyF,EAAIf,EAAIA,EACRA,EAAIgB,EAAIhB,EACRe,EAAIgG,EAAIA,EACRA,EAAI/F,EAAI+F,GAGL7E,EAAE6b,WACP,IAAIta,EACF3C,EAAMxF,EAAGyF,EAAIzF,EAAG0F,EAAI1F,GACpBwF,EAAMd,EAAGe,EAAIf,EAAGgB,EAAIhB,GACpBc,EAAMiG,EAAGhG,EAAIgG,EAAG/F,EAAI+F,IAAAA,CAK1BD,aAAakW,GAEX,OADAve,EAAWoe,GAAMG,GACV/jB,KAAK6kB,cAAcd,EAAKjc,MAAQ9H,KAAK6kB,cAAcd,EAAKhc,IAAI,CAGrE8F,SAASkW,GAEP,OADAve,EAAWoe,GAAMG,GACV/jB,KAAK8H,IAAIxF,KAAKyhB,EAAKjc,MAAQ9H,KAAK+H,IAAIzF,KAAKyhB,EAAKhc,IAAI,CAG3D8F,eAAe4Q,GAMbpU,EAAcoU,EAAKC,OAAQD,EAAKE,MAChC,MAAMJ,EAAME,EAAKE,KAAKne,KAAKqM,GAAOA,GAAMzI,SAClC2gB,EAAQ/kB,KAAK8H,IAAI8H,MAAM6O,EAAKC,QAAQsG,KAAKzG,GACzC0G,EAAQjlB,KAAK+H,IAAI6H,MAAM6O,EAAKC,QAAQsG,KAAKzG,GACzC2G,EAAOH,EAAMjd,IAAImd,GAAOE,aAC5BC,EAAOL,EAAMhd,IAAIkd,GAAOI,aAC1B,OAAOH,GAAQE,KAAUA,EAAO3G,EAAKyG,MAAQzG,EAAK2G,KAAOF,EAAAA,CAG3DrX,YACE,OACE7N,KAAK8H,IAAIzF,GAAKrC,KAAK+H,IAAI1F,GACvBrC,KAAK8H,IAAIf,GAAK/G,KAAK+H,IAAIhB,GACvB/G,KAAK8H,IAAIgG,GAAK9N,KAAK+H,IAAI+F,CAAC,CAI5BD,SACE,IAAK7N,KAAKslB,YACR,OAAQ,EAEV,MAAMrW,EAAIjP,KAAK+H,IAAI6H,MAAM5P,KAAK8H,KAC9B,OAAOmH,EAAE5M,EAAI4M,EAAElI,EAAIkI,EAAEnB,CAAC,CAGxBD,OACE,OAAO7N,KAAK+H,IAAI6H,MAAM5P,KAAK8H,IAAI,CAGjC+F,YACE,OAAO7N,KAAK8H,IAAIuI,KAAKrQ,KAAK+H,KAAKiJ,IAAI,EAAE,CAGvCnD,UAAUkR,GACRvZ,EAAW+M,GAAIwM,GACfhZ,EAAOgZ,EAAGwG,iBACV,MAAMxB,EAAO,IAAIH,GAGjB,OAFAG,EAAKG,SAASnF,EAAG2C,eAAe1hB,KAAK8H,MACrCic,EAAKG,SAASnF,EAAG2C,eAAe1hB,KAAK+H,MAC9Bgc,CAAAA,CAGTlW,cAAckR,GACZvZ,EAAW+M,GAAIwM,GACf,MAAMgF,EAAO,IAAIH,GAEjB,OADAG,EAAKyB,UAAUzG,EAAG0G,kBAAkBzlB,KAAK0lB,YAClC3B,CAAAA,CAGTlW,UACE,MAAM/F,IAAEA,EAAGC,IAAEA,GAAQ/H,KACrB,MAAO,CACL8H,EACA,IAAI0C,EAAG1C,EAAIzF,EAAGyF,EAAIf,EAAGgB,EAAI+F,GACzB,IAAItD,EAAG1C,EAAIzF,EAAG0F,EAAIhB,EAAGe,EAAIgG,GACzB,IAAItD,EAAG1C,EAAIzF,EAAG0F,EAAIhB,EAAGgB,EAAI+F,GAEzB,IAAItD,EAAGzC,EAAI1F,EAAGyF,EAAIf,EAAGe,EAAIgG,GACzB,IAAItD,EAAGzC,EAAI1F,EAAGyF,EAAIf,EAAGgB,EAAI+F,GACzB,IAAItD,EAAGzC,EAAI1F,EAAG0F,EAAIhB,EAAGe,EAAIgG,GACzB/F,EAAAA,CAIJ8F,WACE,OAAO1D,EAAW,WAAYnK,KAAK8H,IAAK9H,KAAK+H,IAAI,CAGnD8F,WACE,OAAO7N,KAAKI,UAAU,CAIxByN,QACE,OAAO0E,GAAGG,UAAU1S,KAAK8H,KAAKsI,MAAMmC,GAAGI,MAAM3S,KAAK+C,QAAQ,E","sources":["/dev/workshop/./node_modules/javasetmap.ts/src/JavaMap.ts?","/dev/workshop/./node_modules/ts3dutils/src/toSource.ts?","/dev/workshop/./node_modules/ts3dutils/src/util.ts?","/dev/workshop/./node_modules/ts3dutils/src/NLA.ts?","/dev/workshop/./node_modules/ts3dutils/src/arrayUtils.ts?","/dev/workshop/./node_modules/ts3dutils/src/V3.ts?","/dev/workshop/./node_modules/ts3dutils/src/Transformable.ts?","/dev/workshop/./node_modules/ts3dutils/src/Matrix.ts?","/dev/workshop/./node_modules/ts3dutils/src/M4.ts?","/dev/workshop/./node_modules/ts3dutils/src/Vector.ts?","/dev/workshop/./node_modules/ts3dutils/src/AABB.ts?"],"sourcesContent":["import { Equalable, int } from \"./Equalable\"\n\n/**\n * Java style map.\n */\nexport class JavaMap<\n  K extends Equalable & { hashCodes?(): int[]; like?(x: any): boolean },\n  V\n> implements Map<K, V> {\n  [Symbol.toStringTag]: \"Map\" = \"Map\"\n\n  toString() {\n    return (\n      \"{\" +\n      Array.from(this.entries2())\n        .map(({ key, value }) => key + \":\" + value)\n        .join(\", \") +\n      \"}\"\n    )\n  }\n\n  forEach(\n    callbackfn: (value: V, index: K, map: Map<K, V>) => void,\n    thisArg?: any\n  ): void {\n    for (const bucket of this._map.values()) {\n      for (const { key, value } of bucket) {\n        callbackfn.call(thisArg, value, key, this)\n      }\n    }\n  }\n\n  *keys(): IterableIterator<K> {\n    for (const bucket of this._map.values()) {\n      for (const { key } of bucket) {\n        yield key\n      }\n    }\n  }\n\n  *values(): IterableIterator<V> {\n    for (const bucket of this._map.values()) {\n      for (const { value } of bucket) {\n        yield value\n      }\n    }\n  }\n\n  protected _map: Map<int, { key: K; value: V }[]>\n  protected _size: int\n\n  constructor() {\n    this._map = new Map()\n    this._size = 0\n  }\n\n  [Symbol.iterator]() {\n    return this.entries()\n  }\n\n  set(key: K, value: V): this {\n    this.set2(key, value)\n    return this\n  }\n\n  /**\n   * Like {@link #set} except it returns true if key was new and false if the value was only updated.\n   *\n   */\n  set2(key: K, val: V): boolean {\n    const hashCode = key.hashCode(),\n      bucket = this._map.get(hashCode)\n    //assert(hashCode === (hashCode | 0))\n    if (bucket) {\n      const pairIndex = bucket.findIndex((pair) => pair.key.equals(key))\n      if (-1 == pairIndex) {\n        bucket.push({ key: key, value: val })\n      } else {\n        bucket[pairIndex].value = val\n        return false\n      }\n    } else {\n      this._map.set(hashCode, [{ key: key, value: val }])\n    }\n    this._size++\n    return true\n  }\n\n  has(key: K): boolean {\n    const hashCode = key.hashCode(),\n      bucket = this._map.get(hashCode)\n    //assert(hashCode === (hashCode | 0))\n    return undefined !== bucket && bucket.some((pair) => pair.key.equals(key))\n  }\n\n  get(key: K): V | undefined {\n    const hashCode = key.hashCode(),\n      bucket = this._map.get(hashCode),\n      pair = bucket && bucket.find((pair) => pair.key.equals(key))\n    return pair && pair.value\n  }\n\n  getLike(key: K) {\n    for (const hashCode of key.hashCodes!()) {\n      const bucket = this._map.get(hashCode)\n      const canonVal = bucket && bucket.find((x) => x.key.like!(key))\n      if (canonVal) return canonVal\n    }\n  }\n\n  setLike(key: K, val: V) {\n    return !this.getLike(key) && this.set(key, val)\n  }\n\n  delete(key: K) {\n    const hashCode = key.hashCode(),\n      bucket = this._map.get(hashCode)\n    if (bucket) {\n      const index = bucket.findIndex((x) => x.key.equals(key))\n      if (-1 != index) {\n        if (1 == bucket.length) {\n          this._map.delete(hashCode)\n        } else {\n          bucket.splice(index, 1)\n        }\n        this._size--\n        return true\n      }\n    }\n    return false\n  }\n\n  deleteLike(key: K) {\n    for (const hashCode of key.hashCodes!()) {\n      const bucket = this._map.get(hashCode)\n      if (bucket) {\n        const index = bucket.findIndex((x) => x.key.like!(key))\n        if (-1 != index) {\n          const deleted = bucket[index]\n          if (1 == bucket.length) {\n            this._map.delete(hashCode)\n          } else {\n            bucket.splice(index, 1)\n          }\n          this._size--\n          return deleted\n        }\n      }\n    }\n  }\n\n  *entries2(): IterableIterator<{ key: K; value: V }> {\n    for (const bucket of this._map.values()) {\n      yield* bucket\n    }\n  }\n\n  *entries(): IterableIterator<[K, V]> {\n    for (const bucket of this._map.values()) {\n      for (const { key, value } of bucket) {\n        yield [key, value]\n      }\n    }\n  }\n\n  clear() {\n    this._map.clear()\n    this._size = 0\n  }\n\n  get size() {\n    return this._size\n  }\n}\n","declare global {\n  interface Object {\n    toSource(): string\n  }\n}\nconst KEYWORD_REGEXP = new RegExp(\n  \"^(\" +\n    \"abstract|boolean|break|byte|case|catch|char|class|const|continue|debugger|\" +\n    \"default|delete|do|double|else|enum|export|extends|false|final|finally|\" +\n    \"float|for|function|goto|if|implements|import|in|instanceof|int|interface|\" +\n    \"long|native|new|null|package|private|protected|public|return|short|static|\" +\n    \"super|switch|synchronized|this|throw|throws|transient|true|try|typeof|\" +\n    \"undefined|var|void|volatile|while|with\" +\n    \")$\",\n)\nfunction stringIsLegalKey(key: string) {\n  return /^[a-z_$][0-9a-z_$]*$/gi.test(key) && !KEYWORD_REGEXP.test(key)\n}\n\nconst seen: {}[] = []\nexport function toSource(o: any, indent = 0) {\n  switch (typeof o) {\n    case \"undefined\":\n      return \"undefined\"\n    case \"function\":\n      return o.toString()\n    case \"number\":\n    case \"boolean\":\n      return \"\" + o\n    case \"string\":\n      return JSON.stringify(o)\n    case \"object\":\n      if (null == o) {\n        return \"null\"\n      } else {\n        return o.sce\n      }\n    default:\n      throw new Error(typeof o)\n  }\n}\nfunction addToSourceMethodToPrototype<T>(\n  clazz: new (...args: any[]) => T,\n  method: (this: T) => string,\n) {\n  if (!clazz.prototype.toSource) {\n    Object.defineProperty(clazz.prototype, \"toSource\", {\n      value: method,\n      writable: true,\n      configurable: true,\n      enumerable: false,\n    })\n  }\n}\n\naddToSourceMethodToPrototype(Boolean, Boolean.prototype.toString)\naddToSourceMethodToPrototype(Function, Function.prototype.toString)\naddToSourceMethodToPrototype(Number, Number.prototype.toString)\naddToSourceMethodToPrototype(RegExp, RegExp.prototype.toString)\naddToSourceMethodToPrototype(Date, function () {\n  return \"new Date(\" + this.getTime() + \")\"\n})\naddToSourceMethodToPrototype(String, function () {\n  return JSON.stringify(this)\n})\naddToSourceMethodToPrototype(Array, function (this: any[]) {\n  if (seen.includes(this)) {\n    return \"CIRCULAR_REFERENCE\"\n  }\n  seen.push(this)\n  let result = \"[\"\n  for (let i = 0; i < this.length; i++) {\n    result += \"\\n\\t\" + toSource(this[i]).replace(/\\r\\n|\\n|\\r/g, \"$&\\t\")\n    if (i !== this.length - 1) {\n      result += \",\"\n    }\n  }\n  result += 0 === this.length ? \"]\" : \"\\n]\"\n  seen.pop()\n  return result\n})\naddToSourceMethodToPrototype(Object, function () {\n  if (seen.includes(this)) {\n    return \"CIRCULAR_REFERENCE\"\n  }\n  seen.push(this)\n  let result = \"{\"\n  const keys = Object.keys(this).sort()\n  for (let i = 0; i < keys.length; i++) {\n    const k = keys[i]\n    result +=\n      \"\\n\\t\" +\n      (stringIsLegalKey(k) ? k : JSON.stringify(k)) +\n      \": \" +\n      toSource((this as any)[k]).replace(/\\r\\n|\\n|\\r/g, \"$&\\t\")\n    if (i !== keys.length - 1) {\n      result += \",\"\n    }\n  }\n  result += 0 === keys.length ? \"}\" : \"\\n}\"\n  seen.pop()\n  return result\n})\n","import { toSource } from \".\"\n\nexport const PI = Math.PI\nexport const TAU = 2 * PI\n/** Alias for number. Doesn't change anything for type-checking, but it is useful for documentation purposes. */\nexport type int = number\n/** Alias for number. Doesn't change anything for type-checking, but it is useful for documentation purposes. */\nexport type raddd = number\nexport type colorstr = string // e.g. '#abcdef\nexport type FloatArray = Float32Array | Float64Array | number[]\n\n/** Use rollup-plugin-replace or similar to avoid error in browser. */\n// @ts-ignore\nexport const NLA_DEBUG = process.env.NODE_ENV != \"production\"\nexport const NLA_PRECISION = 1 / (1 << 26)\n\nlet oldConsole: any = undefined\n\nexport function disableConsole() {\n  oldConsole = console.log\n  console.log = function () {}\n}\n\nexport function enableConsole() {\n  if (oldConsole) {\n    console.log = oldConsole\n  }\n}\n\nexport function hasConstructor<T>(\n  instance: any,\n  cons: { new (...args: any[]): T },\n): instance is T {\n  return instance.constructor == cons\n}\n\nexport function assertInst<T>(what: Function & { prototype: T }, ...objs: T[]) {\n  if (NLA_DEBUG) {\n    for (let i = 0; i < objs.length; i++) {\n      if (!(objs[i] instanceof what)) {\n        throw new Error(\n          \"assertInst objs[\" +\n            i +\n            \"] is not a \" +\n            what.prototype.name +\n            \". \" +\n            (objs[i] as any)?.constructor?.name +\n            objs[i],\n        )\n      }\n    }\n  }\n  return true\n}\n\nexport function assertNumbers(...numbers: number[]): void {\n  if (NLA_DEBUG) {\n    for (let i = 0; i < numbers.length; i++) {\n      if (\"number\" !== typeof numbers[i]) {\n        throw new Error(\n          `assertNumbers arguments[${i}] is not a number. ${typeof numbers[\n            i\n          ]} == typeof ${numbers[i]}`,\n        )\n      }\n    }\n  }\n}\n\nexport function assertInts(...numbers: number[]): void {\n  if (NLA_DEBUG) {\n    for (let i = 0; i < numbers.length; i++) {\n      if (\"number\" !== typeof numbers[i] || numbers[i] % 1 !== 0) {\n        throw new Error(\n          `assertNumbers arguments[${i}] is not an int. ${typeof numbers[\n            i\n          ]} == typeof ${numbers[i]}`,\n        )\n      }\n    }\n  }\n}\n\nexport function assertReals(...numbers: number[]): void {\n  if (NLA_DEBUG) {\n    for (let i = 0; i < numbers.length; i++) {\n      const x = numbers[i]\n      //noinspection SuspiciousTypeOfGuard\n      if (\"number\" !== typeof x || isNaN(x) || !isFinite(x)) {\n        throw new Error(`assertNumbers arguments[${i}] = ${x} is not a real.`)\n      }\n    }\n  }\n}\n\nexport function assert(\n  value: any,\n  ...messages: (any | (() => string))[]\n): value is true {\n  if (NLA_DEBUG && !value) {\n    throw new Error(\n      \"assert failed: \" +\n        messages\n          .map((message) =>\n            \"function\" === typeof message ? message() : message || \"\",\n          )\n          .join(\"\\n\"),\n    )\n  }\n  return true\n}\n\nexport function assertNever(value?: never): never {\n  throw new Error(value)\n}\n\nexport function assertf(f: () => any, ...messages: (any | (() => any))[]) {\n  if (NLA_DEBUG && !f()) {\n    throw new Error(\n      \"assertf failed: \" +\n        f.toString() +\n        messages\n          .map((message) =>\n            \"function\" === typeof message ? message() : message || \"\",\n          )\n          .join(\"\\n\"),\n    )\n  }\n}\n\nexport function assertBetween(\n  minInclusive: number,\n  maxInclusive: number,\n  value: number,\n  message: string,\n) {\n  if (NLA_DEBUG && !between(value, minInclusive, maxInclusive)) {\n    throw new Error(\n      `${value} is not in [${minInclusive}, ${maxInclusive}] (${message})`,\n    )\n  }\n}\n\nexport function lerp(a: number, b: number, t: number) {\n  return a * (1 - t) + b * t\n}\n\nexport function lerpInv(a: number, b: number, t: number) {\n  return (t - a) / (b - a)\n}\n\nconst originalNumberToString = Number.prototype.toString\nNumber.prototype.toString = function (radix) {\n  if (PI == this) {\n    return \"PI\"\n  }\n  return originalNumberToString.call(this, radix)\n}\n\nexport const eq0 = (x: number, EPS: number = NLA_PRECISION): boolean =>\n  Math.abs(x) <= EPS\nexport const eq = (\n  x: number,\n  y: number,\n  EPS: number = NLA_PRECISION,\n): boolean => Math.abs(x - y) <= EPS\nexport const lt = (\n  x: number,\n  y: number,\n  EPS: number = NLA_PRECISION,\n): boolean => x - y < -EPS\nexport const gt = (\n  x: number,\n  y: number,\n  EPS: number = NLA_PRECISION,\n): boolean => y - x < -EPS\nexport const le = (\n  x: number,\n  y: number,\n  EPS: number = NLA_PRECISION,\n): boolean => x - y <= EPS\nexport const ge = (\n  x: number,\n  y: number,\n  EPS: number = NLA_PRECISION,\n): boolean => y - x <= EPS\n\nexport const eqAngle = (x: number, y: number): boolean => zeroAngle(x - y)\nexport const zeroAngle = (x: number): boolean =>\n  ((x % (2 * Math.PI)) + 2 * Math.PI + NLA_PRECISION) % (2 * Math.PI) <\n  2 * NLA_PRECISION\nexport const snap = (x: number, to: number): number =>\n  Math.abs(x - to) <= NLA_PRECISION ? to : x\nexport const snap2 = (x: number, ...to: number[]): number =>\n  to.reduce((x, to) => (Math.abs(x - to) <= NLA_PRECISION ? to : x), x)\nexport const snapEPS = (x: number, EPS: number, ...to: number[]): number =>\n  to.reduce((x, to) => (Math.abs(x - to) <= EPS ? to : x), x)\nexport const snap0 = (x: number, EPS = NLA_PRECISION): number =>\n  Math.abs(x) <= EPS ? 0 : x\nexport const canonAngle = (x: number): number =>\n  ((x % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI)\n\n/** @deprecated */ export const eq02 = eq0\n\n/**\n * Decimal adjustment of a number.\n *\n * @param f The type of adjustment.\n * @param value The number.\n * @param exp The exponent (the 10 logarithm of the adjustment base).\n * @returns The adjusted value.\n */\nfunction decimalAdjust(\n  f: (x: number) => number,\n  value: number,\n  exp: number,\n): number {\n  // If the exp is undefined or zero...\n  if (typeof exp === \"undefined\" || +exp === 0) {\n    return f(value)\n  }\n  value = +value\n  exp = +exp\n  // If the value is not a number or the exp is not an integer...\n  if (isNaN(value) || !(typeof exp === \"number\" && exp % 1 === 0)) {\n    return NaN\n  }\n  // Shift\n  let vs = value.toString().split(\"e\")\n  value = f(+(vs[0] + \"e\" + (vs[1] ? +vs[1] - exp : -exp)))\n  // Shift back\n  vs = value.toString().split(\"e\")\n  return +(vs[0] + \"e\" + (vs[1] ? +vs[1] + exp : exp))\n}\n\nexport const round10: (\n  value: number,\n  exp: number,\n) => number = decimalAdjust.bind(undefined, Math.round)\nexport const floor10: (\n  value: number,\n  exp: number,\n) => number = decimalAdjust.bind(undefined, Math.floor)\nexport const ceil10: (\n  value: number,\n  exp: number,\n) => number = decimalAdjust.bind(undefined, Math.ceil)\n\nexport const GOLDEN_RATIO = (1 + Math.sqrt(5)) / 2\n\nexport function mod(a: number, b: number) {\n  return ((a % b) + b) % b\n}\n\nexport function clamp(val: number, min: number, max: number) {\n  assertNumbers(val, min, max)\n  return Math.max(min, Math.min(max, val))\n}\n\nexport function between(\n  val: number,\n  minInclusive: number,\n  maxInclusive: number,\n) {\n  assertNumbers(val, minInclusive, maxInclusive)\n  return minInclusive <= val && val <= maxInclusive\n}\n\nexport function fuzzyBetween(val: number, min: number, max: number) {\n  assertNumbers(val, min, max)\n  return le(min, val) && le(val, max)\n}\n\nexport function mapPush<T, U>(map: Map<T, U[]>, key: T, val: U) {\n  const array = map.get(key)\n  if (array) {\n    array.push(val)\n  } else {\n    map.set(key, [val])\n  }\n}\n\nexport function fuzzyUniques(vals: number[]): number[] {\n  const round = (val: number) => Math.floor(val * (1 << 26)) / (1 << 26)\n  const map = new Map()\n  for (let i = 0; i < vals.length; i++) {\n    const val = vals[i],\n      roundVal = round(val)\n    let key\n    if (\n      !map.has(roundVal) &&\n      !((key = map.get(roundVal - 1 / (1 << 26))) && eq(key, val)) &&\n      !((key = map.get(roundVal + 1 / (1 << 26))) && eq(key, val))\n    ) {\n      map.set(roundVal, val)\n    }\n  }\n  return Array.from(map.values())\n}\n\nexport function fuzzyUniquesF<T>(vals: T[], f: (o: T) => number): T[] {\n  const round = (val: number) => Math.floor(val * (1 << 26)) / (1 << 26)\n  const map = new Map()\n  for (let i = 0; i < vals.length; i++) {\n    const val = vals[i],\n      roundVal = round(f(val))\n    let key\n    if (\n      !map.has(roundVal) &&\n      !((key = map.get(roundVal - 1 / (1 << 26))) && eq(key, f(val))) &&\n      !((key = map.get(roundVal + 1 / (1 << 26))) && eq(key, f(val)))\n    ) {\n      map.set(roundVal, val)\n    }\n  }\n  return Array.from(map.values())\n}\n\nexport function addOwnProperties(\n  target: any,\n  props: any,\n  ...exclude: string[]\n) {\n  Object.getOwnPropertyNames(props).forEach((key) => {\n    //console.log(props, key)\n    if (!exclude.includes(key)) {\n      if (target.hasOwnProperty(key)) {\n        console.warn(\n          \"target \",\n          target,\n          \" already has property \",\n          key,\n          target[key],\n        )\n      }\n      Object.defineProperty(\n        target,\n        key,\n        Object.getOwnPropertyDescriptor(props, key)!,\n      )\n    }\n  })\n}\n\nexport let defaultRoundFunction = (x: number) => x // Math.round10(x, -4)\n\nexport function forceFinite(val: string): number {\n  const valNum = parseFloat(val.replace(\",\", \".\").replace(/^[^0-9,.\\-]/, \"\"))\n  return Number.isFinite(valNum) ? valNum : 0\n}\n\nexport const MINUS = (a: number, b: number) => a - b\n\nexport function floatHashCode(f: number) {\n  return ~~(f * (1 << 28))\n}\n\n/**\n * @example\n *   combinations(2) // [0,0] [0,1] [1,1] [0,2] [1,2] [2,2]\n */\nexport function* combinations(\n  n: int,\n): IterableIterator<{ i: number; j: number }> {\n  for (let i = 0; i < n; i++) {\n    for (let j = i; j < n; j++) {\n      yield { i: i, j: j }\n    }\n  }\n}\n\n/* The arithmetic-geometric mean of two non-negative numbers */\nexport function arithmeticGeometricMean(x: number, y: number): number {\n  assertf(() => lt(0, x))\n  assertf(() => lt(0, y))\n  let a = x,\n    g = y\n  let i = 30\n  while (i-- && a != g) {\n    ;[a, g] = [(a + g) / 2, Math.sqrt(a * g)]\n  }\n  assert(i != -1)\n\n  return a\n}\n\n/** One degree in radians. Use like Math.sin(30 * DEG). */\nexport const DEG = 0.017453292519943295\n\nexport function rad2deg(rad: number): number {\n  //  discuss at: http://phpjs.org/functions/deg2rad/\n  // original by: Enrique Gonzalez\n  // improved by: Thomas Grainger (http://graingert.co.uk)\n  //   example 1: deg2rad(45)\n  //   returns 1: 0.7853981633974483\n\n  return rad / DEG\n}\n\n/**\n * @example\n *   numberToStr(2 / 3) // \"0.6p\"\n *   numberToStr(7 / 12) // \"0.583p\"\n *   numberToStr(2 / 7) // \"0.285714pppppp\"\n *   numberToStr(NLA_PRECISION) // \"0+\"\n *   numberToStr(-NLA_PRECISION) // \"0-\"\n *   numberToStr(2 - NLA_PRECISION) // \"2-\"\n *   numberToStr(0) // \"0=\"\n */\nexport function numberToStr(value: number, length: int) {\n  let minAbsDiff = Infinity,\n    closestValue: number | undefined = undefined,\n    closestValueStr: string | undefined = undefined\n\n  function test(testValue: number, testValueStr: string) {\n    const absDiff = Math.abs(testValue - value)\n    console.log(testValue, testValueStr, absDiff)\n    if (absDiff < minAbsDiff) {\n      minAbsDiff = absDiff\n      closestValue = testValue\n      closestValueStr = testValueStr\n    }\n    return 0 == absDiff\n  }\n\n  function overline(str: string) {\n    return str\n      .split(\"\")\n      .map((c) => c + \"\\u0304\")\n      .join(\"\")\n  }\n\n  if (test(parseFloat(value.toFixed(length)), value.toFixed(length)))\n    return closestValueStr + \"=\"\n\n  const valueStr = \"\" + value\n  const toDecimal = valueStr.substr(0, valueStr.indexOf(\".\") + 1)\n  const decimals = valueStr.substr(valueStr.indexOf(\".\") + 1)\n\n  for (let startPos = 0; startPos < length; startPos++) {\n    for (let endPos = startPos + 1; endPos <= length; endPos++) {\n      const prefixDecimals = decimals.substr(0, startPos)\n      const period = decimals.substr(startPos, endPos)\n      const testValue = parseFloat(\n        toDecimal +\n          prefixDecimals +\n          period.repeat(Math.ceil((17 - startPos) / period.length)),\n      )\n      if (test(testValue, toDecimal + prefixDecimals + overline(period)))\n        return closestValueStr + \"=\"\n    }\n  }\n\n  return closestValueStr + (closestValue! < value ? \"-\" : \"+\")\n}\n\nexport function time(f: () => void) {\n  const start = performance.now()\n  f()\n  return performance.now() - start\n}\n\nexport type Tuple2<T> = [T, T]\nexport type Tuple3<T> = [T, T, T]\nexport type Tuple4<T> = [T, T, T, T]\nexport type Tuple5<T> = [T, T, T, T, T]\nexport type Tuple6<T> = [T, T, T, T, T, T]\nexport type Tuple7<T> = [T, T, T, T, T, T, T]\nexport type Tuple8<T> = [T, T, T, T, T, T, T, T]\n//console.log(numberToStr(29 / 99, 4))\n//console.log(numberToStr(77 / 99, 4))\n\n// interface Object {\n//    cw(f: (x: any) => any): any\n// }\n//Object.prototype.cw = function (f) {\n//    return f(this)\n//}\n//Object.construct = function <T>(cons: {new(...args: any[]): T}, args: any[]) {\n//    return f(this)\n//}\ndeclare global {\n  interface Object {\n    sce: string\n\n    toSource(): string\n  }\n\n  interface ObjectConstructor {\n    construct<T>(cons: { new (...args: any[]): T }, args: any[]): T\n\n    map<T, S, K extends string>(\n      o: { [k in K]: T },\n      f: (this: undefined, v: T, key: string, o: { [k in K]: T }) => S,\n    ): { [k in K]: S }\n\n    map<T, S, K extends string, C>(\n      o: { [k in K]: T },\n      f: (this: C, v: T, key: string, o: { [k in K]: T }) => S,\n      context: C,\n    ): { [k in K]: S }\n  }\n\n  interface Array<T> {\n    /** `this[this.length - 1]` */\n    map<U>(\n      this: [T],\n      callbackfn: (value: T, index: number, array: T[]) => U,\n      thisArg?: any,\n    ): [U]\n\n    map<U>(\n      this: Tuple2<T>,\n      callbackfn: (value: T, index: number, array: T[]) => U,\n      thisArg?: any,\n    ): Tuple2<U>\n\n    map<U>(\n      this: Tuple3<T>,\n      callbackfn: (value: T, index: number, array: T[]) => U,\n      thisArg?: any,\n    ): Tuple3<U>\n\n    map<U>(\n      this: Tuple4<T>,\n      callbackfn: (value: T, index: number, array: T[]) => U,\n      thisArg?: any,\n    ): Tuple4<U>\n\n    map<U>(\n      this: Tuple5<T>,\n      callbackfn: (value: T, index: number, array: T[]) => U,\n      thisArg?: any,\n    ): Tuple5<U>\n\n    map<U>(\n      this: Tuple6<T>,\n      callbackfn: (value: T, index: number, array: T[]) => U,\n      thisArg?: any,\n    ): Tuple6<U>\n\n    map<U>(\n      this: Tuple7<T>,\n      callbackfn: (value: T, index: number, array: T[]) => U,\n      thisArg?: any,\n    ): Tuple7<U>\n\n    map<U>(\n      this: Tuple8<T>,\n      callbackfn: (value: T, index: number, array: T[]) => U,\n      thisArg?: any,\n    ): Tuple8<U>\n  }\n\n  interface String {\n    capitalizeFirstLetter(): string\n\n    equals(x: any): boolean\n  }\n}\nObject.map = function <T, S, K extends string>(\n  o: { [k in K]: T },\n  f: (v: T, key: string, o: { [k in K]: T }) => S,\n  context: any = undefined,\n): { [k in K]: S } {\n  const result = {} as { [k in K]: S }\n  for (const key in o) {\n    result[key] = f.call(context, o[key], key, o)\n  }\n  return result\n}\n\nexport function arrayHashCode(arr: any[]): int {\n  let result = 0\n  for (let i = 0; i < arr.length; i++) {\n    result = (result * 31 + hashCode(arr[i])) | 0\n  }\n  return result | 0\n}\n\nexport function hashCode(o: any) {\n  if (\"number\" === typeof o || undefined === o) {\n    return o | 0\n  } else if (Array.isArray(o)) {\n    return arrayHashCode(o)\n  } else {\n    return null === o ? 0 : o.hashCode()\n  }\n}\n\nString.prototype.capitalizeFirstLetter = function () {\n  return this.charAt(0).toUpperCase() + this.slice(1)\n}\nString.prototype.equals = function (x: any) {\n  return this == x\n}\n\nexport function toString(o: any) {\n  return o.toString()\n}\n\nObject.defineProperty(Object.prototype, \"sce\", {\n  get: function () {\n    return this.toSource()\n  },\n  configurable: true,\n})\n\n/*\nObject.defineProperty(Object.prototype, \"str\", {\n  get: function () {\n    return this.toString()\n  },\n  configurable: true,\n})\n */\n\nexport function ilog<T>(x: T) {\n  console.log(x)\n  return x\n}\n\n//const NLA = {}\n//for (let key in ARRAY_UTILITIES) {\n//    const nlaName = 'array' + key.capitalizeFirstLetter()\n//    assert(!NLA[nlaName])\n//    NLA[nlaName] = (arr, ...rest) => ARRAY_UTILITIES[key].apply(arr, rest)\n//}\n\n/** Solves x + px + q = 0 */\nexport function pqFormula(p: number, q: number): number[] {\n  // 4 times the discriminant:in\n  const discriminantX4 = (p * p) / 4 - q\n  if (discriminantX4 < -NLA_PRECISION) {\n    return []\n  } else if (discriminantX4 <= NLA_PRECISION) {\n    return [-p / 2]\n  } else {\n    const root = Math.sqrt(discriminantX4)\n    return [-p / 2 - root, -p / 2 + root]\n  }\n}\n\n/**\n * From pomax' library solves ax + bx + cx + d = 0 This function from pomax' utils\n *\n * @returns 0-3 roots\n */\nexport function solveCubicReal2(\n  a: number,\n  b: number,\n  c: number,\n  d: number,\n): number[] {\n  if (eq0(a)) {\n    if (eq0(b)) {\n      return [-d / c]\n    } else {\n      return pqFormula(c / b, d / b)\n    }\n  }\n  const divisor = a\n  a = b / divisor\n  b = c / divisor\n  c = d / divisor\n  const p = (3 * b - a * a) / 3,\n    pDiv3 = p / 3,\n    pDiv3Pow3 = pDiv3 * pDiv3 * pDiv3,\n    q = (2 * a * a * a - 9 * a * b + 27 * c) / 27,\n    qDiv2 = q / 2,\n    discriminant = qDiv2 * qDiv2 + pDiv3Pow3\n  // 18abcd - 4bd + bc - 4ac - 27ad\n  if (discriminant < -NLA_PRECISION / 8) {\n    const r = Math.sqrt(-pDiv3Pow3),\n      t = -q / (2 * r),\n      cosphi = t < -1 ? -1 : t > 1 ? 1 : t, // clamp t to [-1;1]\n      phi = Math.acos(cosphi),\n      t1 = 2 * Math.cbrt(r)\n    const x1 = t1 * Math.cos(phi / 3) - a / 3\n    const x2 = t1 * Math.cos((phi + 2 * Math.PI) / 3) - a / 3\n    const x3 = t1 * Math.cos((phi + 4 * Math.PI) / 3) - a / 3\n    return [x1, x2, x3]\n  } else if (discriminant <= NLA_PRECISION / 8) {\n    if (0 == qDiv2) {\n      // TODO: compare with likeO?\n      return [-a / 3]\n    }\n    const u1 = qDiv2 < 0 ? Math.cbrt(-qDiv2) : -Math.cbrt(qDiv2)\n    const x1 = 2 * u1 - a / 3\n    const x2 = -u1 - a / 3\n    return [x1, x2]\n  } else {\n    const sd = Math.sqrt(discriminant)\n    const u1 = Math.cbrt(-qDiv2 + sd)\n    const v1 = Math.cbrt(qDiv2 + sd)\n    return [u1 - v1 - a / 3]\n  }\n}\n\nexport function checkDerivate(\n  f: (x: number) => number,\n  df: (x: number) => number,\n  a: number,\n  b: number,\n  maxFaults: int = 0,\n) {\n  const eps = 1e-4\n  let faults = 0\n  for (let t = a; t < b; t += (b - a) / 100) {\n    const dfdt = df(t)\n    const df2 = (f(t + eps) - f(t)) / eps\n    assert(\n      (faults += +!eq(df2, dfdt, 0.1)) <= maxFaults,\n      `df2 == ${df2} != ${df(t)} = df(t)`,\n    )\n  }\n}\n\nexport function bisect(\n  f: (x: number) => number,\n  a: number,\n  b: number,\n  steps: int,\n) {\n  assert(a < b)\n  let fA = f(a),\n    fB = f(b)\n  assert(fA * fB < 0)\n  while (steps--) {\n    const c = (b + a) / 2\n    const fC = f(c)\n    if (Math.sign(fA) == Math.sign(fC)) {\n      a = c\n      fA = fC\n    } else {\n      b = c\n      fB = fC\n    }\n  }\n  assert(a <= (b + a) / 2)\n  assert(b >= (b + a) / 2)\n  return lerp(a, b, 0.5)\n}\n\nexport function callSource(name: string, ...params: any[]) {\n  return name + \"(\" + params.map(toSource).join(\",\") + \")\"\n}\n\nexport function removeJSComments(str: string) {\n  const SPLITTER = /\\/\\/[^\\r\\n]+(?:\\r\\n|\\n\\r|\\r|\\n|$)|\\/\\*(?:[^*]|\\*[^/])+\\*\\/|\"(?:[^\"\\\\]|\\\\.)+\"|'(?:[^'\\\\]|\\\\.)+'|[`}](?:[^`$\\\\]|\\$[^{]|\\\\.)+(?:`|\\${)|(?:\\/(?:(?:(?!\\\\*\\/).)|\\\\\\\\|\\\\\\/|[^\\\\]\\[(?:\\\\\\\\|\\\\]|[^]])+])+\\/)|[^`\"']/g\n  return str.replace(SPLITTER, (x) =>\n    x.startsWith(\"//\") || x.startsWith(\"/*\") ? \"\" : x,\n  )\n}\n","import {\n  Matrix,\n  NLA_DEBUG,\n  NLA_PRECISION,\n  V,\n  V3,\n  Vector,\n  arrayFromFunction,\n  assert,\n  eq,\n  eq0,\n  getLast,\n  int,\n  snap,\n  sumInPlaceTree,\n  FloatArray,\n} from \".\"\n\nexport const gaussLegendre24Xs: ReadonlyArray<number> = [\n  -0.0640568928626056260850430826247450385909,\n  0.0640568928626056260850430826247450385909,\n  -0.1911188674736163091586398207570696318404,\n  0.1911188674736163091586398207570696318404,\n  -0.3150426796961633743867932913198102407864,\n  0.3150426796961633743867932913198102407864,\n  -0.4337935076260451384870842319133497124524,\n  0.4337935076260451384870842319133497124524,\n  -0.5454214713888395356583756172183723700107,\n  0.5454214713888395356583756172183723700107,\n  -0.6480936519369755692524957869107476266696,\n  0.6480936519369755692524957869107476266696,\n  -0.7401241915785543642438281030999784255232,\n  0.7401241915785543642438281030999784255232,\n  -0.8200019859739029219539498726697452080761,\n  0.8200019859739029219539498726697452080761,\n  -0.8864155270044010342131543419821967550873,\n  0.8864155270044010342131543419821967550873,\n  -0.9382745520027327585236490017087214496548,\n  0.9382745520027327585236490017087214496548,\n  -0.9747285559713094981983919930081690617411,\n  0.9747285559713094981983919930081690617411,\n  -0.9951872199970213601799974097007368118745,\n  0.9951872199970213601799974097007368118745,\n]\nexport const gaussLegendre24Weights: ReadonlyArray<number> = [\n  0.1279381953467521569740561652246953718517,\n  0.1279381953467521569740561652246953718517,\n  0.1258374563468282961213753825111836887264,\n  0.1258374563468282961213753825111836887264,\n  0.121670472927803391204463153476262425607,\n  0.121670472927803391204463153476262425607,\n  0.1155056680537256013533444839067835598622,\n  0.1155056680537256013533444839067835598622,\n  0.1074442701159656347825773424466062227946,\n  0.1074442701159656347825773424466062227946,\n  0.0976186521041138882698806644642471544279,\n  0.0976186521041138882698806644642471544279,\n  0.086190161531953275917185202983742667185,\n  0.086190161531953275917185202983742667185,\n  0.0733464814110803057340336152531165181193,\n  0.0733464814110803057340336152531165181193,\n  0.0592985849154367807463677585001085845412,\n  0.0592985849154367807463677585001085845412,\n  0.0442774388174198061686027482113382288593,\n  0.0442774388174198061686027482113382288593,\n  0.0285313886289336631813078159518782864491,\n  0.0285313886289336631813078159518782864491,\n  0.0123412297999871995468056670700372915759,\n  0.0123412297999871995468056670700372915759,\n]\n\nexport function assertVectors(...vectors: (Vector | V3)[]) {\n  if (NLA_DEBUG) {\n    for (let i = 0; i < arguments.length; i++) {\n      if (!(arguments[i] instanceof V3 || arguments[i] instanceof Vector)) {\n        throw new Error(\n          \"assertVectors arguments[\" +\n            i +\n            \"] is not a vector. \" +\n            typeof arguments[i] +\n            \" == typeof \" +\n            arguments[i],\n        )\n      }\n    }\n  }\n  return true\n}\n\nexport function gaussLegendreQuadrature24(\n  f: (x: number) => number,\n  startT: number,\n  endT: number,\n): number {\n  //let result = 0\n  //for (let i = 0; i < gaussLegendre24Xs.length; i++) {\n  //\t// gauss-legendre goes from -1 to 1, so we need to scale\n  //\tlet t = startT + (gaussLegendre24Xs[i] + 1) / 2 * (endT - startT)\n  //\tresult += gaussLegendre24Weights[i] * f(t)\n  //}\n  //const result = NLA\n  //\t\t.arrayFromFunction(24, i => startT + (gaussLegendre24Xs[i] + 1) / 2 * (endT - startT))\n  //\t\t.map((t, i) => gaussLegendre24Weights[i] * f(t))\n  //\t\t.sumInPlaceTree()\n  //99.54182500782605\n  //99.54182500782602\n  // again, [-1,1], so div by 2\n  //return result // 2 * (endT - startT)\n\n  return (\n    (glq24_11((t) => f(startT + ((t + 1) / 2) * (endT - startT))) / 2) *\n    (endT - startT)\n  )\n}\n\n/**\n * Calculate the integral of f in the interval [-1;1].\n *\n * @param f\n */\nexport function glq24_11(f: (x: number) => number): number {\n  return sumInPlaceTree(\n    arrayFromFunction(\n      24,\n      (i) => gaussLegendre24Weights[i] * f(gaussLegendre24Xs[i]),\n    ),\n  )\n}\n\nexport function glqInSteps(\n  f: (x: number) => number,\n  startT: number,\n  endT: number,\n  steps: int,\n) {\n  const dt = (endT - startT) / steps\n  return (\n    (sumInPlaceTree(\n      arrayFromFunction(steps, (i) =>\n        glq24_11((t) => f(startT + dt * i + ((t + 1) / 2) * dt)),\n      ),\n    ) /\n      2) *\n    dt\n  )\n}\n\nexport function midpointRuleQuadrature(\n  f: (x: number) => number,\n  startT: number,\n  endT: number,\n  steps: int = 32,\n): number {\n  const dt = (endT - startT) / steps\n  return (\n    sumInPlaceTree(\n      arrayFromFunction(steps, (i) => startT + dt / 2 + dt * i).map(f),\n    ) * dt\n  )\n}\n\n/**\n * Incomplete elliptic integral of the first kind EllipticF(phi, k2) = INT[0;\n * phi] 1 / sqrt(1 - k2 * sin(phi)) dphi\n */\nexport function EllipticF(phi: number, k2: number): number {\n  return gaussLegendreQuadrature24(\n    (phi) => Math.pow(1 - k2 * Math.sin(phi) ** 2, -0.5),\n    0,\n    phi,\n  )\n}\n\n/**\n * Incomplete elliptic integral of the second kind EllipticE(phi, k2) = INT[0;\n * phi] sqrt(1 - k2 * sin(phi)) dphi\n */\nexport function EllipticE(phi: number, k2: number): number {\n  return gaussLegendreQuadrature24(\n    (phi) => Math.pow(1 - k2 * Math.sin(phi) ** 2, 0.5),\n    0,\n    phi,\n  )\n}\n\nexport function getIntervals(\n  ts: number[],\n  min: number,\n  max: number,\n): [number, number][] {\n  ts.sort((a, b) => a - b)\n  if (!eq(ts[0], min)) {\n    ts.splice(0, 0, min)\n  }\n  if (!eq(getLast(ts), max)) {\n    ts.push(max)\n  }\n  return arrayFromFunction(\n    ts.length - 1,\n    (i) => [ts[i], ts[i + 1]] as [number, number],\n  )\n}\n\nexport function isCCW(vertices: V3[], normal: V3) {\n  const dsa = doubleSignedArea(vertices, normal)\n  assert(0 != dsa)\n  return dsa < 0\n}\n\nexport function doubleSignedArea(vertices: V3[], normal: V3) {\n  assert(!normal.likeO(), \"!normal.likeO()\")\n  const absMaxDim = normal.maxAbsDim()\n  // order is important, coord0 and coord1 must be set so that coord0, coord1 and maxDim span a right-hand coordinate\n  // system var [coord0, coord1] = [['y', 'z'], ['z', 'x'], ['x', 'y']][maxAbsDim]\n  const doubleSignedArea = vertices\n    .map((v0, i, vertices) => {\n      const v1 = vertices[(i + 1) % vertices.length]\n      //return (v1[coord0] - v0[coord0]) * (v1[coord1] + v0[coord1])\n      switch (absMaxDim) {\n        case 0:\n          return (v1.y - v0.y) * (v1.z + v0.z)\n        case 1:\n          return (v1.z - v0.z) * (v1.x + v0.x)\n        case 2:\n          return (v1.x - v0.x) * (v1.y + v0.y)\n      }\n    })\n    .reduce((a, b) => a + b)\n  return snap(doubleSignedArea * Math.sign(normal.e(absMaxDim)), 0)\n}\n\nexport function newtonIterate(\n  f: (x: FloatArray) => ArrayLike<number>,\n  x: number[],\n  steps: int = 4,\n  EPSILON?: number,\n  stepize = 1,\n) {\n  EPSILON = EPSILON || 1e-8\n\n  for (let i = 0; i < steps; i++) {\n    const fx = f(x)\n    const dfdx = Matrix.jacobi(f, x, fx, EPSILON)\n    assert(!dfdx.isZero())\n    const dx = dfdx.solveLinearSystem(new Vector(new Float64Array(fx))).v\n    assert(!isNaN(dx[0]))\n    //console.log('fx / dfdx', fx / dfdx)\n    for (let j = 0; j < x.length; j++) x[j] -= dx[j] * stepize\n  }\n  return x\n}\n\nexport function newtonIterate1d(\n  f: (x: number) => number,\n  xStart: number,\n  steps: number | undefined,\n  df: (x: number) => number,\n): number\nexport function newtonIterate1d(\n  f: (x: number) => number,\n  xStart: number,\n  steps: number,\n  EPSILON?: number,\n): number\nexport function newtonIterate1d(\n  f: (x: number) => number,\n  xStart: number,\n  steps: number = 8,\n  epsOrDf: number | ((x: number) => number) = 1e-8,\n): number {\n  if (\"number\" === typeof epsOrDf) {\n    let x = xStart\n\n    for (let i = 0; i < steps; i++) {\n      const fx = f(x)\n      const dfdx = (f(x + epsOrDf) - fx) / epsOrDf\n      //console.log('fx / dfdx', fx / dfdx)\n      x = x - fx / dfdx\n    }\n    return x\n  } else {\n    return newtonIterateWithDerivative(f, xStart, steps, epsOrDf)\n  }\n}\n\nexport function newtonIterateWithDerivative(\n  f: (x: number) => number,\n  xStart: number,\n  steps: number = 4,\n  df: (x: number) => number,\n) {\n  let x = xStart\n  for (let i = 0; i < steps; i++) {\n    const fx = f(x)\n    const dfdx = df(x)\n    if (isNaN(fx) || isNaN(dfdx)) {\n      console.log()\n      //console.log('fx / dfdx', fx / dfdx)\n    }\n    x = x - fx / dfdx\n    if (isNaN(fx)) {\n      console.log()\n      //console.log('fx / dfdx', fx / dfdx)\n    }\n  }\n  return x\n}\n\nexport function newtonIterateWithDerivative2(\n  fAndDf: (x: number) => [number, number],\n  xStart: number,\n  steps: number = 8,\n  xMin = -Infinity,\n  xMax = Infinity,\n): number | undefined {\n  assert(steps % 1 == 0)\n  let x = xStart\n  for (let i = 0; i < steps; i++) {\n    const [fx, dfdx] = fAndDf(x)\n    if (isNaN(fx) || isNaN(dfdx)) {\n      console.log()\n      //console.log('fx / dfdx', fx / dfdx)\n    }\n    x = x - fx / dfdx\n    if (0 == dfdx || x < xMin || xMax < x) {\n      return undefined\n    }\n  }\n  return x\n}\n\nexport function newtonIterateSmart(\n  f: (x: number) => number,\n  xStart: number,\n  steps: number = 4,\n  df: (x: number) => number,\n  mindf = 1e-6,\n) {\n  let x = xStart\n  for (let i = 0; i < steps; i++) {\n    const fx = f(x)\n    const dfdx = df(x)\n    if (Math.abs(dfdx) < mindf && Math.abs(fx) < mindf) {\n      return newtonIterate1d(df, x, steps, df)\n    }\n    if (isNaN(fx) || isNaN(dfdx)) {\n      console.log()\n      //console.log('fx / dfdx', fx / dfdx)\n    }\n    x = x - fx / dfdx\n    if (isNaN(fx)) {\n      console.log()\n      //console.log('fx / dfdx', fx / dfdx)\n    }\n  }\n  return x\n}\n\nexport function newtonIterate2d(\n  f1: (s: number, t: number) => number,\n  f2: (s: number, t: number) => number,\n  sStart: number,\n  tStart: number,\n  steps?: number,\n): V3 | undefined {\n  const EPSILON = 1e-6\n  steps = steps || 4\n  let s = sStart,\n    t = tStart,\n    f1ts,\n    f2ts\n  do {\n    /*\n         | a b |-1                   |  d -b |\n         | c d |   = 1 / (ad - bc) * | -c  a |\n         */\n    f1ts = f1(s, t)\n    f2ts = f2(s, t)\n    /*\n         let df1s = (f1(s + EPSILON, t) - f1ts) / EPSILON, df1t = (f1(s, t + EPSILON) - f1ts) / EPSILON,\n         df2s = (f2(s + EPSILON, t) - f2ts) / EPSILON, df2t = (f2(s, t + EPSILON) - f2ts) / EPSILON\n         let det = df1s * df2t - df1t * df2s\n         s = s - ( df2t * f1ts - df1t * f2ts) / det\n         t = t - (-df2s * f1ts + df1s * f2ts) / det\n         */\n    // TODO: is this even more accurate?\n    const df1s = f1(s + EPSILON, t) - f1ts,\n      df1t = f1(s, t + EPSILON) - f1ts,\n      df2s = f2(s + EPSILON, t) - f2ts,\n      df2t = f2(s, t + EPSILON) - f2ts\n    const det = (df1s * df2t - df1t * df2s) / EPSILON\n    const ds = (df2t * f1ts - df1t * f2ts) / det\n    const dt = (-df2s * f1ts + df1s * f2ts) / det\n    s -= ds\n    t -= dt\n  } while (--steps && f1ts ** 2 + f2ts ** 2 > NLA_PRECISION)\n  if (f1ts ** 2 + f2ts ** 2 > NLA_PRECISION) {\n    console.log(f1ts ** 2 + f2ts ** 2)\n    return undefined\n  }\n  return new V3(s, t, 0)\n}\n\nexport function newtonIterate2dWithDerivatives(\n  f: (s: number, t: number) => number,\n  g: (s: number, t: number) => number,\n  sStart: number,\n  tStart: number,\n  steps: int,\n  dfds: (s: number, t: number) => number,\n  dfdt: (s: number, t: number) => number,\n  dgds: (s: number, t: number) => number,\n  dgdt: (s: number, t: number) => number,\n): V3 | undefined {\n  steps = steps || 4\n  let s = sStart,\n    t = tStart\n  let f1ts, f2ts\n  do {\n    /*\n         | a b |-1                   |  d -b |\n         | c d |   = 1 / (ad - bc) * | -c  a |\n         */\n    f1ts = f(s, t)\n    f2ts = g(s, t)\n    const df1s = dfds(s, t),\n      df1t = dfdt(s, t),\n      df2s = dgds(s, t),\n      df2t = dgdt(s, t)\n    // TODO: is this even more accurate?\n    const det = df1s * df2t - df1t * df2s\n    const ds = (df2t * f1ts - df1t * f2ts) / det\n    const dt = (-df2s * f1ts + df1s * f2ts) / det\n    s -= ds\n    t -= dt\n  } while (--steps && f1ts * f1ts + f2ts * f2ts > NLA_PRECISION / 32)\n  if (!steps) {\n    //console.log(f1ts * f1ts + f2ts * f2ts)\n    return undefined\n  }\n  return V(s, t, 0)\n}\n\nexport function getRoots(\n  f: (x: number) => number,\n  a: number,\n  b: number,\n  stepSize: number,\n  df: (x: number) => number,\n): number[] {\n  const results: number[] = []\n  for (let startT = a; startT <= b; startT += stepSize) {\n    const dt = stepSize * Math.abs(df(startT))\n    if (Math.abs(f(startT)) <= dt) {\n      //const t = newtonIterate1d(f, startT, 16)\n      let t = newtonIterateWithDerivative(f, startT, 16, df)\n      if (!eq0(f(t)) || eq0(df(t))) {\n        t = newtonIterate1d(df, startT, 16)\n        // const a = startT - dt,\n        // \tb = startT + dt\n        //if (f(a) * f(b) < 0) {\n        //    t = bisect(f, a, b, 16)\n        //} else if (df(a) * df(b) < 0) {\n        //    t = bisect(df, a, b, 16)\n        //}\n      }\n      if (eq0(f(t)) && !results.some((r) => eq(r, t))) {\n        results.push(t)\n      }\n    }\n  }\n  return results\n}\n","import { assert, assertInts, assertNumbers, int, lerp, MINUS, mod } from \".\"\n\nexport function arraySwap(arr: any[], i: int, j: int) {\n  const temp = arr[i]\n  arr[i] = arr[j]\n  arr[j] = temp\n}\n\nexport type ArrayLikeWriteAble<T> = {\n  readonly length: int\n  [index: number]: T\n}\n\nexport function arrayCopy<T, A extends ArrayLikeWriteAble<T>>(\n  src: ArrayLike<T>,\n  sstart: int,\n  dst: A,\n  dstart: int,\n  length: int,\n): A {\n  assertInts(sstart, dstart, length)\n  dstart += length\n  length += sstart\n  while (length-- > sstart) {\n    dst[--dstart] = src[length]\n  }\n  return dst\n}\n\n/**\n * Copies a number of items from one array to another, with a definable step\n * size between items in the source and destination array.\n *\n * @param src The source array.\n * @param sstart The location of the first item in the source array.\n * @param sstep The offset between items in the source array.\n * @param dst The destination array.\n * @param dstart The location of the first item in the destination array.\n * @param dstep The offset between items in the destination array.\n * @param count The number of items to copy.\n */\nexport function arrayCopyStep<T>(\n  src: ArrayLike<T>,\n  sstart: int,\n  sstep: int,\n  dst: ArrayLikeWriteAble<T>,\n  dstart: int,\n  dstep: int,\n  count: int,\n): void {\n  let srcIndex = sstart + count * sstep\n  let dIndex = dstart + count * dstep\n  while (srcIndex > sstart) {\n    dst[(dIndex -= dstep)] = src[(srcIndex -= sstep)]\n  }\n}\n\n/**\n * Copies a number of contiguous, evenly-spaced blocks from one array to another.\n *\n * @param src The source array.\n * @param sstart The start of the first block in the source array.\n * @param sstep The offset from the start of one block to the start of the next\n *     block in the source array.\n * @param dst The destination array.\n * @param dstart The start of the first block in the destination array.\n * @param dstep The offset from the start of one block to the start of the next\n *     block in the destination array.\n * @param blockSize The length of one block.\n * @param blockCount The number of blocks to copy.\n */\nexport function arrayCopyBlocks<T>(\n  src: ArrayLike<T>,\n  sstart: int,\n  sstep: int,\n  dst: ArrayLikeWriteAble<T>,\n  dstart: int,\n  dstep: int,\n  blockSize: int,\n  blockCount: int,\n): void {\n  for (let i = 0; i < blockCount; i++) {\n    arrayCopy(src, sstart + sstep * i, dst, dstart + dstep * i, blockSize)\n  }\n}\n\nexport function arrayRange(\n  startInclusive: int,\n  endExclusive: int,\n  step: int = 1,\n) {\n  assertNumbers(startInclusive, step)\n  //console.log(Math.ceil((endExclusive - startInclusive) / step))\n  const arrLength = Math.ceil((endExclusive - startInclusive) / step)\n  const result = new Array(arrLength) // '- startInclusive' so that chunk in the last row will also be selected, even\n  // if the row is not complete\n  for (\n    let i = startInclusive, index = 0;\n    index < arrLength;\n    i += step, index++\n  ) {\n    result[index] = i\n  }\n  return result\n}\n\n/**\n * Returns a number of evenly-spaced values between t0 and t1 (inclusive).\n *\n * @param t0 First value.\n * @param t1 Last value.\n * @param count Total number of values.\n */\nexport function arraySamples(t0: number, t1: number, count: int = 64) {\n  return arrayFromFunction(count, (i) => lerp(t0, t1, i / (count - 1)))\n}\n\nexport function arrayFromFunction<T>(\n  length: 1,\n  f: (i: int, total: int) => T,\n): [T]\nexport function arrayFromFunction<T>(\n  length: 2,\n  f: (i: int, total: int) => T,\n): [T, T]\nexport function arrayFromFunction<T>(\n  length: 3,\n  f: (i: int, total: int) => T,\n): [T, T, T]\nexport function arrayFromFunction<T>(\n  length: 4,\n  f: (i: int, total: int) => T,\n): [T, T, T, T]\nexport function arrayFromFunction<T>(\n  length: 5,\n  f: (i: int, total: int) => T,\n): [T, T, T, T, T]\nexport function arrayFromFunction<T>(\n  length: int,\n  f: (i: int, total: int) => T,\n): T[]\nexport function arrayFromFunction<T>(\n  length: int,\n  f: (i: int, total: int) => T,\n): T[] {\n  assertNumbers(length)\n  assert(\"function\" == typeof f)\n  const a = new Array(length)\n  let elIndex = length\n  while (elIndex--) {\n    a[elIndex] = f(elIndex, length)\n  }\n  return a\n}\n\n/**\n * Return the element in the array for which f(el) is highest. There is no\n * `withMin`, call `withMax(x => -f(x))` instead.\n *\n * @param arr The array to search.\n * @param f\n */\nexport function withMax<A extends ArrayLike<unknown>>(\n  arr: A,\n  f: (t: A[number], i: int, arr: A) => number,\n): A[number] | undefined {\n  let i = arr.length,\n    result = undefined,\n    maxVal = -Infinity\n  while (i--) {\n    const el = arr[i],\n      val = f(el, i, arr)\n    if (val > maxVal) {\n      maxVal = val\n      result = el\n    }\n  }\n  return result\n}\n\n/**\n * Returns the sum of the absolute values of the components of arr vector.\n *\n * @example\n *   absSum(V(1, -2, 3)) === abs(1) + abs(-2) + abs(3)) === 1 + 2 + 3 === 6\n */\nexport function absSum(arr: number[]) {\n  let i = arr.length\n  let result = 0\n  while (i--) {\n    result += Math.abs(arr[i])\n  }\n  return result\n}\n\nexport function emod<T>(arr: ArrayLike<T>, i: int): T {\n  return arr[mod(i, arr.length)]\n}\n\nexport function sliceStep<T>(\n  arr: ArrayLike<T>,\n  start: int,\n  end: int,\n  step: int,\n  chunkSize = 1,\n): T[] {\n  assertNumbers(start, step)\n  start < 0 && (start = arr.length + start)\n  end <= 0 && (end = arr.length + end)\n  const resultLength = Math.ceil((end - start) / step)\n  const result = new Array(resultLength) // '- start' so that chunk in the last row\n  // will also be selected, even if the row is\n  // not complete\n  let index = 0\n  for (let i = start; i < end; i += step) {\n    for (let j = i; j < Math.min(i + chunkSize, end); j++) {\n      result[index++] = arr[j]\n    }\n  }\n  assert(resultLength == index)\n  return result\n}\n\nexport function splicePure<T>(\n  arr: ArrayLike<T>,\n  start = 0,\n  deleteCount = 0,\n  ...items: T[]\n): T[] {\n  const arrayLength = arr.length\n  const _deleteCount = deleteCount < 0 ? 0 : deleteCount\n  let _start\n  if (start < 0) {\n    if (Math.abs(start) > arrayLength) {\n      _start = 0\n    } else {\n      _start = arrayLength + start\n    }\n  } else if (start > arrayLength) {\n    _start = arrayLength\n  } else {\n    _start = start\n  }\n  const newLength = arr.length - _deleteCount + items.length\n  const result = new Array(newLength)\n  let dst = newLength\n  let src = arr.length\n  while (src-- > _start + _deleteCount) {\n    result[--dst] = arr[src]\n  }\n  src = items.length\n  while (src--) {\n    result[--dst] = items[src]\n  }\n  src = _start\n  while (src--) {\n    result[--dst] = items[src]\n  }\n  return result\n}\n\nexport function arrayEquals(\n  arr: ArrayLike<unknown>,\n  obj: ArrayLike<unknown>,\n): boolean {\n  if (arr === obj) return true\n  if (Object.getPrototypeOf(obj) !== Array.prototype) return false\n  if (arr.length !== obj.length) return false\n  for (let i = 0; i < arr.length; i++) {\n    if (!equals(arr[i], obj[i])) return false\n  }\n  return true\n}\n\nexport function equals(a: any, b: any) {\n  return Array.isArray(a)\n    ? arrayEquals(a, b)\n    : \"object\" === typeof a\n    ? a.equals(b)\n    : a === b\n}\n\n/** Equivalent to `arr.map(f).filter((x) => x)`. */\nexport function mapFilter<T, S>(\n  arr: T[],\n  f: (item: T, index: int, arr: T[]) => S | undefined | false | null,\n): S[] {\n  const length = arr.length\n  const result: S[] = []\n  for (let i = 0; i < length; i++) {\n    if (i in arr) {\n      const val = f(arr[i], i, arr)\n      if (val) {\n        result.push(val)\n      }\n    }\n  }\n  return result\n}\n\nexport function clear<T>(arr: T[], ...newItems: T[]): T[] {\n  return arr.splice(0, arr.length, ...newItems)\n}\n\nexport function concatenated<T>(arr: T[]) {\n  return Array.prototype.concat.apply([], arr)\n}\n\nexport function min<T>(arr: ArrayLike<number>): number {\n  let i = arr.length,\n    max = Infinity\n  while (i--) {\n    const val = arr[i]\n    if (max > val) max = val\n  }\n  return max\n}\n\nexport function max(arr: ArrayLike<number>): number {\n  // faster and no limit on array size, see https://jsperf.com/math-max-apply-vs-loop/2\n  let i = arr.length,\n    max = -Infinity\n  while (i--) {\n    const val = arr[i]\n    if (max < val) max = val\n  }\n  return max\n}\n\nexport function indexWithMax<A extends ArrayLike<unknown>>(\n  arr: A,\n  f: (e: A[number], i: int, arr: A) => number,\n): int {\n  if (arr.length == 0) {\n    return -1\n  }\n  let i = arr.length,\n    result = -1,\n    maxVal = -Infinity\n  while (i--) {\n    const val = f(arr[i], i, arr)\n    if (val > maxVal) {\n      maxVal = val\n      result = i\n    }\n  }\n  return result\n}\n\nexport function sum(arr: ArrayLike<number>) {\n  let i = arr.length\n  let result = 0\n  while (i--) {\n    result += arr[i]\n  }\n  return result\n}\n\nexport function sumInPlaceTree(arr: ArrayLikeWriteAble<number>) {\n  if (0 == arr.length) return 0\n  let l = arr.length\n  while (l != 1) {\n    const lHalfFloor = Math.floor(l / 2)\n    const lHalfCeil = Math.ceil(l / 2)\n    for (let i = 0; i < lHalfFloor; i++) {\n      arr[i] += arr[i + lHalfCeil]\n    }\n    l = lHalfCeil\n  }\n  return arr[0]\n}\n\nexport function unique<T>(arr: T[]): T[] {\n  const uniqueSet = new Set<T>(arr)\n  return Array.from(uniqueSet)\n}\n\nexport function remove<T>(arr: T[], o: T): boolean {\n  const index = arr.indexOf(o)\n  if (index != -1) {\n    arr.splice(index, 1)\n    return true\n  }\n  return false\n}\n\nexport function removeIndex<T>(arr: T[], i: int): T {\n  const result = arr[i]\n  arr.splice(i, 1)\n  return result\n}\n\nexport function bagRemoveIndex<T>(arr: T[], i: int): T {\n  const result = arr[i]\n  if (i == arr.length - 1) {\n    arr.pop()\n  } else {\n    arr[i] = arr.pop()!\n  }\n  return result\n}\n\nexport function removeMatch<T>(arr: T[], matcher: (el: T) => boolean) {\n  const index = arr.findIndex(matcher)\n  if (-1 != index) {\n    return removeIndex(arr, index)\n  }\n}\n\nexport function removeAll<T>(arr: T[], o: T[]): void {\n  let i = o.length\n  while (i--) {\n    remove(arr, o[i])\n  }\n}\n\nexport function toggle<T>(arr: T[], o: T) {\n  const index = arr.indexOf(o)\n  if (index != -1) {\n    arr.splice(index, 1)\n    return false\n  } else {\n    arr.push(o)\n    return true\n  }\n}\n\nexport function bagToggle<T>(arr: T[], o: T) {\n  const index = arr.indexOf(o)\n  if (index != -1) {\n    bagRemoveIndex(arr, index)\n    return false\n  } else {\n    arr.push(o)\n    return true\n  }\n}\n\nexport function binaryIndexOf(\n  arr: ArrayLike<number>,\n  searchElement: number,\n  cmp?: (a: number, b: number) => number,\n): int\nexport function binaryIndexOf<T, S>(\n  arr: ArrayLike<T>,\n  searchElement: S,\n  cmp: (a: T, b: S) => number,\n): int\nexport function binaryIndexOf<T, S>(\n  arr: ArrayLike<T>,\n  searchElement: S,\n  cmp = (a: any, b: any) => a - b,\n): int {\n  let minIndex = 0\n  let maxIndex = arr.length - 1\n  let currentIndex\n  let currentElement\n\n  while (minIndex <= maxIndex) {\n    currentIndex = ((minIndex + maxIndex) / 2) | 0\n    currentElement = arr[currentIndex]\n\n    if (cmp(currentElement, searchElement) < 0) {\n      minIndex = currentIndex + 1\n    } else if (cmp(currentElement, searchElement) > 0) {\n      maxIndex = currentIndex - 1\n    } else {\n      return currentIndex\n    }\n  }\n\n  return -minIndex - 1\n}\n\nexport function binaryInsert<T>(\n  arr: number[],\n  el: number,\n  cmp?: (a: number, b: number) => number,\n): void\nexport function binaryInsert<T>(\n  arr: T[],\n  el: number,\n  cmp: (a: T, b: T) => number,\n): void\nexport function binaryInsert<T>(\n  arr: T[],\n  el: any,\n  cmp: (a: T, b: T) => number = MINUS as any,\n): void {\n  let minIndex = 0\n  let maxIndex = arr.length\n  let currentIndex\n  let currentElement\n\n  while (minIndex < maxIndex) {\n    currentIndex = ~~((minIndex + maxIndex) / 2)\n    currentElement = arr[currentIndex]\n\n    if (cmp(currentElement, el) < 0) {\n      minIndex = currentIndex + 1\n    } else {\n      maxIndex = currentIndex\n    }\n  }\n\n  arr.splice(minIndex, 0, el)\n}\n\nexport function firstUnsorted<T>(\n  arr: ArrayLike<T>,\n  cmp: (a: T, b: T) => number,\n) {\n  for (let i = 1; i < arr.length; i++) {\n    if (cmp(arr[i - 1], arr[i]) > 0) return i\n  }\n  return -1\n}\n\nexport function getLast<T>(arr: ArrayLike<T>): T {\n  return arr[arr.length - 1]\n}\n\nexport function setLast<T>(arr: ArrayLikeWriteAble<T>, val: T): T {\n  return (arr[arr.length - 1] = val)\n}\n\nexport function removeIndexes<T>(arr: T[], indexes: int[]): T[] {\n  indexes.sort((a, b) => a - b)\n  if (0 === indexes.length) return arr\n  if (1 === indexes.length) {\n    arr.splice(indexes[0], 1)\n    return arr\n  }\n  let dstPos = indexes[0]\n  let nextSkip = indexes[0]\n  let indexesPos = 0\n  for (let srcPos = indexes[0]; srcPos < arr.length; srcPos++) {\n    if (srcPos !== nextSkip) {\n      arr[dstPos++] = arr[srcPos]\n    } else {\n      indexesPos++\n      if (indexesPos < indexes.length) {\n        nextSkip = indexes[indexesPos]\n      } else {\n        arr.splice(dstPos, srcPos + 1 - dstPos)\n        return arr\n      }\n    }\n  }\n  throw new Error(\"illegal state\")\n}\n","import { Equalable, JavaMap as CustomMap } from \"javasetmap.ts\"\n\nimport {\n  assert,\n  assertf,\n  assertInst,\n  assertNumbers,\n  assertVectors,\n  defaultRoundFunction,\n  eq,\n  eq0,\n  FloatArray,\n  int,\n  NLA_PRECISION,\n  raddd,\n} from \".\"\n\n/** Immutable 3d-vector/point. */\nexport class V3 implements Equalable {\n  static readonly O: V3 = new V3(0, 0, 0)\n  static readonly X: V3 = new V3(1, 0, 0)\n  static readonly Y: V3 = new V3(0, 1, 0)\n  static readonly Z: V3 = new V3(0, 0, 1)\n  static readonly XY: V3 = new V3(1, 1, 0)\n  static readonly XYZ: V3 = new V3(1, 1, 1)\n  static readonly INF: V3 = new V3(Infinity, Infinity, Infinity)\n  static readonly UNITS: V3[] = [V3.X, V3.Y, V3.Z]\n  static readonly NAMEMAP = new CustomMap<V3, string>()\n    .set(V3.O, \"V3.O\")\n    .set(V3.X, \"V3.X\")\n    .set(V3.Y, \"V3.Y\")\n    .set(V3.Z, \"V3.Z\")\n    .set(V3.XYZ, \"V3.XYZ\")\n    .set(V3.INF, \"V3.INF\")\n\n  constructor(readonly x: number, readonly y: number, readonly z: number) {\n    assertNumbers(x, y, z)\n  }\n\n  static random(): V3 {\n    return new V3(Math.random(), Math.random(), Math.random())\n  }\n\n  static parallel(a: V3, b: V3) {\n    return a.dot(b) - a.length() * b.length()\n  }\n\n  /**\n   * See\n   * http://math.stackexchange.com/questions/44689/how-to-find-a-random-axis-or-unit-vector-in-3d\n   *\n   *\n   * @returns A random point on the unit sphere with uniform distribution across\n   *     the surface.\n   */\n  static randomUnit(): V3 {\n    const zRotation = Math.random() * 2 * Math.PI\n    const z = Math.random() * 2 - 1\n    const zRadius = Math.sqrt(1 - z ** 2)\n    return new V3(\n      zRadius * Math.cos(zRotation),\n      zRadius * Math.sin(zRotation),\n      z,\n    )\n  }\n\n  //noinspection JSUnusedLocalSymbols\n  /** Documentation stub. You want {@see V3#sphere} */\n  static fromAngles(theta: number, phi: number): V3 {\n    throw new Error()\n  }\n\n  static fromFunction(f: (dim: number) => number) {\n    return new V3(f(0), f(1), f(2))\n  }\n\n  static min(a: V3, b: V3): V3 {\n    return new V3(Math.min(a.x, b.x), Math.min(a.y, b.y), Math.min(a.z, b.z))\n  }\n\n  static max(a: V3, b: V3): V3 {\n    return new V3(Math.max(a.x, b.x), Math.max(a.y, b.y), Math.max(a.z, b.z))\n  }\n\n  static lerp(a: V3, b: V3, t: number): V3 {\n    return new V3(\n      a.x * (1 - t) + b.x * t,\n      a.y * (1 - t) + b.y * t,\n      a.z * (1 - t) + b.z * t,\n    )\n  }\n\n  static fromArray(a: number[]): V3 {\n    return new V3(a[0], a[1], a[2])\n  }\n\n  static angleBetween(a: V3, b: V3): number {\n    return a.angleTo(b)\n  }\n\n  static zip(f: (...args: number[]) => number, ...args: V3[]): V3 {\n    assert(f instanceof Function)\n    return new V3(\n      f.apply(\n        undefined,\n        args.map((x) => x.x),\n      ),\n      f.apply(\n        undefined,\n        args.map((x) => x.y),\n      ),\n      f.apply(\n        undefined,\n        args.map((x) => x.z),\n      ),\n    )\n  }\n\n  static normalOnPoints(a: V3, b: V3, c: V3): V3 {\n    assertVectors(a, b, c)\n    return a.to(b).cross(a.to(c))\n  }\n\n  static add(...vs: V3[]): V3 {\n    assertVectors(...vs)\n    let x = 0,\n      y = 0,\n      z = 0\n    let i = vs.length\n    while (i--) {\n      x += vs[i].x\n      y += vs[i].y\n      z += vs[i].z\n    }\n    return new V3(x, y, z)\n  }\n\n  static sub(...vs: V3[]): V3 {\n    assertVectors(...vs)\n    let x = vs[0].x,\n      y = vs[0].y,\n      z = vs[0].z\n    let i = vs.length\n    while (i--) {\n      x -= vs[i].x\n      y -= vs[i].y\n      z -= vs[i].z\n    }\n    return new V3(x, y, z)\n  }\n\n  /**\n   * Pack an array of V3s into an array of numbers (Float32Array by default).\n   *\n   * @param v3arr Source array\n   * @param dest Destination array. If provided, must be large enough to fit\n   *     v3count items.\n   * @param srcStart Starting index in source array\n   * @param destStart Starting index in destination array\n   * @param v3count Number of V3s to copy.\n   * @returns Packed array.\n   */\n  static pack<T extends FloatArray = Float32Array>(\n    v3arr: ReadonlyArray<V3>,\n    dest?: T,\n    srcStart: number = 0,\n    destStart: number = 0,\n    v3count: number = v3arr.length - srcStart,\n  ): T {\n    //assert (v3arr.every(v3 => v3 instanceof V3), 'v3arr.every(v3 => v3 instanceof V3)')\n    const result = dest || (new Float32Array(3 * v3count) as any) // TODO\n    assert(\n      result.length - destStart >= v3count * 3,\n      \"dest.length - destStart >= v3count * 3\",\n      result.length,\n      destStart,\n      v3count * 3,\n    )\n\n    let i = v3count,\n      srcIndex = srcStart,\n      destIndex = destStart\n    while (i--) {\n      const v = v3arr[srcIndex++]\n      result[destIndex++] = v.x\n      result[destIndex++] = v.y\n      result[destIndex++] = v.z\n    }\n    return result\n  }\n\n  static unpack(\n    packedArray: ArrayLike<number>,\n    dest?: V3[],\n    srcStart: number = 0,\n    destStart: number = 0,\n    v3count: number = (packedArray.length - srcStart) / 3,\n  ) {\n    //assert (v3arr.every(v3 => v3 instanceof V3), 'v3arr.every(v3 => v3 instanceof V3)')\n    dest = dest || new Array(v3count)\n    assert(\n      dest.length - destStart >= v3count,\n      \"dest.length - destStart >= v3count\",\n    )\n\n    let i = v3count,\n      srcIndex = srcStart,\n      destIndex = destStart\n    while (i--) {\n      dest[destIndex++] = new V3(\n        packedArray[srcIndex++],\n        packedArray[srcIndex++],\n        packedArray[srcIndex++],\n      )\n    }\n    return dest\n  }\n\n  static packXY<T extends FloatArray = Float32Array>(\n    v3arr: V3[],\n    dest?: T,\n    srcStart: number = 0,\n    destStart: number = 0,\n    v3count: number = v3arr.length - srcStart,\n  ): T {\n    //assert (v3arr.every(v3 => v3 instanceof V3), 'v3arr.every(v3 => v3 instanceof V3)')\n    const result = dest || (new Float32Array(2 * v3count) as any)\n    assert(\n      result.length - destStart >= v3count,\n      \"dest.length - destStart >= v3count\",\n    )\n\n    let i = v3count,\n      srcIndex = srcStart,\n      destIndex = destStart\n    while (i--) {\n      const v = v3arr[srcIndex++]\n      result[destIndex++] = v.x\n      result[destIndex++] = v.y\n    }\n    return result\n  }\n\n  static unpackXY(\n    src: FloatArray,\n    dest?: V3[],\n    srcStart: int = 0,\n    destStart: int = 0,\n    v3count: int = Math.min(src.length / 2, (dest && dest.length) || Infinity) -\n      destStart,\n  ): V3[] {\n    //assert (v3arr.every(v3 => v3 instanceof V3), 'v3arr.every(v3 => v3 instanceof V3)')\n    dest = dest || new Array(v3count)\n    assert(\n      dest.length - destStart >= v3count,\n      \"dest.length - destStart >= v3count\",\n    )\n    assert(\n      src.length - srcStart >= v3count * 2,\n      \"dest.length - destStart >= v3count\",\n    )\n\n    let i = v3count,\n      srcIndex = srcStart,\n      destIndex = destStart\n    while (i--) {\n      dest[destIndex++] = new V3(src[srcIndex++], src[srcIndex++], 0)\n    }\n    return dest\n  }\n\n  static perturbed(v: V3, delta?: number): V3 {\n    return v.perturbed(delta)\n  }\n\n  static polar(radius: number, phi: raddd, z: number = 0): V3 {\n    return new V3(radius * Math.cos(phi), radius * Math.sin(phi), z)\n  }\n\n  /**\n   * @param longitude Angle in XY plane\n   * @param latitude \"height\"/z dir angle\n   */\n  static sphere(longitude: raddd, latitude: raddd, length = 1): V3 {\n    return new V3(\n      length * Math.cos(latitude) * Math.cos(longitude),\n      length * Math.cos(latitude) * Math.sin(longitude),\n      length * Math.sin(latitude),\n    )\n  }\n\n  static inverseLerp(a: V3, b: V3, x: V3) {\n    const ab = a.to(b)\n    return a.to(x).dot(ab) / ab.squared()\n  }\n\n  get [0]() {\n    return this.x\n  }\n  get [1]() {\n    return this.y\n  }\n  get [2]() {\n    return this.z\n  }\n\n  get u() {\n    return this.x\n  }\n  get v() {\n    return this.y\n  }\n\n  perturbed(delta: number = NLA_PRECISION * 0.8): V3 {\n    return this.map((x) => x + (Math.random() - 0.5) * delta)\n  }\n\n  *[Symbol.iterator]() {\n    yield this.x\n    yield this.y\n    yield this.z\n  }\n\n  e(index: int): number {\n    assert(index >= 0 && index < 3)\n    return 0 == index ? this.x : 1 == index ? this.y : this.z\n  }\n\n  negated(): V3 {\n    return new V3(-this.x, -this.y, -this.z)\n  }\n\n  abs(): V3 {\n    return new V3(Math.abs(this.x), Math.abs(this.y), Math.abs(this.z))\n  }\n\n  plus(a: V3): V3 {\n    assertVectors(a)\n    return new V3(this.x + a.x, this.y + a.y, this.z + a.z)\n  }\n\n  /**\n   * Hadarmard product (or Schur product): element-wise multiplication of two vectors.\n   *\n   * @see https://en.wikipedia.org/wiki/Hadamard_product_(matrices)\n   */\n  schur(a: V3): V3 {\n    return new V3(this.x * a.x, this.y * a.y, this.z * a.z)\n  }\n\n  /** Element-wise division. */\n  divv(a: V3): V3 {\n    return new V3(this.x / a.x, this.y / a.y, this.z / a.z)\n  }\n\n  /** See also {@link to} which is a.minus(this) */\n  minus(a: V3): V3 {\n    assertVectors(a)\n    return new V3(this.x - a.x, this.y - a.y, this.z - a.z)\n  }\n\n  to(a: V3): V3 {\n    assertVectors(a)\n    return a.minus(this)\n  }\n\n  times(factor: number): V3 {\n    assertNumbers(factor)\n    return new V3(this.x * factor, this.y * factor, this.z * factor)\n  }\n\n  div(a: number): V3 {\n    assertNumbers(a)\n    return new V3(this.x / a, this.y / a, this.z / a)\n  }\n\n  /**\n   * Dot product.\n   *\n   * @see https://en.wikipedia.org/wiki/Dot_product\n   */\n  dot(a: V3): number {\n    assertInst(V3, a)\n    return this.x * a.x + this.y * a.y + this.z * a.z\n  }\n\n  /** Linearly interpolate */\n  lerp(b: V3, t: number): V3 {\n    assertVectors(b)\n    assertNumbers(t)\n    return V3.lerp(this, b, t)\n  }\n\n  squared(): number {\n    return this.dot(this)\n  }\n\n  distanceTo(a: V3): number {\n    assertVectors(a)\n    //return this.minus(a).length()\n    return Math.hypot(this.x - a.x, this.y - a.y, this.z - a.z)\n  }\n\n  distanceToSquared(a: V3): number {\n    assertVectors(a)\n    return this.minus(a).squared()\n  }\n\n  ///**\n  // * See also {@see #setTo} for the individual\n  // *\n  // * @param v\n  // */\n  //assign(v) {\n  //\tassertVectors(v)\n  //\tthis.x = v.x\n  //\tthis.y = v.y\n  //\tthis.z = v.z\n  //}\n  //\n  ///**\n  // * See also {@see #assign} for the V3 version\n  // *\n  // * @param x\n  // * @param y\n  // * @param z\n  // */\n  //setTo(x, y, z = 0) {\n  //\tthis.x = x\n  //\tthis.y = y\n  //\tthis.z = z\n  //}\n\n  toSource(): string {\n    return V3.NAMEMAP.get(this) || this.toString()\n  }\n\n  nonParallelVector(): V3 {\n    const abs = this.abs()\n    if (abs.x <= abs.y && abs.x <= abs.z) {\n      return V3.X\n    } else if (abs.y <= abs.x && abs.y <= abs.z) {\n      return V3.Y\n    } else {\n      return V3.Z\n    }\n  }\n\n  slerp(b: V3, t: number): V3 {\n    assertVectors(b)\n    assertNumbers(t)\n    const sin = Math.sin\n    const omega = this.angleTo(b)\n    return this.times(sin((1 - t) * omega) / sin(omega)).plus(\n      b.times(sin(t * omega) / sin(omega)),\n    )\n  }\n\n  min(b: V3): V3 {\n    return new V3(\n      Math.min(this.x, b.x),\n      Math.min(this.y, b.y),\n      Math.min(this.z, b.z),\n    )\n  }\n\n  max(b: V3): V3 {\n    return new V3(\n      Math.max(this.x, b.x),\n      Math.max(this.y, b.y),\n      Math.max(this.z, b.z),\n    )\n  }\n\n  equals(v: any): boolean {\n    return this == v || (this.x == v.x && this.y == v.y && this.z == v.z)\n  }\n\n  /**\n   * The cross product is defined as: a x b = |a| * |b| * sin(phi) * n where |.|\n   * is the euclidean norm, phi is the angle between the vectors and n is a\n   * unit vector perpendicular to both a and b.\n   *\n   * The cross product is zero for parallel vectors.\n   *\n   * @see https://en.wikipedia.org/wiki/Cross_product\n   */\n  cross(v: V3): V3 {\n    return new V3(\n      this.y * v.z - this.z * v.y,\n      this.z * v.x - this.x * v.z,\n      this.x * v.y - this.y * v.x,\n    )\n  }\n\n  minElement(): number {\n    return Math.min(this.x, this.y, this.z)\n  }\n\n  maxElement(): number {\n    return Math.max(this.x, this.y, this.z)\n  }\n\n  toArray(n: int = 3): number[] {\n    return [this.x, this.y, this.z].slice(0, n)\n  }\n\n  /**\n   * Get a perpendicular vector.\n   *\n   * For vectors in the XY-Plane, returns vector rotated 90 CCW.\n   */\n  getPerpendicular(): V3 {\n    if (eq0(this.x) && eq0(this.y)) {\n      if (eq0(this.z)) {\n        throw new Error(\"zero vector\")\n      }\n      // v is Vector(0, 0, v.z)\n      return V3.Y\n    }\n    return new V3(-this.y, this.x, 0)\n  }\n\n  //noinspection JSMethodCanBeStatic\n  dim(): int {\n    return 3\n  }\n\n  els(): number[] {\n    return [this.x, this.y, this.z]\n  }\n\n  angleXY(): number {\n    return Math.atan2(this.y, this.x)\n  }\n\n  lengthXY(): number {\n    return Math.hypot(this.x, this.y)\n    //return Math.sqrt(this.x * this.x + this.y * this.y)\n  }\n\n  squaredXY(): number {\n    return this.x * this.x + this.y * this.y\n  }\n\n  xy(): V3 {\n    return new V3(this.x, this.y, 0)\n  }\n\n  /**\n   * Transform this vector element-wise by way of function f. Returns V3(f(x), f(y), f(z))\n   *\n   * @param f Function to apply to elements (number -> number)\n   */\n  map(f: (el: number, dim: \"x\" | \"y\" | \"z\") => number): V3 {\n    return new V3(f(this.x, \"x\"), f(this.y, \"y\"), f(this.z, \"z\"))\n  }\n\n  toString(roundFunction?: (x: number) => any): string {\n    roundFunction = roundFunction || defaultRoundFunction\n    return (\n      V3.NAMEMAP.get(this) ||\n      \"V(\" + [this.x, this.y, this.z].map(roundFunction).join(\", \") + \")\"\n    ) //+ this.id\n  }\n\n  angleTo(b: V3): number {\n    assert(1 == arguments.length)\n    assertVectors(b)\n    assert(!this.likeO())\n    assert(!b.likeO())\n    return Math.acos(Math.min(1, this.dot(b) / this.length() / b.length()))\n  }\n\n  /**\n   * Phi = angle between A and B alpha = angle between n and normal1\n   *\n   * A . B = ||A|| * ||B|| * cos(phi) A x B = ||A|| * ||B|| * sin(phi) * n (n =\n   * unit vector perpendicular) (A x B) . normal1 = ||A|| * ||B|| * sin(phi) * cos(alpha)\n   */\n  angleRelativeNormal(vector: V3, normal1: V3): number {\n    assert(2 == arguments.length)\n    assertVectors(vector, normal1)\n    assertf(() => normal1.hasLength(1))\n    //assert(vector.isPerpendicularTo(normal1), 'vector.isPerpendicularTo(normal1)' + vector.sce + normal1.sce)\n    //assert(this.isPerpendicularTo(normal1), 'this.isPerpendicularTo(normal1)' + this.dot(vector)) //\n    // -0.000053600770598683675\n    return Math.atan2(this.cross(vector).dot(normal1), this.dot(vector))\n  }\n\n  /**\n   * Returns true iff this is parallel to vector, i.e. this * s == vector, where\n   * s is a positive or negative number, using eq. Throw a DebugError - if\n   * vector is not a Vector or - if this has a length of 0 or - if vector has a\n   * length of 0\n   */\n  isParallelTo(vector: V3): boolean {\n    assertVectors(vector)\n    assert(!this.likeO())\n    assert(!vector.likeO())\n    // a . b takes on values of +|a|*|b| (vectors same direction) to -|a|*|b| (opposite direction)\n    // in both cases the vectors are parallel, so check if abs(a . b) == |a|*|b|\n    const dot = this.dot(vector)\n    return eq(this.squared() * vector.squared(), dot * dot)\n  }\n\n  isPerpendicularTo(vector: V3): boolean {\n    assertVectors(vector)\n    assert(!this.likeO(), \"!this.likeO()\")\n    assert(!vector.likeO(), \"!vector.likeO()\")\n    return eq0(this.dot(vector))\n  }\n\n  isReverseDirTo(other: V3): boolean {\n    assertVectors(other)\n    assert(!this.likeO())\n    assert(!other.likeO())\n    // a . b takes on values of +|a|*|b| (vectors same direction) to -|a|*|b| (opposite direction)\n    // in both cases the vectors are parallel, so check if abs(a . b) == |a|*|b|\n    const dot = this.dot(other)\n    return eq(Math.sqrt(this.squared() * other.squared()), dot)\n  }\n\n  /**\n   * Returns the length of this Vector, i.e. the euclidean norm.\n   *\n   * Note that the partial derivatives of the euclidean norm at point x are\n   * equal to the components of the unit vector x.\n   */\n  length(): number {\n    return Math.hypot(this.x, this.y, this.z)\n    //return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)\n  }\n\n  /** Definition: V3.likeO == V3.like(V3.O) */\n  likeO(): boolean {\n    return this.like(V3.O)\n  }\n\n  /**\n   * Eq(this.x, obj.x) && eq(this.y, obj.y) && eq(this.z, obj.z)\n   *\n   * @param obj\n   */\n  like(obj: any): boolean {\n    if (obj === this) return true\n    if (!(obj instanceof V3)) return false\n    return eq(this.x, obj.x) && eq(this.y, obj.y) && eq(this.z, obj.z)\n  }\n\n  /** Equivalent to this.like(v) || this.negated().like(v) */\n  likeOrReversed(v: V3): boolean {\n    return eq(Math.abs(this.dot(v)), Math.sqrt(this.squared() * v.squared()))\n  }\n\n  /**\n   * Returns a new unit Vector (.length() === 1) with the same direction as this\n   * vector. Throws a DebugError if this has a length of 0.\n   */\n  unit(): V3 {\n    assert(!this.likeO(), \"cannot normalize zero vector\")\n    return this.div(this.length())\n  }\n\n  /** Documentation stub. You want {@link unit} */\n  normalized(): V3 {\n    throw new Error(\"documentation stub. use .unit()\")\n  }\n\n  /**\n   * Returns a new V3 equal to this scaled so that its length is equal to newLength.\n   *\n   * Passing a negative newLength will flip the vector.\n   */\n  toLength(newLength: number): V3 {\n    assertNumbers(newLength)\n    return this.times(newLength / this.length())\n  }\n\n  /**\n   * Returns a new Vector which is the projection of this vector onto the passed\n   * vector. Examples\n   *\n   * V(3, 4).projectedOn(V(1, 0)) // returns V(3, 0) V(3, 4).projectedOn(V(2,\n   * 0)) // returns V(3, 0) V(3, 4).projectedOn(V(-1, 0)) // returns V(-3, 0)\n   * V(3, 4).projectedOn(V(0, 1)) // returns V(0, 4) V(3, 4).projectedOn(V(1,\n   * 1)) // returns\n   */\n  projectedOn(b: V3): V3 {\n    assertVectors(b)\n    // https://en.wikipedia.org/wiki/Vector_projection#Vector_projection_2\n    return b.times(this.dot(b) / b.dot(b))\n  }\n\n  rejectedFrom(b: V3): V3 {\n    assertVectors(b)\n    // https://en.wikipedia.org/wiki/Vector_projection#Vector_projection_2\n    return this.minus(b.times(this.dot(b) / b.dot(b)))\n  }\n\n  rejectedFrom1(b1: V3): V3 {\n    assertVectors(b1)\n    assert(b1.hasLength(1))\n    // https://en.wikipedia.org/wiki/Vector_projection#Vector_projection_2\n    return this.minus(b1.times(this.dot(b1)))\n  }\n\n  /**\n   * Returns the length of this vector rejected from the unit vector b.\n   *\n   *     /| this / | ^\n   *     /__| | b\n   *     r Returns length of r (r === this.rejectedFrom(b))\n   */\n  rejectedLength(b: V3): number {\n    assertVectors(b)\n    return Math.sqrt(this.dot(this) - this.dot(b) ** 2 / b.dot(b))\n  }\n\n  /**\n   * Returns the length of this vector rejected from the unit vector b1.\n   *\n   *     /| this / | ^\n   *     /__| | b1\n   *     r Returns length of r (r === this.rejectedFrom(b1))\n   */\n  rejected1Length(b1: V3): number {\n    assertVectors(b1)\n    assert(b1.hasLength(1))\n    return Math.sqrt(this.dot(this) - this.dot(b1) ** 2)\n  }\n\n  /**\n   * Returns true iff the length() of this vector is equal to 'length', using eq\n   *\n   * @example\n   *   V(3, 4).hasLength(5) === true\n   *\n   * @example\n   *   V(1, 1).hasLength(1) === false\n   */\n  hasLength(length: number): boolean {\n    assertNumbers(length)\n    return eq(length, this.length())\n  }\n\n  /**\n   * Returns the sum of the absolute values of the components of this vector.\n   * E.g. V(1, -2, 3) === abs(1) + abs(-2) + abs(3) === 1 + 2 + 3 === 6\n   */\n  absSum(): number {\n    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)\n  }\n\n  /** @returns `min(|x|, |y|, |z|)` */\n  minAbsElement(): number {\n    return Math.min(Math.abs(this.x), Math.abs(this.y), Math.min(this.z))\n  }\n\n  /** @returns `max(|x|, |y|, |z|)` */\n  maxAbsElement(): number {\n    return Math.max(Math.abs(this.x), Math.abs(this.y), Math.abs(this.z))\n  }\n\n  maxAbsDim(): 0 | 1 | 2 {\n    const xAbs = Math.abs(this.x),\n      yAbs = Math.abs(this.y),\n      zAbs = Math.abs(this.z)\n    return xAbs >= yAbs ? (xAbs >= zAbs ? 0 : 2) : yAbs >= zAbs ? 1 : 2\n  }\n\n  minAbsDim(): 0 | 1 | 2 {\n    const xAbs = Math.abs(this.x),\n      yAbs = Math.abs(this.y),\n      zAbs = Math.abs(this.z)\n    return xAbs < yAbs ? (xAbs < zAbs ? 0 : 2) : yAbs < zAbs ? 1 : 2\n  }\n\n  withElement(dim: \"x\" | \"y\" | \"z\", el: number) {\n    assert([\"x\", \"y\", \"z\"].includes(dim), \"\" + dim)\n    assertNumbers(el)\n    if (\"x\" == dim) {\n      return new V3(el, this.y, this.z)\n    }\n    if (\"y\" == dim) {\n      return new V3(this.x, el, this.z)\n    }\n    return new V3(this.x, this.y, el)\n  }\n\n  hashCode(): int {\n    function floatHashCode(f: number) {\n      return ~~(f * (1 << 28))\n    }\n\n    return ~~(\n      (floatHashCode(this.x) * 31 + floatHashCode(this.y)) * 31 +\n      floatHashCode(this.z)\n    )\n  }\n\n  hashCodes() {\n    //function floatHashCode(f) {\n    //\treturn ~~(f * (1 << 28))\n    //}\n\n    // compare hashCode.floatHashCode\n    // the following ops are equivalent to\n    // floatHashCode((el - NLA_PRECISION) % (2 * NLA_PRECISION))\n    // this results in the hashCode for the (out of 8 possible) cube with the lowest hashCode\n    // the other 7 can be calculated by adding constants\n    const xHC = ~~(this.x * (1 << 28) - 0.5),\n      yHC = ~~(this.y * (1 << 28) - 0.5),\n      zHC = ~~(this.z * (1 << 28) - 0.5),\n      hc = ~~((xHC * 31 + yHC) * 31 + zHC)\n    return [\n      ~~hc,\n      ~~(hc + 961),\n      ~~(hc + 31),\n      ~~(hc + 31 + 961),\n      ~~(hc + 1),\n      ~~(hc + 1 + 961),\n      ~~(hc + 1 + 31),\n      ~~(hc + 1 + 31 + 961),\n    ]\n  }\n\n  //static areDisjoint(it: Iterable<V3>): boolean {\n  //\tconst vSet = new CustomSet\n  //\tfor (const v of it) {\n  //\t\tif (!v.equals(vSet.canonicalizeLike(v))) {\n  //\t\t\t// like value already in set\n  //\t\t\treturn false\n  //\t\t}\n  //\t}\n  //\treturn true\n  //}\n\n  compareTo(other: V3): number {\n    if (this.x != other.x) {\n      return this.x - other.x\n    } else if (this.y != other.y) {\n      return this.y - other.y\n    } else {\n      return this.z - other.z\n    }\n  }\n\n  compareTo2(other: V3, eps: number = NLA_PRECISION): number {\n    if (!eq(this.x, other.x, eps)) {\n      return this.x - other.x\n    } else if (!eq(this.y, other.y, eps)) {\n      return this.y - other.y\n    } else if (!eq(this.z, other.z, eps)) {\n      return this.z - other.z\n    } else {\n      return 0\n    }\n  }\n\n  toAngles(): { theta: raddd; phi: raddd } {\n    return {\n      theta: Math.atan2(this.y, this.x),\n      phi: Math.asin(this.z / this.length()),\n    }\n  }\n}\n\n/**\n * Utility method for creating V3s\n *\n * Example usage:\n *\n *     V(1, 2, 3)\n *     V([1, 2, 3])\n *     V({ x: 1, y: 2, z: 3 })\n *     V(1, 2) * assumes z=0\n *     V([1, 2]) // assumes z=0\n */\nexport function V(x: number, y: number, z?: number): V3\nexport function V(arr: [number, number, number] | [number, number]): V3\nexport function V(obj: { x: number; y: number; z?: number }): V3\nexport function V(a: any, b?: any, c?: any): V3 {\n  if (arguments.length == 3) {\n    return new V3(parseFloat(a), parseFloat(b), parseFloat(c))\n  } else if (arguments.length == 2) {\n    return new V3(parseFloat(a), parseFloat(b), 0)\n  } else if (arguments.length == 1) {\n    if (typeof a == \"object\") {\n      if (a instanceof V3) {\n        // immutable, so\n        return a\n      } else if (\n        a instanceof Array ||\n        a instanceof Float32Array ||\n        a instanceof Float64Array\n      ) {\n        if (2 == a.length) {\n          return new V3(parseFloat(a[0]), parseFloat(a[1]), 0)\n        } else if (3 == a.length) {\n          return new V3(parseFloat(a[0]), parseFloat(a[1]), parseFloat(a[2]))\n        }\n      } else if (\"x\" in a && \"y\" in a) {\n        return new V3(\n          parseFloat(a.x),\n          parseFloat(a.y),\n          \"z\" in a ? parseFloat(a.z) : 0,\n        )\n      }\n    }\n  }\n  throw new Error(\"invalid arguments\" + arguments)\n}\n","import { callSource, M4, raddd, V3 } from \".\"\n\nexport const P3YZ = { normal1: V3.X, w: 0 }\nexport const P3ZX = { normal1: V3.Y, w: 0 }\nexport const P3XY = { normal1: V3.Z, w: 0 }\n\nexport abstract class Transformable {\n  mirror(plane: { normal1: V3; w: number }): this {\n    return this.transform(M4.mirror(plane))\n  }\n\n  mirroredX(): this {\n    return this.mirror(P3YZ)\n  }\n\n  mirrorY(): this {\n    return this.mirror(P3ZX)\n  }\n\n  mirrorZ(): this {\n    return this.mirror(P3XY)\n  }\n\n  project(plane: { normal1: V3; w: number }): this {\n    return this.transform(M4.project(plane))\n  }\n\n  projectXY(): this {\n    return this.transform(M4.project(P3XY))\n  }\n\n  projectYZ(): this {\n    return this.transform(M4.project(P3YZ))\n  }\n\n  projectZX(): this {\n    return this.transform(M4.project(P3ZX))\n  }\n\n  translate(x: number, y?: number, z?: number): this\n  translate(v: V3): this\n  translate(...args: any): this {\n    return this.transform(\n      M4.translate.apply(undefined, args),\n      callSource.call(undefined, \".translate\", ...args),\n    )\n  }\n\n  scale(x: number, y?: number, z?: number): this\n  scale(f: V3): this\n  scale(...args: any): this {\n    return this.transform(\n      M4.scale.apply(undefined, args),\n      callSource.call(undefined, \".scale\", ...args),\n    )\n  }\n\n  rotateX(radians: raddd): this {\n    return this.transform(M4.rotateX(radians), `.rotateX(${radians})`)\n  }\n\n  rotateY(radians: raddd): this {\n    return this.transform(M4.rotateY(radians), `.rotateY(${radians})`)\n  }\n\n  rotateZ(radians: raddd): this {\n    return this.transform(M4.rotateZ(radians), `.rotateZ(${radians})`)\n  }\n\n  rotate(rotationCenter: V3, rotationAxis: V3, radians: raddd): this {\n    return this.transform(\n      M4.rotateLine(rotationCenter, rotationAxis, radians),\n      callSource(\".rotate\", rotationCenter, rotationAxis, radians),\n    )\n  }\n\n  rotateAB(from: V3, to: V3): this {\n    return this.transform(\n      M4.rotateAB(from, to),\n      callSource(\".rotateAB\", from, to),\n    )\n  }\n\n  eulerZXZ(alpha: raddd, beta: raddd, gamma: raddd): this {\n    throw new Error()\n    //return this.transform(M4.eulerZXZ(alpha, beta, gamma))\n  }\n\n  shearX(y: number, z: number): this {\n    // prettier-ignore\n    return this.transform(new M4([\n      1, y, z, 0,\n      0, 1, 0, 0,\n      0, 0, 1, 0,\n      0, 0, 0, 1]))\n  }\n\n  foo(): this {\n    return this.transform(M4.FOO)\n  }\n\n  fooInv(): this {\n    return this.transform(M4.FOO_INV)\n  }\n\n  abstract transform(m4: M4, desc?: string): this\n\n  visit<R>(visitor: { [name: string]: (this: Transformable) => R }): R\n  visit<R, A>(\n    visitor: { [name: string]: (this: Transformable, a: A) => R },\n    a: A,\n  ): R\n  visit<R, A, B>(\n    visitor: { [name: string]: (this: Transformable, a: A, b: B) => R },\n    a: A,\n    b: B,\n  ): R\n  visit<R, A, B, C>(\n    visitor: { [name: string]: (this: Transformable, a: A, b: B, c: C) => R },\n    a: A,\n    b: B,\n    c: C,\n  ): R\n  visit<R, A, B, C, D>(\n    visitor: {\n      [name: string]: (this: Transformable, a: A, b: B, c: C, d: D) => R\n    },\n    a: A,\n    b: B,\n    c: C,\n    d: D,\n  ): R\n  visit(\n    visitor: { [name: string]: (this: Transformable, ...args: any[]) => any },\n    ...args: any[]\n  ) {\n    let proto = Object.getPrototypeOf(this)\n    // walk up the prototype chain until we find a defined function in o\n    while (\n      !visitor.hasOwnProperty(proto.constructor.name) &&\n      proto !== Transformable.prototype\n    ) {\n      proto = Object.getPrototypeOf(proto)\n    }\n    if (visitor.hasOwnProperty(proto.constructor.name)) {\n      return visitor[proto.constructor.name].apply(this, args)\n    } else {\n      throw new Error(\"No implementation for \" + this.constructor.name)\n    }\n  }\n}\n","import { Equalable } from \"javasetmap.ts\"\n\nimport {\n  arrayCopy,\n  arrayCopyBlocks,\n  arrayCopyStep,\n  arrayFromFunction,\n  arraySwap,\n  assert,\n  assertf,\n  assertInst,\n  assertInts,\n  assertNumbers,\n  assertVectors,\n  eq,\n  eq0,\n  FloatArray,\n  floatHashCode,\n  int,\n  max,\n  min,\n  NLA_PRECISION,\n  Vector,\n} from \".\"\n\nexport class Matrix implements Equalable {\n  constructor(\n    public width: int,\n    public height: int,\n    public readonly m: Float64Array,\n  ) {\n    assertInts(width, height)\n    assertf(() => 0 < width)\n    assertf(() => 0 < height)\n    assert(\n      width * height == m.length,\n      \"width * height == m.length\",\n      width,\n      height,\n      m.length,\n    )\n  }\n\n  static random(width: int, height: int): Matrix {\n    return Matrix.fromFunction(width, height, () => Math.random())\n  }\n\n  static fromFunction(\n    width: int,\n    height: int,\n    f: (row: int, col: int, elIndex: int) => number,\n  ): Matrix {\n    const m = new Float64Array(height * width)\n    let elIndex = height * width\n    while (elIndex--) {\n      m[elIndex] = f(Math.floor(elIndex / width), elIndex % width, elIndex)\n    }\n    return new Matrix(width, height, m)\n  }\n\n  static identityN(dim: int): Matrix {\n    assertInts(dim)\n    const m = new Float64Array(dim * dim)\n    // Float64Arrays are init to 0\n    let elIndex = dim * (dim + 1)\n    while (elIndex) {\n      elIndex -= dim + 1\n      m[elIndex] = 1\n    }\n    return new Matrix(dim, dim, m)\n  }\n\n  /**\n   * Create new dim x dim matrix equal to an identity matrix with rows/colums i\n   * and k swapped. Note that i and k are 0-indexed.\n   */\n  static permutation(dim: int, i: int, k: int): Matrix {\n    assertInts(dim, i, k)\n    assertf(() => 0 <= i && i < dim)\n    assertf(() => 0 <= k && k < dim)\n    const m = new Float64Array(dim * dim)\n    // Float64Array are init to 0\n    let elIndex = dim * (dim + 1)\n    while (elIndex) {\n      elIndex -= dim + 1\n      m[elIndex] = 1\n    }\n    m[i * dim + i] = 0\n    m[k * dim + k] = 0\n    m[i * dim + k] = 1\n    m[k * dim + i] = 1\n    return new Matrix(dim, dim, m)\n  }\n\n  static fromRowArrays(...rowArrays: ArrayLike<number>[]): Matrix {\n    if (0 == rowArrays.length) {\n      throw new Error(\"cannot have 0 vector\")\n    }\n    const height = rowArrays.length\n    const width = rowArrays[0].length\n    const m = new Float64Array(height * width)\n    arrayCopy(rowArrays[0], 0, m, 0, width)\n    for (let rowIndex = 1; rowIndex < height; rowIndex++) {\n      if (rowArrays[rowIndex].length != width) {\n        throw new Error(\"all row arrays must be the same length\")\n      }\n      arrayCopy(rowArrays[rowIndex], 0, m, rowIndex * width, width)\n    }\n    return this.new(width, height, m)\n  }\n\n  static fromColVectors(colVectors: Vector[]): Matrix {\n    return Matrix.fromColArrays(...colVectors.map((v) => v.v))\n  }\n\n  static forWidthHeight(width: int, height: int): Matrix {\n    return new Matrix(width, height, new Float64Array(width * height))\n  }\n\n  static fromColArrays(...colArrays: ArrayLike<number>[]): Matrix {\n    if (0 == colArrays.length) {\n      throw new Error(\"cannot have 0 vector\")\n    }\n    const width = colArrays.length\n    const height = colArrays[0].length\n    const m = new Float64Array(height * width)\n    arrayCopyStep(colArrays[0], 0, 1, m, 0, width, height)\n    for (let colIndex = 1; colIndex < width; colIndex++) {\n      if (colArrays[colIndex].length != height) {\n        throw new Error(\"all col arrays must be the same length\")\n      }\n      arrayCopyStep(colArrays[colIndex], 0, 1, m, colIndex, width, height)\n    }\n    return this.new(width, height, m)\n  }\n\n  static product(...m4s: Matrix[]): Matrix\n  static product(ms: Matrix[], result?: Matrix): Matrix\n  static product(...args: any[]): Matrix {\n    const [ms, result]: [Matrix[], Matrix | undefined] = Array.isArray(args[0])\n      ? [args[0], args[1]]\n      : [args, undefined]\n    if (0 == ms.length) throw new Error(\"Can't guess matrix size.\")\n    if (1 == ms.length) return Matrix.copy(ms[0], result)\n    return Matrix.copy(\n      ms.reduce((a, b) => a.times(b)),\n      result,\n    )\n  }\n\n  /**\n   * Numerically calculate all the partial derivatives of f at x0.\n   *\n   * @param f\n   * @param x0\n   * @param fx0 F(x0), pass it if you have it already\n   * @param EPSILON\n   */\n  static jacobi(\n    f: (x: number[] | Float32Array | Float64Array) => ArrayLike<number>,\n    x0: FloatArray,\n    fx0: ArrayLike<number> = f(x0),\n    EPSILON: number = 1e-6,\n  ): Matrix {\n    const jacobi = Matrix.forWidthHeight(x0.length, fx0.length)\n    for (let colIndex = 0; colIndex < x0.length; colIndex++) {\n      x0[colIndex] += EPSILON\n      const fx = f(x0)\n      for (let rowIndex = 0; rowIndex < fx0.length; rowIndex++) {\n        const value = (fx[rowIndex] - fx0[rowIndex]) / EPSILON\n        jacobi.setEl(rowIndex, colIndex, value)\n      }\n      x0[colIndex] -= EPSILON\n    }\n    return jacobi\n  }\n\n  static copy<T extends Matrix>(src: T, result: T = src.new()): T {\n    assertInst(Matrix, src, result)\n    assert(src.width == result.width)\n    assert(src.height == result.height)\n    assert(result != src, \"result != src\")\n    const s = src.m,\n      d = result.m\n    let i = s.length\n    while (i--) {\n      d[i] = s[i]\n    }\n    return result\n  }\n\n  protected static new(width: int, height: int, m: Float64Array) {\n    return new Matrix(width, height, m)\n  }\n\n  copy(): this {\n    return Matrix.copy<this>(this)\n  }\n\n  e(rowIndex: number, colIndex: number): number {\n    assertInts(rowIndex, colIndex)\n    assert(\n      0 <= rowIndex && rowIndex < this.height,\n      \"rowIndex out of bounds \" + rowIndex,\n    )\n    assert(\n      0 <= colIndex && colIndex < this.width,\n      \"colIndex out of bounds \" + colIndex,\n    )\n    return this.m[rowIndex * this.width + colIndex]\n  }\n\n  setEl(rowIndex: number, colIndex: number, val: number): void {\n    assertInts(rowIndex, colIndex)\n    assert(\n      0 <= rowIndex && rowIndex < this.height,\n      \"rowIndex out of bounds \" + rowIndex,\n    )\n    assert(\n      0 <= colIndex && colIndex < this.width,\n      \"colIndex out of bounds \" + colIndex,\n    )\n    assertNumbers(val)\n    this.m[rowIndex * this.width + colIndex] = val\n  }\n\n  plus(m: this): this {\n    assert(this.width == m.width)\n    assert(this.height == m.height)\n    const r = this.new()\n    let i = this.m.length\n    while (i--) r.m[i] = this.m[i] + m.m[i]\n    return r\n  }\n\n  minus(m: Matrix): Matrix {\n    assert(this.width == m.width)\n    assert(this.height == m.height)\n    const r = this.new()\n    let i = this.m.length\n    while (i--) r.m[i] = this.m[i] - m.m[i]\n    return r\n  }\n\n  mulScalar(scalar: number): this {\n    assertNumbers(scalar)\n    const r = this.new()\n    let i = this.m.length\n    while (i--) r.m[i] = this.m[i] * scalar\n    return r\n  }\n\n  divScalar(scalar: number): this {\n    assertNumbers(scalar)\n    const r = this.new()\n    let i = this.m.length\n    while (i--) r.m[i] = this.m[i] / scalar\n    return r\n  }\n\n  new(): this {\n    return new Matrix(\n      this.width,\n      this.height,\n      new Float64Array(this.width * this.height),\n    ) as this\n  }\n\n  toString(\n    f?: (el: number) => string,\n    colNames?: ReadonlyArray<string>,\n    rowNames?: ReadonlyArray<string>,\n  ): string {\n    f = f || ((v) => v.toFixed(6))\n    assert(typeof f(0) == \"string\", \"\" + typeof f(0))\n    assert(!colNames || colNames.length == this.width)\n    assert(!rowNames || rowNames.length == this.height)\n    const rounded: string[] = Array.from(this.m).map(f)\n    const rows = arrayFromFunction(this.height, (rowIndex) =>\n      rounded.slice(rowIndex * this.width, (rowIndex + 1) * this.width),\n    ) // select matrix row\n    if (colNames) {\n      rows.unshift(Array.from(colNames))\n    }\n    if (rowNames) {\n      rows.forEach((row, rowIndex) =>\n        row.unshift(rowNames[rowIndex - (colNames ? 1 : 0)] || \"\"),\n      )\n    }\n    const colWidths = arrayFromFunction(this.width, (colIndex) =>\n      max(rows.map((row) => row[colIndex].length)),\n    )\n    return rows\n      .map((row, rowIndex) =>\n        row\n          .map((x, colIndex) => {\n            // pad numbers with spaces to col width\n            const padder =\n              (rowIndex == 0 && colNames) || (colIndex == 0 && rowNames)\n                ? String.prototype.padEnd\n                : String.prototype.padStart\n            return padder.call(x, colWidths[colIndex])\n          })\n          .join(\"  \"),\n      )\n      .map((x) => x + \"\\n\")\n      .join(\"\") // join rows\n  }\n\n  row(rowIndex: int): Vector {\n    assertInts(rowIndex)\n    assert(\n      0 <= rowIndex && rowIndex < this.height,\n      \"rowIndex out of bounds \" + rowIndex,\n    )\n    const v = new Float64Array(this.width)\n    arrayCopy(this.m, rowIndex * this.width, v, 0, this.width)\n    return new Vector(v)\n  }\n\n  col(colIndex: int): Vector {\n    assertInts(colIndex)\n    assert(\n      0 <= colIndex && colIndex < this.width,\n      \"colIndex out of bounds \" + colIndex,\n    )\n    const v = new Float64Array(this.height)\n    arrayCopyStep(this.m, colIndex, this.width, v, 0, 1, this.height)\n    return new Vector(v)\n  }\n\n  dim(): { width: int; height: int } {\n    return { width: this.width, height: this.height }\n  }\n\n  dimString(): string {\n    return this.width + \"x\" + this.height\n  }\n\n  equals(obj: any): boolean {\n    if (obj.constructor != this.constructor) return false\n    if (this.width != obj.width || this.height != obj.height) return false\n    let elIndex = this.m.length\n    while (elIndex--) {\n      if (this.m[elIndex] != obj.m[elIndex]) return false\n    }\n    return true\n  }\n\n  equalsMatrix(matrix: Matrix, precision: number = NLA_PRECISION): boolean {\n    assertInst(Matrix, matrix)\n    if (this.width != matrix.width || this.height != matrix.height) return false\n    let elIndex = this.m.length\n    while (elIndex--) {\n      if (Math.abs(this.m[elIndex] - matrix.m[elIndex]) > precision)\n        return false\n    }\n    return true\n  }\n\n  hashCode(): int {\n    let result = 0\n    let elIndex = this.m.length\n    while (elIndex--) {\n      result = result * 31 + floatHashCode(this.m[elIndex])\n    }\n    return result\n  }\n\n  // todo rename\n  isZero(): boolean {\n    let elIndex = this.m.length\n    while (elIndex--) {\n      if (!eq0(this.m[elIndex])) {\n        return false\n      }\n    }\n    return true\n  }\n\n  isOrthogonal(): boolean {\n    return (\n      this.isSquare() &&\n      this.transposed().times(this).equalsMatrix(Matrix.identityN(this.width))\n    )\n  }\n\n  /** Returns L, U, P such that L * U == P * this */\n  luDecomposition(): { L: Matrix; U: Matrix; P: Matrix } {\n    const width = this.width\n    const height = this.height\n    const uRowArrays = this.asRowArrays(Float64Array)\n    const lRowArrays = arrayFromFunction(height, () => new Float64Array(height))\n    const pRowArrays = Matrix.identityN(height).asRowArrays(Float64Array)\n    let currentRowIndex = 0\n    for (let colIndex = 0; colIndex < width; colIndex++) {\n      currentRowIndex = colIndex\n      // console.log('currentRowIndex', currentRowIndex)\t// find largest value in colIndex\n      let maxAbsValue = 0,\n        pivotRowIndex = -1,\n        numberOfNonZeroRows = 0\n      for (let rowIndex = currentRowIndex; rowIndex < height; rowIndex++) {\n        const el = uRowArrays[rowIndex][colIndex]\n        numberOfNonZeroRows += +(0 != el)\n        if (Math.abs(el) > maxAbsValue) {\n          maxAbsValue = Math.abs(el)\n          pivotRowIndex = rowIndex\n        }\n      }\n      // TODO: check with isZero\n      if (0 == maxAbsValue) {\n        // column contains only zeros\n        continue\n      }\n      assert(-1 !== pivotRowIndex)\n      // swap rows\n      arraySwap(uRowArrays, currentRowIndex, pivotRowIndex)\n      arraySwap(lRowArrays, currentRowIndex, pivotRowIndex)\n      arraySwap(pRowArrays, currentRowIndex, pivotRowIndex)\n      lRowArrays[currentRowIndex][colIndex] = 1\n\n      if (1 < numberOfNonZeroRows) {\n        // subtract pivot (now current) row from all below it\n        for (\n          let rowIndex = currentRowIndex + 1;\n          rowIndex < height;\n          rowIndex++\n        ) {\n          const l =\n            uRowArrays[rowIndex][colIndex] /\n            uRowArrays[currentRowIndex][colIndex]\n          lRowArrays[rowIndex][colIndex] = l\n          // subtract pivot row * l from row 'rowIndex'\n          for (let colIndex2 = colIndex; colIndex2 < width; colIndex2++) {\n            uRowArrays[rowIndex][colIndex2] -=\n              l * uRowArrays[currentRowIndex][colIndex2]\n          }\n        }\n      }\n      //  currentRowIndex++ // this doesn't increase if pivot was zero\n    }\n    return {\n      L: Matrix.fromRowArrays(...lRowArrays),\n      U: Matrix.fromRowArrays(...uRowArrays),\n      P: Matrix.fromRowArrays(...pRowArrays),\n    }\n  }\n\n  qrDecompositionGivensRotation(): { Q: Matrix; R: Matrix } {\n    // function sigma(c: number, s: number) {\n    // \tif (0 == c) {\n    // \t\treturn 1\n    // \t}\n    // \tif (Math.abs(s) < Math.abs(c)) {\n    // \t\treturn 0.5 * Math.sign(c) * s\n    // \t}\n    // \treturn (2 * Math.sign(s)) / c\n    // }\n    const R = this.copy()\n\n    function matrixForCS(dim: int, i: int, k: int, c: number, s: number) {\n      const m = Matrix.identityN(dim)\n      m.setEl(i, i, c)\n      m.setEl(k, k, c)\n      m.setEl(i, k, s)\n      m.setEl(k, i, -s)\n      return m\n    }\n\n    let qTransposed = Matrix.identityN(this.height)\n    for (let colIndex = 0; colIndex < this.width; colIndex++) {\n      // find largest value in colIndex\n      for (let rowIndex = colIndex + 1; rowIndex < this.height; rowIndex++) {\n        //console.log('row ', rowIndex, 'col ', colIndex)\n        const xi = R.e(colIndex, colIndex)\n        const xk = R.e(rowIndex, colIndex)\n        if (xk == 0) {\n          continue\n        }\n        const r = Math.hypot(xi, xk)\n        const c = xi / r\n        const s = xk / r\n\n        // apply transformation on every column:\n        for (let col2 = colIndex; col2 < this.width; col2++) {\n          const x1 = R.e(colIndex, col2) * c + R.e(rowIndex, col2) * s\n          const x2 = R.e(rowIndex, col2) * c - R.e(colIndex, col2) * s\n          R.setEl(colIndex, col2, x1)\n          R.setEl(rowIndex, col2, x2)\n        }\n        //console.log('r ', r, 'c ', c, 's ', s, 'sigma', sigma(c, s))\n        //console.log(this.toString(),'cs\\n', matrixForCS(this.height, colIndex, rowIndex, c, s).toString())\n        qTransposed = matrixForCS(this.height, colIndex, rowIndex, c, s).times(\n          qTransposed,\n        )\n      }\n    }\n    //console.log(qTransposed.transposed().toString(), this.toString(),\n    // qTransposed.transposed().times(this).toString())\n    return { Q: qTransposed.transposed(), R }\n  }\n\n  isPermutation(): boolean {\n    if (!this.isSquare()) return false\n    if (this.m.some((value) => !eq0(value) && !eq(1, value))) return false\n\n    const rows = this.asRowArrays(Array)\n    if (\n      rows.some(\n        (row) => (row as number[]).filter((value) => eq(1, value)).length != 1,\n      )\n    )\n      return false\n\n    const cols = this.asColArrays(Array)\n    return !cols.some(\n      (col) => (col as number[]).filter((value) => eq(1, value)).length != 1,\n    )\n  }\n\n  isDiagonal(precision?: number): boolean {\n    let i = this.m.length\n    while (i--) {\n      if (0 !== i % (this.width + 1) && !eq0(this.m[i], precision)) return false\n    }\n    return true\n  }\n\n  isIdentity(precision?: number): boolean {\n    return (\n      this.isLowerUnitriangular(precision) && this.isUpperTriangular(precision)\n    )\n  }\n\n  /**\n   * @example\n   *   Matrix.fromRowArrays(\n   *     [1, 2, 3], //\n   *     [0, 4, 5],\n   *     [0, 0, 5],\n   *   ).isUpperTriangular() // true\n   *\n   * @param precision {@link eq}\n   */\n  isUpperTriangular(precision?: number) {\n    return this.isSquare() && this.isUpperTrapezoidal(precision)\n  }\n\n  isUpperTrapezoidal(precision: number = NLA_PRECISION) {\n    for (let rowIndex = 1; rowIndex < this.height; rowIndex++) {\n      for (let colIndex = 0; colIndex < rowIndex; colIndex++) {\n        if (!eq0(this.m[rowIndex * this.width + colIndex], precision)) {\n          return false\n        }\n      }\n    }\n    return true\n  }\n\n  isSymmetric(precision = NLA_PRECISION) {\n    if (!this.isSquare()) return false\n    for (let rowIndex = 0; rowIndex < this.height - 1; rowIndex++) {\n      for (let colIndex = rowIndex + 1; colIndex < this.width; colIndex++) {\n        const a = this.m[rowIndex * this.width + colIndex]\n        const b = this.m[colIndex * this.width + rowIndex]\n        if (!eq(a, b, precision)) {\n          return false\n        }\n      }\n    }\n    return true\n  }\n\n  /**\n   * Returns x, so that this * x = b More efficient than calculating the inverse\n   * for few (~ <= this.height) values\n   */\n  solveLinearSystem(b: Vector): Vector {\n    assertInst(Vector, b)\n    const { L, U, P } = this.luDecomposition()\n    const y = L.solveForwards(P.timesVector(b))\n    return U.solveBackwards(y)\n  }\n\n  isLowerUnitriangular(precision: number = NLA_PRECISION): boolean {\n    if (!this.isSquare()) return false\n    for (let rowIndex = 0; rowIndex < this.height - 1; rowIndex++) {\n      for (let colIndex = rowIndex; colIndex < this.width; colIndex++) {\n        const el = this.m[rowIndex * this.width + colIndex]\n        if (\n          rowIndex == colIndex ? !eq(1, el, precision) : !eq0(el, precision)\n        ) {\n          return false\n        }\n      }\n    }\n    return true\n  }\n\n  isLowerTriangular(precision?: number): boolean {\n    return this.isSquare() && this.isLowerTrapezoidal(precision)\n  }\n\n  isLowerTrapezoidal(precision: number = NLA_PRECISION): boolean {\n    for (let rowIndex = 0; rowIndex < this.height - 1; rowIndex++) {\n      for (let colIndex = rowIndex + 1; colIndex < this.width; colIndex++) {\n        if (!eq0(this.m[rowIndex * this.width + colIndex], precision)) {\n          return false\n        }\n      }\n    }\n    return true\n  }\n\n  solveBackwards(x: Vector): Vector {\n    assertVectors(x)\n    assert(this.height == x.dim(), \"this.height == x.dim()\")\n    assert(\n      this.isUpperTriangular(),\n      \"this.isUpperTriangular()\\n\" + this.toString(),\n    )\n    const v = new Float64Array(this.width)\n    let rowIndex = this.height\n    while (rowIndex--) {\n      let temp = x.v[rowIndex]\n      for (let colIndex = rowIndex + 1; colIndex < this.width; colIndex++) {\n        temp -= v[colIndex] * this.e(rowIndex, colIndex)\n      }\n      v[rowIndex] = temp / this.e(rowIndex, rowIndex)\n    }\n    return new Vector(v)\n  }\n\n  solveBackwardsMatrix(matrix: Matrix): Matrix {\n    const colVectors = new Array(matrix.width)\n    let i = matrix.width\n    while (i--) {\n      colVectors[i] = this.solveBackwards(matrix.col(i))\n    }\n    return Matrix.fromColVectors(colVectors)\n  }\n\n  solveForwardsMatrix(matrix: Matrix): Matrix {\n    const colVectors = new Array(matrix.width)\n    let i = matrix.width\n    while (i--) {\n      colVectors[i] = this.solveForwards(matrix.col(i))\n    }\n    return Matrix.fromColVectors(colVectors)\n  }\n\n  solveForwards(x: Vector): Vector {\n    assertVectors(x)\n    assert(this.height == x.dim(), \"this.height == x.dim()\")\n    assertf(() => this.isLowerTriangular(), this.toString())\n    const v = new Float64Array(this.width)\n    for (let rowIndex = 0; rowIndex < this.height; rowIndex++) {\n      let temp = x.v[rowIndex]\n      for (let colIndex = 0; colIndex < rowIndex; colIndex++) {\n        temp -= v[colIndex] * this.e(rowIndex, colIndex)\n      }\n      v[rowIndex] = temp / this.e(rowIndex, rowIndex)\n    }\n    return new Vector(v)\n  }\n\n  /**\n   * Calculates rank of matrix. Number of linearly independant row/column\n   * vectors. Is equal to the unmber of dimensions the image of the affine\n   * transformation represented this matrix has.\n   */\n  rank(): int {\n    const U = this.luDecomposition().U\n    let rowIndex = this.height\n    let rank = this.height\n    while (rowIndex--) {\n      rank -= +U.row(rowIndex).isZero()\n    }\n    return rank\n  }\n\n  rowsIndependent(): boolean {\n    return this.height == this.rank()\n  }\n\n  colsIndependent(): boolean {\n    return this.width == this.rank()\n  }\n\n  asRowArrays<T extends FloatArray>(\n    arrayConstructor: new (length: int) => T = Float64Array as any,\n  ): T[] {\n    return arrayFromFunction(this.height, (rowIndex) =>\n      this.rowArray(rowIndex, arrayConstructor),\n    )\n  }\n\n  asColArrays<T extends FloatArray>(\n    arrayConstructor: new (length: int) => T = Float64Array as any,\n  ): T[] {\n    return arrayFromFunction(this.width, (colIndex) =>\n      this.colArray(colIndex, arrayConstructor),\n    )\n  }\n\n  rowArray<T extends FloatArray>(\n    rowIndex: int,\n    arrayConstructor: new (length: int) => T = Float64Array as any,\n  ): T {\n    const result = new arrayConstructor(this.width)\n    return arrayCopy(this.m, rowIndex * this.width, result, 0, this.width)\n  }\n\n  colArray<T extends FloatArray>(\n    colIndex: int,\n    arrayConstructor: new (length: int) => T = Float64Array as any,\n  ): T {\n    const result = new arrayConstructor(this.width)\n    arrayCopyStep(this.m, colIndex, this.height, result, 0, 1, this.height)\n    return result\n  }\n\n  subMatrix(\n    firstColIndex: int,\n    subWidth: int,\n    firstRowIndex: int,\n    subHeight: int,\n  ): Matrix {\n    assert(\n      0 < firstColIndex && 0 < subWidth && 0 < firstRowIndex && 0 < subHeight,\n    )\n    assert(\n      firstColIndex + subWidth <= this.width &&\n        firstRowIndex + subHeight <= this.height,\n    )\n    const m = new Float64Array(subWidth * subHeight)\n    arrayCopyBlocks(\n      this.m,\n      firstColIndex,\n      this.width,\n      m,\n      0,\n      subWidth,\n      subHeight,\n      subWidth,\n    )\n    return new Matrix(subWidth, subHeight, m)\n  }\n\n  map(\n    fn: (el: number, elIndex: number, array: Float64Array) => number,\n  ): Matrix {\n    return new Matrix(this.width, this.height, this.m.map(fn))\n  }\n\n  dimEquals(matrix: Matrix): boolean {\n    assertInst(Matrix, matrix)\n    return this.width == matrix.width && this.height == matrix.height\n  }\n\n  inversed(): Matrix {\n    if (this.isSquare()) {\n      if (2 == this.width) return this.inversed2()\n      if (3 == this.width) return this.inversed3()\n      if (4 == this.width) return this.inversed4()\n    }\n    const { L, U, P } = this.luDecomposition()\n    const y = L.solveForwardsMatrix(P)\n    return U.solveBackwardsMatrix(y)\n  }\n\n  inversed2(): Matrix {\n    assertf(() => 2 == this.width && 2 == this.height)\n    const result = Matrix.forWidthHeight(2, 2),\n      m = this.m,\n      r = result.m\n\n    const det = m[0] * m[3] - m[1] * r[2]\n\n    r[0] = m[3] / det\n    r[1] = -m[2] / det\n\n    r[2] = -m[1] / det\n    r[3] = m[0] / det\n\n    return result\n  }\n\n  inversed3(result = Matrix.forWidthHeight(3, 3)): Matrix {\n    assertInst(Matrix, result)\n    assertf(() => 3 == this.width && 3 == this.height)\n    assertf(() => 3 == result.width && 3 == result.height)\n    assert(() => this != result)\n    const m = this.m,\n      r = result.m\n\n    r[0] = m[4] * m[8] - m[5] * m[7]\n    r[1] = -m[1] * m[8] + m[2] * m[7]\n    r[2] = m[1] * m[5] - m[2] * m[4]\n\n    r[3] = -m[3] * m[8] + m[5] * m[6]\n    r[4] = m[0] * m[8] - m[2] * m[6]\n    r[5] = -m[0] * m[5] + m[2] * m[3]\n\n    r[6] = m[3] * m[7] - m[4] * m[6]\n    r[7] = -m[0] * m[7] + m[1] * m[6]\n    r[8] = m[0] * m[4] - m[1] * m[3]\n\n    const det = m[0] * r[0] + m[1] * r[3] + m[2] * r[6]\n    let i = 9\n    while (i--) {\n      r[i] /= det\n    }\n\n    return result\n  }\n\n  // prettier-ignore\n  inversed4(result: Matrix = Matrix.forWidthHeight(4, 4)): Matrix {\n    assertInst(Matrix, result)\n    assertf(() => 4 == this.width && 4 == this.height)\n    assertf(() => 4 == result.width && 4 == result.height)\n    assert(() => this != result)\n    const m = this.m,\n      r = result.m\n\n    // first compute transposed cofactor matrix:\n    // cofactor of an element is the determinant of the 3x3 matrix gained by removing the column and row belonging\n    // to the element\n    r[0] = m[5] * m[10] * m[15] - m[5] * m[14] * m[11] - m[6] * m[9] * m[15]\n      + m[6] * m[13] * m[11] + m[7] * m[9] * m[14] - m[7] * m[13] * m[10]\n    r[1] = -m[1] * m[10] * m[15] + m[1] * m[14] * m[11] + m[2] * m[9] * m[15]\n      - m[2] * m[13] * m[11] - m[3] * m[9] * m[14] + m[3] * m[13] * m[10]\n    r[2] = m[1] * m[6] * m[15] - m[1] * m[14] * m[7] - m[2] * m[5] * m[15]\n      + m[2] * m[13] * m[7] + m[3] * m[5] * m[14] - m[3] * m[13] * m[6]\n    r[3] = -m[1] * m[6] * m[11] + m[1] * m[10] * m[7] + m[2] * m[5] * m[11]\n      - m[2] * m[9] * m[7] - m[3] * m[5] * m[10] + m[3] * m[9] * m[6]\n\n\n    r[4] = -m[4] * m[10] * m[15] + m[4] * m[14] * m[11] + m[6] * m[8] * m[15]\n      - m[6] * m[12] * m[11] - m[7] * m[8] * m[14] + m[7] * m[12] * m[10]\n    r[5] = m[0] * m[10] * m[15] - m[0] * m[14] * m[11] - m[2] * m[8] * m[15]\n      + m[2] * m[12] * m[11] + m[3] * m[8] * m[14] - m[3] * m[12] * m[10]\n    r[6] = -m[0] * m[6] * m[15] + m[0] * m[14] * m[7] + m[2] * m[4] * m[15]\n      - m[2] * m[12] * m[7] - m[3] * m[4] * m[14] + m[3] * m[12] * m[6]\n    r[7] = m[0] * m[6] * m[11] - m[0] * m[10] * m[7] - m[2] * m[4] * m[11]\n      + m[2] * m[8] * m[7] + m[3] * m[4] * m[10] - m[3] * m[8] * m[6]\n\n\n    r[8] = m[4] * m[9] * m[15] - m[4] * m[13] * m[11] - m[5] * m[8] * m[15]\n      + m[5] * m[12] * m[11] + m[7] * m[8] * m[13] - m[7] * m[12] * m[9]\n    r[9] = -m[0] * m[9] * m[15] + m[0] * m[13] * m[11] + m[1] * m[8] * m[15]\n      - m[1] * m[12] * m[11] - m[3] * m[8] * m[13] + m[3] * m[12] * m[9]\n    r[10] = m[0] * m[5] * m[15] - m[0] * m[13] * m[7] - m[1] * m[4] * m[15]\n      + m[1] * m[12] * m[7] + m[3] * m[4] * m[13] - m[3] * m[12] * m[5]\n    r[11] = -m[0] * m[5] * m[11] + m[0] * m[9] * m[7] + m[1] * m[4] * m[11]\n      - m[1] * m[8] * m[7] - m[3] * m[4] * m[9] + m[3] * m[8] * m[5]\n\n\n    r[12] = -m[4] * m[9] * m[14] + m[4] * m[13] * m[10] + m[5] * m[8] * m[14]\n      - m[5] * m[12] * m[10] - m[6] * m[8] * m[13] + m[6] * m[12] * m[9]\n    r[13] = m[0] * m[9] * m[14] - m[0] * m[13] * m[10] - m[1] * m[8] * m[14]\n      + m[1] * m[12] * m[10] + m[2] * m[8] * m[13] - m[2] * m[12] * m[9]\n    r[14] = -m[0] * m[5] * m[14] + m[0] * m[13] * m[6] + m[1] * m[4] * m[14]\n      - m[1] * m[12] * m[6] - m[2] * m[4] * m[13] + m[2] * m[12] * m[5]\n    r[15] = m[0] * m[5] * m[10] - m[0] * m[9] * m[6] - m[1] * m[4] * m[10]\n      + m[1] * m[8] * m[6] + m[2] * m[4] * m[9] - m[2] * m[8] * m[5]\n\n    // calculate determinant using laplace expansion (cf https://en.wikipedia.org/wiki/Laplace_expansion),\n    // as we already have the cofactors. We multiply a column by a row as the cofactor matrix is transposed.\n    const det = m[0] * r[0] + m[1] * r[4] + m[2] * r[8] + m[3] * r[12]\n    // assert(!isZero(det), 'det may not be zero, i.e. the matrix is not invertible')\n    let i = 16\n    while (i--) {\n      r[i] /= det\n    }\n    return result\n  }\n\n  canMultiply(matrix: Matrix): boolean {\n    assertInst(Matrix, matrix)\n    return this.width == matrix.height\n  }\n\n  times(matrix: Matrix): Matrix {\n    assertInst(Matrix, matrix)\n    assert(\n      this.canMultiply(matrix),\n      `Cannot multiply this ${this.dimString()} by matrix ${matrix.dimString()}`,\n    )\n    const nWidth = matrix.width,\n      nHeight = this.height,\n      n = this.width\n    const nM = new Float64Array(nWidth * nHeight)\n    let nRowIndex = nHeight\n    while (nRowIndex--) {\n      let nColIndex = nWidth\n      while (nColIndex--) {\n        let result = 0\n        let i = n\n        while (i--) {\n          result += this.m[nRowIndex * n + i] * matrix.m[i * nWidth + nColIndex]\n        }\n        nM[nRowIndex * nWidth + nColIndex] = result\n      }\n    }\n    return new Matrix(nWidth, nHeight, nM)\n  }\n\n  timesVector(v: Vector): Vector {\n    assertVectors(v)\n    assert(this.width == v.dim())\n    const nHeight = this.height,\n      n = this.width\n    const nM = new Float64Array(nHeight)\n    let nRowIndex = nHeight\n    while (nRowIndex--) {\n      let result = 0\n      let i = n\n      while (i--) {\n        result += this.m[nRowIndex * n + i] * v.v[i]\n      }\n      nM[nRowIndex] = result\n    }\n    return new Vector(nM)\n  }\n\n  transposed(): Matrix {\n    const tWidth = this.height,\n      tHeight = this.width\n    const tM = new Float64Array(tWidth * tHeight)\n    let tRowIndex = tHeight\n    while (tRowIndex--) {\n      let tColIndex = tWidth\n      while (tColIndex--) {\n        tM[tRowIndex * tWidth + tColIndex] = this.m[\n          tColIndex * tHeight + tRowIndex\n        ]\n      }\n    }\n    return new Matrix(tWidth, tHeight, tM)\n  }\n\n  /** In-place transpose. */\n  transpose(): void {\n    const h = this.height,\n      w = this.width,\n      tM = this.m\n    let tRowIndex = h\n    while (tRowIndex--) {\n      let tColIndex = Math.min(tRowIndex, w)\n      while (tColIndex--) {\n        const temp = tM[tRowIndex * w + tColIndex]\n        tM[tRowIndex * w + tColIndex] = tM[tColIndex * h + tRowIndex]\n        tM[tColIndex * h + tRowIndex] = temp\n      }\n    }\n    this.width = h\n    this.height = w\n  }\n\n  isSquare(): boolean {\n    return this.height == this.width\n  }\n\n  diagonal(): Vector {\n    if (!this.isSquare()) {\n      throw new Error(\"!!\")\n    }\n    const v = new Float64Array(this.width)\n    let elIndex = this.width * (this.width + 1)\n    let vIndex = this.width\n    while (vIndex--) {\n      elIndex -= this.width + 1\n      v[vIndex] = this.m[elIndex]\n    }\n    return new Vector(v)\n  }\n\n  maxEl(): number {\n    return max(this.m)\n  }\n\n  minEl(): number {\n    return min(this.m)\n  }\n\n  //noinspection DuplicatedCode\n  maxAbsColSum(): number {\n    let result = 0\n    let colIndex = this.width\n    while (colIndex--) {\n      let absSum = 0\n      let rowIndex = this.height\n      while (rowIndex--) {\n        absSum += Math.abs(this.m[rowIndex * this.width + colIndex])\n      }\n      result = Math.max(result, absSum)\n    }\n    return result\n  }\n\n  //noinspection DuplicatedCode\n  maxAbsRowSum(): number {\n    let result = 0\n    let rowIndex = this.height\n    while (rowIndex--) {\n      let absSum = 0\n      let colIndex = this.width\n      while (colIndex--) {\n        absSum += Math.abs(this.m[rowIndex * this.width + colIndex])\n      }\n      result = Math.max(result, absSum)\n    }\n    return result\n  }\n\n  getTriangularDeterminant(): number {\n    assert(\n      this.isUpperTriangular() || this.isLowerTriangular(),\n      \"not a triangular matrix\",\n    )\n\n    let product = 1\n    let elIndex = this.width * (this.width + 1)\n    while (elIndex) {\n      elIndex -= this.width + 1\n      product *= this.m[elIndex]\n    }\n    return product\n  }\n\n  /**\n   * Calculates the determinant by first calculating the LU decomposition. If\n   * you already have that, use U.getTriangularDeterminant()\n   */\n  getDeterminant(): number {\n    // PA = LU\n    // det(A) * det(B) = det(A * B)\n    // det(P) == 1 (permutation matrix)\n    // det(L) == 1 (main diagonal is 1s\n    // =>  det(A) == det(U)\n    return this.luDecomposition().U.getTriangularDeterminant()\n  }\n\n  hasFullRank(): boolean {\n    return Math.min(this.width, this.height) == this.rank()\n  }\n\n  permutationAsIndexMap(): int[] {\n    assertf(() => this.isPermutation())\n    const result = new Array(this.height)\n    let i = this.height\n    while (i--) {\n      const searchIndexStart = i * this.width\n      let searchIndex = searchIndexStart\n      while (this.m[searchIndex] < 0.5) searchIndex++\n      result[i] = searchIndex - searchIndexStart\n    }\n    return result\n  }\n\n  getDependentRowIndexes(\n    gauss: { L: Matrix; U: Matrix; P: Matrix } = this.luDecomposition(),\n  ): int[] {\n    const { L, U, P } = gauss\n    // rows which end up as zero vectors in U are not linearly independent\n    const dependents = new Array(this.height)\n    let uRowIndex = this.height\n    while (uRowIndex--) {\n      const uRow = U.row(uRowIndex)\n      if (uRow.length() < NLA_PRECISION) {\n        dependents[uRowIndex] = true\n      } else {\n        break\n      }\n    }\n    // figure out from which other rows the rows which end up as zero vectors are created by\n    let lRowIndex = this.height\n    while (lRowIndex--) {\n      if (dependents[lRowIndex]) {\n        let lColIndex = Math.min(lRowIndex, this.width)\n        while (lColIndex--) {\n          if (0 !== L.e(lRowIndex, lColIndex)) {\n            dependents[lColIndex] = true\n          }\n        }\n      }\n    }\n    console.log(\n      \"m\\n\",\n      this.toString((x) => \"\" + x),\n    )\n    console.log(\n      \"L\\n\",\n      L.toString((x) => \"\" + x),\n    )\n    console.log(\n      \"U\\n\",\n      U.toString((x) => \"\" + x),\n    )\n    console.log(\n      \"P\\n\",\n      P.toString((x) => \"\" + x),\n    )\n    // gauss algorithm permutes the order of the rows, so map our results back to the original indices\n    const indexMap = P.permutationAsIndexMap()\n    return dependents\n      .map((b, index) => b && indexMap[index])\n      .filter((x) => x != undefined)\n  }\n\n  lerp(b: Matrix, t: number, result = this.new()): this {\n    assertInst(Matrix, b, result)\n    assertNumbers(t)\n    assert(this.width == b.width && this.height == b.height)\n    const s = 1 - t\n    let i = this.m.length\n    while (i--) {\n      result.m[i] = s * this.m[i] + t * b.m[i]\n    }\n    return result\n  }\n}\n","import { JavaMap } from \"javasetmap.ts\"\n\nimport {\n  addOwnProperties,\n  arrayFromFunction,\n  assert,\n  assertf,\n  assertInst,\n  assertInts,\n  assertNumbers,\n  assertVectors,\n  callSource,\n  concatenated,\n  DEG,\n  eq,\n  eq0,\n  getLast,\n  int,\n  Matrix,\n  max,\n  NLA_PRECISION,\n  raddd,\n  sliceStep,\n  solveCubicReal2,\n  Transformable,\n  V3,\n  VV,\n} from \".\"\n\nconst { PI, abs } = Math\n\n// tslint:enable:member-ordering\nexport class M4 extends Matrix {\n  /**\n   * A simple (consists of integers), regular, non-orthogonal matrix, useful\n   * mainly for testing. M4.FOO_INV = M4.FOO.inverse()\n   */\n  // prettier-ignore\n  static readonly FOO = new M4(\n    0,   1,   1,    2,\n    0.3, 0.4, 0.8, 13,\n    2.1, 3.4, 5.5,  8.9,\n    0,   0,   0,    1,\n  )\n  static readonly FOO_INV = M4.FOO.inversed()\n  static readonly IDENTITY = M4.identity()\n  // prettier-ignore\n  static readonly O = new M4(\n    0, 0, 0, 0,\n    0, 0, 0, 0,\n    0, 0, 0, 0,\n    0, 0, 0, 0,\n  )\n  static readonly YZX = M4.forSys(V3.Y, V3.Z, V3.X)\n  static readonly ZXY = M4.forSys(V3.Z, V3.X, V3.Y)\n  // prettier-ignore\n  static IDENTITY3 = new M4(\n    1, 0, 0, 0,\n    0, 1, 0, 0,\n    0, 0, 1, 0,\n    0, 0, 0, 0,\n  )\n  static readonly temp0 = new M4()\n  static readonly temp1 = new M4()\n  static readonly temp2 = new M4()\n\n  static readonly NAMEMAP = new JavaMap<M4, string>()\n    .set(M4.IDENTITY3, \"M4.IDENTITY3\")\n    .set(M4.FOO, \"M4.FOO\")\n    .set(M4.O, \"M4.O\")\n    .set(M4.FOO_INV, \"M4.FOO_INV\")\n    .set(M4.IDENTITY, \"M4.IDENTITY\")\n    .set(M4.ZXY, \"M4.ZXY\")\n    .set(M4.YZX, \"M4.YZX\")\n\n  /**\n   * Takes 16 arguments in row-major order, which can be passed individually, as\n   * a list, or even as four lists, one for each row. If the arguments are\n   * omitted then the identity matrix is constructed instead.\n   *\n   *     ```\n   *     0 1 2 3\n   *     4 5 6 7\n   *     8 9 10 11\n   *     12 13 14 15\n   *     ```\n   */\n  constructor(...var_args: (number | number[])[]) {\n    let m\n    if (0 == var_args.length) {\n      m = new Float64Array(16)\n    } else {\n      const flattened = concatenated(var_args)\n      assert(\n        flattened.length == 16,\n        \"flattened.length == 16 \" + flattened.length,\n      )\n      m = new Float64Array(flattened)\n    }\n    super(4, 4, m)\n  }\n\n  /**\n   * Returns the matrix that when multiplied with `matrix` results in the\n   * identity matrix. You can optionally pass an existing matrix in `result` to\n   * avoid allocating a new matrix. This implementation is from the Mesa OpenGL\n   * function `__gluInvertMatrixd()` found in `project.c`.\n   */\n  static inverse(matrix: M4, result: M4 = new M4()): M4 {\n    return matrix.inversed4(result) as M4\n  }\n\n  /**\n   * Create new dim x dim matrix equal to an identity matrix with rows/colums i\n   * and k swapped. Note that i and k are 0-indexed.\n   */\n  static permutation4(i: int, k: int, result = new M4()): Matrix {\n    assertInts(i, k)\n    assertf(() => 0 <= i && i < 4)\n    assertf(() => 0 <= k && k < 4)\n    const m = result.m\n    M4.identity(result)\n    m[i * 4 + i] = 0\n    m[k * 4 + k] = 0\n    m[i * 4 + k] = 1\n    m[k * 4 + i] = 1\n    return result\n  }\n\n  /**\n   * Returns `matrix`, exchanging columns for rows. You can optionally pass an\n   * existing matrix in `result` to avoid allocating a new matrix.\n   */\n  static transpose(matrix: M4, result: M4 = new M4()): M4 {\n    assertInst(M4, matrix)\n    assertInst(M4, result)\n    assert(matrix != result, \"matrix != result\")\n    const m = matrix.m,\n      r = result.m\n    r[0] = m[0]\n    r[1] = m[4]\n    r[2] = m[8]\n    r[3] = m[12]\n    r[4] = m[1]\n    r[5] = m[5]\n    r[6] = m[9]\n    r[7] = m[13]\n    r[8] = m[2]\n    r[9] = m[6]\n    r[10] = m[10]\n    r[11] = m[14]\n    r[12] = m[3]\n    r[13] = m[7]\n    r[14] = m[11]\n    r[15] = m[15]\n    return result\n  }\n\n  /** Returns the concatenation of the transforms for `left` and `right`. */\n  static multiply(left: M4, right: M4, result: M4 = new M4()): M4 {\n    assertInst(M4, left, right)\n    assertInst(M4, result)\n    assert(left != result, \"left != result\")\n    assert(right != result, \"right != result\")\n    const a = left.m,\n      b = right.m,\n      r = result.m\n\n    r[0] = a[0] * b[0] + a[1] * b[4] + (a[2] * b[8] + a[3] * b[12])\n    r[1] = a[0] * b[1] + a[1] * b[5] + (a[2] * b[9] + a[3] * b[13])\n    r[2] = a[0] * b[2] + a[1] * b[6] + (a[2] * b[10] + a[3] * b[14])\n    r[3] = a[0] * b[3] + a[1] * b[7] + (a[2] * b[11] + a[3] * b[15])\n\n    r[4] = a[4] * b[0] + a[5] * b[4] + (a[6] * b[8] + a[7] * b[12])\n    r[5] = a[4] * b[1] + a[5] * b[5] + (a[6] * b[9] + a[7] * b[13])\n    r[6] = a[4] * b[2] + a[5] * b[6] + (a[6] * b[10] + a[7] * b[14])\n    r[7] = a[4] * b[3] + a[5] * b[7] + (a[6] * b[11] + a[7] * b[15])\n\n    r[8] = a[8] * b[0] + a[9] * b[4] + (a[10] * b[8] + a[11] * b[12])\n    r[9] = a[8] * b[1] + a[9] * b[5] + (a[10] * b[9] + a[11] * b[13])\n    r[10] = a[8] * b[2] + a[9] * b[6] + (a[10] * b[10] + a[11] * b[14])\n    r[11] = a[8] * b[3] + a[9] * b[7] + (a[10] * b[11] + a[11] * b[15])\n\n    r[12] = a[12] * b[0] + a[13] * b[4] + (a[14] * b[8] + a[15] * b[12])\n    r[13] = a[12] * b[1] + a[13] * b[5] + (a[14] * b[9] + a[15] * b[13])\n    r[14] = a[12] * b[2] + a[13] * b[6] + (a[14] * b[10] + a[15] * b[14])\n    r[15] = a[12] * b[3] + a[13] * b[7] + (a[14] * b[11] + a[15] * b[15])\n\n    return result\n  }\n\n  static product(...m4s: M4[]): M4\n  static product(m4s: M4[], result?: M4): M4\n  static product(...args: any[]): M4 {\n    const [m4s, result]: [M4[], M4] = Array.isArray(args[0])\n      ? [args[0], args[1]]\n      : [args, new M4()]\n    if (0 == m4s.length) return M4.identity(result)\n    if (1 == m4s.length) return M4.copy(m4s[0], result)\n    if (2 == m4s.length) return M4.multiply(m4s[0], m4s[1], result)\n    let a = M4.temp0,\n      b = M4.temp1\n    M4.multiply(m4s[0], m4s[1], a)\n    for (let i = 2; i < m4s.length - 1; i++) {\n      M4.multiply(a, m4s[i], b)\n      ;[a, b] = [b, a]\n    }\n    return M4.multiply(a, getLast(m4s), result)\n  }\n\n  static forSys(e0: V3, e1: V3, e2: V3 = e0.cross(e1), origin: V3 = V3.O): M4 {\n    assertVectors(e0, e1, e2, origin)\n    // prettier-ignore\n    return new M4(\n      e0.x, e1.x, e2.x, origin.x,\n      e0.y, e1.y, e2.y, origin.y,\n      e0.z, e1.z, e2.z, origin.z,\n      0, 0, 0, 1,\n    )\n  }\n\n  static forRows(n0: V3, n1: V3, n2: V3, n3: V3 = V3.O): M4 {\n    assertVectors(n0, n1, n2, n3)\n    // prettier-ignore\n    return new M4(\n      n0.x, n0.y, n0.z, 0,\n      n1.x, n1.y, n1.z, 0,\n      n2.x, n2.y, n2.z, 0,\n      n3.x, n3.y, n3.z, 1)\n  }\n\n  /**\n   * Returns an identity matrix. You can optionally pass an existing matrix in\n   * `result` to avoid allocating a new matrix. This emulates the OpenGL\n   * function `glLoadIdentity()`\n   *\n   * Unless initializing a matrix to be modified, use M4.IDENTITY\n   */\n  static identity(result: M4 = new M4()): M4 {\n    assertInst(M4, result)\n    const m = result.m\n    m[0] = m[5] = m[10] = m[15] = 1\n    m[1] = m[2] = m[3] = m[4] = m[6] = m[7] = m[8] = m[9] = m[11] = m[12] = m[13] = m[14] = 0\n\n    return result\n  }\n\n  /**\n   * Creates a new M4 initialized by a user defined callback function\n   *\n   * @param f Signature: (elRow, elCol, elIndex) =>\n   *     el, where elIndex is the row-major index, i.e. eLindex == elRow * 4 + elCol\n   * @param result\n   */\n  static fromFunction4(\n    f: (elRow: number, elCol: number, elIndex: number) => number,\n    result: M4 = new M4(),\n  ): M4 {\n    assert(typeof f == \"function\")\n    assertInst(M4, result)\n    const m = result.m\n    let i = 16\n    while (i--) {\n      m[i] = f(Math.floor(i / 4), i % 4, i)\n    }\n    return result\n  }\n\n  /**\n   * Returns a perspective transform matrix, which makes far away objects appear\n   * smaller than nearby objects. The `aspect` argument should be the width\n   * divided by the height of your viewport and `fov` is the top-to-bottom\n   * angle of the field of view in degrees. You can optionally pass an existing\n   * matrix in `result` to avoid allocating a new matrix. This emulates the\n   * OpenGL function `gluPerspective()`. {@see perspectiveRad} perspectiveRad\n   *\n   * @param fovDegrees In degrees\n   * @param aspect Aspect ratio = width/height of viewport\n   * @param near Near plane\n   * @param far Far plane\n   * @param result A new M4 as described.\n   */\n  static perspective(\n    fovDegrees: number,\n    aspect: number,\n    near: number,\n    far: number,\n    result: M4 = new M4(),\n  ): M4 {\n    return M4.perspectiveRad(fovDegrees * DEG, aspect, near, far, result)\n  }\n\n  static perspectiveRad(\n    fov: raddd,\n    aspect: number,\n    near: number,\n    far: number,\n    result: M4 = new M4(),\n  ): M4 {\n    assertInst(M4, result)\n    assertNumbers(fov, aspect, near, far)\n    const y = Math.tan(fov / 2) * near\n    const x = y * aspect\n    return M4.frustum(-x, x, -y, y, near, far, result)\n  }\n\n  static perspectivePlane(\n    vanishingPlane: { normal1: V3; w: number },\n    result: M4 = new M4(),\n  ) {\n    assertInst(M4, result)\n    const m = result.m\n    m[0] = 1\n    m[1] = 0\n    m[2] = 0\n    m[3] = 0\n\n    m[4] = 0\n    m[5] = 1\n    m[6] = 0\n    m[7] = 0\n\n    m[8] = 0\n    m[9] = 0\n    m[10] = 1\n    m[11] = 0\n\n    m[12] = vanishingPlane.normal1.x\n    m[13] = vanishingPlane.normal1.y\n    m[14] = vanishingPlane.normal1.z\n    m[15] = -vanishingPlane.w\n\n    return result\n  }\n\n  // the OpenGL function `glFrustum()`.\n  static frustum(\n    left: number,\n    right: number,\n    bottom: number,\n    top: number,\n    near: number,\n    far: number,\n    result: M4 = new M4(),\n  ): M4 {\n    assertNumbers(left, right, bottom, top, near, far)\n    assert(0 < near, \"0 < near\")\n    assert(near < far, \"near < far\")\n    assertInst(M4, result)\n    const m = result.m\n\n    m[0] = (2 * near) / (right - left)\n    m[1] = 0\n    m[2] = (right + left) / (right - left)\n    m[3] = 0\n\n    m[4] = 0\n    m[5] = (2 * near) / (top - bottom)\n    m[6] = (top + bottom) / (top - bottom)\n    m[7] = 0\n\n    m[8] = 0\n    m[9] = 0\n    m[10] = -(far + near) / (far - near)\n    m[11] = (-2 * far * near) / (far - near)\n\n    m[12] = 0\n    m[13] = 0\n    m[14] = -1\n    m[15] = 0\n\n    return result\n  }\n\n  /** Returns a new M4 representing the a projection through/towards a point onto a plane. */\n  static projectPlanePoint(\n    p: V3,\n    plane: { normal1: V3; w: number },\n    result: M4 = new M4(),\n  ): M4 {\n    assertVectors(p, plane.normal1)\n    assertInst(M4, result)\n    const m = result.m\n    const n = plane.normal1,\n      w = plane.w\n    const np = n.dot(p)\n\n    m[0] = p.x * n.x + w - np\n    m[1] = p.x * n.y\n    m[2] = p.x * n.z\n    m[3] = -w * p.x\n\n    m[4] = p.y * n.x\n    m[5] = p.y * n.y + w - np\n    m[6] = p.y * n.z\n    m[7] = -w * p.y\n\n    m[8] = p.z * n.x\n    m[9] = p.z * n.y\n    m[10] = p.z * n.z + w - np\n    m[11] = -w * p.z\n\n    m[12] = n.x\n    m[13] = n.y\n    m[14] = n.z\n    m[15] = -np\n\n    return result\n  }\n\n  /**\n   * Orthographic/orthogonal projection. Transforms the cuboid with the\n   * dimensions X: [left right] Y: [bottom, top] Z: [near far] to the cuboid X:\n   * [-1, 1] Y [-1, 1] Z [-1, 1]\n   */\n  static ortho(\n    left: number,\n    right: number,\n    bottom: number,\n    top: number,\n    near: number,\n    far: number,\n    result: M4 = new M4(),\n  ): M4 {\n    assertNumbers(left, right, bottom, top, near, far)\n    assertInst(M4, result)\n    const m = result.m\n\n    m[0] = 2 / (right - left)\n    m[1] = 0\n    m[2] = 0\n    m[3] = -(right + left) / (right - left)\n\n    m[4] = 0\n    m[5] = 2 / (top - bottom)\n    m[6] = 0\n    m[7] = -(top + bottom) / (top - bottom)\n\n    m[8] = 0\n    m[9] = 0\n    m[10] = -2 / (far - near)\n    m[11] = -(far + near) / (far - near)\n\n    m[12] = 0\n    m[13] = 0\n    m[14] = 0\n    m[15] = 1\n\n    return result\n  }\n\n  /**\n   * This emulates the OpenGL function `glScale()`. You can optionally pass an\n   * existing matrix in `result` to avoid allocating a new matrix.\n   */\n  static scale(x: number, y: number, z?: number, result?: M4): M4\n\n  static scale(scale: number, result?: M4): M4\n\n  static scale(v: V3, result?: M4): M4\n\n  static scale(...args: any[]): M4 {\n    let x: number, y: number, z: number, result: M4\n    if (args[0] instanceof V3) {\n      assert(args.length <= 2)\n      ;({ x, y, z } = args[0])\n      result = args[1]\n    } else if (\"number\" != typeof args[1]) {\n      x = y = z = args[0]\n      result = args[1]\n    } else {\n      assert(args.length <= 4)\n      x = args[0]\n      y = args[1]\n      z = undefined != args[2] ? args[2] : 1\n      result = args[3]\n    }\n    undefined == result && (result = new M4())\n    assertInst(M4, result)\n    assertNumbers(x, y, z)\n\n    const m = result.m\n    m[0] = x\n    m[1] = 0\n    m[2] = 0\n    m[3] = 0\n\n    m[4] = 0\n    m[5] = y\n    m[6] = 0\n    m[7] = 0\n\n    m[8] = 0\n    m[9] = 0\n    m[10] = z\n    m[11] = 0\n\n    m[12] = 0\n    m[13] = 0\n    m[14] = 0\n    m[15] = 1\n\n    return result\n  }\n\n  /**\n   * This emulates the OpenGL function `glTranslate()`. You can optionally pass\n   * an existing matrix in `result` to avoid allocating a new matrix.\n   */\n  static translate(x: number, y?: number, z?: number, result?: M4): M4\n\n  static translate(v: V3, result?: M4): M4\n\n  static translate(...args: any[]): M4 {\n    let x, y, z, result\n    if (args[0] instanceof V3) {\n      assert(args.length <= 2)\n      ;({ x, y, z } = args[0])\n      result = args[1]\n    } else {\n      assert(args.length <= 4)\n      x = args[0]\n      y = undefined != args[1] ? args[1] : 0\n      z = undefined != args[2] ? args[2] : 0\n      result = args[3]\n    }\n    undefined == result && (result = new M4())\n    assertInst(M4, result)\n    assertNumbers(x, y, z)\n\n    const m = result.m\n\n    m[0] = 1\n    m[1] = 0\n    m[2] = 0\n    m[3] = x\n\n    m[4] = 0\n    m[5] = 1\n    m[6] = 0\n    m[7] = y\n\n    m[8] = 0\n    m[9] = 0\n    m[10] = 1\n    m[11] = z\n\n    m[12] = 0\n    m[13] = 0\n    m[14] = 0\n    m[15] = 1\n\n    return result\n  }\n\n  /**\n   * Returns a matrix that rotates by `a` degrees around the vector (x, y, z).\n   * You can optionally pass an existing matrix in `result` to avoid allocating\n   * a new matrix. This emulates the OpenGL function `glRotate()`.\n   */\n  //static rotation(radians: raddd, x: number, y: number, z: number, result?: M4): M4\n  static rotate(\n    radians: raddd,\n    v: { x: number; y: number; z: number },\n    result?: M4,\n  ): M4 {\n    undefined == result && (result = new M4())\n    assertInst(M4, result)\n    let { x, y, z } = v\n    assert(!new V3(x, y, z).likeO(), \"!V(x, y, z).likeO()\")\n    const m = result.m\n\n    const d = Math.sqrt(x * x + y * y + z * z)\n    x /= d\n    y /= d\n    z /= d\n    const cos = Math.cos(radians),\n      sin = Math.sin(radians),\n      t = 1 - cos\n\n    m[0] = x * x * t + cos\n    m[1] = x * y * t - z * sin\n    m[2] = x * z * t + y * sin\n    m[3] = 0\n\n    m[4] = y * x * t + z * sin\n    m[5] = y * y * t + cos\n    m[6] = y * z * t - x * sin\n    m[7] = 0\n\n    m[8] = z * x * t - y * sin\n    m[9] = z * y * t + x * sin\n    m[10] = z * z * t + cos\n    m[11] = 0\n\n    m[12] = 0\n    m[13] = 0\n    m[14] = 0\n    m[15] = 1\n\n    return result\n  }\n\n  /**\n   * Returns a matrix that puts the camera at the eye point `ex, ey, ez` looking\n   * toward the center point `cx, cy, cz` with an up direction of `ux, uy, uz`.\n   * You can optionally pass an existing matrix in `result` to avoid allocating\n   * a new matrix. This emulates the OpenGL function `gluLookAt()`.\n   */\n  static lookAt(eye: V3, focus: V3, up: V3, result: M4 = new M4()): M4 {\n    assertVectors(eye, focus, up)\n    assertInst(M4, result)\n\n    const m = result.m\n\n    const f = eye.minus(focus).unit()\n    const s = up.cross(f).unit()\n    const t = f.cross(s).unit()\n\n    m[0] = s.x\n    m[1] = s.y\n    m[2] = s.z\n    m[3] = -s.dot(eye)\n\n    m[4] = t.x\n    m[5] = t.y\n    m[6] = t.z\n    m[7] = -t.dot(eye)\n\n    m[8] = f.x\n    m[9] = f.y\n    m[10] = f.z\n    m[11] = -f.dot(eye)\n\n    m[12] = 0\n    m[13] = 0\n    m[14] = 0\n    m[15] = 1\n\n    return result\n  }\n\n  /** Create a rotation matrix for rotating around the X axis */\n  static rotateX(radians: raddd): M4 {\n    assertNumbers(radians)\n    const sin = Math.sin(radians),\n      cos = Math.cos(radians)\n    const els = [1, 0, 0, 0, 0, cos, -sin, 0, 0, sin, cos, 0, 0, 0, 0, 1]\n    return new M4(els)\n  }\n\n  /** Create a rotation matrix for rotating around the Y axis */\n  static rotateY(radians: raddd): M4 {\n    const sin = Math.sin(radians),\n      cos = Math.cos(radians)\n    const els = [cos, 0, sin, 0, 0, 1, 0, 0, -sin, 0, cos, 0, 0, 0, 0, 1]\n    return new M4(els)\n  }\n\n  /** Create a rotation matrix for rotating around the Z axis */\n  static rotateZ(radians: raddd): M4 {\n    const sin = Math.sin(radians),\n      cos = Math.cos(radians)\n    const els = [cos, -sin, 0, 0, sin, cos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]\n    return new M4(els)\n  }\n\n  /**\n   * New rotation matrix such that result.transformVector(a).isParallelTo(b)\n   * through smallest rotation. Performs no scaling.\n   */\n  static rotateAB(a: V3, b: V3, result: M4 = new M4()): M4 {\n    // see http://inside.mines.edu/fs_home/gmurray/ArbitraryAxisRotation/\n    assertVectors(a, b)\n    assertInst(M4, result)\n    const rotationAxis = a.cross(b),\n      rotationAxisLength = rotationAxis.length()\n    if (eq0(rotationAxisLength)) {\n      return M4.identity(result)\n    }\n    const radians = Math.atan2(rotationAxisLength, a.dot(b))\n    return M4.rotateLine(V3.O, rotationAxis, radians, result)\n  }\n\n  /**\n   * Matrix for rotation about arbitrary line defined by an anchor point and\n   * direction. rotationAxis does not need to be unit\n   */\n  static rotateLine(\n    rotationAnchor: V3,\n    rotationAxis: V3,\n    radians: raddd,\n    result: M4 = new M4(),\n  ): M4 {\n    // see http://inside.mines.edu/fs_home/gmurray/ArbitraryAxisRotation/\n    assertVectors(rotationAnchor, rotationAxis)\n    assertNumbers(radians)\n    assertInst(M4, result)\n    rotationAxis = rotationAxis.unit()\n\n    const ax = rotationAnchor.x,\n      ay = rotationAnchor.y,\n      az = rotationAnchor.z,\n      dx = rotationAxis.x,\n      dy = rotationAxis.y,\n      dz = rotationAxis.z\n    const m = result.m,\n      cos = Math.cos(radians),\n      sin = Math.sin(radians)\n\n    m[0] = dx * dx + (dy * dy + dz * dz) * cos\n    m[1] = dx * dy * (1 - cos) - dz * sin\n    m[2] = dx * dz * (1 - cos) + dy * sin\n    m[3] =\n      (ax * (dy * dy + dz * dz) - dx * (ay * dy + az * dz)) * (1 - cos) +\n      (ay * dz - az * dy) * sin\n\n    m[4] = dx * dy * (1 - cos) + dz * sin\n    m[5] = dy * dy + (dx * dx + dz * dz) * cos\n    m[6] = dy * dz * (1 - cos) - dx * sin\n    m[7] =\n      (ay * (dx * dx + dz * dz) - dy * (ax * dx + az * dz)) * (1 - cos) +\n      (az * dx - ax * dz) * sin\n\n    m[8] = dx * dz * (1 - cos) - dy * sin\n    m[9] = dy * dz * (1 - cos) + dx * sin\n    m[10] = dz * dz + (dx * dx + dy * dy) * cos\n    m[11] =\n      (az * (dx * dx + dy * dy) - dz * (ax * dx + ay * dy)) * (1 - cos) +\n      (ax * dy - ay * dx) * sin\n\n    m[12] = 0\n    m[13] = 0\n    m[14] = 0\n    m[15] = 1\n\n    return result\n  }\n\n  /** Create an affine matrix for mirroring into an arbitrary plane: */\n  static mirror(plane: { normal1: V3; w: number }, result: M4 = new M4()): M4 {\n    assertVectors(plane.normal1)\n    assertInst(M4, result)\n    const [nx, ny, nz] = plane.normal1\n    const w = plane.w\n    const m = result.m\n\n    m[0] = 1.0 - 2.0 * nx * nx\n    m[1] = -2.0 * ny * nx\n    m[2] = -2.0 * nz * nx\n    m[3] = 2.0 * nx * w\n\n    m[4] = -2.0 * nx * ny\n    m[5] = 1.0 - 2.0 * ny * ny\n    m[6] = -2.0 * nz * ny\n    m[7] = 2.0 * ny * w\n\n    m[8] = -2.0 * nx * nz\n    m[9] = -2.0 * ny * nz\n    m[10] = 1.0 - 2.0 * nz * nz\n    m[11] = 2.0 * nz * w\n\n    m[12] = 0\n    m[13] = 0\n    m[14] = 0\n    m[15] = 1\n    return result\n  }\n\n  /**\n   * @param plane\n   * @param dir Projection direction. Optional, if not specified plane normal1\n   *     will be used.\n   * @param result {@see M4}\n   */\n  static project(\n    plane: { normal1: V3; w: number },\n    dir: V3 = plane.normal1,\n    result: M4 = new M4(),\n  ): M4 {\n    // TODO: doc\n\n    // plane.normal1 DOT (p + lambda * dir) = w (1)\n    // extract lambda:\n    // plane.normal1 DOT p + lambda * plane.normal1 DOT dir = w\n    // lambda = (w - plane.normal1 DOT p) / plane.normal1 DOT dir\n    // result = p + lambda * dir\n    // result = p + dir * (w - plane.normal1 DOT p) / plane.normal1 DOT dir\n    // result =  w * dir / (plane.normal1 DOT dir) + p - plane.normal1 DOT p * dir / (plane.normal1 DOT dir) *\n\n    //  a + d * (w - n . a) / (nd)\n    //  a + dw - d * na\n    assertVectors(dir, plane.normal1)\n    assertInst(M4, result)\n    const w = plane.w\n    const m = result.m\n    const nd = plane.normal1.dot(dir)\n    const { x: nx, y: ny, z: nz } = plane.normal1\n    const { x: dx, y: dy, z: dz } = dir.div(nd)\n    /*\n     rejectedFrom: return this.minus(b.times(this.dot(b) / b.dot(b)))\n     return M4.forSys(\n     V3.X.rejectedFrom(plane.normal1),\n     V3.Y.rejectedFrom(plane.normal1),\n     V3.Z.rejectedFrom(plane.normal1),\n     plane.anchor,\n     result\n     )\n     */\n\n    m[0] = 1.0 - nx * dx\n    m[1] = -ny * dx\n    m[2] = -nz * dx\n    m[3] = dx * w\n\n    m[4] = -nx * dy\n    m[5] = 1.0 - ny * dy\n    m[6] = -nz * dy\n    m[7] = dy * w\n\n    m[8] = -nx * dz\n    m[9] = -ny * dz\n    m[10] = 1.0 - nz * dz\n    m[11] = dz * w\n\n    m[12] = 0\n    m[13] = 0\n    m[14] = 0\n    m[15] = 1\n\n    return result\n  }\n\n  static lineProjection(\n    line: { anchor: V3; dir1: V3 },\n    result: M4 = new M4(),\n  ): M4 {\n    assertVectors(line.anchor, line.dir1)\n    assertInst(M4, result)\n    const ax = line.anchor.x,\n      ay = line.anchor.y,\n      az = line.anchor.z\n    const dx = line.dir1.x,\n      dy = line.dir1.y,\n      dz = line.dir1.z\n    const m = result.m\n\n    /*\n     projectedOn: return b.times(this.dot(b) / b.dot(b))\n     */\n\n    m[0] = dx * dx\n    m[1] = dx * dy\n    m[2] = dx * dz\n    m[3] = ax\n\n    m[4] = dy * dx\n    m[5] = dy * dy\n    m[6] = dy * dz\n    m[7] = ay\n\n    m[8] = dz * dx\n    m[9] = dz * dy\n    m[10] = dz * dz\n    m[11] = az\n\n    m[12] = 0\n    m[13] = 0\n    m[14] = 0\n    m[15] = 1\n    return result\n  }\n\n  static pointInversion(p: V3, result: M4 = new M4()): M4 {\n    assertVectors(p)\n    assertInst(M4, result)\n    const m = result.m\n\n    m[0] = -1\n    m[1] = 0\n    m[2] = 0\n    m[3] = 2 * p.x\n\n    m[4] = 0\n    m[5] = -1\n    m[6] = 0\n    m[7] = 2 * p.y\n\n    m[8] = 0\n    m[9] = 0\n    m[10] = -1\n    m[11] = 2 * p.z\n\n    m[12] = 0\n    m[13] = 0\n    m[14] = 0\n    m[15] = 1\n    return result\n  }\n\n  protected static new(width: int, height: int, m: Float64Array) {\n    assert(4 == width && 4 == height)\n    return new M4(...m)\n  }\n\n  get X(): V3 {\n    return this.transformVector(V3.X)\n  }\n\n  get Y(): V3 {\n    return this.transformVector(V3.Y)\n  }\n\n  get Z(): V3 {\n    return this.transformVector(V3.Z)\n  }\n\n  get O(): V3 {\n    return this.getTranslation()\n  }\n\n  isMirror(precision = NLA_PRECISION) {\n    const m = this.m\n    const nx = Math.sqrt((1 - m[0]) / 2)\n    const ny = Math.sqrt((1 - m[5]) / 2)\n    const nz = Math.sqrt((1 - m[10]) / 2)\n\n    return (\n      eq(m[1], -2.0 * ny * nx, precision) &&\n      eq(m[2], -2.0 * nz * nx, precision) &&\n      eq(m[4], -2.0 * nx * ny, precision) &&\n      eq(m[6], -2.0 * nz * ny, precision) &&\n      eq(m[8], -2.0 * nx * nz, precision) &&\n      eq(m[9], -2.0 * ny * nz, precision) &&\n      eq(m[12], 0, precision) &&\n      eq(m[13], 0, precision) &&\n      eq(m[14], 0, precision) &&\n      eq(m[15], 1, precision) &&\n      eq(m[3] * ny, m[7] * nx, precision) &&\n      eq(m[7] * nz, m[11] * ny, precision) &&\n      eq(m[11] * nx, m[3] * nz, precision)\n    )\n  }\n\n  // ### GL.Matrix.frustum(left, right, bottom, top, near, far[, result])\n  //\n  // Sets up a viewing frustum, which is shaped like a truncated pyramid with the\n  // camera where the point of the pyramid would be. You can optionally pass an\n  // existing matrix in `result` to avoid allocating a new matrix. This emulates\n\n  /** Returns a new M4 which is equal to the inverse of this. */\n  inversed(result?: M4): M4 {\n    return M4.inverse(this, result)\n  }\n\n  /** Matrix trace is defined as the sum of the elements of the main diagonal. */\n  trace(): number {\n    return this.m[0] + this.m[5] + this.m[10] + this.m[15]\n  }\n\n  as3x3(result?: M4): M4 {\n    result = M4.copy<M4>(this, result)\n    const m = result.m\n\n    m[3] = m[7] = m[11] = m[12] = m[13] = m[14] = 0\n    m[15] = 1\n    return result\n  }\n\n  transform(m4: M4): this {\n    return m4.times(this) as this\n  }\n\n  realEigenValues3(): number[] {\n    const m = this.m\n    assert(0 == m[12] && 0 == m[13] && 0 == m[14])\n    // determinant of (this - I):\n    // | a-  b   c  |\n    // |  d  e-  f  | = -^3 + ^2 (a+e+i) +  (-a e-a i+b d+c g-e i+f h) + a(ei - fh) - b(di - fg) + c(dh - eg)\n    // |  g   h  i- |\n\n    const [a, b, c, , d, e, f, , g, h, i] = m\n    // det(this - I) = -^3 +^2 (a+e+i) +  (-a e-a i-b d+c g-e i+f h)+ (a e i-a f h-b d i+b f g+c d h-c e g)\n    const s = -1\n    const t = a + e + i // equivalent to trace of matrix\n    const u = -a * e - a * i + b * d + c * g - e * i + f * h // equivalent to 1/2 (trace(this) - trace(A))\n    const w = a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g) // equivalent to matrix determinant\n\n    console.log(s, t, u, w)\n    return solveCubicReal2(s, t, u, w)\n  }\n\n  realEigenVectors3(): V3[] {\n    const eigenValues = this.realEigenValues3()\n    const this3x3 = this.times(M4.IDENTITY3)\n    console.log(this.toString())\n    console.log(this3x3.toString())\n    let mats = eigenValues.map((ev) => M4.IDENTITY3.scale(-ev).plus(this3x3))\n    console.log(mats.map((m) => m.determinant3()))\n    console.log(mats.map((m) => \"\" + m.toString((v) => \"\" + v)).join(\"\\n\\n\"))\n    console.log(\n      mats\n        .map((m) => \"\" + m.luDecomposition().U.toString((v) => \"\" + v))\n        .join(\"\\n\\n\"),\n    )\n    console.log(\n      \"mats.map(m=>m.rank())\",\n      mats.map((m) => m.rank()),\n    )\n    if (1 == eigenValues.length) {\n      console.log(mats[0].toString())\n      assertf(() => 0 == mats[0].rank())\n      // col vectors\n      return arrayFromFunction(\n        3,\n        (col) => new V3(this.m[col], this.m[4 + col], this.m[8 + col]),\n      )\n    }\n    if (2 == eigenValues.length) {\n      // one matrix should have rank 1, the other rank 2\n      if (1 == mats[0].rank()) {\n        mats = [mats[1], mats[0]]\n      }\n      assertf(() => 2 == mats[0].rank())\n      assertf(() => 1 == mats[1].rank())\n\n      // mat[0] has rank 2, mat[1] has rank 1\n      const gauss0 = mats[0].luDecomposition().U\n      const eigenVector0 = gauss0.row(0).cross(gauss0.row(1)).V3().unit()\n\n      const planeNormal = mats[1].luDecomposition().U.row(0).V3()\n      const eigenVector1 = planeNormal.getPerpendicular().unit()\n      const eigenVector2 = eigenVector0\n        .cross(eigenVector1)\n        .rejectedFrom(planeNormal)\n\n      return [eigenVector0, eigenVector1, eigenVector2]\n    }\n    if (3 == eigenValues.length) {\n      mats.forEach((mat, i) => assert(2 == mat.rank(), i + \": \" + mat.rank()))\n      // the (A - lambda I) matrices map to a plane. This means, that there is an entire line in R which maps to\n      // the point V3.O\n      return mats.map((mat) => {\n        const gauss = mat.luDecomposition().U\n        return gauss.row(0).cross(gauss.row(1)).V3().unit()\n      })\n    }\n    throw new Error(\"there cannot be more than 3 eigen values\")\n  }\n\n  /**\n   * U * SIGMA * VSTAR = this\n   *\n   * U and VSTAR are orthogonal matrices\n   *\n   * SIGMA is a diagonal matrix\n   */\n  svd3(): { U: M4; SIGMA: M4; VSTAR: M4 } {\n    function matrixForCS(i: int, k: int, c: number, s: number) {\n      const m = M4.identity()\n      m.setEl(i, i, c)\n      m.setEl(k, k, c)\n      m.setEl(i, k, s)\n      m.setEl(k, i, -s)\n      return m\n    }\n\n    const A = this.as3x3()\n    let S = A.transposed().times(A),\n      V = M4.identity()\n    console.log(S.toString())\n    for (let it = 0; it < 16; it++) {\n      console.log(\"blahg\\n\", V.times(S).times(V.transposed()).toString())\n      assert(\n        V.times(S).times(V.transposed()).likeM4(A.transposed().times(A)),\n        V.times(S).times(V.transposed()).toString(),\n        A.transposed().times(A).toString(),\n      )\n      let maxOffDiagonal = 0,\n        maxOffDiagonalIndex = 1,\n        j = 10\n      while (j--) {\n        const val = Math.abs(S.m[j])\n        if (j % 4 != Math.floor(j / 4) && val > maxOffDiagonal) {\n          maxOffDiagonal = val\n          maxOffDiagonalIndex = j\n        }\n      }\n\n      const i = Math.floor(maxOffDiagonalIndex / 4),\n        k = maxOffDiagonalIndex % 4\n      const a_ii = S.m[5 * i],\n        a_kk = S.m[5 * k],\n        a_ik = S.m[maxOffDiagonalIndex]\n      const phi =\n        a_ii === a_kk ? PI / 4 : Math.atan((2 * a_ik) / (a_ii - a_kk)) / 2\n      console.log(maxOffDiagonalIndex, i, k, \"phi\", phi)\n      const cos = Math.cos(phi),\n        sin = Math.sin(phi)\n      const givensRotation = matrixForCS(i, k, cos, -sin)\n      assert(givensRotation.transposed().times(givensRotation).likeIdentity())\n      console.log(givensRotation.toString())\n      V = V.times(givensRotation)\n      S = M4.product(givensRotation.transposed(), S, givensRotation)\n      console.log(S.toString())\n    }\n\n    const sigma = S.map((el, elIndex) => (elIndex % 5 == 0 ? Math.sqrt(el) : 0))\n    return {\n      U: M4.product(\n        A,\n        V,\n        sigma.map((el, elIndex) => (elIndex % 5 == 0 ? 1 / el : 0)),\n      ),\n      SIGMA: sigma,\n      VSTAR: V.transposed(),\n    }\n  }\n\n  map(fn: (el: number, elIndex: number, array: Float64Array) => number): M4 {\n    return M4.fromFunction4((x, y, i) => fn(this.m[i], i, this.m))\n  }\n\n  likeM4(m4: M4): boolean {\n    assertInst(M4, m4)\n    return this.m.every((el, index) => eq(el, m4.m[index]))\n  }\n\n  /** Returns a new M4 equal to the transpose of this. */\n  transposed(result?: M4): M4 {\n    return M4.transpose(this, result)\n  }\n\n  /** Returns a new M4 which equal to (this * matrix) (in that order) */\n  times(matrix: M4): M4 {\n    return M4.multiply(this, matrix)\n  }\n\n  /**\n   * In a perspective projection, parallel lines meet in a vanishing point.\n   *\n   * Returns undefined if there is no vanishing point, either because this is\n   * not a perspective transform, or because the passed dir is perpendicular to\n   * the projections direction.\n   *\n   * @param dir\n   */\n  vanishingPoint(dir: V3) {\n    assertVectors(dir)\n    const m = this.m\n    const vx = dir.x,\n      vy = dir.y,\n      vz = dir.z\n    const w = vx * m[12] + vy * m[13] + vz * m[14]\n    if (eq0(w)) return undefined\n    const x = vx * m[0] + vy * m[1] + vz * m[2]\n    const y = vx * m[4] + vy * m[5] + vz * m[6]\n    const z = vx * m[8] + vy * m[9] + vz * m[10]\n    return new V3(x / w, y / w, z / w)\n  }\n\n  /**\n   * Transforms the vector as a point with a w coordinate of 1. This means\n   * translations will have an effect, for example.\n   */\n  transformPoint(v: V3): V3 {\n    assertVectors(v)\n    const m = this.m\n    const vx = v.x,\n      vy = v.y,\n      vz = v.z\n    const x = vx * m[0] + vy * m[1] + vz * m[2] + m[3]\n    const y = vx * m[4] + vy * m[5] + vz * m[6] + m[7]\n    const z = vx * m[8] + vy * m[9] + vz * m[10] + m[11]\n    const w = vx * m[12] + vy * m[13] + vz * m[14] + m[15]\n    // scale such that fourth element becomes 1:\n    return new V3(x / w, y / w, z / w)\n  }\n\n  /**\n   * Transforms the vector as a vector with a w coordinate of 0. This means\n   * translations will have no effect, for example. Will throw an exception if\n   * the calculated w component != 0. This occurs for example when attempting\n   * to transform a vector with a perspective matrix.\n   */\n  transformVector(v: V3, checkW = true): V3 {\n    assertVectors(v)\n    const m = this.m\n    const w = v.x * m[12] + v.y * m[13] + v.z * m[14]\n    checkW &&\n      assert(\n        eq0(w),\n        () =>\n          \"w === 0 needs to be true for this to make sense (w =\" +\n          w +\n          this.toString(),\n      )\n    return new V3(\n      m[0] * v.x + m[1] * v.y + m[2] * v.z,\n      m[4] * v.x + m[5] * v.y + m[6] * v.z,\n      m[8] * v.x + m[9] * v.y + m[10] * v.z,\n    )\n  }\n\n  transformVector2(v: V3, anchor: V3): V3 {\n    // v and anchor define a line(t) = anchor + t v\n    // we can view the calculation of the transformed vector as the derivative of the transformed line at t = 0\n    // d/dt (this * line(t)) (0)\n    assertVectors(v, anchor)\n    const transformedAnchor = this.timesVector(\n      VV(anchor.x, anchor.y, anchor.z, 1),\n    )\n    const transformedVector = this.timesVector(VV(v.x, v.y, v.z, 0))\n    return transformedVector\n      .times(transformedAnchor.w)\n      .minus(transformedAnchor.times(transformedVector.w))\n      .div(transformedAnchor.w ** 2)\n      .V3()\n  }\n\n  transformedPoints(vs: ReadonlyArray<V3>): V3[] {\n    return vs.map((v) => this.transformPoint(v))\n  }\n\n  transformedVectors(vs: ReadonlyArray<V3>): V3[] {\n    return vs.map((v) => this.transformVector(v))\n  }\n\n  new() {\n    return new M4() as this\n  }\n\n  isRegular(): boolean {\n    return !eq0(this.determinant())\n  }\n\n  isAxisAligned(): boolean {\n    const m = this.m\n    return (\n      1 >= +!eq0(m[0]) + +!eq0(m[1]) + +!eq0(m[2]) &&\n      1 >= +!eq0(m[4]) + +!eq0(m[5]) + +!eq0(m[6]) &&\n      1 >= +!eq0(m[8]) + +!eq0(m[9]) + +!eq0(m[10])\n    )\n  }\n\n  /**\n   * A matrix M is orthogonal iff M * M^T = I I being the identity matrix.\n   *\n   * @returns If this matrix is orthogonal or very close to it. Comparison of\n   *     the identity matrix and this * this^T is done with {@link #likeM4}\n   */\n  isOrthogonal(): boolean {\n    // return this.transposed().times(this).likeM4(M4.IDENTITY)\n    M4.transpose(this, M4.temp0)\n    M4.multiply(this, M4.temp0, M4.temp1)\n    return M4.IDENTITY.likeM4(M4.temp1)\n  }\n\n  /**\n   * A matrix M is symmetric iff M == M^T I being the identity matrix.\n   *\n   * @returns If this matrix is symmetric or very close to it. Comparison of the\n   *     identity matrix and this * this^T is done with {@link #likeM4}\n   */\n  isSymmetric(): boolean {\n    M4.transpose(this, M4.temp0)\n    return this.likeM4(M4.temp0)\n  }\n\n  /** A matrix M is skew symmetric iff M = -M^T */\n  isSkewSymmetric(precision?: number): boolean {\n    return (\n      eq0(this.m[0], precision) &&\n      eq0(this.m[5], precision) &&\n      eq0(this.m[10], precision) &&\n      eq0(this.m[15], precision) &&\n      eq(this.m[1], this.m[4], precision) &&\n      eq(this.m[2], this.m[8], precision) &&\n      eq(this.m[3], this.m[12], precision) &&\n      eq(this.m[6], this.m[9], precision) &&\n      eq(this.m[7], this.m[13], precision) &&\n      eq(this.m[11], this.m[14], precision)\n    )\n  }\n\n  /**\n   * A matrix M is normal1 iff M * M^-T == M^T * M TODO: ^-T? I being the identity matrix.\n   *\n   * @returns If this matrix is symmetric or very close to it. Comparison of the\n   *     identity matrix and this * this^T is done with {@link #likeM4}\n   */\n  isNormal(): boolean {\n    M4.transpose(this, M4.temp0) // temp0 = this^-T\n    M4.multiply(this, M4.temp0, M4.temp1) // temp1 = this * this^-T\n    M4.multiply(M4.temp0, this, M4.temp2) // temp2 = this^-T * this\n    return M4.temp1.likeM4(M4.temp2)\n  }\n\n  /**\n   * Determinant of matrix.\n   *\n   * Notes:\n   *     For matrices A and B\n   *     det(A * B) = det(A) * det(B)\n   *     det(A^-1) = 1 / det(A)\n   */\n  determinant(): number {\n    // | a b c d |\n    // | e f g h |\n    // | i j k l |\n    // | m n o p |\n    const $ = this.m,\n      a = $[0],\n      b = $[1],\n      c = $[2],\n      d = $[3],\n      e = $[4],\n      f = $[5],\n      g = $[6],\n      h = $[7],\n      i = $[8],\n      j = $[9],\n      k = $[10],\n      l = $[11],\n      m = $[12],\n      n = $[13],\n      o = $[14],\n      p = $[15],\n      klop = k * p - l * o,\n      jlnp = j * p - l * n,\n      jkno = j * o - k * n,\n      ilmp = i * p - l * m,\n      ikmo = i * o - k * m,\n      ijmn = i * n - j * m\n    return (\n      a * (f * klop - g * jlnp + h * jkno) -\n      b * (e * klop - g * ilmp + h * ikmo) +\n      c * (e * jlnp - f * ilmp + h * ijmn) -\n      d * (e * jkno - f * ikmo + g * ijmn)\n    )\n  }\n\n  determinant3(): number {\n    const [a, b, c, , d, e, f, , g, h, i] = this.m\n    return a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g)\n  }\n\n  /** Determine whether this matrix is a mirroring transformation */\n  isMirroring(): boolean {\n    /*\n     var u = V(this.m[0], this.m[4], this.m[8])\n     var v = V(this.m[1], this.m[5], this.m[9])\n     var w = V(this.m[2], this.m[6], this.m[10])\n\n     // for a true orthogonal, non-mirrored base, u.cross(v) == w\n     // If they have an opposite direction then we are mirroring\n     var mirrorvalue = u.cross(v).dot(w)\n     var ismirror = (mirrorvalue < 0)\n     return ismirror\n     */\n\n    return this.determinant() < 0 // TODO: also valid for 4x4?\n  }\n\n  /** Get the translation part of this matrix, i.e. the result of this.transformPoint(V3.O) */\n  getTranslation(): V3 {\n    const m = this.m,\n      w = m[15]\n    return new V3(m[3] / w, m[7] / w, m[11] / w)\n  }\n\n  /**\n   * Returns this matrix scaled so that the determinant is 1. det(c * A) = (c **\n   * n) * det(A) for n x n matrices, so we need to divide by the 4th root of\n   * the determinant\n   */\n  normalized(): M4 {\n    const detAbs = abs(this.determinant())\n    return 1 == detAbs ? this : this.divScalar(detAbs ** 0.25)\n  }\n\n  /** Returns this matrix scaled so that the bottom-right element is 1. */\n  normalized2(): M4 {\n    const div = this.m[15]\n    return 1 == div ? this : this.divScalar(div)\n  }\n\n  /**\n   * Returns if the matrix has the following form (within NLA_PRECISION): a b c\n   * 0 c d e 0 f g h 0 0 0 0 1\n   */\n  like3x3(): boolean {\n    const m = this.m\n    return (\n      eq(1, m[15]) &&\n      eq0(m[12]) &&\n      eq0(m[13]) &&\n      eq0(m[14]) &&\n      eq0(m[3]) &&\n      eq0(m[7]) &&\n      eq0(m[11])\n    )\n  }\n\n  isNoProj(): boolean {\n    const m = this.m\n    return 0 == m[12] && 0 == m[13] && 0 == m[14] && 1 == m[15]\n  }\n\n  likeIdentity(): boolean {\n    return this.m.every((val, i) =>\n      ((i / 4) | 0) == i % 4 ? eq(1, val) : eq0(val),\n    )\n  }\n\n  isIdentity(): boolean {\n    return this.m.every((val, i) =>\n      ((i / 4) | 0) == i % 4 ? 1 == val : 0 == val,\n    )\n  }\n\n  toString(\n    f: (number: number) => string = (v) =>\n      v.toFixed(6).replace(/([0.])(?=0*$)/g, \" \"),\n  ): string {\n    assert(typeof f(0) == \"string\", \"\" + typeof f(0))\n    // slice this.m to convert it to an Array (from TypeArray)\n    const rounded = Array.prototype.slice.call(this.m).map(f) as string[]\n    const colWidths = [0, 1, 2, 3].map((colIndex) =>\n      max(sliceStep(rounded, colIndex, 0, 4).map((x) => x.length)),\n    )\n    return [0, 1, 2, 3]\n      .map((rowIndex) =>\n        rounded\n          .slice(rowIndex * 4, rowIndex * 4 + 4) // select matrix row\n          .map((x, colIndex) => \" \".repeat(colWidths[colIndex] - x.length) + x) // pad numbers with\n          // spaces to col width\n          .join(\" \"),\n      )\n      .join(\"\\n\") // join rows\n  }\n\n  /**\n   * Wether this matrix is a translation matrix, i.e. of the form\n   *\n   *     1, 0, 0, x,\n   *     0, 1, 0, y,\n   *     0, 0, 1, z,\n   *     0, 0, 0, 1\n   */\n  isTranslation(): boolean {\n    // 2: any value, otherwise same value\n    // prettier-ignore\n    const mask = [\n      1, 0, 0, 2,\n      0, 1, 0, 2,\n      0, 0, 1, 2,\n      0, 0, 0, 1]\n    return mask.every(\n      (expected, index) => expected == 2 || expected == this.m[index],\n    )\n  }\n\n  /**\n   * Wether this matrix is a translation matrix, i.e. of the form\n   *\n   *     S, 0, 0, 0,\n   *     0, t, 0, 0,\n   *     0, 0, v, 0,\n   *     0, 0, 0, 1\n   */\n  isScaling(): boolean {\n    // prettier-ignore\n    const mask = [\n      2, 0, 0, 0,\n      0, 2, 0, 0,\n      0, 0, 2, 0,\n      0, 0, 0, 1]\n    return mask.every(\n      (expected, index) => expected == 2 || expected == this.m[index],\n    )\n  }\n\n  isZRotation(): boolean {\n    // prettier-ignore\n    const mask = [\n      2, 2, 0, 0,\n      2, 2, 0, 0,\n      0, 0, 1, 0,\n      0, 0, 0, 1]\n    return (\n      mask.every(\n        (expected, index) => expected == 2 || expected == this.m[index],\n      ) &&\n      eq(1, this.m[0] ** 2 + this.m[1] ** 2) &&\n      this.m[0] == this.m[5] &&\n      this.m[1] == -this.m[4]\n    )\n  }\n\n  toSource(): string {\n    const name = M4.NAMEMAP.get(this)\n    if (name) {\n      return name\n    } else if (this.isTranslation()) {\n      return callSource(\"M4.translate\", this.O)\n    } else if (this.isScaling()) {\n      return callSource(\"M4.scale\", this.m[0], this.m[5], this.m[10])\n    } else if (this.isNoProj()) {\n      return !this.O.equals(V3.O)\n        ? callSource(\"M4.forSys\", this.X, this.Y, this.Z, this.O)\n        : callSource(\"M4.forSys\", this.X, this.Y, this.Z)\n    } else if (this.isMirror(0)) {\n      const m = this.m\n      const nx = Math.sqrt((1 - m[0]) / 2)\n      const ny = Math.sqrt((1 - m[5]) / 2)\n      const nz = Math.sqrt((1 - m[10]) / 2)\n      const w = m[3] / 2.0 / nx\n      return callSource(\"M4.mirror\", { normal1: new V3(nx, ny, nz), w })\n    } else {\n      const m = this.m\n      return (\n        \"new M4(\" +\n        (\"\\n\\t\" + m[0] + \",\\t\" + m[1] + \",\\t\" + m[2] + \",\\t\" + m[3] + \",\") +\n        (\"\\n\\t\" + m[4] + \",\\t\" + m[5] + \",\\t\" + m[6] + \",\\t\" + m[7] + \",\") +\n        (\"\\n\\t\" + m[8] + \",\\t\" + m[9] + \",\\t\" + m[10] + \",\\t\" + m[11] + \",\") +\n        (\"\\n\\t\" + m[12] + \",\\t\" + m[13] + \",\\t\" + m[14] + \",\\t\" + m[15] + \")\")\n      )\n    }\n  }\n\n  xyAreaFactor(): number {\n    return this.transformVector(V3.X).cross(this.transformVector(V3.Y)).length()\n  }\n}\n\nM4.prototype.height = 4\nM4.prototype.width = 4\n\nexport interface M4 extends Transformable {}\n\naddOwnProperties(M4.prototype, Transformable.prototype, \"constructor\")\n","import {\n  ArrayLikeWriteAble,\n  FloatArray,\n  Matrix,\n  V3,\n  assert,\n  assertInst,\n  assertNumbers,\n  callSource,\n  clamp,\n  eq,\n  eq0,\n  int,\n} from \".\"\n\nexport class Vector {\n  constructor(readonly v: Float64Array) {\n    assertInst(Float64Array, v)\n  }\n\n  static fromFunction(dims: int, f: (dim: int) => number): Vector {\n    assertNumbers(dims)\n    const e = new Float64Array(dims)\n    let i = dims\n    while (i--) {\n      e[i] = f(i)\n    }\n    return new Vector(e)\n  }\n\n  static random(dims: int): Vector {\n    return Vector.fromFunction(dims, (_i) => Math.random())\n  }\n\n  static from(f64a: Float64Array): Vector\n  static from(...args: number[]): Vector\n  static from(...args: any[]): Vector {\n    assert(\n      args[0] instanceof Float64Array ||\n        args.every((a) => \"number\" == typeof a),\n      'args[0] instanceof Float64Array || args.every(a => \"number\" == typeof a)',\n    )\n    return new Vector(\n      args[0] instanceof Float64Array ? args[0] : Float64Array.from(args),\n    )\n  }\n\n  static Zero(dims: int): Vector {\n    assertNumbers(dims)\n    let i = 0\n    const n = new Float64Array(dims)\n    while (i--) {\n      n[i] = 0\n    }\n    return new Vector(n)\n  }\n\n  static Unit(dims: int, dir: int): Vector {\n    assertNumbers(dims, dir)\n    let i = 0\n    const n = new Float64Array(dims)\n    while (i--) {\n      n[i] = +(i == dir) // +true === 1, +false === 0\n    }\n    return new Vector(n)\n  }\n\n  /**\n   * Pack an array of Vectors into an array of numbers (Float32Array by default).\n   *\n   * @param vectors Source array\n   * @param dest Destination array. If provided, must be large enough to fit\n   *     v3count items.\n   * @param srcStart Starting index in source array\n   * @param destStart Starting index in destination array\n   * @param vectorCount Number of V3s to copy.\n   * @returns Packed array.\n   */\n  static pack<T extends FloatArray = Float32Array>(\n    vectors: ReadonlyArray<Vector>,\n    dest?: T,\n    srcStart: number = 0,\n    destStart: number = 0,\n    vectorCount: number = vectors.length - srcStart,\n  ): T {\n    //assert (v3arr.every(v3 => v3 instanceof V3), 'v3arr.every(v3 => v3 instanceof V3)')\n    const dim = vectors[0].dim()\n    const result = dest || (new Float32Array(dim * vectorCount) as any) // TODO\n    assert(\n      result.length - destStart >= vectorCount * dim,\n      \"dest.length - destStart >= v3count * 3\",\n      result.length,\n      destStart,\n      vectorCount * 3,\n    )\n\n    let i = vectorCount,\n      srcIndex = srcStart,\n      destIndex = destStart\n    while (i--) {\n      const v = vectors[srcIndex++]\n      for (let d = 0; d < dim; d++) {\n        result[destIndex++] = v.v[d]\n      }\n    }\n    return result\n  }\n\n  static lerp(a: Vector, b: Vector, t: number) {\n    assert(a.dim() == b.dim())\n    const n = new Float64Array(a.v.length)\n    let i = a.v.length\n    while (i--) {\n      n[i] = a.v[i] * (1 - t) + b.v[i] * t\n    }\n    return new Vector(n)\n  }\n\n  static add(...vs: Vector[]): Vector {\n    const dim = vs[0].v.length\n    const result = new Float64Array(dim)\n    let i = vs.length\n    while (i--) {\n      let d = dim\n      while (d--) {\n        result[d] += vs[i].v[d]\n      }\n    }\n    return new Vector(result)\n  }\n\n  /**\n   * Create a new 4D Vector from a V3 and a weight.\n   *\n   * @param v3\n   * @param weight\n   */\n  static fromV3AndWeight(v3: V3, weight: number) {\n    return new Vector(\n      new Float64Array([v3.x * weight, v3.y * weight, v3.z * weight, weight]),\n    )\n  }\n\n  get x() {\n    return this.v[0]\n  }\n  get y() {\n    return this.v[1]\n  }\n  get z() {\n    return this.v[2]\n  }\n  get w() {\n    return this.v[3]\n  }\n\n  [Symbol.iterator]() {\n    return this.v[Symbol.iterator]()\n  }\n\n  dim(): int {\n    return this.v.length\n  }\n\n  e(index: int): number {\n    if (0 > index || index >= this.v.length) {\n      throw new Error(\"array index out of bounds\")\n    }\n    return this.v[index]\n  }\n\n  plus(vector: Vector): Vector {\n    const u = this.v,\n      v = vector.v\n    const n = new Float64Array(u.length)\n    let i = u.length\n    while (i--) {\n      n[i] = u[i] + v[i]\n    }\n    return new Vector(n)\n  }\n\n  minus(vector: Vector): Vector {\n    const u = this.v,\n      v = vector.v\n    const n = new Float64Array(u.length)\n    let i = u.length\n    while (i--) {\n      n[i] = u[i] - v[i]\n    }\n    return new Vector(n)\n  }\n\n  times(factor: number): Vector {\n    const u = this.v\n    const n = new Float64Array(u.length)\n    let i = u.length\n    while (i--) {\n      n[i] = u[i] * factor\n    }\n    return new Vector(n)\n  }\n\n  div(val: number): Vector {\n    const u = this.v\n    const n = new Float64Array(u.length)\n    let i = u.length\n    while (i--) {\n      n[i] = u[i] / val\n    }\n    return new Vector(n)\n  }\n\n  dot(vector: Vector): number {\n    assert(this.dim == vector.dim, \"passed vector must have the same dim\")\n    let result = 0\n    const u = this.v,\n      v = vector.v\n    let i = u.length\n    while (i--) {\n      result += u[i] * v[i]\n    }\n    return result\n  }\n\n  cross(vector: Vector): Vector {\n    assertInst(Vector, vector)\n    const n = new Float64Array(3)\n    n[0] = this.v[1] * vector.v[2] - this.v[2] * vector.v[1]\n    n[1] = this.v[2] * vector.v[0] - this.v[0] * vector.v[2]\n    n[2] = this.v[0] * vector.v[1] - this.v[1] * vector.v[0]\n\n    return new Vector(n)\n  }\n\n  schur(vector: Vector): Vector {\n    assertInst(Vector, vector)\n    const u = this.v,\n      v = vector.v\n    const n = new Float64Array(u.length)\n    let i = u.length\n    while (i--) {\n      n[i] = u[i] * v[i]\n    }\n    return new Vector(n)\n  }\n\n  equals(obj: any): boolean {\n    if (obj === this) return true\n    if (obj.constructor !== Vector) return false\n    if (this.v.length != obj.v.length) return false\n    let i = this.v.length\n    while (i--) {\n      if (this.v[i] !== obj.v[i]) return false\n    }\n    return true\n  }\n\n  like(obj: any, precision?: number): boolean {\n    if (obj === this) return true\n    if (obj.constructor !== Vector) return false\n    if (this.v.length != obj.v.length) return false\n    let i = this.v.length\n    while (i--) {\n      if (!eq(this.v[i], obj.v[i], precision)) return false\n    }\n    return true\n  }\n\n  map(f: (el: number, dim: number) => number): Vector {\n    return new Vector(this.v.map(f))\n  }\n\n  toString(roundFunction?: (x: number) => any): string {\n    roundFunction = roundFunction || ((v) => +v.toFixed(6))\n    return \"Vector(\" + this.v.map(roundFunction).join(\", \") + \")\"\n  }\n\n  toSource() {\n    return callSource(\"VV\", ...this.v)\n  }\n\n  angleTo(vector: Vector): number {\n    assertInst(Vector, vector)\n    assert(!this.isZero(), \"!this.likeO()\")\n    assert(!vector.isZero(), \"!vector.likeO()\")\n    return Math.acos(\n      clamp(this.dot(vector) / this.length() / vector.length(), -1, 1),\n    )\n  }\n\n  /**\n   * Returns true iff this is parallel to vector, using eq Throw a DebugError -\n   * if vector is not a Vector or - if this has a length of 0 or - if vector\n   * has a length of 0\n   */\n  isParallelTo(vector: Vector): boolean {\n    assertInst(Vector, vector)\n    assert(!this.isZero(), \"!this.likeO()\")\n    assert(!vector.isZero(), \"!vector.likeO()\")\n    // a . b takes on values of +|a|*|b| (vectors same direction) to -|a|*|b| (opposite direction)\n    // in both cases the vectors are paralle, so check if abs(a . b) == |a|*|b|\n    return eq(\n      Math.sqrt(this.lengthSquared() * vector.lengthSquared()),\n      Math.abs(this.dot(vector)),\n    )\n  }\n\n  isPerpendicularTo(vector: Vector): boolean {\n    assertInst(Vector, vector)\n    assert(!this.isZero(), \"!this.likeO()\")\n    assert(!vector.isZero(), \"!vector.likeO()\")\n    return eq0(this.dot(vector))\n  }\n\n  /**\n   * Returns true iff the length of this vector is 0, as returned by NLA.isZero.\n   * Definition: Vector.prototype.isZero = () => NLA.isZero(this.length())\n   */\n  isZero(): boolean {\n    return eq0(this.length())\n  }\n\n  /*/ Returns the length of this Vector, i.e. the euclidian norm.*/\n  length(): number {\n    return Math.hypot.apply(undefined, (this.v as unknown) as number[])\n    //return Math.sqrt(this.lengthSquared())\n  }\n\n  lengthSquared(): number {\n    let result = 0\n    const u = this.v\n    let i = u.length\n    while (i--) {\n      result += u[i] * u[i]\n    }\n    return result\n  }\n\n  /**\n   * Returns a new unit Vector (.length() === 1) with the same direction as this\n   * vector. Throws a\n   */\n  unit(): Vector {\n    const length = this.length()\n    if (eq0(length)) {\n      throw new Error(\"cannot normalize zero vector\")\n    }\n    return this.div(this.length())\n  }\n\n  /** Documentation stub. You want {@link unit} */\n  normalized(): V3 {\n    throw new Error(\"documentation stub. use .unit()\")\n  }\n\n  asRowMatrix(): Matrix {\n    return new Matrix(this.v.length, 1, this.v)\n  }\n\n  asColMatrix(): Matrix {\n    return new Matrix(1, this.v.length, this.v)\n  }\n\n  /**\n   * Returns a new Vector which is the projection of this vector onto the passed vector.\n   *\n   * @example\n   *   VV(3, 4).projectedOn(VV(1, 0)) // VV(3, 0)\n   *   VV(3, 4).projectedOn(VV(2, 0)) // VV(3, 0)\n   *   VV(3, 4).projectedOn(VV(-1, 0)) // VV(-3, 0)\n   *   VV(3, 4).projectedOn(VV(0, 1)) // VV(0, 4)\n   *   VV(3, 4).projectedOn(VV(1, 1)) //\n   */\n  projectedOn(b: Vector): Vector {\n    assertInst(Vector, b)\n    // https://en.wikipedia.org/wiki/Vector_projection#Vector_projection_2\n    return b.times(this.dot(b) / b.dot(b))\n  }\n\n  rejectedOn(b: Vector): Vector {\n    assertInst(Vector, b)\n    // https://en.wikipedia.org/wiki/Vector_projection#Vector_projection_2\n    return this.minus(b.times(this.dot(b) / b.dot(b)))\n  }\n\n  to(a: Vector): Vector {\n    return a.minus(this)\n  }\n\n  /**\n   * Returns true iff the length() of this vector is equal to 'length', using equals\n   *\n   * @example\n   *   V(3, 4).hasLength(5) // true\n   *   V(1, 1).hasLength(1) // false\n   */\n  hasLength(length: number): boolean {\n    assertNumbers(length)\n    return eq(length, this.length())\n  }\n\n  V3(): V3 {\n    //assert(this.dim() == 3)\n    return new V3(this.v[0], this.v[1], this.v[2])\n  }\n\n  /** Project into 3 dimensions. */\n  p3(): V3 {\n    assert(this.v.length == 4)\n    const w = this.v[3]\n    return new V3(this.v[0] / w, this.v[1] / w, this.v[2] / w)\n  }\n\n  transposed() {\n    return new Matrix(this.v.length, 1, this.v)\n  }\n}\n\nexport function VV(...values: number[]) {\n  return new Vector(new Float64Array(values))\n}\n\nexport function vArrGet(vArr: ArrayLike<number>, dim: int, i: int) {\n  assert(vArr.length % dim == 0)\n  return new Vector(\n    Float64Array.prototype.slice.call(vArr, i * dim, (i + 1) * dim),\n  )\n}\n\nexport function vArrSet(\n  vArr: ArrayLikeWriteAble<number>,\n  i: int,\n  vector: Vector,\n) {\n  const dim = vector.dim()\n  assert(vArr.length % dim == 0)\n  let d = dim\n  while (d--) {\n    vArr[i * dim + d] = vector.v[d]\n  }\n}\n","import {\n  assert,\n  assertInst,\n  assertNumbers,\n  assertVectors,\n  callSource,\n  clamp,\n  lt,\n  M4,\n  NLA_PRECISION,\n  Transformable,\n  V3,\n} from \".\"\n\nexport class AABB extends Transformable {\n  constructor(public min: V3 = V3.INF, public max: V3 = V3.INF.negated()) {\n    super()\n    assertVectors(min, max)\n  }\n\n  static forXYZ(x: number, y: number, z: number): AABB {\n    return new AABB(V3.O, new V3(x, y, z))\n  }\n\n  static forAABBs(aabbs: Iterable<AABB>): AABB {\n    const result = new AABB()\n    for (const aabb of aabbs) {\n      result.addAABB(aabb)\n    }\n    return result\n  }\n\n  addPoint(p: V3): this {\n    assertVectors(p)\n    this.min = this.min.min(p)\n    this.max = this.max.max(p)\n    return this\n  }\n\n  addPoints(ps: V3[]): this {\n    ps.forEach((p) => this.addPoint(p))\n    return this\n  }\n\n  addAABB(aabb: AABB): this {\n    assertInst(AABB, aabb)\n    this.addPoint(aabb.min)\n    this.addPoint(aabb.max)\n    return this\n  }\n\n  /**\n   * Returns the largest AABB contained in this which doesn't overlap with aabb\n   *\n   * @param aabb\n   */\n  withoutAABB(aabb: AABB): AABB {\n    assertInst(AABB, aabb)\n    let min, max\n    const volume = this.volume(),\n      size = this.size()\n    let remainingVolume = -Infinity\n    for (let i = 0; i < 3; i++) {\n      const dim = [\"x\", \"y\", \"z\"][i] as \"x\" | \"y\" | \"z\"\n      const cond = aabb.min[dim] - this.min[dim] > this.max[dim] - aabb.max[dim]\n      const dimMin = cond\n        ? this.min[dim]\n        : Math.max(this.min[dim], aabb.max[dim])\n      const dimMax = !cond\n        ? this.max[dim]\n        : Math.min(this.max[dim], aabb.min[dim])\n      const newRemainingVolume = ((dimMax - dimMin) * volume) / size[dim]\n      if (newRemainingVolume > remainingVolume) {\n        remainingVolume = newRemainingVolume\n        min = this.min.withElement(dim, dimMin)\n        max = this.max.withElement(dim, dimMax)\n      }\n    }\n    return new AABB(min, max)\n  }\n\n  getIntersectionAABB(aabb: AABB): AABB {\n    assertInst(AABB, aabb)\n    return new AABB(this.min.max(aabb.min), this.max.min(aabb.max))\n  }\n\n  touchesAABB(aabb: AABB): boolean {\n    assertInst(AABB, aabb)\n    return !(\n      this.min.x > aabb.max.x ||\n      this.max.x < aabb.min.x ||\n      this.min.y > aabb.max.y ||\n      this.max.y < aabb.min.y ||\n      this.min.z > aabb.max.z ||\n      this.max.z < aabb.min.z\n    )\n  }\n\n  touchesAABBfuzzy(aabb: AABB, precisision = NLA_PRECISION): boolean {\n    assertInst(AABB, aabb)\n    return !(\n      lt(aabb.max.x, this.min.x, precisision) ||\n      lt(this.max.x, aabb.min.x, precisision) ||\n      lt(aabb.max.y, this.min.y, precisision) ||\n      lt(this.max.y, aabb.min.y, precisision) ||\n      lt(aabb.max.z, this.min.z, precisision) ||\n      lt(this.max.z, aabb.min.z, precisision)\n    )\n  }\n\n  intersectsAABB(aabb: AABB): boolean {\n    assertInst(AABB, aabb)\n    return !(\n      this.min.x >= aabb.max.x ||\n      this.max.x <= aabb.min.x ||\n      this.min.y >= aabb.max.y ||\n      this.max.y <= aabb.min.y ||\n      this.min.z >= aabb.max.z ||\n      this.max.z <= aabb.min.z\n    )\n  }\n\n  intersectsAABB2d(aabb: AABB): boolean {\n    assertInst(AABB, aabb)\n    return !(\n      this.min.x >= aabb.max.x ||\n      this.max.x <= aabb.min.x ||\n      this.min.y >= aabb.max.y ||\n      this.max.y <= aabb.min.y\n    )\n  }\n\n  containsPoint(p: V3): boolean {\n    assertVectors(p)\n    return (\n      this.min.x <= p.x &&\n      this.min.y <= p.y &&\n      this.min.z <= p.z &&\n      this.max.x >= p.x &&\n      this.max.y >= p.y &&\n      this.max.z >= p.z\n    )\n  }\n\n  containsSphere(center: V3, radius: number) {\n    assertVectors(center)\n    assertNumbers(radius)\n    return this.distanceToPoint(center) > radius\n  }\n\n  intersectsSphere(center: V3, radius: number) {\n    assertVectors(center)\n    assertNumbers(radius)\n    return this.distanceToPoint(center) <= radius\n  }\n\n  distanceToPoint(p: V3) {\n    assertVectors(p)\n    const x = p.x,\n      y = p.y,\n      z = p.z\n    const min = this.min,\n      max = this.max\n    if (this.containsPoint(p)) {\n      return Math.max(\n        min.x - x,\n        x - max.x,\n        min.y - y,\n        y - max.y,\n        min.z - z,\n        z - max.z,\n      )\n    }\n    return p.distanceTo(\n      new V3(\n        clamp(x, min.x, max.x),\n        clamp(y, min.y, max.y),\n        clamp(z, min.z, max.z),\n      ),\n    )\n  }\n\n  containsAABB(aabb: AABB) {\n    assertInst(AABB, aabb)\n    return this.containsPoint(aabb.min) && this.containsPoint(aabb.max)\n  }\n\n  likeAABB(aabb: AABB): boolean {\n    assertInst(AABB, aabb)\n    return this.min.like(aabb.min) && this.max.like(aabb.max)\n  }\n\n  intersectsLine(line: {\n    anchor: V3\n    dir1: V3\n    tMin: number\n    tMax: number\n  }): boolean {\n    assertVectors(line.anchor, line.dir1)\n    const dir = line.dir1.map((el) => el || Number.MIN_VALUE)\n    const minTs = this.min.minus(line.anchor).divv(dir)\n    const maxTs = this.max.minus(line.anchor).divv(dir)\n    const tMin = minTs.min(maxTs).maxElement(),\n      tMax = minTs.max(maxTs).minElement()\n    return tMin <= tMax && !(tMax < line.tMin || line.tMax < tMin)\n  }\n\n  hasVolume(): boolean {\n    return (\n      this.min.x <= this.max.x &&\n      this.min.y <= this.max.y &&\n      this.min.z <= this.max.z\n    )\n  }\n\n  volume(): number {\n    if (!this.hasVolume()) {\n      return -1\n    }\n    const v = this.max.minus(this.min)\n    return v.x * v.y * v.z\n  }\n\n  size(): V3 {\n    return this.max.minus(this.min)\n  }\n\n  getCenter(): V3 {\n    return this.min.plus(this.max).div(2)\n  }\n\n  transform(m4: M4): this {\n    assertInst(M4, m4)\n    assert(m4.isAxisAligned())\n    const aabb = new AABB()\n    aabb.addPoint(m4.transformPoint(this.min))\n    aabb.addPoint(m4.transformPoint(this.max))\n    return aabb as this\n  }\n\n  ofTransformed(m4: M4): AABB {\n    assertInst(M4, m4)\n    const aabb = new AABB()\n    aabb.addPoints(m4.transformedPoints(this.corners()))\n    return aabb\n  }\n\n  corners(): V3[] {\n    const { min, max } = this\n    return [\n      min,\n      new V3(min.x, min.y, max.z),\n      new V3(min.x, max.y, min.z),\n      new V3(min.x, max.y, max.z),\n\n      new V3(max.x, min.y, min.z),\n      new V3(max.x, min.y, max.z),\n      new V3(max.x, max.y, min.z),\n      max,\n    ]\n  }\n\n  toString(): string {\n    return callSource(\"new AABB\", this.min, this.max)\n  }\n\n  toSource(): string {\n    return this.toString()\n  }\n\n  /** Return the matrix which transforms the AABB from V3.O to V3.XYZ to this AABB. */\n  getM4(): M4 {\n    return M4.translate(this.min).times(M4.scale(this.size()))\n  }\n}\n"],"names":["JavaMap","constructor","Symbol","toStringTag","this","_map","Map","_size","toString","Array","from","entries2","map","key","value","join","forEach","callbackfn","thisArg","bucket","values","call","iterator","entries","set","set2","val","hashCode","get","pairIndex","findIndex","pair","equals","push","has","undefined","some","find","getLike","hashCodes","canonVal","x","like","setLike","delete","index","length","splice","deleteLike","deleted","clear","size","KEYWORD_REGEXP","seen","toSource","o","indent","JSON","stringify","sce","Error","addToSourceMethodToPrototype","clazz","method","prototype","Object","defineProperty","writable","configurable","enumerable","Boolean","Function","Number","RegExp","Date","getTime","String","includes","result","i","replace","pop","keys","sort","k","test","PI","Math","TAU","NLA_DEBUG","NLA_PRECISION","cons","assertInst","what","objs","name","assertNumbers","numbers","assertInts","assert","messages","message","assertf","f","lerp","a","b","t","lerpInv","originalNumberToString","radix","eq0","EPS","abs","eq","y","lt","decimalAdjust","exp","isNaN","NaN","vs","split","round10","bind","round","GOLDEN_RATIO","floor","ceil","clamp","min","max","addOwnProperties","target","props","exclude","getOwnPropertyNames","hasOwnProperty","console","warn","getOwnPropertyDescriptor","defaultRoundFunction","MINUS","floatHashCode","DEG","root","solveCubicReal2","c","d","p","q","discriminantX4","sqrt","pqFormula","divisor","pDiv3","pDiv3Pow3","qDiv2","discriminant","r","phi","acos","t1","cbrt","cos","u1","sd","callSource","params","assertVectors","vectors","arguments","V3","Vector","newtonIterate1d","xStart","steps","epsOrDf","fx","df","dfdx","log","newtonIterateWithDerivative","results","arraySwap","arr","j","temp","arrayCopy","src","sstart","dst","dstart","arrayCopyStep","sstep","dstep","count","srcIndex","dIndex","blockSize","arrayRange","startInclusive","endExclusive","step","arrLength","arrayFromFunction","elIndex","withMax","maxVal","el","unique","uniqueSet","Set","bagRemoveIndex","removeIndexes","indexes","dstPos","nextSkip","indexesPos","srcPos","context","capitalizeFirstLetter","charAt","toUpperCase","slice","[object Object]","z","random","dot","zRotation","zRadius","sin","theta","angleTo","args","apply","to","cross","v3arr","dest","srcStart","destStart","v3count","Float32Array","destIndex","v","packedArray","Infinity","delta","perturbed","radius","longitude","latitude","ab","squared","u","minus","factor","hypot","NAMEMAP","X","Y","Z","omega","times","plus","n","atan2","roundFunction","likeO","vector","normal1","hasLength","other","O","obj","div","newLength","b1","xAbs","yAbs","zAbs","dim","hc","eps","asin","V","parseFloat","Float64Array","CustomMap","XYZ","INF","P3YZ","w","P3ZX","P3XY","Transformable","plane","transform","M4","mirror","project","translate","scale","radians","rotateX","rotateY","rotateZ","rotationCenter","rotationAxis","rotateLine","rotateAB","alpha","beta","gamma","FOO","FOO_INV","visitor","proto","getPrototypeOf","Matrix","width","height","m","fromFunction","rowArrays","rowIndex","new","colVectors","fromColArrays","colArrays","colIndex","ms","isArray","copy","reduce","x0","fx0","EPSILON","jacobi","forWidthHeight","setEl","s","scalar","colNames","rowNames","toFixed","rounded","rows","unshift","row","colWidths","padEnd","padStart","matrix","precision","isSquare","transposed","equalsMatrix","identityN","uRowArrays","asRowArrays","lRowArrays","pRowArrays","currentRowIndex","maxAbsValue","pivotRowIndex","numberOfNonZeroRows","l","colIndex2","L","fromRowArrays","U","P","R","matrixForCS","qTransposed","xi","e","xk","col2","x1","x2","Q","filter","asColArrays","col","isLowerUnitriangular","isUpperTriangular","isUpperTrapezoidal","luDecomposition","solveForwards","timesVector","solveBackwards","isLowerTrapezoidal","fromColVectors","isLowerTriangular","rank","isZero","arrayConstructor","rowArray","colArray","firstColIndex","subWidth","firstRowIndex","subHeight","blockCount","arrayCopyBlocks","fn","inversed2","inversed3","inversed4","solveForwardsMatrix","solveBackwardsMatrix","det","canMultiply","dimString","nWidth","nHeight","nM","nRowIndex","nColIndex","tWidth","tHeight","tM","tRowIndex","tColIndex","h","vIndex","absSum","product","getTriangularDeterminant","isPermutation","searchIndexStart","searchIndex","gauss","dependents","uRowIndex","lRowIndex","lColIndex","indexMap","permutationAsIndexMap","var_args","flattened","newItems","concat","concatenated","super","identity","left","right","m4s","multiply","temp0","temp1","getLast","e0","e1","e2","origin","n0","n1","n2","n3","fovDegrees","aspect","near","far","perspectiveRad","fov","tan","frustum","vanishingPlane","bottom","top","np","eye","focus","up","unit","rotationAxisLength","rotationAnchor","ax","ay","az","dx","dy","dz","nx","ny","nz","dir","nd","line","anchor","dir1","transformVector","getTranslation","inverse","m4","g","eigenValues","realEigenValues3","this3x3","IDENTITY3","mats","ev","determinant3","gauss0","eigenVector0","planeNormal","eigenVector1","getPerpendicular","eigenVector2","rejectedFrom","mat","A","as3x3","S","it","likeM4","maxOffDiagonal","maxOffDiagonalIndex","a_ii","a_kk","a_ik","atan","givensRotation","likeIdentity","sigma","SIGMA","VSTAR","fromFunction4","every","transpose","vx","vy","vz","checkW","transformedAnchor","VV","transformedVector","transformPoint","determinant","IDENTITY","temp2","$","klop","jlnp","jkno","ilmp","ikmo","ijmn","detAbs","divScalar","start","end","chunkSize","resultLength","sliceStep","repeat","expected","isTranslation","isScaling","isNoProj","isMirror","inversed","forSys","ZXY","YZX","dims","_i","vectorCount","v3","weight","lengthSquared","AABB","negated","aabbs","aabb","addAABB","ps","addPoint","volume","remainingVolume","cond","dimMin","dimMax","newRemainingVolume","withElement","precisision","center","distanceToPoint","containsPoint","distanceTo","minTs","divv","maxTs","tMin","maxElement","tMax","minElement","hasVolume","isAxisAligned","addPoints","transformedPoints","corners"],"sourceRoot":""}