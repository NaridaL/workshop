{"version":3,"file":"856.js","mappings":"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","sources":["/dev/workshop/./node_modules/javasetmap.ts/src/JavaMap.ts?","/dev/workshop/./node_modules/ts3dutils/src/toSource.ts?","/dev/workshop/./node_modules/ts3dutils/src/util.ts?","/dev/workshop/./node_modules/ts3dutils/src/NLA.ts?","/dev/workshop/./node_modules/ts3dutils/src/arrayUtils.ts?","/dev/workshop/./node_modules/ts3dutils/src/V3.ts?","/dev/workshop/./node_modules/ts3dutils/src/Transformable.ts?","/dev/workshop/./node_modules/ts3dutils/src/Matrix.ts?","/dev/workshop/./node_modules/ts3dutils/src/M4.ts?","/dev/workshop/./node_modules/ts3dutils/src/Vector.ts?","/dev/workshop/./node_modules/ts3dutils/src/AABB.ts?"],"sourcesContent":["import { Equalable, int } from \"./Equalable\"\n\n/**\n * Java style map.\n */\nexport class JavaMap<\n  K extends Equalable & { hashCodes?(): int[]; like?(x: any): boolean },\n  V\n> implements Map<K, V> {\n  [Symbol.toStringTag]: \"Map\" = \"Map\"\n\n  toString() {\n    return (\n      \"{\" +\n      Array.from(this.entries2())\n        .map(({ key, value }) => key + \":\" + value)\n        .join(\", \") +\n      \"}\"\n    )\n  }\n\n  forEach(\n    callbackfn: (value: V, index: K, map: Map<K, V>) => void,\n    thisArg?: any\n  ): void {\n    for (const bucket of this._map.values()) {\n      for (const { key, value } of bucket) {\n        callbackfn.call(thisArg, value, key, this)\n      }\n    }\n  }\n\n  *keys(): IterableIterator<K> {\n    for (const bucket of this._map.values()) {\n      for (const { key } of bucket) {\n        yield key\n      }\n    }\n  }\n\n  *values(): IterableIterator<V> {\n    for (const bucket of this._map.values()) {\n      for (const { value } of bucket) {\n        yield value\n      }\n    }\n  }\n\n  protected _map: Map<int, { key: K; value: V }[]>\n  protected _size: int\n\n  constructor() {\n    this._map = new Map()\n    this._size = 0\n  }\n\n  [Symbol.iterator]() {\n    return this.entries()\n  }\n\n  set(key: K, value: V): this {\n    this.set2(key, value)\n    return this\n  }\n\n  /**\n   * Like {@link #set} except it returns true if key was new and false if the value was only updated.\n   *\n   */\n  set2(key: K, val: V): boolean {\n    const hashCode = key.hashCode(),\n      bucket = this._map.get(hashCode)\n    //assert(hashCode === (hashCode | 0))\n    if (bucket) {\n      const pairIndex = bucket.findIndex((pair) => pair.key.equals(key))\n      if (-1 == pairIndex) {\n        bucket.push({ key: key, value: val })\n      } else {\n        bucket[pairIndex].value = val\n        return false\n      }\n    } else {\n      this._map.set(hashCode, [{ key: key, value: val }])\n    }\n    this._size++\n    return true\n  }\n\n  has(key: K): boolean {\n    const hashCode = key.hashCode(),\n      bucket = this._map.get(hashCode)\n    //assert(hashCode === (hashCode | 0))\n    return undefined !== bucket && bucket.some((pair) => pair.key.equals(key))\n  }\n\n  get(key: K): V | undefined {\n    const hashCode = key.hashCode(),\n      bucket = this._map.get(hashCode),\n      pair = bucket && bucket.find((pair) => pair.key.equals(key))\n    return pair && pair.value\n  }\n\n  getLike(key: K) {\n    for (const hashCode of key.hashCodes!()) {\n      const bucket = this._map.get(hashCode)\n      const canonVal = bucket && bucket.find((x) => x.key.like!(key))\n      if (canonVal) return canonVal\n    }\n  }\n\n  setLike(key: K, val: V) {\n    return !this.getLike(key) && this.set(key, val)\n  }\n\n  delete(key: K) {\n    const hashCode = key.hashCode(),\n      bucket = this._map.get(hashCode)\n    if (bucket) {\n      const index = bucket.findIndex((x) => x.key.equals(key))\n      if (-1 != index) {\n        if (1 == bucket.length) {\n          this._map.delete(hashCode)\n        } else {\n          bucket.splice(index, 1)\n        }\n        this._size--\n        return true\n      }\n    }\n    return false\n  }\n\n  deleteLike(key: K) {\n    for (const hashCode of key.hashCodes!()) {\n      const bucket = this._map.get(hashCode)\n      if (bucket) {\n        const index = bucket.findIndex((x) => x.key.like!(key))\n        if (-1 != index) {\n          const deleted = bucket[index]\n          if (1 == bucket.length) {\n            this._map.delete(hashCode)\n          } else {\n            bucket.splice(index, 1)\n          }\n          this._size--\n          return deleted\n        }\n      }\n    }\n  }\n\n  *entries2(): IterableIterator<{ key: K; value: V }> {\n    for (const bucket of this._map.values()) {\n      yield* bucket\n    }\n  }\n\n  *entries(): IterableIterator<[K, V]> {\n    for (const bucket of this._map.values()) {\n      for (const { key, value } of bucket) {\n        yield [key, value]\n      }\n    }\n  }\n\n  clear() {\n    this._map.clear()\n    this._size = 0\n  }\n\n  get size() {\n    return this._size\n  }\n}\n","declare global {\n  interface Object {\n    toSource(): string\n  }\n}\nconst KEYWORD_REGEXP = new RegExp(\n  \"^(\" +\n    \"abstract|boolean|break|byte|case|catch|char|class|const|continue|debugger|\" +\n    \"default|delete|do|double|else|enum|export|extends|false|final|finally|\" +\n    \"float|for|function|goto|if|implements|import|in|instanceof|int|interface|\" +\n    \"long|native|new|null|package|private|protected|public|return|short|static|\" +\n    \"super|switch|synchronized|this|throw|throws|transient|true|try|typeof|\" +\n    \"undefined|var|void|volatile|while|with\" +\n    \")$\",\n)\nfunction stringIsLegalKey(key: string) {\n  return /^[a-z_$][0-9a-z_$]*$/gi.test(key) && !KEYWORD_REGEXP.test(key)\n}\n\nconst seen: {}[] = []\nexport function toSource(o: any, indent = 0) {\n  switch (typeof o) {\n    case \"undefined\":\n      return \"undefined\"\n    case \"function\":\n      return o.toString()\n    case \"number\":\n    case \"boolean\":\n      return \"\" + o\n    case \"string\":\n      return JSON.stringify(o)\n    case \"object\":\n      if (null == o) {\n        return \"null\"\n      } else {\n        return o.sce\n      }\n    default:\n      throw new Error(typeof o)\n  }\n}\nfunction addToSourceMethodToPrototype<T>(\n  clazz: new (...args: any[]) => T,\n  method: (this: T) => string,\n) {\n  if (!clazz.prototype.toSource) {\n    Object.defineProperty(clazz.prototype, \"toSource\", {\n      value: method,\n      writable: true,\n      configurable: true,\n      enumerable: false,\n    })\n  }\n}\n\naddToSourceMethodToPrototype(Boolean, Boolean.prototype.toString)\naddToSourceMethodToPrototype(Function, Function.prototype.toString)\naddToSourceMethodToPrototype(Number, Number.prototype.toString)\naddToSourceMethodToPrototype(RegExp, RegExp.prototype.toString)\naddToSourceMethodToPrototype(Date, function () {\n  return \"new Date(\" + this.getTime() + \")\"\n})\naddToSourceMethodToPrototype(String, function () {\n  return JSON.stringify(this)\n})\naddToSourceMethodToPrototype(Array, function (this: any[]) {\n  if (seen.includes(this)) {\n    return \"CIRCULAR_REFERENCE\"\n  }\n  seen.push(this)\n  let result = \"[\"\n  for (let i = 0; i < this.length; i++) {\n    result += \"\\n\\t\" + toSource(this[i]).replace(/\\r\\n|\\n|\\r/g, \"$&\\t\")\n    if (i !== this.length - 1) {\n      result += \",\"\n    }\n  }\n  result += 0 === this.length ? \"]\" : \"\\n]\"\n  seen.pop()\n  return result\n})\naddToSourceMethodToPrototype(Object, function () {\n  if (seen.includes(this)) {\n    return \"CIRCULAR_REFERENCE\"\n  }\n  seen.push(this)\n  let result = \"{\"\n  const keys = Object.keys(this).sort()\n  for (let i = 0; i < keys.length; i++) {\n    const k = keys[i]\n    result +=\n      \"\\n\\t\" +\n      (stringIsLegalKey(k) ? k : JSON.stringify(k)) +\n      \": \" +\n      toSource((this as any)[k]).replace(/\\r\\n|\\n|\\r/g, \"$&\\t\")\n    if (i !== keys.length - 1) {\n      result += \",\"\n    }\n  }\n  result += 0 === keys.length ? \"}\" : \"\\n}\"\n  seen.pop()\n  return result\n})\n","import { toSource } from \".\"\n\nexport const PI = Math.PI\nexport const TAU = 2 * PI\n/** Alias for number. Doesn't change anything for type-checking, but it is useful for documentation purposes. */\nexport type int = number\n/** Alias for number. Doesn't change anything for type-checking, but it is useful for documentation purposes. */\nexport type raddd = number\nexport type colorstr = string // e.g. '#abcdef\nexport type FloatArray = Float32Array | Float64Array | number[]\n\n/** Use rollup-plugin-replace or similar to avoid error in browser. */\n// @ts-ignore\nexport const NLA_DEBUG = process.env.NODE_ENV != \"production\"\nexport const NLA_PRECISION = 1 / (1 << 26)\n\nlet oldConsole: any = undefined\n\nexport function disableConsole() {\n  oldConsole = console.log\n  console.log = function () {}\n}\n\nexport function enableConsole() {\n  if (oldConsole) {\n    console.log = oldConsole\n  }\n}\n\nexport function hasConstructor<T>(\n  instance: any,\n  cons: { new (...args: any[]): T },\n): instance is T {\n  return instance.constructor == cons\n}\n\nexport function assertInst<T>(what: Function & { prototype: T }, ...objs: T[]) {\n  if (NLA_DEBUG) {\n    for (let i = 0; i < objs.length; i++) {\n      if (!(objs[i] instanceof what)) {\n        throw new Error(\n          \"assertInst objs[\" +\n            i +\n            \"] is not a \" +\n            what.prototype.name +\n            \". \" +\n            (objs[i] as any)?.constructor?.name +\n            objs[i],\n        )\n      }\n    }\n  }\n  return true\n}\n\nexport function assertNumbers(...numbers: number[]): void {\n  if (NLA_DEBUG) {\n    for (let i = 0; i < numbers.length; i++) {\n      if (\"number\" !== typeof numbers[i]) {\n        throw new Error(\n          `assertNumbers arguments[${i}] is not a number. ${typeof numbers[\n            i\n          ]} == typeof ${numbers[i]}`,\n        )\n      }\n    }\n  }\n}\n\nexport function assertInts(...numbers: number[]): void {\n  if (NLA_DEBUG) {\n    for (let i = 0; i < numbers.length; i++) {\n      if (\"number\" !== typeof numbers[i] || numbers[i] % 1 !== 0) {\n        throw new Error(\n          `assertNumbers arguments[${i}] is not an int. ${typeof numbers[\n            i\n          ]} == typeof ${numbers[i]}`,\n        )\n      }\n    }\n  }\n}\n\nexport function assertReals(...numbers: number[]): void {\n  if (NLA_DEBUG) {\n    for (let i = 0; i < numbers.length; i++) {\n      const x = numbers[i]\n      //noinspection SuspiciousTypeOfGuard\n      if (\"number\" !== typeof x || isNaN(x) || !isFinite(x)) {\n        throw new Error(`assertNumbers arguments[${i}] = ${x} is not a real.`)\n      }\n    }\n  }\n}\n\nexport function assert(\n  value: any,\n  ...messages: (any | (() => string))[]\n): value is true {\n  if (NLA_DEBUG && !value) {\n    throw new Error(\n      \"assert failed: \" +\n        messages\n          .map((message) =>\n            \"function\" === typeof message ? message() : message || \"\",\n          )\n          .join(\"\\n\"),\n    )\n  }\n  return true\n}\n\nexport function assertNever(value?: never): never {\n  throw new Error(value)\n}\n\nexport function assertf(f: () => any, ...messages: (any | (() => any))[]) {\n  if (NLA_DEBUG && !f()) {\n    throw new Error(\n      \"assertf failed: \" +\n        f.toString() +\n        messages\n          .map((message) =>\n            \"function\" === typeof message ? message() : message || \"\",\n          )\n          .join(\"\\n\"),\n    )\n  }\n}\n\nexport function assertBetween(\n  minInclusive: number,\n  maxInclusive: number,\n  value: number,\n  message: string,\n) {\n  if (NLA_DEBUG && !between(value, minInclusive, maxInclusive)) {\n    throw new Error(\n      `${value} is not in [${minInclusive}, ${maxInclusive}] (${message})`,\n    )\n  }\n}\n\nexport function lerp(a: number, b: number, t: number) {\n  return a * (1 - t) + b * t\n}\n\nexport function lerpInv(a: number, b: number, t: number) {\n  return (t - a) / (b - a)\n}\n\nconst originalNumberToString = Number.prototype.toString\nNumber.prototype.toString = function (radix) {\n  if (PI == this) {\n    return \"PI\"\n  }\n  return originalNumberToString.call(this, radix)\n}\n\nexport const eq0 = (x: number, EPS: number = NLA_PRECISION): boolean =>\n  Math.abs(x) <= EPS\nexport const eq = (\n  x: number,\n  y: number,\n  EPS: number = NLA_PRECISION,\n): boolean => Math.abs(x - y) <= EPS\nexport const lt = (\n  x: number,\n  y: number,\n  EPS: number = NLA_PRECISION,\n): boolean => x - y < -EPS\nexport const gt = (\n  x: number,\n  y: number,\n  EPS: number = NLA_PRECISION,\n): boolean => y - x < -EPS\nexport const le = (\n  x: number,\n  y: number,\n  EPS: number = NLA_PRECISION,\n): boolean => x - y <= EPS\nexport const ge = (\n  x: number,\n  y: number,\n  EPS: number = NLA_PRECISION,\n): boolean => y - x <= EPS\n\nexport const eqAngle = (x: number, y: number): boolean => zeroAngle(x - y)\nexport const zeroAngle = (x: number): boolean =>\n  ((x % (2 * Math.PI)) + 2 * Math.PI + NLA_PRECISION) % (2 * Math.PI) <\n  2 * NLA_PRECISION\nexport const snap = (x: number, to: number): number =>\n  Math.abs(x - to) <= NLA_PRECISION ? to : x\nexport const snap2 = (x: number, ...to: number[]): number =>\n  to.reduce((x, to) => (Math.abs(x - to) <= NLA_PRECISION ? to : x), x)\nexport const snapEPS = (x: number, EPS: number, ...to: number[]): number =>\n  to.reduce((x, to) => (Math.abs(x - to) <= EPS ? to : x), x)\nexport const snap0 = (x: number, EPS = NLA_PRECISION): number =>\n  Math.abs(x) <= EPS ? 0 : x\nexport const canonAngle = (x: number): number =>\n  ((x % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI)\n\n/** @deprecated */ export const eq02 = eq0\n\n/**\n * Decimal adjustment of a number.\n *\n * @param f The type of adjustment.\n * @param value The number.\n * @param exp The exponent (the 10 logarithm of the adjustment base).\n * @returns The adjusted value.\n */\nfunction decimalAdjust(\n  f: (x: number) => number,\n  value: number,\n  exp: number,\n): number {\n  // If the exp is undefined or zero...\n  if (typeof exp === \"undefined\" || +exp === 0) {\n    return f(value)\n  }\n  value = +value\n  exp = +exp\n  // If the value is not a number or the exp is not an integer...\n  if (isNaN(value) || !(typeof exp === \"number\" && exp % 1 === 0)) {\n    return NaN\n  }\n  // Shift\n  let vs = value.toString().split(\"e\")\n  value = f(+(vs[0] + \"e\" + (vs[1] ? +vs[1] - exp : -exp)))\n  // Shift back\n  vs = value.toString().split(\"e\")\n  return +(vs[0] + \"e\" + (vs[1] ? +vs[1] + exp : exp))\n}\n\nexport const round10: (\n  value: number,\n  exp: number,\n) => number = decimalAdjust.bind(undefined, Math.round)\nexport const floor10: (\n  value: number,\n  exp: number,\n) => number = decimalAdjust.bind(undefined, Math.floor)\nexport const ceil10: (\n  value: number,\n  exp: number,\n) => number = decimalAdjust.bind(undefined, Math.ceil)\n\nexport const GOLDEN_RATIO = (1 + Math.sqrt(5)) / 2\n\nexport function mod(a: number, b: number) {\n  return ((a % b) + b) % b\n}\n\nexport function clamp(val: number, min: number, max: number) {\n  assertNumbers(val, min, max)\n  return Math.max(min, Math.min(max, val))\n}\n\nexport function between(\n  val: number,\n  minInclusive: number,\n  maxInclusive: number,\n) {\n  assertNumbers(val, minInclusive, maxInclusive)\n  return minInclusive <= val && val <= maxInclusive\n}\n\nexport function fuzzyBetween(val: number, min: number, max: number) {\n  assertNumbers(val, min, max)\n  return le(min, val) && le(val, max)\n}\n\nexport function mapPush<T, U>(map: Map<T, U[]>, key: T, val: U) {\n  const array = map.get(key)\n  if (array) {\n    array.push(val)\n  } else {\n    map.set(key, [val])\n  }\n}\n\nexport function fuzzyUniques(vals: number[]): number[] {\n  const round = (val: number) => Math.floor(val * (1 << 26)) / (1 << 26)\n  const map = new Map()\n  for (let i = 0; i < vals.length; i++) {\n    const val = vals[i],\n      roundVal = round(val)\n    let key\n    if (\n      !map.has(roundVal) &&\n      !((key = map.get(roundVal - 1 / (1 << 26))) && eq(key, val)) &&\n      !((key = map.get(roundVal + 1 / (1 << 26))) && eq(key, val))\n    ) {\n      map.set(roundVal, val)\n    }\n  }\n  return Array.from(map.values())\n}\n\nexport function fuzzyUniquesF<T>(vals: T[], f: (o: T) => number): T[] {\n  const round = (val: number) => Math.floor(val * (1 << 26)) / (1 << 26)\n  const map = new Map()\n  for (let i = 0; i < vals.length; i++) {\n    const val = vals[i],\n      roundVal = round(f(val))\n    let key\n    if (\n      !map.has(roundVal) &&\n      !((key = map.get(roundVal - 1 / (1 << 26))) && eq(key, f(val))) &&\n      !((key = map.get(roundVal + 1 / (1 << 26))) && eq(key, f(val)))\n    ) {\n      map.set(roundVal, val)\n    }\n  }\n  return Array.from(map.values())\n}\n\nexport function addOwnProperties(\n  target: any,\n  props: any,\n  ...exclude: string[]\n) {\n  Object.getOwnPropertyNames(props).forEach((key) => {\n    //console.log(props, key)\n    if (!exclude.includes(key)) {\n      if (target.hasOwnProperty(key)) {\n        console.warn(\n          \"target \",\n          target,\n          \" already has property \",\n          key,\n          target[key],\n        )\n      }\n      Object.defineProperty(\n        target,\n        key,\n        Object.getOwnPropertyDescriptor(props, key)!,\n      )\n    }\n  })\n}\n\nexport let defaultRoundFunction = (x: number) => x // Math.round10(x, -4)\n\nexport function forceFinite(val: string): number {\n  const valNum = parseFloat(val.replace(\",\", \".\").replace(/^[^0-9,.\\-]/, \"\"))\n  return Number.isFinite(valNum) ? valNum : 0\n}\n\nexport const MINUS = (a: number, b: number) => a - b\n\nexport function floatHashCode(f: number) {\n  return ~~(f * (1 << 28))\n}\n\n/**\n * @example\n *   combinations(2) // [0,0] [0,1] [1,1] [0,2] [1,2] [2,2]\n */\nexport function* combinations(\n  n: int,\n): IterableIterator<{ i: number; j: number }> {\n  for (let i = 0; i < n; i++) {\n    for (let j = i; j < n; j++) {\n      yield { i: i, j: j }\n    }\n  }\n}\n\n/* The arithmetic-geometric mean of two non-negative numbers */\nexport function arithmeticGeometricMean(x: number, y: number): number {\n  assertf(() => lt(0, x))\n  assertf(() => lt(0, y))\n  let a = x,\n    g = y\n  let i = 30\n  while (i-- && a != g) {\n    ;[a, g] = [(a + g) / 2, Math.sqrt(a * g)]\n  }\n  assert(i != -1)\n\n  return a\n}\n\n/** One degree in radians. Use like Math.sin(30 * DEG). */\nexport const DEG = 0.017453292519943295\n\nexport function rad2deg(rad: number): number {\n  //  discuss at: http://phpjs.org/functions/deg2rad/\n  // original by: Enrique Gonzalez\n  // improved by: Thomas Grainger (http://graingert.co.uk)\n  //   example 1: deg2rad(45)\n  //   returns 1: 0.7853981633974483\n\n  return rad / DEG\n}\n\n/**\n * @example\n *   numberToStr(2 / 3) // \"0.6p\"\n *   numberToStr(7 / 12) // \"0.583p\"\n *   numberToStr(2 / 7) // \"0.285714pppppp\"\n *   numberToStr(NLA_PRECISION) // \"0+\"\n *   numberToStr(-NLA_PRECISION) // \"0-\"\n *   numberToStr(2 - NLA_PRECISION) // \"2-\"\n *   numberToStr(0) // \"0=\"\n */\nexport function numberToStr(value: number, length: int) {\n  let minAbsDiff = Infinity,\n    closestValue: number | undefined = undefined,\n    closestValueStr: string | undefined = undefined\n\n  function test(testValue: number, testValueStr: string) {\n    const absDiff = Math.abs(testValue - value)\n    console.log(testValue, testValueStr, absDiff)\n    if (absDiff < minAbsDiff) {\n      minAbsDiff = absDiff\n      closestValue = testValue\n      closestValueStr = testValueStr\n    }\n    return 0 == absDiff\n  }\n\n  function overline(str: string) {\n    return str\n      .split(\"\")\n      .map((c) => c + \"\\u0304\")\n      .join(\"\")\n  }\n\n  if (test(parseFloat(value.toFixed(length)), value.toFixed(length)))\n    return closestValueStr + \"=\"\n\n  const valueStr = \"\" + value\n  const toDecimal = valueStr.substr(0, valueStr.indexOf(\".\") + 1)\n  const decimals = valueStr.substr(valueStr.indexOf(\".\") + 1)\n\n  for (let startPos = 0; startPos < length; startPos++) {\n    for (let endPos = startPos + 1; endPos <= length; endPos++) {\n      const prefixDecimals = decimals.substr(0, startPos)\n      const period = decimals.substr(startPos, endPos)\n      const testValue = parseFloat(\n        toDecimal +\n          prefixDecimals +\n          period.repeat(Math.ceil((17 - startPos) / period.length)),\n      )\n      if (test(testValue, toDecimal + prefixDecimals + overline(period)))\n        return closestValueStr + \"=\"\n    }\n  }\n\n  return closestValueStr + (closestValue! < value ? \"-\" : \"+\")\n}\n\nexport function time(f: () => void) {\n  const start = performance.now()\n  f()\n  return performance.now() - start\n}\n\nexport type Tuple2<T> = [T, T]\nexport type Tuple3<T> = [T, T, T]\nexport type Tuple4<T> = [T, T, T, T]\nexport type Tuple5<T> = [T, T, T, T, T]\nexport type Tuple6<T> = [T, T, T, T, T, T]\nexport type Tuple7<T> = [T, T, T, T, T, T, T]\nexport type Tuple8<T> = [T, T, T, T, T, T, T, T]\n//console.log(numberToStr(29 / 99, 4))\n//console.log(numberToStr(77 / 99, 4))\n\n// interface Object {\n//    cw(f: (x: any) => any): any\n// }\n//Object.prototype.cw = function (f) {\n//    return f(this)\n//}\n//Object.construct = function <T>(cons: {new(...args: any[]): T}, args: any[]) {\n//    return f(this)\n//}\ndeclare global {\n  interface Object {\n    sce: string\n\n    toSource(): string\n  }\n\n  interface ObjectConstructor {\n    construct<T>(cons: { new (...args: any[]): T }, args: any[]): T\n\n    map<T, S, K extends string>(\n      o: { [k in K]: T },\n      f: (this: undefined, v: T, key: string, o: { [k in K]: T }) => S,\n    ): { [k in K]: S }\n\n    map<T, S, K extends string, C>(\n      o: { [k in K]: T },\n      f: (this: C, v: T, key: string, o: { [k in K]: T }) => S,\n      context: C,\n    ): { [k in K]: S }\n  }\n\n  interface Array<T> {\n    /** `this[this.length - 1]` */\n    map<U>(\n      this: [T],\n      callbackfn: (value: T, index: number, array: T[]) => U,\n      thisArg?: any,\n    ): [U]\n\n    map<U>(\n      this: Tuple2<T>,\n      callbackfn: (value: T, index: number, array: T[]) => U,\n      thisArg?: any,\n    ): Tuple2<U>\n\n    map<U>(\n      this: Tuple3<T>,\n      callbackfn: (value: T, index: number, array: T[]) => U,\n      thisArg?: any,\n    ): Tuple3<U>\n\n    map<U>(\n      this: Tuple4<T>,\n      callbackfn: (value: T, index: number, array: T[]) => U,\n      thisArg?: any,\n    ): Tuple4<U>\n\n    map<U>(\n      this: Tuple5<T>,\n      callbackfn: (value: T, index: number, array: T[]) => U,\n      thisArg?: any,\n    ): Tuple5<U>\n\n    map<U>(\n      this: Tuple6<T>,\n      callbackfn: (value: T, index: number, array: T[]) => U,\n      thisArg?: any,\n    ): Tuple6<U>\n\n    map<U>(\n      this: Tuple7<T>,\n      callbackfn: (value: T, index: number, array: T[]) => U,\n      thisArg?: any,\n    ): Tuple7<U>\n\n    map<U>(\n      this: Tuple8<T>,\n      callbackfn: (value: T, index: number, array: T[]) => U,\n      thisArg?: any,\n    ): Tuple8<U>\n  }\n\n  interface String {\n    capitalizeFirstLetter(): string\n\n    equals(x: any): boolean\n  }\n}\nObject.map = function <T, S, K extends string>(\n  o: { [k in K]: T },\n  f: (v: T, key: string, o: { [k in K]: T }) => S,\n  context: any = undefined,\n): { [k in K]: S } {\n  const result = {} as { [k in K]: S }\n  for (const key in o) {\n    result[key] = f.call(context, o[key], key, o)\n  }\n  return result\n}\n\nexport function arrayHashCode(arr: any[]): int {\n  let result = 0\n  for (let i = 0; i < arr.length; i++) {\n    result = (result * 31 + hashCode(arr[i])) | 0\n  }\n  return result | 0\n}\n\nexport function hashCode(o: any) {\n  if (\"number\" === typeof o || undefined === o) {\n    return o | 0\n  } else if (Array.isArray(o)) {\n    return arrayHashCode(o)\n  } else {\n    return null === o ? 0 : o.hashCode()\n  }\n}\n\nString.prototype.capitalizeFirstLetter = function () {\n  return this.charAt(0).toUpperCase() + this.slice(1)\n}\nString.prototype.equals = function (x: any) {\n  return this == x\n}\n\nexport function toString(o: any) {\n  return o.toString()\n}\n\nObject.defineProperty(Object.prototype, \"sce\", {\n  get: function () {\n    return this.toSource()\n  },\n  configurable: true,\n})\n\n/*\nObject.defineProperty(Object.prototype, \"str\", {\n  get: function () {\n    return this.toString()\n  },\n  configurable: true,\n})\n */\n\nexport function ilog<T>(x: T) {\n  console.log(x)\n  return x\n}\n\n//const NLA = {}\n//for (let key in ARRAY_UTILITIES) {\n//    const nlaName = 'array' + key.capitalizeFirstLetter()\n//    assert(!NLA[nlaName])\n//    NLA[nlaName] = (arr, ...rest) => ARRAY_UTILITIES[key].apply(arr, rest)\n//}\n\n/** Solves x + px + q = 0 */\nexport function pqFormula(p: number, q: number): number[] {\n  // 4 times the discriminant:in\n  const discriminantX4 = (p * p) / 4 - q\n  if (discriminantX4 < -NLA_PRECISION) {\n    return []\n  } else if (discriminantX4 <= NLA_PRECISION) {\n    return [-p / 2]\n  } else {\n    const root = Math.sqrt(discriminantX4)\n    return [-p / 2 - root, -p / 2 + root]\n  }\n}\n\n/**\n * From pomax' library solves ax + bx + cx + d = 0 This function from pomax' utils\n *\n * @returns 0-3 roots\n */\nexport function solveCubicReal2(\n  a: number,\n  b: number,\n  c: number,\n  d: number,\n): number[] {\n  if (eq0(a)) {\n    if (eq0(b)) {\n      return [-d / c]\n    } else {\n      return pqFormula(c / b, d / b)\n    }\n  }\n  const divisor = a\n  a = b / divisor\n  b = c / divisor\n  c = d / divisor\n  const p = (3 * b - a * a) / 3,\n    pDiv3 = p / 3,\n    pDiv3Pow3 = pDiv3 * pDiv3 * pDiv3,\n    q = (2 * a * a * a - 9 * a * b + 27 * c) / 27,\n    qDiv2 = q / 2,\n    discriminant = qDiv2 * qDiv2 + pDiv3Pow3\n  // 18abcd - 4bd + bc - 4ac - 27ad\n  if (discriminant < -NLA_PRECISION / 8) {\n    const r = Math.sqrt(-pDiv3Pow3),\n      t = -q / (2 * r),\n      cosphi = t < -1 ? -1 : t > 1 ? 1 : t, // clamp t to [-1;1]\n      phi = Math.acos(cosphi),\n      t1 = 2 * Math.cbrt(r)\n    const x1 = t1 * Math.cos(phi / 3) - a / 3\n    const x2 = t1 * Math.cos((phi + 2 * Math.PI) / 3) - a / 3\n    const x3 = t1 * Math.cos((phi + 4 * Math.PI) / 3) - a / 3\n    return [x1, x2, x3]\n  } else if (discriminant <= NLA_PRECISION / 8) {\n    if (0 == qDiv2) {\n      // TODO: compare with likeO?\n      return [-a / 3]\n    }\n    const u1 = qDiv2 < 0 ? Math.cbrt(-qDiv2) : -Math.cbrt(qDiv2)\n    const x1 = 2 * u1 - a / 3\n    const x2 = -u1 - a / 3\n    return [x1, x2]\n  } else {\n    const sd = Math.sqrt(discriminant)\n    const u1 = Math.cbrt(-qDiv2 + sd)\n    const v1 = Math.cbrt(qDiv2 + sd)\n    return [u1 - v1 - a / 3]\n  }\n}\n\nexport function checkDerivate(\n  f: (x: number) => number,\n  df: (x: number) => number,\n  a: number,\n  b: number,\n  maxFaults: int = 0,\n) {\n  const eps = 1e-4\n  let faults = 0\n  for (let t = a; t < b; t += (b - a) / 100) {\n    const dfdt = df(t)\n    const df2 = (f(t + eps) - f(t)) / eps\n    assert(\n      (faults += +!eq(df2, dfdt, 0.1)) <= maxFaults,\n      `df2 == ${df2} != ${df(t)} = df(t)`,\n    )\n  }\n}\n\nexport function bisect(\n  f: (x: number) => number,\n  a: number,\n  b: number,\n  steps: int,\n) {\n  assert(a < b)\n  let fA = f(a),\n    fB = f(b)\n  assert(fA * fB < 0)\n  while (steps--) {\n    const c = (b + a) / 2\n    const fC = f(c)\n    if (Math.sign(fA) == Math.sign(fC)) {\n      a = c\n      fA = fC\n    } else {\n      b = c\n      fB = fC\n    }\n  }\n  assert(a <= (b + a) / 2)\n  assert(b >= (b + a) / 2)\n  return lerp(a, b, 0.5)\n}\n\nexport function callSource(name: string, ...params: any[]) {\n  return name + \"(\" + params.map(toSource).join(\",\") + \")\"\n}\n\nexport function removeJSComments(str: string) {\n  const SPLITTER = /\\/\\/[^\\r\\n]+(?:\\r\\n|\\n\\r|\\r|\\n|$)|\\/\\*(?:[^*]|\\*[^/])+\\*\\/|\"(?:[^\"\\\\]|\\\\.)+\"|'(?:[^'\\\\]|\\\\.)+'|[`}](?:[^`$\\\\]|\\$[^{]|\\\\.)+(?:`|\\${)|(?:\\/(?:(?:(?!\\\\*\\/).)|\\\\\\\\|\\\\\\/|[^\\\\]\\[(?:\\\\\\\\|\\\\]|[^]])+])+\\/)|[^`\"']/g\n  return str.replace(SPLITTER, (x) =>\n    x.startsWith(\"//\") || x.startsWith(\"/*\") ? \"\" : x,\n  )\n}\n","import {\n  Matrix,\n  NLA_DEBUG,\n  NLA_PRECISION,\n  V,\n  V3,\n  Vector,\n  arrayFromFunction,\n  assert,\n  eq,\n  eq0,\n  getLast,\n  int,\n  snap,\n  sumInPlaceTree,\n  FloatArray,\n} from \".\"\n\nexport const gaussLegendre24Xs: ReadonlyArray<number> = [\n  -0.0640568928626056260850430826247450385909,\n  0.0640568928626056260850430826247450385909,\n  -0.1911188674736163091586398207570696318404,\n  0.1911188674736163091586398207570696318404,\n  -0.3150426796961633743867932913198102407864,\n  0.3150426796961633743867932913198102407864,\n  -0.4337935076260451384870842319133497124524,\n  0.4337935076260451384870842319133497124524,\n  -0.5454214713888395356583756172183723700107,\n  0.5454214713888395356583756172183723700107,\n  -0.6480936519369755692524957869107476266696,\n  0.6480936519369755692524957869107476266696,\n  -0.7401241915785543642438281030999784255232,\n  0.7401241915785543642438281030999784255232,\n  -0.8200019859739029219539498726697452080761,\n  0.8200019859739029219539498726697452080761,\n  -0.8864155270044010342131543419821967550873,\n  0.8864155270044010342131543419821967550873,\n  -0.9382745520027327585236490017087214496548,\n  0.9382745520027327585236490017087214496548,\n  -0.9747285559713094981983919930081690617411,\n  0.9747285559713094981983919930081690617411,\n  -0.9951872199970213601799974097007368118745,\n  0.9951872199970213601799974097007368118745,\n]\nexport const gaussLegendre24Weights: ReadonlyArray<number> = [\n  0.1279381953467521569740561652246953718517,\n  0.1279381953467521569740561652246953718517,\n  0.1258374563468282961213753825111836887264,\n  0.1258374563468282961213753825111836887264,\n  0.121670472927803391204463153476262425607,\n  0.121670472927803391204463153476262425607,\n  0.1155056680537256013533444839067835598622,\n  0.1155056680537256013533444839067835598622,\n  0.1074442701159656347825773424466062227946,\n  0.1074442701159656347825773424466062227946,\n  0.0976186521041138882698806644642471544279,\n  0.0976186521041138882698806644642471544279,\n  0.086190161531953275917185202983742667185,\n  0.086190161531953275917185202983742667185,\n  0.0733464814110803057340336152531165181193,\n  0.0733464814110803057340336152531165181193,\n  0.0592985849154367807463677585001085845412,\n  0.0592985849154367807463677585001085845412,\n  0.0442774388174198061686027482113382288593,\n  0.0442774388174198061686027482113382288593,\n  0.0285313886289336631813078159518782864491,\n  0.0285313886289336631813078159518782864491,\n  0.0123412297999871995468056670700372915759,\n  0.0123412297999871995468056670700372915759,\n]\n\nexport function assertVectors(...vectors: (Vector | V3)[]) {\n  if (NLA_DEBUG) {\n    for (let i = 0; i < arguments.length; i++) {\n      if (!(arguments[i] instanceof V3 || arguments[i] instanceof Vector)) {\n        throw new Error(\n          \"assertVectors arguments[\" +\n            i +\n            \"] is not a vector. \" +\n            typeof arguments[i] +\n            \" == typeof \" +\n            arguments[i],\n        )\n      }\n    }\n  }\n  return true\n}\n\nexport function gaussLegendreQuadrature24(\n  f: (x: number) => number,\n  startT: number,\n  endT: number,\n): number {\n  //let result = 0\n  //for (let i = 0; i < gaussLegendre24Xs.length; i++) {\n  //\t// gauss-legendre goes from -1 to 1, so we need to scale\n  //\tlet t = startT + (gaussLegendre24Xs[i] + 1) / 2 * (endT - startT)\n  //\tresult += gaussLegendre24Weights[i] * f(t)\n  //}\n  //const result = NLA\n  //\t\t.arrayFromFunction(24, i => startT + (gaussLegendre24Xs[i] + 1) / 2 * (endT - startT))\n  //\t\t.map((t, i) => gaussLegendre24Weights[i] * f(t))\n  //\t\t.sumInPlaceTree()\n  //99.54182500782605\n  //99.54182500782602\n  // again, [-1,1], so div by 2\n  //return result // 2 * (endT - startT)\n\n  return (\n    (glq24_11((t) => f(startT + ((t + 1) / 2) * (endT - startT))) / 2) *\n    (endT - startT)\n  )\n}\n\n/**\n * Calculate the integral of f in the interval [-1;1].\n *\n * @param f\n */\nexport function glq24_11(f: (x: number) => number): number {\n  return sumInPlaceTree(\n    arrayFromFunction(\n      24,\n      (i) => gaussLegendre24Weights[i] * f(gaussLegendre24Xs[i]),\n    ),\n  )\n}\n\nexport function glqInSteps(\n  f: (x: number) => number,\n  startT: number,\n  endT: number,\n  steps: int,\n) {\n  const dt = (endT - startT) / steps\n  return (\n    (sumInPlaceTree(\n      arrayFromFunction(steps, (i) =>\n        glq24_11((t) => f(startT + dt * i + ((t + 1) / 2) * dt)),\n      ),\n    ) /\n      2) *\n    dt\n  )\n}\n\nexport function midpointRuleQuadrature(\n  f: (x: number) => number,\n  startT: number,\n  endT: number,\n  steps: int = 32,\n): number {\n  const dt = (endT - startT) / steps\n  return (\n    sumInPlaceTree(\n      arrayFromFunction(steps, (i) => startT + dt / 2 + dt * i).map(f),\n    ) * dt\n  )\n}\n\n/**\n * Incomplete elliptic integral of the first kind EllipticF(phi, k2) = INT[0;\n * phi] 1 / sqrt(1 - k2 * sin(phi)) dphi\n */\nexport function EllipticF(phi: number, k2: number): number {\n  return gaussLegendreQuadrature24(\n    (phi) => Math.pow(1 - k2 * Math.sin(phi) ** 2, -0.5),\n    0,\n    phi,\n  )\n}\n\n/**\n * Incomplete elliptic integral of the second kind EllipticE(phi, k2) = INT[0;\n * phi] sqrt(1 - k2 * sin(phi)) dphi\n */\nexport function EllipticE(phi: number, k2: number): number {\n  return gaussLegendreQuadrature24(\n    (phi) => Math.pow(1 - k2 * Math.sin(phi) ** 2, 0.5),\n    0,\n    phi,\n  )\n}\n\nexport function getIntervals(\n  ts: number[],\n  min: number,\n  max: number,\n): [number, number][] {\n  ts.sort((a, b) => a - b)\n  if (!eq(ts[0], min)) {\n    ts.splice(0, 0, min)\n  }\n  if (!eq(getLast(ts), max)) {\n    ts.push(max)\n  }\n  return arrayFromFunction(\n    ts.length - 1,\n    (i) => [ts[i], ts[i + 1]] as [number, number],\n  )\n}\n\nexport function isCCW(vertices: V3[], normal: V3) {\n  const dsa = doubleSignedArea(vertices, normal)\n  assert(0 != dsa)\n  return dsa < 0\n}\n\nexport function doubleSignedArea(vertices: V3[], normal: V3) {\n  assert(!normal.likeO(), \"!normal.likeO()\")\n  const absMaxDim = normal.maxAbsDim()\n  // order is important, coord0 and coord1 must be set so that coord0, coord1 and maxDim span a right-hand coordinate\n  // system var [coord0, coord1] = [['y', 'z'], ['z', 'x'], ['x', 'y']][maxAbsDim]\n  const doubleSignedArea = vertices\n    .map((v0, i, vertices) => {\n      const v1 = vertices[(i + 1) % vertices.length]\n      //return (v1[coord0] - v0[coord0]) * (v1[coord1] + v0[coord1])\n      switch (absMaxDim) {\n        case 0:\n          return (v1.y - v0.y) * (v1.z + v0.z)\n        case 1:\n          return (v1.z - v0.z) * (v1.x + v0.x)\n        case 2:\n          return (v1.x - v0.x) * (v1.y + v0.y)\n      }\n    })\n    .reduce((a, b) => a + b)\n  return snap(doubleSignedArea * Math.sign(normal.e(absMaxDim)), 0)\n}\n\nexport function newtonIterate(\n  f: (x: FloatArray) => ArrayLike<number>,\n  x: number[],\n  steps: int = 4,\n  EPSILON?: number,\n  stepize = 1,\n) {\n  EPSILON = EPSILON || 1e-8\n\n  for (let i = 0; i < steps; i++) {\n    const fx = f(x)\n    const dfdx = Matrix.jacobi(f, x, fx, EPSILON)\n    assert(!dfdx.isZero())\n    const dx = dfdx.solveLinearSystem(new Vector(new Float64Array(fx))).v\n    assert(!isNaN(dx[0]))\n    //console.log('fx / dfdx', fx / dfdx)\n    for (let j = 0; j < x.length; j++) x[j] -= dx[j] * stepize\n  }\n  return x\n}\n\nexport function newtonIterate1d(\n  f: (x: number) => number,\n  xStart: number,\n  steps: number | undefined,\n  df: (x: number) => number,\n): number\nexport function newtonIterate1d(\n  f: (x: number) => number,\n  xStart: number,\n  steps: number,\n  EPSILON?: number,\n): number\nexport function newtonIterate1d(\n  f: (x: number) => number,\n  xStart: number,\n  steps: number = 8,\n  epsOrDf: number | ((x: number) => number) = 1e-8,\n): number {\n  if (\"number\" === typeof epsOrDf) {\n    let x = xStart\n\n    for (let i = 0; i < steps; i++) {\n      const fx = f(x)\n      const dfdx = (f(x + epsOrDf) - fx) / epsOrDf\n      //console.log('fx / dfdx', fx / dfdx)\n      x = x - fx / dfdx\n    }\n    return x\n  } else {\n    return newtonIterateWithDerivative(f, xStart, steps, epsOrDf)\n  }\n}\n\nexport function newtonIterateWithDerivative(\n  f: (x: number) => number,\n  xStart: number,\n  steps: number = 4,\n  df: (x: number) => number,\n) {\n  let x = xStart\n  for (let i = 0; i < steps; i++) {\n    const fx = f(x)\n    const dfdx = df(x)\n    if (isNaN(fx) || isNaN(dfdx)) {\n      console.log()\n      //console.log('fx / dfdx', fx / dfdx)\n    }\n    x = x - fx / dfdx\n    if (isNaN(fx)) {\n      console.log()\n      //console.log('fx / dfdx', fx / dfdx)\n    }\n  }\n  return x\n}\n\nexport function newtonIterateWithDerivative2(\n  fAndDf: (x: number) => [number, number],\n  xStart: number,\n  steps: number = 8,\n  xMin = -Infinity,\n  xMax = Infinity,\n): number | undefined {\n  assert(steps % 1 == 0)\n  let x = xStart\n  for (let i = 0; i < steps; i++) {\n    const [fx, dfdx] = fAndDf(x)\n    if (isNaN(fx) || isNaN(dfdx)) {\n      console.log()\n      //console.log('fx / dfdx', fx / dfdx)\n    }\n    x = x - fx / dfdx\n    if (0 == dfdx || x < xMin || xMax < x) {\n      return undefined\n    }\n  }\n  return x\n}\n\nexport function newtonIterateSmart(\n  f: (x: number) => number,\n  xStart: number,\n  steps: number = 4,\n  df: (x: number) => number,\n  mindf = 1e-6,\n) {\n  let x = xStart\n  for (let i = 0; i < steps; i++) {\n    const fx = f(x)\n    const dfdx = df(x)\n    if (Math.abs(dfdx) < mindf && Math.abs(fx) < mindf) {\n      return newtonIterate1d(df, x, steps, df)\n    }\n    if (isNaN(fx) || isNaN(dfdx)) {\n      console.log()\n      //console.log('fx / dfdx', fx / dfdx)\n    }\n    x = x - fx / dfdx\n    if (isNaN(fx)) {\n      console.log()\n      //console.log('fx / dfdx', fx / dfdx)\n    }\n  }\n  return x\n}\n\nexport function newtonIterate2d(\n  f1: (s: number, t: number) => number,\n  f2: (s: number, t: number) => number,\n  sStart: number,\n  tStart: number,\n  steps?: number,\n): V3 | undefined {\n  const EPSILON = 1e-6\n  steps = steps || 4\n  let s = sStart,\n    t = tStart,\n    f1ts,\n    f2ts\n  do {\n    /*\n         | a b |-1                   |  d -b |\n         | c d |   = 1 / (ad - bc) * | -c  a |\n         */\n    f1ts = f1(s, t)\n    f2ts = f2(s, t)\n    /*\n         let df1s = (f1(s + EPSILON, t) - f1ts) / EPSILON, df1t = (f1(s, t + EPSILON) - f1ts) / EPSILON,\n         df2s = (f2(s + EPSILON, t) - f2ts) / EPSILON, df2t = (f2(s, t + EPSILON) - f2ts) / EPSILON\n         let det = df1s * df2t - df1t * df2s\n         s = s - ( df2t * f1ts - df1t * f2ts) / det\n         t = t - (-df2s * f1ts + df1s * f2ts) / det\n         */\n    // TODO: is this even more accurate?\n    const df1s = f1(s + EPSILON, t) - f1ts,\n      df1t = f1(s, t + EPSILON) - f1ts,\n      df2s = f2(s + EPSILON, t) - f2ts,\n      df2t = f2(s, t + EPSILON) - f2ts\n    const det = (df1s * df2t - df1t * df2s) / EPSILON\n    const ds = (df2t * f1ts - df1t * f2ts) / det\n    const dt = (-df2s * f1ts + df1s * f2ts) / det\n    s -= ds\n    t -= dt\n  } while (--steps && f1ts ** 2 + f2ts ** 2 > NLA_PRECISION)\n  if (f1ts ** 2 + f2ts ** 2 > NLA_PRECISION) {\n    console.log(f1ts ** 2 + f2ts ** 2)\n    return undefined\n  }\n  return new V3(s, t, 0)\n}\n\nexport function newtonIterate2dWithDerivatives(\n  f: (s: number, t: number) => number,\n  g: (s: number, t: number) => number,\n  sStart: number,\n  tStart: number,\n  steps: int,\n  dfds: (s: number, t: number) => number,\n  dfdt: (s: number, t: number) => number,\n  dgds: (s: number, t: number) => number,\n  dgdt: (s: number, t: number) => number,\n): V3 | undefined {\n  steps = steps || 4\n  let s = sStart,\n    t = tStart\n  let f1ts, f2ts\n  do {\n    /*\n         | a b |-1                   |  d -b |\n         | c d |   = 1 / (ad - bc) * | -c  a |\n         */\n    f1ts = f(s, t)\n    f2ts = g(s, t)\n    const df1s = dfds(s, t),\n      df1t = dfdt(s, t),\n      df2s = dgds(s, t),\n      df2t = dgdt(s, t)\n    // TODO: is this even more accurate?\n    const det = df1s * df2t - df1t * df2s\n    const ds = (df2t * f1ts - df1t * f2ts) / det\n    const dt = (-df2s * f1ts + df1s * f2ts) / det\n    s -= ds\n    t -= dt\n  } while (--steps && f1ts * f1ts + f2ts * f2ts > NLA_PRECISION / 32)\n  if (!steps) {\n    //console.log(f1ts * f1ts + f2ts * f2ts)\n    return undefined\n  }\n  return V(s, t, 0)\n}\n\nexport function getRoots(\n  f: (x: number) => number,\n  a: number,\n  b: number,\n  stepSize: number,\n  df: (x: number) => number,\n): number[] {\n  const results: number[] = []\n  for (let startT = a; startT <= b; startT += stepSize) {\n    const dt = stepSize * Math.abs(df(startT))\n    if (Math.abs(f(startT)) <= dt) {\n      //const t = newtonIterate1d(f, startT, 16)\n      let t = newtonIterateWithDerivative(f, startT, 16, df)\n      if (!eq0(f(t)) || eq0(df(t))) {\n        t = newtonIterate1d(df, startT, 16)\n        // const a = startT - dt,\n        // \tb = startT + dt\n        //if (f(a) * f(b) < 0) {\n        //    t = bisect(f, a, b, 16)\n        //} else if (df(a) * df(b) < 0) {\n        //    t = bisect(df, a, b, 16)\n        //}\n      }\n      if (eq0(f(t)) && !results.some((r) => eq(r, t))) {\n        results.push(t)\n      }\n    }\n  }\n  return results\n}\n","import { assert, assertInts, assertNumbers, int, lerp, MINUS, mod } from \".\"\n\nexport function arraySwap(arr: any[], i: int, j: int) {\n  const temp = arr[i]\n  arr[i] = arr[j]\n  arr[j] = temp\n}\n\nexport type ArrayLikeWriteAble<T> = {\n  readonly length: int\n  [index: number]: T\n}\n\nexport function arrayCopy<T, A extends ArrayLikeWriteAble<T>>(\n  src: ArrayLike<T>,\n  sstart: int,\n  dst: A,\n  dstart: int,\n  length: int,\n): A {\n  assertInts(sstart, dstart, length)\n  dstart += length\n  length += sstart\n  while (length-- > sstart) {\n    dst[--dstart] = src[length]\n  }\n  return dst\n}\n\n/**\n * Copies a number of items from one array to another, with a definable step\n * size between items in the source and destination array.\n *\n * @param src The source array.\n * @param sstart The location of the first item in the source array.\n * @param sstep The offset between items in the source array.\n * @param dst The destination array.\n * @param dstart The location of the first item in the destination array.\n * @param dstep The offset between items in the destination array.\n * @param count The number of items to copy.\n */\nexport function arrayCopyStep<T>(\n  src: ArrayLike<T>,\n  sstart: int,\n  sstep: int,\n  dst: ArrayLikeWriteAble<T>,\n  dstart: int,\n  dstep: int,\n  count: int,\n): void {\n  let srcIndex = sstart + count * sstep\n  let dIndex = dstart + count * dstep\n  while (srcIndex > sstart) {\n    dst[(dIndex -= dstep)] = src[(srcIndex -= sstep)]\n  }\n}\n\n/**\n * Copies a number of contiguous, evenly-spaced blocks from one array to another.\n *\n * @param src The source array.\n * @param sstart The start of the first block in the source array.\n * @param sstep The offset from the start of one block to the start of the next\n *     block in the source array.\n * @param dst The destination array.\n * @param dstart The start of the first block in the destination array.\n * @param dstep The offset from the start of one block to the start of the next\n *     block in the destination array.\n * @param blockSize The length of one block.\n * @param blockCount The number of blocks to copy.\n */\nexport function arrayCopyBlocks<T>(\n  src: ArrayLike<T>,\n  sstart: int,\n  sstep: int,\n  dst: ArrayLikeWriteAble<T>,\n  dstart: int,\n  dstep: int,\n  blockSize: int,\n  blockCount: int,\n): void {\n  for (let i = 0; i < blockCount; i++) {\n    arrayCopy(src, sstart + sstep * i, dst, dstart + dstep * i, blockSize)\n  }\n}\n\nexport function arrayRange(\n  startInclusive: int,\n  endExclusive: int,\n  step: int = 1,\n) {\n  assertNumbers(startInclusive, step)\n  //console.log(Math.ceil((endExclusive - startInclusive) / step))\n  const arrLength = Math.ceil((endExclusive - startInclusive) / step)\n  const result = new Array(arrLength) // '- startInclusive' so that chunk in the last row will also be selected, even\n  // if the row is not complete\n  for (\n    let i = startInclusive, index = 0;\n    index < arrLength;\n    i += step, index++\n  ) {\n    result[index] = i\n  }\n  return result\n}\n\n/**\n * Returns a number of evenly-spaced values between t0 and t1 (inclusive).\n *\n * @param t0 First value.\n * @param t1 Last value.\n * @param count Total number of values.\n */\nexport function arraySamples(t0: number, t1: number, count: int = 64) {\n  return arrayFromFunction(count, (i) => lerp(t0, t1, i / (count - 1)))\n}\n\nexport function arrayFromFunction<T>(\n  length: 1,\n  f: (i: int, total: int) => T,\n): [T]\nexport function arrayFromFunction<T>(\n  length: 2,\n  f: (i: int, total: int) => T,\n): [T, T]\nexport function arrayFromFunction<T>(\n  length: 3,\n  f: (i: int, total: int) => T,\n): [T, T, T]\nexport function arrayFromFunction<T>(\n  length: 4,\n  f: (i: int, total: int) => T,\n): [T, T, T, T]\nexport function arrayFromFunction<T>(\n  length: 5,\n  f: (i: int, total: int) => T,\n): [T, T, T, T, T]\nexport function arrayFromFunction<T>(\n  length: int,\n  f: (i: int, total: int) => T,\n): T[]\nexport function arrayFromFunction<T>(\n  length: int,\n  f: (i: int, total: int) => T,\n): T[] {\n  assertNumbers(length)\n  assert(\"function\" == typeof f)\n  const a = new Array(length)\n  let elIndex = length\n  while (elIndex--) {\n    a[elIndex] = f(elIndex, length)\n  }\n  return a\n}\n\n/**\n * Return the element in the array for which f(el) is highest. There is no\n * `withMin`, call `withMax(x => -f(x))` instead.\n *\n * @param arr The array to search.\n * @param f\n */\nexport function withMax<A extends ArrayLike<unknown>>(\n  arr: A,\n  f: (t: A[number], i: int, arr: A) => number,\n): A[number] | undefined {\n  let i = arr.length,\n    result = undefined,\n    maxVal = -Infinity\n  while (i--) {\n    const el = arr[i],\n      val = f(el, i, arr)\n    if (val > maxVal) {\n      maxVal = val\n      result = el\n    }\n  }\n  return result\n}\n\n/**\n * Returns the sum of the absolute values of the components of arr vector.\n *\n * @example\n *   absSum(V(1, -2, 3)) === abs(1) + abs(-2) + abs(3)) === 1 + 2 + 3 === 6\n */\nexport function absSum(arr: number[]) {\n  let i = arr.length\n  let result = 0\n  while (i--) {\n    result += Math.abs(arr[i])\n  }\n  return result\n}\n\nexport function emod<T>(arr: ArrayLike<T>, i: int): T {\n  return arr[mod(i, arr.length)]\n}\n\nexport function sliceStep<T>(\n  arr: ArrayLike<T>,\n  start: int,\n  end: int,\n  step: int,\n  chunkSize = 1,\n): T[] {\n  assertNumbers(start, step)\n  start < 0 && (start = arr.length + start)\n  end <= 0 && (end = arr.length + end)\n  const resultLength = Math.ceil((end - start) / step)\n  const result = new Array(resultLength) // '- start' so that chunk in the last row\n  // will also be selected, even if the row is\n  // not complete\n  let index = 0\n  for (let i = start; i < end; i += step) {\n    for (let j = i; j < Math.min(i + chunkSize, end); j++) {\n      result[index++] = arr[j]\n    }\n  }\n  assert(resultLength == index)\n  return result\n}\n\nexport function splicePure<T>(\n  arr: ArrayLike<T>,\n  start = 0,\n  deleteCount = 0,\n  ...items: T[]\n): T[] {\n  const arrayLength = arr.length\n  const _deleteCount = deleteCount < 0 ? 0 : deleteCount\n  let _start\n  if (start < 0) {\n    if (Math.abs(start) > arrayLength) {\n      _start = 0\n    } else {\n      _start = arrayLength + start\n    }\n  } else if (start > arrayLength) {\n    _start = arrayLength\n  } else {\n    _start = start\n  }\n  const newLength = arr.length - _deleteCount + items.length\n  const result = new Array(newLength)\n  let dst = newLength\n  let src = arr.length\n  while (src-- > _start + _deleteCount) {\n    result[--dst] = arr[src]\n  }\n  src = items.length\n  while (src--) {\n    result[--dst] = items[src]\n  }\n  src = _start\n  while (src--) {\n    result[--dst] = items[src]\n  }\n  return result\n}\n\nexport function arrayEquals(\n  arr: ArrayLike<unknown>,\n  obj: ArrayLike<unknown>,\n): boolean {\n  if (arr === obj) return true\n  if (Object.getPrototypeOf(obj) !== Array.prototype) return false\n  if (arr.length !== obj.length) return false\n  for (let i = 0; i < arr.length; i++) {\n    if (!equals(arr[i], obj[i])) return false\n  }\n  return true\n}\n\nexport function equals(a: any, b: any) {\n  return Array.isArray(a)\n    ? arrayEquals(a, b)\n    : \"object\" === typeof a\n    ? a.equals(b)\n    : a === b\n}\n\n/** Equivalent to `arr.map(f).filter((x) => x)`. */\nexport function mapFilter<T, S>(\n  arr: T[],\n  f: (item: T, index: int, arr: T[]) => S | undefined | false | null,\n): S[] {\n  const length = arr.length\n  const result: S[] = []\n  for (let i = 0; i < length; i++) {\n    if (i in arr) {\n      const val = f(arr[i], i, arr)\n      if (val) {\n        result.push(val)\n      }\n    }\n  }\n  return result\n}\n\nexport function clear<T>(arr: T[], ...newItems: T[]): T[] {\n  return arr.splice(0, arr.length, ...newItems)\n}\n\nexport function concatenated<T>(arr: T[]) {\n  return Array.prototype.concat.apply([], arr)\n}\n\nexport function min<T>(arr: ArrayLike<number>): number {\n  let i = arr.length,\n    max = Infinity\n  while (i--) {\n    const val = arr[i]\n    if (max > val) max = val\n  }\n  return max\n}\n\nexport function max(arr: ArrayLike<number>): number {\n  // faster and no limit on array size, see https://jsperf.com/math-max-apply-vs-loop/2\n  let i = arr.length,\n    max = -Infinity\n  while (i--) {\n    const val = arr[i]\n    if (max < val) max = val\n  }\n  return max\n}\n\nexport function indexWithMax<A extends ArrayLike<unknown>>(\n  arr: A,\n  f: (e: A[number], i: int, arr: A) => number,\n): int {\n  if (arr.length == 0) {\n    return -1\n  }\n  let i = arr.length,\n    result = -1,\n    maxVal = -Infinity\n  while (i--) {\n    const val = f(arr[i], i, arr)\n    if (val > maxVal) {\n      maxVal = val\n      result = i\n    }\n  }\n  return result\n}\n\nexport function sum(arr: ArrayLike<number>) {\n  let i = arr.length\n  let result = 0\n  while (i--) {\n    result += arr[i]\n  }\n  return result\n}\n\nexport function sumInPlaceTree(arr: ArrayLikeWriteAble<number>) {\n  if (0 == arr.length) return 0\n  let l = arr.length\n  while (l != 1) {\n    const lHalfFloor = Math.floor(l / 2)\n    const lHalfCeil = Math.ceil(l / 2)\n    for (let i = 0; i < lHalfFloor; i++) {\n      arr[i] += arr[i + lHalfCeil]\n    }\n    l = lHalfCeil\n  }\n  return arr[0]\n}\n\nexport function unique<T>(arr: T[]): T[] {\n  const uniqueSet = new Set<T>(arr)\n  return Array.from(uniqueSet)\n}\n\nexport function remove<T>(arr: T[], o: T): boolean {\n  const index = arr.indexOf(o)\n  if (index != -1) {\n    arr.splice(index, 1)\n    return true\n  }\n  return false\n}\n\nexport function removeIndex<T>(arr: T[], i: int): T {\n  const result = arr[i]\n  arr.splice(i, 1)\n  return result\n}\n\nexport function bagRemoveIndex<T>(arr: T[], i: int): T {\n  const result = arr[i]\n  if (i == arr.length - 1) {\n    arr.pop()\n  } else {\n    arr[i] = arr.pop()!\n  }\n  return result\n}\n\nexport function removeMatch<T>(arr: T[], matcher: (el: T) => boolean) {\n  const index = arr.findIndex(matcher)\n  if (-1 != index) {\n    return removeIndex(arr, index)\n  }\n}\n\nexport function removeAll<T>(arr: T[], o: T[]): void {\n  let i = o.length\n  while (i--) {\n    remove(arr, o[i])\n  }\n}\n\nexport function toggle<T>(arr: T[], o: T) {\n  const index = arr.indexOf(o)\n  if (index != -1) {\n    arr.splice(index, 1)\n    return false\n  } else {\n    arr.push(o)\n    return true\n  }\n}\n\nexport function bagToggle<T>(arr: T[], o: T) {\n  const index = arr.indexOf(o)\n  if (index != -1) {\n    bagRemoveIndex(arr, index)\n    return false\n  } else {\n    arr.push(o)\n    return true\n  }\n}\n\nexport function binaryIndexOf(\n  arr: ArrayLike<number>,\n  searchElement: number,\n  cmp?: (a: number, b: number) => number,\n): int\nexport function binaryIndexOf<T, S>(\n  arr: ArrayLike<T>,\n  searchElement: S,\n  cmp: (a: T, b: S) => number,\n): int\nexport function binaryIndexOf<T, S>(\n  arr: ArrayLike<T>,\n  searchElement: S,\n  cmp = (a: any, b: any) => a - b,\n): int {\n  let minIndex = 0\n  let maxIndex = arr.length - 1\n  let currentIndex\n  let currentElement\n\n  while (minIndex <= maxIndex) {\n    currentIndex = ((minIndex + maxIndex) / 2) | 0\n    currentElement = arr[currentIndex]\n\n    if (cmp(currentElement, searchElement) < 0) {\n      minIndex = currentIndex + 1\n    } else if (cmp(currentElement, searchElement) > 0) {\n      maxIndex = currentIndex - 1\n    } else {\n      return currentIndex\n    }\n  }\n\n  return -minIndex - 1\n}\n\nexport function binaryInsert<T>(\n  arr: number[],\n  el: number,\n  cmp?: (a: number, b: number) => number,\n): void\nexport function binaryInsert<T>(\n  arr: T[],\n  el: number,\n  cmp: (a: T, b: T) => number,\n): void\nexport function binaryInsert<T>(\n  arr: T[],\n  el: any,\n  cmp: (a: T, b: T) => number = MINUS as any,\n): void {\n  let minIndex = 0\n  let maxIndex = arr.length\n  let currentIndex\n  let currentElement\n\n  while (minIndex < maxIndex) {\n    currentIndex = ~~((minIndex + maxIndex) / 2)\n    currentElement = arr[currentIndex]\n\n    if (cmp(currentElement, el) < 0) {\n      minIndex = currentIndex + 1\n    } else {\n      maxIndex = currentIndex\n    }\n  }\n\n  arr.splice(minIndex, 0, el)\n}\n\nexport function firstUnsorted<T>(\n  arr: ArrayLike<T>,\n  cmp: (a: T, b: T) => number,\n) {\n  for (let i = 1; i < arr.length; i++) {\n    if (cmp(arr[i - 1], arr[i]) > 0) return i\n  }\n  return -1\n}\n\nexport function getLast<T>(arr: ArrayLike<T>): T {\n  return arr[arr.length - 1]\n}\n\nexport function setLast<T>(arr: ArrayLikeWriteAble<T>, val: T): T {\n  return (arr[arr.length - 1] = val)\n}\n\nexport function removeIndexes<T>(arr: T[], indexes: int[]): T[] {\n  indexes.sort((a, b) => a - b)\n  if (0 === indexes.length) return arr\n  if (1 === indexes.length) {\n    arr.splice(indexes[0], 1)\n    return arr\n  }\n  let dstPos = indexes[0]\n  let nextSkip = indexes[0]\n  let indexesPos = 0\n  for (let srcPos = indexes[0]; srcPos < arr.length; srcPos++) {\n    if (srcPos !== nextSkip) {\n      arr[dstPos++] = arr[srcPos]\n    } else {\n      indexesPos++\n      if (indexesPos < indexes.length) {\n        nextSkip = indexes[indexesPos]\n      } else {\n        arr.splice(dstPos, srcPos + 1 - dstPos)\n        return arr\n      }\n    }\n  }\n  throw new Error(\"illegal state\")\n}\n","import { Equalable, JavaMap as CustomMap } from \"javasetmap.ts\"\n\nimport {\n  assert,\n  assertf,\n  assertInst,\n  assertNumbers,\n  assertVectors,\n  defaultRoundFunction,\n  eq,\n  eq0,\n  FloatArray,\n  int,\n  NLA_PRECISION,\n  raddd,\n} from \".\"\n\n/** Immutable 3d-vector/point. */\nexport class V3 implements Equalable {\n  static readonly O: V3 = new V3(0, 0, 0)\n  static readonly X: V3 = new V3(1, 0, 0)\n  static readonly Y: V3 = new V3(0, 1, 0)\n  static readonly Z: V3 = new V3(0, 0, 1)\n  static readonly XY: V3 = new V3(1, 1, 0)\n  static readonly XYZ: V3 = new V3(1, 1, 1)\n  static readonly INF: V3 = new V3(Infinity, Infinity, Infinity)\n  static readonly UNITS: V3[] = [V3.X, V3.Y, V3.Z]\n  static readonly NAMEMAP = new CustomMap<V3, string>()\n    .set(V3.O, \"V3.O\")\n    .set(V3.X, \"V3.X\")\n    .set(V3.Y, \"V3.Y\")\n    .set(V3.Z, \"V3.Z\")\n    .set(V3.XYZ, \"V3.XYZ\")\n    .set(V3.INF, \"V3.INF\")\n\n  constructor(readonly x: number, readonly y: number, readonly z: number) {\n    assertNumbers(x, y, z)\n  }\n\n  static random(): V3 {\n    return new V3(Math.random(), Math.random(), Math.random())\n  }\n\n  static parallel(a: V3, b: V3) {\n    return a.dot(b) - a.length() * b.length()\n  }\n\n  /**\n   * See\n   * http://math.stackexchange.com/questions/44689/how-to-find-a-random-axis-or-unit-vector-in-3d\n   *\n   *\n   * @returns A random point on the unit sphere with uniform distribution across\n   *     the surface.\n   */\n  static randomUnit(): V3 {\n    const zRotation = Math.random() * 2 * Math.PI\n    const z = Math.random() * 2 - 1\n    const zRadius = Math.sqrt(1 - z ** 2)\n    return new V3(\n      zRadius * Math.cos(zRotation),\n      zRadius * Math.sin(zRotation),\n      z,\n    )\n  }\n\n  //noinspection JSUnusedLocalSymbols\n  /** Documentation stub. You want {@see V3#sphere} */\n  static fromAngles(theta: number, phi: number): V3 {\n    throw new Error()\n  }\n\n  static fromFunction(f: (dim: number) => number) {\n    return new V3(f(0), f(1), f(2))\n  }\n\n  static min(a: V3, b: V3): V3 {\n    return new V3(Math.min(a.x, b.x), Math.min(a.y, b.y), Math.min(a.z, b.z))\n  }\n\n  static max(a: V3, b: V3): V3 {\n    return new V3(Math.max(a.x, b.x), Math.max(a.y, b.y), Math.max(a.z, b.z))\n  }\n\n  static lerp(a: V3, b: V3, t: number): V3 {\n    return new V3(\n      a.x * (1 - t) + b.x * t,\n      a.y * (1 - t) + b.y * t,\n      a.z * (1 - t) + b.z * t,\n    )\n  }\n\n  static fromArray(a: number[]): V3 {\n    return new V3(a[0], a[1], a[2])\n  }\n\n  static angleBetween(a: V3, b: V3): number {\n    return a.angleTo(b)\n  }\n\n  static zip(f: (...args: number[]) => number, ...args: V3[]): V3 {\n    assert(f instanceof Function)\n    return new V3(\n      f.apply(\n        undefined,\n        args.map((x) => x.x),\n      ),\n      f.apply(\n        undefined,\n        args.map((x) => x.y),\n      ),\n      f.apply(\n        undefined,\n        args.map((x) => x.z),\n      ),\n    )\n  }\n\n  static normalOnPoints(a: V3, b: V3, c: V3): V3 {\n    assertVectors(a, b, c)\n    return a.to(b).cross(a.to(c))\n  }\n\n  static add(...vs: V3[]): V3 {\n    assertVectors(...vs)\n    let x = 0,\n      y = 0,\n      z = 0\n    let i = vs.length\n    while (i--) {\n      x += vs[i].x\n      y += vs[i].y\n      z += vs[i].z\n    }\n    return new V3(x, y, z)\n  }\n\n  static sub(...vs: V3[]): V3 {\n    assertVectors(...vs)\n    let x = vs[0].x,\n      y = vs[0].y,\n      z = vs[0].z\n    let i = vs.length\n    while (i--) {\n      x -= vs[i].x\n      y -= vs[i].y\n      z -= vs[i].z\n    }\n    return new V3(x, y, z)\n  }\n\n  /**\n   * Pack an array of V3s into an array of numbers (Float32Array by default).\n   *\n   * @param v3arr Source array\n   * @param dest Destination array. If provided, must be large enough to fit\n   *     v3count items.\n   * @param srcStart Starting index in source array\n   * @param destStart Starting index in destination array\n   * @param v3count Number of V3s to copy.\n   * @returns Packed array.\n   */\n  static pack<T extends FloatArray = Float32Array>(\n    v3arr: ReadonlyArray<V3>,\n    dest?: T,\n    srcStart: number = 0,\n    destStart: number = 0,\n    v3count: number = v3arr.length - srcStart,\n  ): T {\n    //assert (v3arr.every(v3 => v3 instanceof V3), 'v3arr.every(v3 => v3 instanceof V3)')\n    const result = dest || (new Float32Array(3 * v3count) as any) // TODO\n    assert(\n      result.length - destStart >= v3count * 3,\n      \"dest.length - destStart >= v3count * 3\",\n      result.length,\n      destStart,\n      v3count * 3,\n    )\n\n    let i = v3count,\n      srcIndex = srcStart,\n      destIndex = destStart\n    while (i--) {\n      const v = v3arr[srcIndex++]\n      result[destIndex++] = v.x\n      result[destIndex++] = v.y\n      result[destIndex++] = v.z\n    }\n    return result\n  }\n\n  static unpack(\n    packedArray: ArrayLike<number>,\n    dest?: V3[],\n    srcStart: number = 0,\n    destStart: number = 0,\n    v3count: number = (packedArray.length - srcStart) / 3,\n  ) {\n    //assert (v3arr.every(v3 => v3 instanceof V3), 'v3arr.every(v3 => v3 instanceof V3)')\n    dest = dest || new Array(v3count)\n    assert(\n      dest.length - destStart >= v3count,\n      \"dest.length - destStart >= v3count\",\n    )\n\n    let i = v3count,\n      srcIndex = srcStart,\n      destIndex = destStart\n    while (i--) {\n      dest[destIndex++] = new V3(\n        packedArray[srcIndex++],\n        packedArray[srcIndex++],\n        packedArray[srcIndex++],\n      )\n    }\n    return dest\n  }\n\n  static packXY<T extends FloatArray = Float32Array>(\n    v3arr: V3[],\n    dest?: T,\n    srcStart: number = 0,\n    destStart: number = 0,\n    v3count: number = v3arr.length - srcStart,\n  ): T {\n    //assert (v3arr.every(v3 => v3 instanceof V3), 'v3arr.every(v3 => v3 instanceof V3)')\n    const result = dest || (new Float32Array(2 * v3count) as any)\n    assert(\n      result.length - destStart >= v3count,\n      \"dest.length - destStart >= v3count\",\n    )\n\n    let i = v3count,\n      srcIndex = srcStart,\n      destIndex = destStart\n    while (i--) {\n      const v = v3arr[srcIndex++]\n      result[destIndex++] = v.x\n      result[destIndex++] = v.y\n    }\n    return result\n  }\n\n  static unpackXY(\n    src: FloatArray,\n    dest?: V3[],\n    srcStart: int = 0,\n    destStart: int = 0,\n    v3count: int = Math.min(src.length / 2, (dest && dest.length) || Infinity) -\n      destStart,\n  ): V3[] {\n    //assert (v3arr.every(v3 => v3 instanceof V3), 'v3arr.every(v3 => v3 instanceof V3)')\n    dest = dest || new Array(v3count)\n    assert(\n      dest.length - destStart >= v3count,\n      \"dest.length - destStart >= v3count\",\n    )\n    assert(\n      src.length - srcStart >= v3count * 2,\n      \"dest.length - destStart >= v3count\",\n    )\n\n    let i = v3count,\n      srcIndex = srcStart,\n      destIndex = destStart\n    while (i--) {\n      dest[destIndex++] = new V3(src[srcIndex++], src[srcIndex++], 0)\n    }\n    return dest\n  }\n\n  static perturbed(v: V3, delta?: number): V3 {\n    return v.perturbed(delta)\n  }\n\n  static polar(radius: number, phi: raddd, z: number = 0): V3 {\n    return new V3(radius * Math.cos(phi), radius * Math.sin(phi), z)\n  }\n\n  /**\n   * @param longitude Angle in XY plane\n   * @param latitude \"height\"/z dir angle\n   */\n  static sphere(longitude: raddd, latitude: raddd, length = 1): V3 {\n    return new V3(\n      length * Math.cos(latitude) * Math.cos(longitude),\n      length * Math.cos(latitude) * Math.sin(longitude),\n      length * Math.sin(latitude),\n    )\n  }\n\n  static inverseLerp(a: V3, b: V3, x: V3) {\n    const ab = a.to(b)\n    return a.to(x).dot(ab) / ab.squared()\n  }\n\n  get [0]() {\n    return this.x\n  }\n  get [1]() {\n    return this.y\n  }\n  get [2]() {\n    return this.z\n  }\n\n  get u() {\n    return this.x\n  }\n  get v() {\n    return this.y\n  }\n\n  perturbed(delta: number = NLA_PRECISION * 0.8): V3 {\n    return this.map((x) => x + (Math.random() - 0.5) * delta)\n  }\n\n  *[Symbol.iterator]() {\n    yield this.x\n    yield this.y\n    yield this.z\n  }\n\n  e(index: int): number {\n    assert(index >= 0 && index < 3)\n    return 0 == index ? this.x : 1 == index ? this.y : this.z\n  }\n\n  negated(): V3 {\n    return new V3(-this.x, -this.y, -this.z)\n  }\n\n  abs(): V3 {\n    return new V3(Math.abs(this.x), Math.abs(this.y), Math.abs(this.z))\n  }\n\n  plus(a: V3): V3 {\n    assertVectors(a)\n    return new V3(this.x + a.x, this.y + a.y, this.z + a.z)\n  }\n\n  /**\n   * Hadarmard product (or Schur product): element-wise multiplication of two vectors.\n   *\n   * @see https://en.wikipedia.org/wiki/Hadamard_product_(matrices)\n   */\n  schur(a: V3): V3 {\n    return new V3(this.x * a.x, this.y * a.y, this.z * a.z)\n  }\n\n  /** Element-wise division. */\n  divv(a: V3): V3 {\n    return new V3(this.x / a.x, this.y / a.y, this.z / a.z)\n  }\n\n  /** See also {@link to} which is a.minus(this) */\n  minus(a: V3): V3 {\n    assertVectors(a)\n    return new V3(this.x - a.x, this.y - a.y, this.z - a.z)\n  }\n\n  to(a: V3): V3 {\n    assertVectors(a)\n    return a.minus(this)\n  }\n\n  times(factor: number): V3 {\n    assertNumbers(factor)\n    return new V3(this.x * factor, this.y * factor, this.z * factor)\n  }\n\n  div(a: number): V3 {\n    assertNumbers(a)\n    return new V3(this.x / a, this.y / a, this.z / a)\n  }\n\n  /**\n   * Dot product.\n   *\n   * @see https://en.wikipedia.org/wiki/Dot_product\n   */\n  dot(a: V3): number {\n    assertInst(V3, a)\n    return this.x * a.x + this.y * a.y + this.z * a.z\n  }\n\n  /** Linearly interpolate */\n  lerp(b: V3, t: number): V3 {\n    assertVectors(b)\n    assertNumbers(t)\n    return V3.lerp(this, b, t)\n  }\n\n  squared(): number {\n    return this.dot(this)\n  }\n\n  distanceTo(a: V3): number {\n    assertVectors(a)\n    //return this.minus(a).length()\n    return Math.hypot(this.x - a.x, this.y - a.y, this.z - a.z)\n  }\n\n  distanceToSquared(a: V3): number {\n    assertVectors(a)\n    return this.minus(a).squared()\n  }\n\n  ///**\n  // * See also {@see #setTo} for the individual\n  // *\n  // * @param v\n  // */\n  //assign(v) {\n  //\tassertVectors(v)\n  //\tthis.x = v.x\n  //\tthis.y = v.y\n  //\tthis.z = v.z\n  //}\n  //\n  ///**\n  // * See also {@see #assign} for the V3 version\n  // *\n  // * @param x\n  // * @param y\n  // * @param z\n  // */\n  //setTo(x, y, z = 0) {\n  //\tthis.x = x\n  //\tthis.y = y\n  //\tthis.z = z\n  //}\n\n  toSource(): string {\n    return V3.NAMEMAP.get(this) || this.toString()\n  }\n\n  nonParallelVector(): V3 {\n    const abs = this.abs()\n    if (abs.x <= abs.y && abs.x <= abs.z) {\n      return V3.X\n    } else if (abs.y <= abs.x && abs.y <= abs.z) {\n      return V3.Y\n    } else {\n      return V3.Z\n    }\n  }\n\n  slerp(b: V3, t: number): V3 {\n    assertVectors(b)\n    assertNumbers(t)\n    const sin = Math.sin\n    const omega = this.angleTo(b)\n    return this.times(sin((1 - t) * omega) / sin(omega)).plus(\n      b.times(sin(t * omega) / sin(omega)),\n    )\n  }\n\n  min(b: V3): V3 {\n    return new V3(\n      Math.min(this.x, b.x),\n      Math.min(this.y, b.y),\n      Math.min(this.z, b.z),\n    )\n  }\n\n  max(b: V3): V3 {\n    return new V3(\n      Math.max(this.x, b.x),\n      Math.max(this.y, b.y),\n      Math.max(this.z, b.z),\n    )\n  }\n\n  equals(v: any): boolean {\n    return this == v || (this.x == v.x && this.y == v.y && this.z == v.z)\n  }\n\n  /**\n   * The cross product is defined as: a x b = |a| * |b| * sin(phi) * n where |.|\n   * is the euclidean norm, phi is the angle between the vectors and n is a\n   * unit vector perpendicular to both a and b.\n   *\n   * The cross product is zero for parallel vectors.\n   *\n   * @see https://en.wikipedia.org/wiki/Cross_product\n   */\n  cross(v: V3): V3 {\n    return new V3(\n      this.y * v.z - this.z * v.y,\n      this.z * v.x - this.x * v.z,\n      this.x * v.y - this.y * v.x,\n    )\n  }\n\n  minElement(): number {\n    return Math.min(this.x, this.y, this.z)\n  }\n\n  maxElement(): number {\n    return Math.max(this.x, this.y, this.z)\n  }\n\n  toArray(n: int = 3): number[] {\n    return [this.x, this.y, this.z].slice(0, n)\n  }\n\n  /**\n   * Get a perpendicular vector.\n   *\n   * For vectors in the XY-Plane, returns vector rotated 90 CCW.\n   */\n  getPerpendicular(): V3 {\n    if (eq0(this.x) && eq0(this.y)) {\n      if (eq0(this.z)) {\n        throw new Error(\"zero vector\")\n      }\n      // v is Vector(0, 0, v.z)\n      return V3.Y\n    }\n    return new V3(-this.y, this.x, 0)\n  }\n\n  //noinspection JSMethodCanBeStatic\n  dim(): int {\n    return 3\n  }\n\n  els(): number[] {\n    return [this.x, this.y, this.z]\n  }\n\n  angleXY(): number {\n    return Math.atan2(this.y, this.x)\n  }\n\n  lengthXY(): number {\n    return Math.hypot(this.x, this.y)\n    //return Math.sqrt(this.x * this.x + this.y * this.y)\n  }\n\n  squaredXY(): number {\n    return this.x * this.x + this.y * this.y\n  }\n\n  xy(): V3 {\n    return new V3(this.x, this.y, 0)\n  }\n\n  /**\n   * Transform this vector element-wise by way of function f. Returns V3(f(x), f(y), f(z))\n   *\n   * @param f Function to apply to elements (number -> number)\n   */\n  map(f: (el: number, dim: \"x\" | \"y\" | \"z\") => number): V3 {\n    return new V3(f(this.x, \"x\"), f(this.y, \"y\"), f(this.z, \"z\"))\n  }\n\n  toString(roundFunction?: (x: number) => any): string {\n    roundFunction = roundFunction || defaultRoundFunction\n    return (\n      V3.NAMEMAP.get(this) ||\n      \"V(\" + [this.x, this.y, this.z].map(roundFunction).join(\", \") + \")\"\n    ) //+ this.id\n  }\n\n  angleTo(b: V3): number {\n    assert(1 == arguments.length)\n    assertVectors(b)\n    assert(!this.likeO())\n    assert(!b.likeO())\n    return Math.acos(Math.min(1, this.dot(b) / this.length() / b.length()))\n  }\n\n  /**\n   * Phi = angle between A and B alpha = angle between n and normal1\n   *\n   * A . B = ||A|| * ||B|| * cos(phi) A x B = ||A|| * ||B|| * sin(phi) * n (n =\n   * unit vector perpendicular) (A x B) . normal1 = ||A|| * ||B|| * sin(phi) * cos(alpha)\n   */\n  angleRelativeNormal(vector: V3, normal1: V3): number {\n    assert(2 == arguments.length)\n    assertVectors(vector, normal1)\n    assertf(() => normal1.hasLength(1))\n    //assert(vector.isPerpendicularTo(normal1), 'vector.isPerpendicularTo(normal1)' + vector.sce + normal1.sce)\n    //assert(this.isPerpendicularTo(normal1), 'this.isPerpendicularTo(normal1)' + this.dot(vector)) //\n    // -0.000053600770598683675\n    return Math.atan2(this.cross(vector).dot(normal1), this.dot(vector))\n  }\n\n  /**\n   * Returns true iff this is parallel to vector, i.e. this * s == vector, where\n   * s is a positive or negative number, using eq. Throw a DebugError - if\n   * vector is not a Vector or - if this has a length of 0 or - if vector has a\n   * length of 0\n   */\n  isParallelTo(vector: V3): boolean {\n    assertVectors(vector)\n    assert(!this.likeO())\n    assert(!vector.likeO())\n    // a . b takes on values of +|a|*|b| (vectors same direction) to -|a|*|b| (opposite direction)\n    // in both cases the vectors are parallel, so check if abs(a . b) == |a|*|b|\n    const dot = this.dot(vector)\n    return eq(this.squared() * vector.squared(), dot * dot)\n  }\n\n  isPerpendicularTo(vector: V3): boolean {\n    assertVectors(vector)\n    assert(!this.likeO(), \"!this.likeO()\")\n    assert(!vector.likeO(), \"!vector.likeO()\")\n    return eq0(this.dot(vector))\n  }\n\n  isReverseDirTo(other: V3): boolean {\n    assertVectors(other)\n    assert(!this.likeO())\n    assert(!other.likeO())\n    // a . b takes on values of +|a|*|b| (vectors same direction) to -|a|*|b| (opposite direction)\n    // in both cases the vectors are parallel, so check if abs(a . b) == |a|*|b|\n    const dot = this.dot(other)\n    return eq(Math.sqrt(this.squared() * other.squared()), dot)\n  }\n\n  /**\n   * Returns the length of this Vector, i.e. the euclidean norm.\n   *\n   * Note that the partial derivatives of the euclidean norm at point x are\n   * equal to the components of the unit vector x.\n   */\n  length(): number {\n    return Math.hypot(this.x, this.y, this.z)\n    //return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)\n  }\n\n  /** Definition: V3.likeO == V3.like(V3.O) */\n  likeO(): boolean {\n    return this.like(V3.O)\n  }\n\n  /**\n   * Eq(this.x, obj.x) && eq(this.y, obj.y) && eq(this.z, obj.z)\n   *\n   * @param obj\n   */\n  like(obj: any): boolean {\n    if (obj === this) return true\n    if (!(obj instanceof V3)) return false\n    return eq(this.x, obj.x) && eq(this.y, obj.y) && eq(this.z, obj.z)\n  }\n\n  /** Equivalent to this.like(v) || this.negated().like(v) */\n  likeOrReversed(v: V3): boolean {\n    return eq(Math.abs(this.dot(v)), Math.sqrt(this.squared() * v.squared()))\n  }\n\n  /**\n   * Returns a new unit Vector (.length() === 1) with the same direction as this\n   * vector. Throws a DebugError if this has a length of 0.\n   */\n  unit(): V3 {\n    assert(!this.likeO(), \"cannot normalize zero vector\")\n    return this.div(this.length())\n  }\n\n  /** Documentation stub. You want {@link unit} */\n  normalized(): V3 {\n    throw new Error(\"documentation stub. use .unit()\")\n  }\n\n  /**\n   * Returns a new V3 equal to this scaled so that its length is equal to newLength.\n   *\n   * Passing a negative newLength will flip the vector.\n   */\n  toLength(newLength: number): V3 {\n    assertNumbers(newLength)\n    return this.times(newLength / this.length())\n  }\n\n  /**\n   * Returns a new Vector which is the projection of this vector onto the passed\n   * vector. Examples\n   *\n   * V(3, 4).projectedOn(V(1, 0)) // returns V(3, 0) V(3, 4).projectedOn(V(2,\n   * 0)) // returns V(3, 0) V(3, 4).projectedOn(V(-1, 0)) // returns V(-3, 0)\n   * V(3, 4).projectedOn(V(0, 1)) // returns V(0, 4) V(3, 4).projectedOn(V(1,\n   * 1)) // returns\n   */\n  projectedOn(b: V3): V3 {\n    assertVectors(b)\n    // https://en.wikipedia.org/wiki/Vector_projection#Vector_projection_2\n    return b.times(this.dot(b) / b.dot(b))\n  }\n\n  rejectedFrom(b: V3): V3 {\n    assertVectors(b)\n    // https://en.wikipedia.org/wiki/Vector_projection#Vector_projection_2\n    return this.minus(b.times(this.dot(b) / b.dot(b)))\n  }\n\n  rejectedFrom1(b1: V3): V3 {\n    assertVectors(b1)\n    assert(b1.hasLength(1))\n    // https://en.wikipedia.org/wiki/Vector_projection#Vector_projection_2\n    return this.minus(b1.times(this.dot(b1)))\n  }\n\n  /**\n   * Returns the length of this vector rejected from the unit vector b.\n   *\n   *     /| this / | ^\n   *     /__| | b\n   *     r Returns length of r (r === this.rejectedFrom(b))\n   */\n  rejectedLength(b: V3): number {\n    assertVectors(b)\n    return Math.sqrt(this.dot(this) - this.dot(b) ** 2 / b.dot(b))\n  }\n\n  /**\n   * Returns the length of this vector rejected from the unit vector b1.\n   *\n   *     /| this / | ^\n   *     /__| | b1\n   *     r Returns length of r (r === this.rejectedFrom(b1))\n   */\n  rejected1Length(b1: V3): number {\n    assertVectors(b1)\n    assert(b1.hasLength(1))\n    return Math.sqrt(this.dot(this) - this.dot(b1) ** 2)\n  }\n\n  /**\n   * Returns true iff the length() of this vector is equal to 'length', using eq\n   *\n   * @example\n   *   V(3, 4).hasLength(5) === true\n   *\n   * @example\n   *   V(1, 1).hasLength(1) === false\n   */\n  hasLength(length: number): boolean {\n    assertNumbers(length)\n    return eq(length, this.length())\n  }\n\n  /**\n   * Returns the sum of the absolute values of the components of this vector.\n   * E.g. V(1, -2, 3) === abs(1) + abs(-2) + abs(3) === 1 + 2 + 3 === 6\n   */\n  absSum(): number {\n    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)\n  }\n\n  /** @returns `min(|x|, |y|, |z|)` */\n  minAbsElement(): number {\n    return Math.min(Math.abs(this.x), Math.abs(this.y), Math.min(this.z))\n  }\n\n  /** @returns `max(|x|, |y|, |z|)` */\n  maxAbsElement(): number {\n    return Math.max(Math.abs(this.x), Math.abs(this.y), Math.abs(this.z))\n  }\n\n  maxAbsDim(): 0 | 1 | 2 {\n    const xAbs = Math.abs(this.x),\n      yAbs = Math.abs(this.y),\n      zAbs = Math.abs(this.z)\n    return xAbs >= yAbs ? (xAbs >= zAbs ? 0 : 2) : yAbs >= zAbs ? 1 : 2\n  }\n\n  minAbsDim(): 0 | 1 | 2 {\n    const xAbs = Math.abs(this.x),\n      yAbs = Math.abs(this.y),\n      zAbs = Math.abs(this.z)\n    return xAbs < yAbs ? (xAbs < zAbs ? 0 : 2) : yAbs < zAbs ? 1 : 2\n  }\n\n  withElement(dim: \"x\" | \"y\" | \"z\", el: number) {\n    assert([\"x\", \"y\", \"z\"].includes(dim), \"\" + dim)\n    assertNumbers(el)\n    if (\"x\" == dim) {\n      return new V3(el, this.y, this.z)\n    }\n    if (\"y\" == dim) {\n      return new V3(this.x, el, this.z)\n    }\n    return new V3(this.x, this.y, el)\n  }\n\n  hashCode(): int {\n    function floatHashCode(f: number) {\n      return ~~(f * (1 << 28))\n    }\n\n    return ~~(\n      (floatHashCode(this.x) * 31 + floatHashCode(this.y)) * 31 +\n      floatHashCode(this.z)\n    )\n  }\n\n  hashCodes() {\n    //function floatHashCode(f) {\n    //\treturn ~~(f * (1 << 28))\n    //}\n\n    // compare hashCode.floatHashCode\n    // the following ops are equivalent to\n    // floatHashCode((el - NLA_PRECISION) % (2 * NLA_PRECISION))\n    // this results in the hashCode for the (out of 8 possible) cube with the lowest hashCode\n    // the other 7 can be calculated by adding constants\n    const xHC = ~~(this.x * (1 << 28) - 0.5),\n      yHC = ~~(this.y * (1 << 28) - 0.5),\n      zHC = ~~(this.z * (1 << 28) - 0.5),\n      hc = ~~((xHC * 31 + yHC) * 31 + zHC)\n    return [\n      ~~hc,\n      ~~(hc + 961),\n      ~~(hc + 31),\n      ~~(hc + 31 + 961),\n      ~~(hc + 1),\n      ~~(hc + 1 + 961),\n      ~~(hc + 1 + 31),\n      ~~(hc + 1 + 31 + 961),\n    ]\n  }\n\n  //static areDisjoint(it: Iterable<V3>): boolean {\n  //\tconst vSet = new CustomSet\n  //\tfor (const v of it) {\n  //\t\tif (!v.equals(vSet.canonicalizeLike(v))) {\n  //\t\t\t// like value already in set\n  //\t\t\treturn false\n  //\t\t}\n  //\t}\n  //\treturn true\n  //}\n\n  compareTo(other: V3): number {\n    if (this.x != other.x) {\n      return this.x - other.x\n    } else if (this.y != other.y) {\n      return this.y - other.y\n    } else {\n      return this.z - other.z\n    }\n  }\n\n  compareTo2(other: V3, eps: number = NLA_PRECISION): number {\n    if (!eq(this.x, other.x, eps)) {\n      return this.x - other.x\n    } else if (!eq(this.y, other.y, eps)) {\n      return this.y - other.y\n    } else if (!eq(this.z, other.z, eps)) {\n      return this.z - other.z\n    } else {\n      return 0\n    }\n  }\n\n  toAngles(): { theta: raddd; phi: raddd } {\n    return {\n      theta: Math.atan2(this.y, this.x),\n      phi: Math.asin(this.z / this.length()),\n    }\n  }\n}\n\n/**\n * Utility method for creating V3s\n *\n * Example usage:\n *\n *     V(1, 2, 3)\n *     V([1, 2, 3])\n *     V({ x: 1, y: 2, z: 3 })\n *     V(1, 2) * assumes z=0\n *     V([1, 2]) // assumes z=0\n */\nexport function V(x: number, y: number, z?: number): V3\nexport function V(arr: [number, number, number] | [number, number]): V3\nexport function V(obj: { x: number; y: number; z?: number }): V3\nexport function V(a: any, b?: any, c?: any): V3 {\n  if (arguments.length == 3) {\n    return new V3(parseFloat(a), parseFloat(b), parseFloat(c))\n  } else if (arguments.length == 2) {\n    return new V3(parseFloat(a), parseFloat(b), 0)\n  } else if (arguments.length == 1) {\n    if (typeof a == \"object\") {\n      if (a instanceof V3) {\n        // immutable, so\n        return a\n      } else if (\n        a instanceof Array ||\n        a instanceof Float32Array ||\n        a instanceof Float64Array\n      ) {\n        if (2 == a.length) {\n          return new V3(parseFloat(a[0]), parseFloat(a[1]), 0)\n        } else if (3 == a.length) {\n          return new V3(parseFloat(a[0]), parseFloat(a[1]), parseFloat(a[2]))\n        }\n      } else if (\"x\" in a && \"y\" in a) {\n        return new V3(\n          parseFloat(a.x),\n          parseFloat(a.y),\n          \"z\" in a ? parseFloat(a.z) : 0,\n        )\n      }\n    }\n  }\n  throw new Error(\"invalid arguments\" + arguments)\n}\n","import { callSource, M4, raddd, V3 } from \".\"\n\nexport const P3YZ = { normal1: V3.X, w: 0 }\nexport const P3ZX = { normal1: V3.Y, w: 0 }\nexport const P3XY = { normal1: V3.Z, w: 0 }\n\nexport abstract class Transformable {\n  mirror(plane: { normal1: V3; w: number }): this {\n    return this.transform(M4.mirror(plane))\n  }\n\n  mirroredX(): this {\n    return this.mirror(P3YZ)\n  }\n\n  mirrorY(): this {\n    return this.mirror(P3ZX)\n  }\n\n  mirrorZ(): this {\n    return this.mirror(P3XY)\n  }\n\n  project(plane: { normal1: V3; w: number }): this {\n    return this.transform(M4.project(plane))\n  }\n\n  projectXY(): this {\n    return this.transform(M4.project(P3XY))\n  }\n\n  projectYZ(): this {\n    return this.transform(M4.project(P3YZ))\n  }\n\n  projectZX(): this {\n    return this.transform(M4.project(P3ZX))\n  }\n\n  translate(x: number, y?: number, z?: number): this\n  translate(v: V3): this\n  translate(...args: any): this {\n    return this.transform(\n      M4.translate.apply(undefined, args),\n      callSource.call(undefined, \".translate\", ...args),\n    )\n  }\n\n  scale(x: number, y?: number, z?: number): this\n  scale(f: V3): this\n  scale(...args: any): this {\n    return this.transform(\n      M4.scale.apply(undefined, args),\n      callSource.call(undefined, \".scale\", ...args),\n    )\n  }\n\n  rotateX(radians: raddd): this {\n    return this.transform(M4.rotateX(radians), `.rotateX(${radians})`)\n  }\n\n  rotateY(radians: raddd): this {\n    return this.transform(M4.rotateY(radians), `.rotateY(${radians})`)\n  }\n\n  rotateZ(radians: raddd): this {\n    return this.transform(M4.rotateZ(radians), `.rotateZ(${radians})`)\n  }\n\n  rotate(rotationCenter: V3, rotationAxis: V3, radians: raddd): this {\n    return this.transform(\n      M4.rotateLine(rotationCenter, rotationAxis, radians),\n      callSource(\".rotate\", rotationCenter, rotationAxis, radians),\n    )\n  }\n\n  rotateAB(from: V3, to: V3): this {\n    return this.transform(\n      M4.rotateAB(from, to),\n      callSource(\".rotateAB\", from, to),\n    )\n  }\n\n  eulerZXZ(alpha: raddd, beta: raddd, gamma: raddd): this {\n    throw new Error()\n    //return this.transform(M4.eulerZXZ(alpha, beta, gamma))\n  }\n\n  shearX(y: number, z: number): this {\n    // prettier-ignore\n    return this.transform(new M4([\n      1, y, z, 0,\n      0, 1, 0, 0,\n      0, 0, 1, 0,\n      0, 0, 0, 1]))\n  }\n\n  foo(): this {\n    return this.transform(M4.FOO)\n  }\n\n  fooInv(): this {\n    return this.transform(M4.FOO_INV)\n  }\n\n  abstract transform(m4: M4, desc?: string): this\n\n  visit<R>(visitor: { [name: string]: (this: Transformable) => R }): R\n  visit<R, A>(\n    visitor: { [name: string]: (this: Transformable, a: A) => R },\n    a: A,\n  ): R\n  visit<R, A, B>(\n    visitor: { [name: string]: (this: Transformable, a: A, b: B) => R },\n    a: A,\n    b: B,\n  ): R\n  visit<R, A, B, C>(\n    visitor: { [name: string]: (this: Transformable, a: A, b: B, c: C) => R },\n    a: A,\n    b: B,\n    c: C,\n  ): R\n  visit<R, A, B, C, D>(\n    visitor: {\n      [name: string]: (this: Transformable, a: A, b: B, c: C, d: D) => R\n    },\n    a: A,\n    b: B,\n    c: C,\n    d: D,\n  ): R\n  visit(\n    visitor: { [name: string]: (this: Transformable, ...args: any[]) => any },\n    ...args: any[]\n  ) {\n    let proto = Object.getPrototypeOf(this)\n    // walk up the prototype chain until we find a defined function in o\n    while (\n      !visitor.hasOwnProperty(proto.constructor.name) &&\n      proto !== Transformable.prototype\n    ) {\n      proto = Object.getPrototypeOf(proto)\n    }\n    if (visitor.hasOwnProperty(proto.constructor.name)) {\n      return visitor[proto.constructor.name].apply(this, args)\n    } else {\n      throw new Error(\"No implementation for \" + this.constructor.name)\n    }\n  }\n}\n","import { Equalable } from \"javasetmap.ts\"\n\nimport {\n  arrayCopy,\n  arrayCopyBlocks,\n  arrayCopyStep,\n  arrayFromFunction,\n  arraySwap,\n  assert,\n  assertf,\n  assertInst,\n  assertInts,\n  assertNumbers,\n  assertVectors,\n  eq,\n  eq0,\n  FloatArray,\n  floatHashCode,\n  int,\n  max,\n  min,\n  NLA_PRECISION,\n  Vector,\n} from \".\"\n\nexport class Matrix implements Equalable {\n  constructor(\n    public width: int,\n    public height: int,\n    public readonly m: Float64Array,\n  ) {\n    assertInts(width, height)\n    assertf(() => 0 < width)\n    assertf(() => 0 < height)\n    assert(\n      width * height == m.length,\n      \"width * height == m.length\",\n      width,\n      height,\n      m.length,\n    )\n  }\n\n  static random(width: int, height: int): Matrix {\n    return Matrix.fromFunction(width, height, () => Math.random())\n  }\n\n  static fromFunction(\n    width: int,\n    height: int,\n    f: (row: int, col: int, elIndex: int) => number,\n  ): Matrix {\n    const m = new Float64Array(height * width)\n    let elIndex = height * width\n    while (elIndex--) {\n      m[elIndex] = f(Math.floor(elIndex / width), elIndex % width, elIndex)\n    }\n    return new Matrix(width, height, m)\n  }\n\n  static identityN(dim: int): Matrix {\n    assertInts(dim)\n    const m = new Float64Array(dim * dim)\n    // Float64Arrays are init to 0\n    let elIndex = dim * (dim + 1)\n    while (elIndex) {\n      elIndex -= dim + 1\n      m[elIndex] = 1\n    }\n    return new Matrix(dim, dim, m)\n  }\n\n  /**\n   * Create new dim x dim matrix equal to an identity matrix with rows/colums i\n   * and k swapped. Note that i and k are 0-indexed.\n   */\n  static permutation(dim: int, i: int, k: int): Matrix {\n    assertInts(dim, i, k)\n    assertf(() => 0 <= i && i < dim)\n    assertf(() => 0 <= k && k < dim)\n    const m = new Float64Array(dim * dim)\n    // Float64Array are init to 0\n    let elIndex = dim * (dim + 1)\n    while (elIndex) {\n      elIndex -= dim + 1\n      m[elIndex] = 1\n    }\n    m[i * dim + i] = 0\n    m[k * dim + k] = 0\n    m[i * dim + k] = 1\n    m[k * dim + i] = 1\n    return new Matrix(dim, dim, m)\n  }\n\n  static fromRowArrays(...rowArrays: ArrayLike<number>[]): Matrix {\n    if (0 == rowArrays.length) {\n      throw new Error(\"cannot have 0 vector\")\n    }\n    const height = rowArrays.length\n    const width = rowArrays[0].length\n    const m = new Float64Array(height * width)\n    arrayCopy(rowArrays[0], 0, m, 0, width)\n    for (let rowIndex = 1; rowIndex < height; rowIndex++) {\n      if (rowArrays[rowIndex].length != width) {\n        throw new Error(\"all row arrays must be the same length\")\n      }\n      arrayCopy(rowArrays[rowIndex], 0, m, rowIndex * width, width)\n    }\n    return this.new(width, height, m)\n  }\n\n  static fromColVectors(colVectors: Vector[]): Matrix {\n    return Matrix.fromColArrays(...colVectors.map((v) => v.v))\n  }\n\n  static forWidthHeight(width: int, height: int): Matrix {\n    return new Matrix(width, height, new Float64Array(width * height))\n  }\n\n  static fromColArrays(...colArrays: ArrayLike<number>[]): Matrix {\n    if (0 == colArrays.length) {\n      throw new Error(\"cannot have 0 vector\")\n    }\n    const width = colArrays.length\n    const height = colArrays[0].length\n    const m = new Float64Array(height * width)\n    arrayCopyStep(colArrays[0], 0, 1, m, 0, width, height)\n    for (let colIndex = 1; colIndex < width; colIndex++) {\n      if (colArrays[colIndex].length != height) {\n        throw new Error(\"all col arrays must be the same length\")\n      }\n      arrayCopyStep(colArrays[colIndex], 0, 1, m, colIndex, width, height)\n    }\n    return this.new(width, height, m)\n  }\n\n  static product(...m4s: Matrix[]): Matrix\n  static product(ms: Matrix[], result?: Matrix): Matrix\n  static product(...args: any[]): Matrix {\n    const [ms, result]: [Matrix[], Matrix | undefined] = Array.isArray(args[0])\n      ? [args[0], args[1]]\n      : [args, undefined]\n    if (0 == ms.length) throw new Error(\"Can't guess matrix size.\")\n    if (1 == ms.length) return Matrix.copy(ms[0], result)\n    return Matrix.copy(\n      ms.reduce((a, b) => a.times(b)),\n      result,\n    )\n  }\n\n  /**\n   * Numerically calculate all the partial derivatives of f at x0.\n   *\n   * @param f\n   * @param x0\n   * @param fx0 F(x0), pass it if you have it already\n   * @param EPSILON\n   */\n  static jacobi(\n    f: (x: number[] | Float32Array | Float64Array) => ArrayLike<number>,\n    x0: FloatArray,\n    fx0: ArrayLike<number> = f(x0),\n    EPSILON: number = 1e-6,\n  ): Matrix {\n    const jacobi = Matrix.forWidthHeight(x0.length, fx0.length)\n    for (let colIndex = 0; colIndex < x0.length; colIndex++) {\n      x0[colIndex] += EPSILON\n      const fx = f(x0)\n      for (let rowIndex = 0; rowIndex < fx0.length; rowIndex++) {\n        const value = (fx[rowIndex] - fx0[rowIndex]) / EPSILON\n        jacobi.setEl(rowIndex, colIndex, value)\n      }\n      x0[colIndex] -= EPSILON\n    }\n    return jacobi\n  }\n\n  static copy<T extends Matrix>(src: T, result: T = src.new()): T {\n    assertInst(Matrix, src, result)\n    assert(src.width == result.width)\n    assert(src.height == result.height)\n    assert(result != src, \"result != src\")\n    const s = src.m,\n      d = result.m\n    let i = s.length\n    while (i--) {\n      d[i] = s[i]\n    }\n    return result\n  }\n\n  protected static new(width: int, height: int, m: Float64Array) {\n    return new Matrix(width, height, m)\n  }\n\n  copy(): this {\n    return Matrix.copy<this>(this)\n  }\n\n  e(rowIndex: number, colIndex: number): number {\n    assertInts(rowIndex, colIndex)\n    assert(\n      0 <= rowIndex && rowIndex < this.height,\n      \"rowIndex out of bounds \" + rowIndex,\n    )\n    assert(\n      0 <= colIndex && colIndex < this.width,\n      \"colIndex out of bounds \" + colIndex,\n    )\n    return this.m[rowIndex * this.width + colIndex]\n  }\n\n  setEl(rowIndex: number, colIndex: number, val: number): void {\n    assertInts(rowIndex, colIndex)\n    assert(\n      0 <= rowIndex && rowIndex < this.height,\n      \"rowIndex out of bounds \" + rowIndex,\n    )\n    assert(\n      0 <= colIndex && colIndex < this.width,\n      \"colIndex out of bounds \" + colIndex,\n    )\n    assertNumbers(val)\n    this.m[rowIndex * this.width + colIndex] = val\n  }\n\n  plus(m: this): this {\n    assert(this.width == m.width)\n    assert(this.height == m.height)\n    const r = this.new()\n    let i = this.m.length\n    while (i--) r.m[i] = this.m[i] + m.m[i]\n    return r\n  }\n\n  minus(m: Matrix): Matrix {\n    assert(this.width == m.width)\n    assert(this.height == m.height)\n    const r = this.new()\n    let i = this.m.length\n    while (i--) r.m[i] = this.m[i] - m.m[i]\n    return r\n  }\n\n  mulScalar(scalar: number): this {\n    assertNumbers(scalar)\n    const r = this.new()\n    let i = this.m.length\n    while (i--) r.m[i] = this.m[i] * scalar\n    return r\n  }\n\n  divScalar(scalar: number): this {\n    assertNumbers(scalar)\n    const r = this.new()\n    let i = this.m.length\n    while (i--) r.m[i] = this.m[i] / scalar\n    return r\n  }\n\n  new(): this {\n    return new Matrix(\n      this.width,\n      this.height,\n      new Float64Array(this.width * this.height),\n    ) as this\n  }\n\n  toString(\n    f?: (el: number) => string,\n    colNames?: ReadonlyArray<string>,\n    rowNames?: ReadonlyArray<string>,\n  ): string {\n    f = f || ((v) => v.toFixed(6))\n    assert(typeof f(0) == \"string\", \"\" + typeof f(0))\n    assert(!colNames || colNames.length == this.width)\n    assert(!rowNames || rowNames.length == this.height)\n    const rounded: string[] = Array.from(this.m).map(f)\n    const rows = arrayFromFunction(this.height, (rowIndex) =>\n      rounded.slice(rowIndex * this.width, (rowIndex + 1) * this.width),\n    ) // select matrix row\n    if (colNames) {\n      rows.unshift(Array.from(colNames))\n    }\n    if (rowNames) {\n      rows.forEach((row, rowIndex) =>\n        row.unshift(rowNames[rowIndex - (colNames ? 1 : 0)] || \"\"),\n      )\n    }\n    const colWidths = arrayFromFunction(this.width, (colIndex) =>\n      max(rows.map((row) => row[colIndex].length)),\n    )\n    return rows\n      .map((row, rowIndex) =>\n        row\n          .map((x, colIndex) => {\n            // pad numbers with spaces to col width\n            const padder =\n              (rowIndex == 0 && colNames) || (colIndex == 0 && rowNames)\n                ? String.prototype.padEnd\n                : String.prototype.padStart\n            return padder.call(x, colWidths[colIndex])\n          })\n          .join(\"  \"),\n      )\n      .map((x) => x + \"\\n\")\n      .join(\"\") // join rows\n  }\n\n  row(rowIndex: int): Vector {\n    assertInts(rowIndex)\n    assert(\n      0 <= rowIndex && rowIndex < this.height,\n      \"rowIndex out of bounds \" + rowIndex,\n    )\n    const v = new Float64Array(this.width)\n    arrayCopy(this.m, rowIndex * this.width, v, 0, this.width)\n    return new Vector(v)\n  }\n\n  col(colIndex: int): Vector {\n    assertInts(colIndex)\n    assert(\n      0 <= colIndex && colIndex < this.width,\n      \"colIndex out of bounds \" + colIndex,\n    )\n    const v = new Float64Array(this.height)\n    arrayCopyStep(this.m, colIndex, this.width, v, 0, 1, this.height)\n    return new Vector(v)\n  }\n\n  dim(): { width: int; height: int } {\n    return { width: this.width, height: this.height }\n  }\n\n  dimString(): string {\n    return this.width + \"x\" + this.height\n  }\n\n  equals(obj: any): boolean {\n    if (obj.constructor != this.constructor) return false\n    if (this.width != obj.width || this.height != obj.height) return false\n    let elIndex = this.m.length\n    while (elIndex--) {\n      if (this.m[elIndex] != obj.m[elIndex]) return false\n    }\n    return true\n  }\n\n  equalsMatrix(matrix: Matrix, precision: number = NLA_PRECISION): boolean {\n    assertInst(Matrix, matrix)\n    if (this.width != matrix.width || this.height != matrix.height) return false\n    let elIndex = this.m.length\n    while (elIndex--) {\n      if (Math.abs(this.m[elIndex] - matrix.m[elIndex]) > precision)\n        return false\n    }\n    return true\n  }\n\n  hashCode(): int {\n    let result = 0\n    let elIndex = this.m.length\n    while (elIndex--) {\n      result = result * 31 + floatHashCode(this.m[elIndex])\n    }\n    return result\n  }\n\n  // todo rename\n  isZero(): boolean {\n    let elIndex = this.m.length\n    while (elIndex--) {\n      if (!eq0(this.m[elIndex])) {\n        return false\n      }\n    }\n    return true\n  }\n\n  isOrthogonal(): boolean {\n    return (\n      this.isSquare() &&\n      this.transposed().times(this).equalsMatrix(Matrix.identityN(this.width))\n    )\n  }\n\n  /** Returns L, U, P such that L * U == P * this */\n  luDecomposition(): { L: Matrix; U: Matrix; P: Matrix } {\n    const width = this.width\n    const height = this.height\n    const uRowArrays = this.asRowArrays(Float64Array)\n    const lRowArrays = arrayFromFunction(height, () => new Float64Array(height))\n    const pRowArrays = Matrix.identityN(height).asRowArrays(Float64Array)\n    let currentRowIndex = 0\n    for (let colIndex = 0; colIndex < width; colIndex++) {\n      currentRowIndex = colIndex\n      // console.log('currentRowIndex', currentRowIndex)\t// find largest value in colIndex\n      let maxAbsValue = 0,\n        pivotRowIndex = -1,\n        numberOfNonZeroRows = 0\n      for (let rowIndex = currentRowIndex; rowIndex < height; rowIndex++) {\n        const el = uRowArrays[rowIndex][colIndex]\n        numberOfNonZeroRows += +(0 != el)\n        if (Math.abs(el) > maxAbsValue) {\n          maxAbsValue = Math.abs(el)\n          pivotRowIndex = rowIndex\n        }\n      }\n      // TODO: check with isZero\n      if (0 == maxAbsValue) {\n        // column contains only zeros\n        continue\n      }\n      assert(-1 !== pivotRowIndex)\n      // swap rows\n      arraySwap(uRowArrays, currentRowIndex, pivotRowIndex)\n      arraySwap(lRowArrays, currentRowIndex, pivotRowIndex)\n      arraySwap(pRowArrays, currentRowIndex, pivotRowIndex)\n      lRowArrays[currentRowIndex][colIndex] = 1\n\n      if (1 < numberOfNonZeroRows) {\n        // subtract pivot (now current) row from all below it\n        for (\n          let rowIndex = currentRowIndex + 1;\n          rowIndex < height;\n          rowIndex++\n        ) {\n          const l =\n            uRowArrays[rowIndex][colIndex] /\n            uRowArrays[currentRowIndex][colIndex]\n          lRowArrays[rowIndex][colIndex] = l\n          // subtract pivot row * l from row 'rowIndex'\n          for (let colIndex2 = colIndex; colIndex2 < width; colIndex2++) {\n            uRowArrays[rowIndex][colIndex2] -=\n              l * uRowArrays[currentRowIndex][colIndex2]\n          }\n        }\n      }\n      //  currentRowIndex++ // this doesn't increase if pivot was zero\n    }\n    return {\n      L: Matrix.fromRowArrays(...lRowArrays),\n      U: Matrix.fromRowArrays(...uRowArrays),\n      P: Matrix.fromRowArrays(...pRowArrays),\n    }\n  }\n\n  qrDecompositionGivensRotation(): { Q: Matrix; R: Matrix } {\n    // function sigma(c: number, s: number) {\n    // \tif (0 == c) {\n    // \t\treturn 1\n    // \t}\n    // \tif (Math.abs(s) < Math.abs(c)) {\n    // \t\treturn 0.5 * Math.sign(c) * s\n    // \t}\n    // \treturn (2 * Math.sign(s)) / c\n    // }\n    const R = this.copy()\n\n    function matrixForCS(dim: int, i: int, k: int, c: number, s: number) {\n      const m = Matrix.identityN(dim)\n      m.setEl(i, i, c)\n      m.setEl(k, k, c)\n      m.setEl(i, k, s)\n      m.setEl(k, i, -s)\n      return m\n    }\n\n    let qTransposed = Matrix.identityN(this.height)\n    for (let colIndex = 0; colIndex < this.width; colIndex++) {\n      // find largest value in colIndex\n      for (let rowIndex = colIndex + 1; rowIndex < this.height; rowIndex++) {\n        //console.log('row ', rowIndex, 'col ', colIndex)\n        const xi = R.e(colIndex, colIndex)\n        const xk = R.e(rowIndex, colIndex)\n        if (xk == 0) {\n          continue\n        }\n        const r = Math.hypot(xi, xk)\n        const c = xi / r\n        const s = xk / r\n\n        // apply transformation on every column:\n        for (let col2 = colIndex; col2 < this.width; col2++) {\n          const x1 = R.e(colIndex, col2) * c + R.e(rowIndex, col2) * s\n          const x2 = R.e(rowIndex, col2) * c - R.e(colIndex, col2) * s\n          R.setEl(colIndex, col2, x1)\n          R.setEl(rowIndex, col2, x2)\n        }\n        //console.log('r ', r, 'c ', c, 's ', s, 'sigma', sigma(c, s))\n        //console.log(this.toString(),'cs\\n', matrixForCS(this.height, colIndex, rowIndex, c, s).toString())\n        qTransposed = matrixForCS(this.height, colIndex, rowIndex, c, s).times(\n          qTransposed,\n        )\n      }\n    }\n    //console.log(qTransposed.transposed().toString(), this.toString(),\n    // qTransposed.transposed().times(this).toString())\n    return { Q: qTransposed.transposed(), R }\n  }\n\n  isPermutation(): boolean {\n    if (!this.isSquare()) return false\n    if (this.m.some((value) => !eq0(value) && !eq(1, value))) return false\n\n    const rows = this.asRowArrays(Array)\n    if (\n      rows.some(\n        (row) => (row as number[]).filter((value) => eq(1, value)).length != 1,\n      )\n    )\n      return false\n\n    const cols = this.asColArrays(Array)\n    return !cols.some(\n      (col) => (col as number[]).filter((value) => eq(1, value)).length != 1,\n    )\n  }\n\n  isDiagonal(precision?: number): boolean {\n    let i = this.m.length\n    while (i--) {\n      if (0 !== i % (this.width + 1) && !eq0(this.m[i], precision)) return false\n    }\n    return true\n  }\n\n  isIdentity(precision?: number): boolean {\n    return (\n      this.isLowerUnitriangular(precision) && this.isUpperTriangular(precision)\n    )\n  }\n\n  /**\n   * @example\n   *   Matrix.fromRowArrays(\n   *     [1, 2, 3], //\n   *     [0, 4, 5],\n   *     [0, 0, 5],\n   *   ).isUpperTriangular() // true\n   *\n   * @param precision {@link eq}\n   */\n  isUpperTriangular(precision?: number) {\n    return this.isSquare() && this.isUpperTrapezoidal(precision)\n  }\n\n  isUpperTrapezoidal(precision: number = NLA_PRECISION) {\n    for (let rowIndex = 1; rowIndex < this.height; rowIndex++) {\n      for (let colIndex = 0; colIndex < rowIndex; colIndex++) {\n        if (!eq0(this.m[rowIndex * this.width + colIndex], precision)) {\n          return false\n        }\n      }\n    }\n    return true\n  }\n\n  isSymmetric(precision = NLA_PRECISION) {\n    if (!this.isSquare()) return false\n    for (let rowIndex = 0; rowIndex < this.height - 1; rowIndex++) {\n      for (let colIndex = rowIndex + 1; colIndex < this.width; colIndex++) {\n        const a = this.m[rowIndex * this.width + colIndex]\n        const b = this.m[colIndex * this.width + rowIndex]\n        if (!eq(a, b, precision)) {\n          return false\n        }\n      }\n    }\n    return true\n  }\n\n  /**\n   * Returns x, so that this * x = b More efficient than calculating the inverse\n   * for few (~ <= this.height) values\n   */\n  solveLinearSystem(b: Vector): Vector {\n    assertInst(Vector, b)\n    const { L, U, P } = this.luDecomposition()\n    const y = L.solveForwards(P.timesVector(b))\n    return U.solveBackwards(y)\n  }\n\n  isLowerUnitriangular(precision: number = NLA_PRECISION): boolean {\n    if (!this.isSquare()) return false\n    for (let rowIndex = 0; rowIndex < this.height - 1; rowIndex++) {\n      for (let colIndex = rowIndex; colIndex < this.width; colIndex++) {\n        const el = this.m[rowIndex * this.width + colIndex]\n        if (\n          rowIndex == colIndex ? !eq(1, el, precision) : !eq0(el, precision)\n        ) {\n          return false\n        }\n      }\n    }\n    return true\n  }\n\n  isLowerTriangular(precision?: number): boolean {\n    return this.isSquare() && this.isLowerTrapezoidal(precision)\n  }\n\n  isLowerTrapezoidal(precision: number = NLA_PRECISION): boolean {\n    for (let rowIndex = 0; rowIndex < this.height - 1; rowIndex++) {\n      for (let colIndex = rowIndex + 1; colIndex < this.width; colIndex++) {\n        if (!eq0(this.m[rowIndex * this.width + colIndex], precision)) {\n          return false\n        }\n      }\n    }\n    return true\n  }\n\n  solveBackwards(x: Vector): Vector {\n    assertVectors(x)\n    assert(this.height == x.dim(), \"this.height == x.dim()\")\n    assert(\n      this.isUpperTriangular(),\n      \"this.isUpperTriangular()\\n\" + this.toString(),\n    )\n    const v = new Float64Array(this.width)\n    let rowIndex = this.height\n    while (rowIndex--) {\n      let temp = x.v[rowIndex]\n      for (let colIndex = rowIndex + 1; colIndex < this.width; colIndex++) {\n        temp -= v[colIndex] * this.e(rowIndex, colIndex)\n      }\n      v[rowIndex] = temp / this.e(rowIndex, rowIndex)\n    }\n    return new Vector(v)\n  }\n\n  solveBackwardsMatrix(matrix: Matrix): Matrix {\n    const colVectors = new Array(matrix.width)\n    let i = matrix.width\n    while (i--) {\n      colVectors[i] = this.solveBackwards(matrix.col(i))\n    }\n    return Matrix.fromColVectors(colVectors)\n  }\n\n  solveForwardsMatrix(matrix: Matrix): Matrix {\n    const colVectors = new Array(matrix.width)\n    let i = matrix.width\n    while (i--) {\n      colVectors[i] = this.solveForwards(matrix.col(i))\n    }\n    return Matrix.fromColVectors(colVectors)\n  }\n\n  solveForwards(x: Vector): Vector {\n    assertVectors(x)\n    assert(this.height == x.dim(), \"this.height == x.dim()\")\n    assertf(() => this.isLowerTriangular(), this.toString())\n    const v = new Float64Array(this.width)\n    for (let rowIndex = 0; rowIndex < this.height; rowIndex++) {\n      let temp = x.v[rowIndex]\n      for (let colIndex = 0; colIndex < rowIndex; colIndex++) {\n        temp -= v[colIndex] * this.e(rowIndex, colIndex)\n      }\n      v[rowIndex] = temp / this.e(rowIndex, rowIndex)\n    }\n    return new Vector(v)\n  }\n\n  /**\n   * Calculates rank of matrix. Number of linearly independant row/column\n   * vectors. Is equal to the unmber of dimensions the image of the affine\n   * transformation represented this matrix has.\n   */\n  rank(): int {\n    const U = this.luDecomposition().U\n    let rowIndex = this.height\n    let rank = this.height\n    while (rowIndex--) {\n      rank -= +U.row(rowIndex).isZero()\n    }\n    return rank\n  }\n\n  rowsIndependent(): boolean {\n    return this.height == this.rank()\n  }\n\n  colsIndependent(): boolean {\n    return this.width == this.rank()\n  }\n\n  asRowArrays<T extends FloatArray>(\n    arrayConstructor: new (length: int) => T = Float64Array as any,\n  ): T[] {\n    return arrayFromFunction(this.height, (rowIndex) =>\n      this.rowArray(rowIndex, arrayConstructor),\n    )\n  }\n\n  asColArrays<T extends FloatArray>(\n    arrayConstructor: new (length: int) => T = Float64Array as any,\n  ): T[] {\n    return arrayFromFunction(this.width, (colIndex) =>\n      this.colArray(colIndex, arrayConstructor),\n    )\n  }\n\n  rowArray<T extends FloatArray>(\n    rowIndex: int,\n    arrayConstructor: new (length: int) => T = Float64Array as any,\n  ): T {\n    const result = new arrayConstructor(this.width)\n    return arrayCopy(this.m, rowIndex * this.width, result, 0, this.width)\n  }\n\n  colArray<T extends FloatArray>(\n    colIndex: int,\n    arrayConstructor: new (length: int) => T = Float64Array as any,\n  ): T {\n    const result = new arrayConstructor(this.width)\n    arrayCopyStep(this.m, colIndex, this.height, result, 0, 1, this.height)\n    return result\n  }\n\n  subMatrix(\n    firstColIndex: int,\n    subWidth: int,\n    firstRowIndex: int,\n    subHeight: int,\n  ): Matrix {\n    assert(\n      0 < firstColIndex && 0 < subWidth && 0 < firstRowIndex && 0 < subHeight,\n    )\n    assert(\n      firstColIndex + subWidth <= this.width &&\n        firstRowIndex + subHeight <= this.height,\n    )\n    const m = new Float64Array(subWidth * subHeight)\n    arrayCopyBlocks(\n      this.m,\n      firstColIndex,\n      this.width,\n      m,\n      0,\n      subWidth,\n      subHeight,\n      subWidth,\n    )\n    return new Matrix(subWidth, subHeight, m)\n  }\n\n  map(\n    fn: (el: number, elIndex: number, array: Float64Array) => number,\n  ): Matrix {\n    return new Matrix(this.width, this.height, this.m.map(fn))\n  }\n\n  dimEquals(matrix: Matrix): boolean {\n    assertInst(Matrix, matrix)\n    return this.width == matrix.width && this.height == matrix.height\n  }\n\n  inversed(): Matrix {\n    if (this.isSquare()) {\n      if (2 == this.width) return this.inversed2()\n      if (3 == this.width) return this.inversed3()\n      if (4 == this.width) return this.inversed4()\n    }\n    const { L, U, P } = this.luDecomposition()\n    const y = L.solveForwardsMatrix(P)\n    return U.solveBackwardsMatrix(y)\n  }\n\n  inversed2(): Matrix {\n    assertf(() => 2 == this.width && 2 == this.height)\n    const result = Matrix.forWidthHeight(2, 2),\n      m = this.m,\n      r = result.m\n\n    const det = m[0] * m[3] - m[1] * r[2]\n\n    r[0] = m[3] / det\n    r[1] = -m[2] / det\n\n    r[2] = -m[1] / det\n    r[3] = m[0] / det\n\n    return result\n  }\n\n  inversed3(result = Matrix.forWidthHeight(3, 3)): Matrix {\n    assertInst(Matrix, result)\n    assertf(() => 3 == this.width && 3 == this.height)\n    assertf(() => 3 == result.width && 3 == result.height)\n    assert(() => this != result)\n    const m = this.m,\n      r = result.m\n\n    r[0] = m[4] * m[8] - m[5] * m[7]\n    r[1] = -m[1] * m[8] + m[2] * m[7]\n    r[2] = m[1] * m[5] - m[2] * m[4]\n\n    r[3] = -m[3] * m[8] + m[5] * m[6]\n    r[4] = m[0] * m[8] - m[2] * m[6]\n    r[5] = -m[0] * m[5] + m[2] * m[3]\n\n    r[6] = m[3] * m[7] - m[4] * m[6]\n    r[7] = -m[0] * m[7] + m[1] * m[6]\n    r[8] = m[0] * m[4] - m[1] * m[3]\n\n    const det = m[0] * r[0] + m[1] * r[3] + m[2] * r[6]\n    let i = 9\n    while (i--) {\n      r[i] /= det\n    }\n\n    return result\n  }\n\n  // prettier-ignore\n  inversed4(result: Matrix = Matrix.forWidthHeight(4, 4)): Matrix {\n    assertInst(Matrix, result)\n    assertf(() => 4 == this.width && 4 == this.height)\n    assertf(() => 4 == result.width && 4 == result.height)\n    assert(() => this != result)\n    const m = this.m,\n      r = result.m\n\n    // first compute transposed cofactor matrix:\n    // cofactor of an element is the determinant of the 3x3 matrix gained by removing the column and row belonging\n    // to the element\n    r[0] = m[5] * m[10] * m[15] - m[5] * m[14] * m[11] - m[6] * m[9] * m[15]\n      + m[6] * m[13] * m[11] + m[7] * m[9] * m[14] - m[7] * m[13] * m[10]\n    r[1] = -m[1] * m[10] * m[15] + m[1] * m[14] * m[11] + m[2] * m[9] * m[15]\n      - m[2] * m[13] * m[11] - m[3] * m[9] * m[14] + m[3] * m[13] * m[10]\n    r[2] = m[1] * m[6] * m[15] - m[1] * m[14] * m[7] - m[2] * m[5] * m[15]\n      + m[2] * m[13] * m[7] + m[3] * m[5] * m[14] - m[3] * m[13] * m[6]\n    r[3] = -m[1] * m[6] * m[11] + m[1] * m[10] * m[7] + m[2] * m[5] * m[11]\n      - m[2] * m[9] * m[7] - m[3] * m[5] * m[10] + m[3] * m[9] * m[6]\n\n\n    r[4] = -m[4] * m[10] * m[15] + m[4] * m[14] * m[11] + m[6] * m[8] * m[15]\n      - m[6] * m[12] * m[11] - m[7] * m[8] * m[14] + m[7] * m[12] * m[10]\n    r[5] = m[0] * m[10] * m[15] - m[0] * m[14] * m[11] - m[2] * m[8] * m[15]\n      + m[2] * m[12] * m[11] + m[3] * m[8] * m[14] - m[3] * m[12] * m[10]\n    r[6] = -m[0] * m[6] * m[15] + m[0] * m[14] * m[7] + m[2] * m[4] * m[15]\n      - m[2] * m[12] * m[7] - m[3] * m[4] * m[14] + m[3] * m[12] * m[6]\n    r[7] = m[0] * m[6] * m[11] - m[0] * m[10] * m[7] - m[2] * m[4] * m[11]\n      + m[2] * m[8] * m[7] + m[3] * m[4] * m[10] - m[3] * m[8] * m[6]\n\n\n    r[8] = m[4] * m[9] * m[15] - m[4] * m[13] * m[11] - m[5] * m[8] * m[15]\n      + m[5] * m[12] * m[11] + m[7] * m[8] * m[13] - m[7] * m[12] * m[9]\n    r[9] = -m[0] * m[9] * m[15] + m[0] * m[13] * m[11] + m[1] * m[8] * m[15]\n      - m[1] * m[12] * m[11] - m[3] * m[8] * m[13] + m[3] * m[12] * m[9]\n    r[10] = m[0] * m[5] * m[15] - m[0] * m[13] * m[7] - m[1] * m[4] * m[15]\n      + m[1] * m[12] * m[7] + m[3] * m[4] * m[13] - m[3] * m[12] * m[5]\n    r[11] = -m[0] * m[5] * m[11] + m[0] * m[9] * m[7] + m[1] * m[4] * m[11]\n      - m[1] * m[8] * m[7] - m[3] * m[4] * m[9] + m[3] * m[8] * m[5]\n\n\n    r[12] = -m[4] * m[9] * m[14] + m[4] * m[13] * m[10] + m[5] * m[8] * m[14]\n      - m[5] * m[12] * m[10] - m[6] * m[8] * m[13] + m[6] * m[12] * m[9]\n    r[13] = m[0] * m[9] * m[14] - m[0] * m[13] * m[10] - m[1] * m[8] * m[14]\n      + m[1] * m[12] * m[10] + m[2] * m[8] * m[13] - m[2] * m[12] * m[9]\n    r[14] = -m[0] * m[5] * m[14] + m[0] * m[13] * m[6] + m[1] * m[4] * m[14]\n      - m[1] * m[12] * m[6] - m[2] * m[4] * m[13] + m[2] * m[12] * m[5]\n    r[15] = m[0] * m[5] * m[10] - m[0] * m[9] * m[6] - m[1] * m[4] * m[10]\n      + m[1] * m[8] * m[6] + m[2] * m[4] * m[9] - m[2] * m[8] * m[5]\n\n    // calculate determinant using laplace expansion (cf https://en.wikipedia.org/wiki/Laplace_expansion),\n    // as we already have the cofactors. We multiply a column by a row as the cofactor matrix is transposed.\n    const det = m[0] * r[0] + m[1] * r[4] + m[2] * r[8] + m[3] * r[12]\n    // assert(!isZero(det), 'det may not be zero, i.e. the matrix is not invertible')\n    let i = 16\n    while (i--) {\n      r[i] /= det\n    }\n    return result\n  }\n\n  canMultiply(matrix: Matrix): boolean {\n    assertInst(Matrix, matrix)\n    return this.width == matrix.height\n  }\n\n  times(matrix: Matrix): Matrix {\n    assertInst(Matrix, matrix)\n    assert(\n      this.canMultiply(matrix),\n      `Cannot multiply this ${this.dimString()} by matrix ${matrix.dimString()}`,\n    )\n    const nWidth = matrix.width,\n      nHeight = this.height,\n      n = this.width\n    const nM = new Float64Array(nWidth * nHeight)\n    let nRowIndex = nHeight\n    while (nRowIndex--) {\n      let nColIndex = nWidth\n      while (nColIndex--) {\n        let result = 0\n        let i = n\n        while (i--) {\n          result += this.m[nRowIndex * n + i] * matrix.m[i * nWidth + nColIndex]\n        }\n        nM[nRowIndex * nWidth + nColIndex] = result\n      }\n    }\n    return new Matrix(nWidth, nHeight, nM)\n  }\n\n  timesVector(v: Vector): Vector {\n    assertVectors(v)\n    assert(this.width == v.dim())\n    const nHeight = this.height,\n      n = this.width\n    const nM = new Float64Array(nHeight)\n    let nRowIndex = nHeight\n    while (nRowIndex--) {\n      let result = 0\n      let i = n\n      while (i--) {\n        result += this.m[nRowIndex * n + i] * v.v[i]\n      }\n      nM[nRowIndex] = result\n    }\n    return new Vector(nM)\n  }\n\n  transposed(): Matrix {\n    const tWidth = this.height,\n      tHeight = this.width\n    const tM = new Float64Array(tWidth * tHeight)\n    let tRowIndex = tHeight\n    while (tRowIndex--) {\n      let tColIndex = tWidth\n      while (tColIndex--) {\n        tM[tRowIndex * tWidth + tColIndex] = this.m[\n          tColIndex * tHeight + tRowIndex\n        ]\n      }\n    }\n    return new Matrix(tWidth, tHeight, tM)\n  }\n\n  /** In-place transpose. */\n  transpose(): void {\n    const h = this.height,\n      w = this.width,\n      tM = this.m\n    let tRowIndex = h\n    while (tRowIndex--) {\n      let tColIndex = Math.min(tRowIndex, w)\n      while (tColIndex--) {\n        const temp = tM[tRowIndex * w + tColIndex]\n        tM[tRowIndex * w + tColIndex] = tM[tColIndex * h + tRowIndex]\n        tM[tColIndex * h + tRowIndex] = temp\n      }\n    }\n    this.width = h\n    this.height = w\n  }\n\n  isSquare(): boolean {\n    return this.height == this.width\n  }\n\n  diagonal(): Vector {\n    if (!this.isSquare()) {\n      throw new Error(\"!!\")\n    }\n    const v = new Float64Array(this.width)\n    let elIndex = this.width * (this.width + 1)\n    let vIndex = this.width\n    while (vIndex--) {\n      elIndex -= this.width + 1\n      v[vIndex] = this.m[elIndex]\n    }\n    return new Vector(v)\n  }\n\n  maxEl(): number {\n    return max(this.m)\n  }\n\n  minEl(): number {\n    return min(this.m)\n  }\n\n  //noinspection DuplicatedCode\n  maxAbsColSum(): number {\n    let result = 0\n    let colIndex = this.width\n    while (colIndex--) {\n      let absSum = 0\n      let rowIndex = this.height\n      while (rowIndex--) {\n        absSum += Math.abs(this.m[rowIndex * this.width + colIndex])\n      }\n      result = Math.max(result, absSum)\n    }\n    return result\n  }\n\n  //noinspection DuplicatedCode\n  maxAbsRowSum(): number {\n    let result = 0\n    let rowIndex = this.height\n    while (rowIndex--) {\n      let absSum = 0\n      let colIndex = this.width\n      while (colIndex--) {\n        absSum += Math.abs(this.m[rowIndex * this.width + colIndex])\n      }\n      result = Math.max(result, absSum)\n    }\n    return result\n  }\n\n  getTriangularDeterminant(): number {\n    assert(\n      this.isUpperTriangular() || this.isLowerTriangular(),\n      \"not a triangular matrix\",\n    )\n\n    let product = 1\n    let elIndex = this.width * (this.width + 1)\n    while (elIndex) {\n      elIndex -= this.width + 1\n      product *= this.m[elIndex]\n    }\n    return product\n  }\n\n  /**\n   * Calculates the determinant by first calculating the LU decomposition. If\n   * you already have that, use U.getTriangularDeterminant()\n   */\n  getDeterminant(): number {\n    // PA = LU\n    // det(A) * det(B) = det(A * B)\n    // det(P) == 1 (permutation matrix)\n    // det(L) == 1 (main diagonal is 1s\n    // =>  det(A) == det(U)\n    return this.luDecomposition().U.getTriangularDeterminant()\n  }\n\n  hasFullRank(): boolean {\n    return Math.min(this.width, this.height) == this.rank()\n  }\n\n  permutationAsIndexMap(): int[] {\n    assertf(() => this.isPermutation())\n    const result = new Array(this.height)\n    let i = this.height\n    while (i--) {\n      const searchIndexStart = i * this.width\n      let searchIndex = searchIndexStart\n      while (this.m[searchIndex] < 0.5) searchIndex++\n      result[i] = searchIndex - searchIndexStart\n    }\n    return result\n  }\n\n  getDependentRowIndexes(\n    gauss: { L: Matrix; U: Matrix; P: Matrix } = this.luDecomposition(),\n  ): int[] {\n    const { L, U, P } = gauss\n    // rows which end up as zero vectors in U are not linearly independent\n    const dependents = new Array(this.height)\n    let uRowIndex = this.height\n    while (uRowIndex--) {\n      const uRow = U.row(uRowIndex)\n      if (uRow.length() < NLA_PRECISION) {\n        dependents[uRowIndex] = true\n      } else {\n        break\n      }\n    }\n    // figure out from which other rows the rows which end up as zero vectors are created by\n    let lRowIndex = this.height\n    while (lRowIndex--) {\n      if (dependents[lRowIndex]) {\n        let lColIndex = Math.min(lRowIndex, this.width)\n        while (lColIndex--) {\n          if (0 !== L.e(lRowIndex, lColIndex)) {\n            dependents[lColIndex] = true\n          }\n        }\n      }\n    }\n    console.log(\n      \"m\\n\",\n      this.toString((x) => \"\" + x),\n    )\n    console.log(\n      \"L\\n\",\n      L.toString((x) => \"\" + x),\n    )\n    console.log(\n      \"U\\n\",\n      U.toString((x) => \"\" + x),\n    )\n    console.log(\n      \"P\\n\",\n      P.toString((x) => \"\" + x),\n    )\n    // gauss algorithm permutes the order of the rows, so map our results back to the original indices\n    const indexMap = P.permutationAsIndexMap()\n    return dependents\n      .map((b, index) => b && indexMap[index])\n      .filter((x) => x != undefined)\n  }\n\n  lerp(b: Matrix, t: number, result = this.new()): this {\n    assertInst(Matrix, b, result)\n    assertNumbers(t)\n    assert(this.width == b.width && this.height == b.height)\n    const s = 1 - t\n    let i = this.m.length\n    while (i--) {\n      result.m[i] = s * this.m[i] + t * b.m[i]\n    }\n    return result\n  }\n}\n","import { JavaMap } from \"javasetmap.ts\"\n\nimport {\n  addOwnProperties,\n  arrayFromFunction,\n  assert,\n  assertf,\n  assertInst,\n  assertInts,\n  assertNumbers,\n  assertVectors,\n  callSource,\n  concatenated,\n  DEG,\n  eq,\n  eq0,\n  getLast,\n  int,\n  Matrix,\n  max,\n  NLA_PRECISION,\n  raddd,\n  sliceStep,\n  solveCubicReal2,\n  Transformable,\n  V3,\n  VV,\n} from \".\"\n\nconst { PI, abs } = Math\n\n// tslint:enable:member-ordering\nexport class M4 extends Matrix {\n  /**\n   * A simple (consists of integers), regular, non-orthogonal matrix, useful\n   * mainly for testing. M4.FOO_INV = M4.FOO.inverse()\n   */\n  // prettier-ignore\n  static readonly FOO = new M4(\n    0,   1,   1,    2,\n    0.3, 0.4, 0.8, 13,\n    2.1, 3.4, 5.5,  8.9,\n    0,   0,   0,    1,\n  )\n  static readonly FOO_INV = M4.FOO.inversed()\n  static readonly IDENTITY = M4.identity()\n  // prettier-ignore\n  static readonly O = new M4(\n    0, 0, 0, 0,\n    0, 0, 0, 0,\n    0, 0, 0, 0,\n    0, 0, 0, 0,\n  )\n  static readonly YZX = M4.forSys(V3.Y, V3.Z, V3.X)\n  static readonly ZXY = M4.forSys(V3.Z, V3.X, V3.Y)\n  // prettier-ignore\n  static IDENTITY3 = new M4(\n    1, 0, 0, 0,\n    0, 1, 0, 0,\n    0, 0, 1, 0,\n    0, 0, 0, 0,\n  )\n  static readonly temp0 = new M4()\n  static readonly temp1 = new M4()\n  static readonly temp2 = new M4()\n\n  static readonly NAMEMAP = new JavaMap<M4, string>()\n    .set(M4.IDENTITY3, \"M4.IDENTITY3\")\n    .set(M4.FOO, \"M4.FOO\")\n    .set(M4.O, \"M4.O\")\n    .set(M4.FOO_INV, \"M4.FOO_INV\")\n    .set(M4.IDENTITY, \"M4.IDENTITY\")\n    .set(M4.ZXY, \"M4.ZXY\")\n    .set(M4.YZX, \"M4.YZX\")\n\n  /**\n   * Takes 16 arguments in row-major order, which can be passed individually, as\n   * a list, or even as four lists, one for each row. If the arguments are\n   * omitted then the identity matrix is constructed instead.\n   *\n   *     ```\n   *     0 1 2 3\n   *     4 5 6 7\n   *     8 9 10 11\n   *     12 13 14 15\n   *     ```\n   */\n  constructor(...var_args: (number | number[])[]) {\n    let m\n    if (0 == var_args.length) {\n      m = new Float64Array(16)\n    } else {\n      const flattened = concatenated(var_args)\n      assert(\n        flattened.length == 16,\n        \"flattened.length == 16 \" + flattened.length,\n      )\n      m = new Float64Array(flattened)\n    }\n    super(4, 4, m)\n  }\n\n  /**\n   * Returns the matrix that when multiplied with `matrix` results in the\n   * identity matrix. You can optionally pass an existing matrix in `result` to\n   * avoid allocating a new matrix. This implementation is from the Mesa OpenGL\n   * function `__gluInvertMatrixd()` found in `project.c`.\n   */\n  static inverse(matrix: M4, result: M4 = new M4()): M4 {\n    return matrix.inversed4(result) as M4\n  }\n\n  /**\n   * Create new dim x dim matrix equal to an identity matrix with rows/colums i\n   * and k swapped. Note that i and k are 0-indexed.\n   */\n  static permutation4(i: int, k: int, result = new M4()): Matrix {\n    assertInts(i, k)\n    assertf(() => 0 <= i && i < 4)\n    assertf(() => 0 <= k && k < 4)\n    const m = result.m\n    M4.identity(result)\n    m[i * 4 + i] = 0\n    m[k * 4 + k] = 0\n    m[i * 4 + k] = 1\n    m[k * 4 + i] = 1\n    return result\n  }\n\n  /**\n   * Returns `matrix`, exchanging columns for rows. You can optionally pass an\n   * existing matrix in `result` to avoid allocating a new matrix.\n   */\n  static transpose(matrix: M4, result: M4 = new M4()): M4 {\n    assertInst(M4, matrix)\n    assertInst(M4, result)\n    assert(matrix != result, \"matrix != result\")\n    const m = matrix.m,\n      r = result.m\n    r[0] = m[0]\n    r[1] = m[4]\n    r[2] = m[8]\n    r[3] = m[12]\n    r[4] = m[1]\n    r[5] = m[5]\n    r[6] = m[9]\n    r[7] = m[13]\n    r[8] = m[2]\n    r[9] = m[6]\n    r[10] = m[10]\n    r[11] = m[14]\n    r[12] = m[3]\n    r[13] = m[7]\n    r[14] = m[11]\n    r[15] = m[15]\n    return result\n  }\n\n  /** Returns the concatenation of the transforms for `left` and `right`. */\n  static multiply(left: M4, right: M4, result: M4 = new M4()): M4 {\n    assertInst(M4, left, right)\n    assertInst(M4, result)\n    assert(left != result, \"left != result\")\n    assert(right != result, \"right != result\")\n    const a = left.m,\n      b = right.m,\n      r = result.m\n\n    r[0] = a[0] * b[0] + a[1] * b[4] + (a[2] * b[8] + a[3] * b[12])\n    r[1] = a[0] * b[1] + a[1] * b[5] + (a[2] * b[9] + a[3] * b[13])\n    r[2] = a[0] * b[2] + a[1] * b[6] + (a[2] * b[10] + a[3] * b[14])\n    r[3] = a[0] * b[3] + a[1] * b[7] + (a[2] * b[11] + a[3] * b[15])\n\n    r[4] = a[4] * b[0] + a[5] * b[4] + (a[6] * b[8] + a[7] * b[12])\n    r[5] = a[4] * b[1] + a[5] * b[5] + (a[6] * b[9] + a[7] * b[13])\n    r[6] = a[4] * b[2] + a[5] * b[6] + (a[6] * b[10] + a[7] * b[14])\n    r[7] = a[4] * b[3] + a[5] * b[7] + (a[6] * b[11] + a[7] * b[15])\n\n    r[8] = a[8] * b[0] + a[9] * b[4] + (a[10] * b[8] + a[11] * b[12])\n    r[9] = a[8] * b[1] + a[9] * b[5] + (a[10] * b[9] + a[11] * b[13])\n    r[10] = a[8] * b[2] + a[9] * b[6] + (a[10] * b[10] + a[11] * b[14])\n    r[11] = a[8] * b[3] + a[9] * b[7] + (a[10] * b[11] + a[11] * b[15])\n\n    r[12] = a[12] * b[0] + a[13] * b[4] + (a[14] * b[8] + a[15] * b[12])\n    r[13] = a[12] * b[1] + a[13] * b[5] + (a[14] * b[9] + a[15] * b[13])\n    r[14] = a[12] * b[2] + a[13] * b[6] + (a[14] * b[10] + a[15] * b[14])\n    r[15] = a[12] * b[3] + a[13] * b[7] + (a[14] * b[11] + a[15] * b[15])\n\n    return result\n  }\n\n  static product(...m4s: M4[]): M4\n  static product(m4s: M4[], result?: M4): M4\n  static product(...args: any[]): M4 {\n    const [m4s, result]: [M4[], M4] = Array.isArray(args[0])\n      ? [args[0], args[1]]\n      : [args, new M4()]\n    if (0 == m4s.length) return M4.identity(result)\n    if (1 == m4s.length) return M4.copy(m4s[0], result)\n    if (2 == m4s.length) return M4.multiply(m4s[0], m4s[1], result)\n    let a = M4.temp0,\n      b = M4.temp1\n    M4.multiply(m4s[0], m4s[1], a)\n    for (let i = 2; i < m4s.length - 1; i++) {\n      M4.multiply(a, m4s[i], b)\n      ;[a, b] = [b, a]\n    }\n    return M4.multiply(a, getLast(m4s), result)\n  }\n\n  static forSys(e0: V3, e1: V3, e2: V3 = e0.cross(e1), origin: V3 = V3.O): M4 {\n    assertVectors(e0, e1, e2, origin)\n    // prettier-ignore\n    return new M4(\n      e0.x, e1.x, e2.x, origin.x,\n      e0.y, e1.y, e2.y, origin.y,\n      e0.z, e1.z, e2.z, origin.z,\n      0, 0, 0, 1,\n    )\n  }\n\n  static forRows(n0: V3, n1: V3, n2: V3, n3: V3 = V3.O): M4 {\n    assertVectors(n0, n1, n2, n3)\n    // prettier-ignore\n    return new M4(\n      n0.x, n0.y, n0.z, 0,\n      n1.x, n1.y, n1.z, 0,\n      n2.x, n2.y, n2.z, 0,\n      n3.x, n3.y, n3.z, 1)\n  }\n\n  /**\n   * Returns an identity matrix. You can optionally pass an existing matrix in\n   * `result` to avoid allocating a new matrix. This emulates the OpenGL\n   * function `glLoadIdentity()`\n   *\n   * Unless initializing a matrix to be modified, use M4.IDENTITY\n   */\n  static identity(result: M4 = new M4()): M4 {\n    assertInst(M4, result)\n    const m = result.m\n    m[0] = m[5] = m[10] = m[15] = 1\n    m[1] = m[2] = m[3] = m[4] = m[6] = m[7] = m[8] = m[9] = m[11] = m[12] = m[13] = m[14] = 0\n\n    return result\n  }\n\n  /**\n   * Creates a new M4 initialized by a user defined callback function\n   *\n   * @param f Signature: (elRow, elCol, elIndex) =>\n   *     el, where elIndex is the row-major index, i.e. eLindex == elRow * 4 + elCol\n   * @param result\n   */\n  static fromFunction4(\n    f: (elRow: number, elCol: number, elIndex: number) => number,\n    result: M4 = new M4(),\n  ): M4 {\n    assert(typeof f == \"function\")\n    assertInst(M4, result)\n    const m = result.m\n    let i = 16\n    while (i--) {\n      m[i] = f(Math.floor(i / 4), i % 4, i)\n    }\n    return result\n  }\n\n  /**\n   * Returns a perspective transform matrix, which makes far away objects appear\n   * smaller than nearby objects. The `aspect` argument should be the width\n   * divided by the height of your viewport and `fov` is the top-to-bottom\n   * angle of the field of view in degrees. You can optionally pass an existing\n   * matrix in `result` to avoid allocating a new matrix. This emulates the\n   * OpenGL function `gluPerspective()`. {@see perspectiveRad} perspectiveRad\n   *\n   * @param fovDegrees In degrees\n   * @param aspect Aspect ratio = width/height of viewport\n   * @param near Near plane\n   * @param far Far plane\n   * @param result A new M4 as described.\n   */\n  static perspective(\n    fovDegrees: number,\n    aspect: number,\n    near: number,\n    far: number,\n    result: M4 = new M4(),\n  ): M4 {\n    return M4.perspectiveRad(fovDegrees * DEG, aspect, near, far, result)\n  }\n\n  static perspectiveRad(\n    fov: raddd,\n    aspect: number,\n    near: number,\n    far: number,\n    result: M4 = new M4(),\n  ): M4 {\n    assertInst(M4, result)\n    assertNumbers(fov, aspect, near, far)\n    const y = Math.tan(fov / 2) * near\n    const x = y * aspect\n    return M4.frustum(-x, x, -y, y, near, far, result)\n  }\n\n  static perspectivePlane(\n    vanishingPlane: { normal1: V3; w: number },\n    result: M4 = new M4(),\n  ) {\n    assertInst(M4, result)\n    const m = result.m\n    m[0] = 1\n    m[1] = 0\n    m[2] = 0\n    m[3] = 0\n\n    m[4] = 0\n    m[5] = 1\n    m[6] = 0\n    m[7] = 0\n\n    m[8] = 0\n    m[9] = 0\n    m[10] = 1\n    m[11] = 0\n\n    m[12] = vanishingPlane.normal1.x\n    m[13] = vanishingPlane.normal1.y\n    m[14] = vanishingPlane.normal1.z\n    m[15] = -vanishingPlane.w\n\n    return result\n  }\n\n  // the OpenGL function `glFrustum()`.\n  static frustum(\n    left: number,\n    right: number,\n    bottom: number,\n    top: number,\n    near: number,\n    far: number,\n    result: M4 = new M4(),\n  ): M4 {\n    assertNumbers(left, right, bottom, top, near, far)\n    assert(0 < near, \"0 < near\")\n    assert(near < far, \"near < far\")\n    assertInst(M4, result)\n    const m = result.m\n\n    m[0] = (2 * near) / (right - left)\n    m[1] = 0\n    m[2] = (right + left) / (right - left)\n    m[3] = 0\n\n    m[4] = 0\n    m[5] = (2 * near) / (top - bottom)\n    m[6] = (top + bottom) / (top - bottom)\n    m[7] = 0\n\n    m[8] = 0\n    m[9] = 0\n    m[10] = -(far + near) / (far - near)\n    m[11] = (-2 * far * near) / (far - near)\n\n    m[12] = 0\n    m[13] = 0\n    m[14] = -1\n    m[15] = 0\n\n    return result\n  }\n\n  /** Returns a new M4 representing the a projection through/towards a point onto a plane. */\n  static projectPlanePoint(\n    p: V3,\n    plane: { normal1: V3; w: number },\n    result: M4 = new M4(),\n  ): M4 {\n    assertVectors(p, plane.normal1)\n    assertInst(M4, result)\n    const m = result.m\n    const n = plane.normal1,\n      w = plane.w\n    const np = n.dot(p)\n\n    m[0] = p.x * n.x + w - np\n    m[1] = p.x * n.y\n    m[2] = p.x * n.z\n    m[3] = -w * p.x\n\n    m[4] = p.y * n.x\n    m[5] = p.y * n.y + w - np\n    m[6] = p.y * n.z\n    m[7] = -w * p.y\n\n    m[8] = p.z * n.x\n    m[9] = p.z * n.y\n    m[10] = p.z * n.z + w - np\n    m[11] = -w * p.z\n\n    m[12] = n.x\n    m[13] = n.y\n    m[14] = n.z\n    m[15] = -np\n\n    return result\n  }\n\n  /**\n   * Orthographic/orthogonal projection. Transforms the cuboid with the\n   * dimensions X: [left right] Y: [bottom, top] Z: [near far] to the cuboid X:\n   * [-1, 1] Y [-1, 1] Z [-1, 1]\n   */\n  static ortho(\n    left: number,\n    right: number,\n    bottom: number,\n    top: number,\n    near: number,\n    far: number,\n    result: M4 = new M4(),\n  ): M4 {\n    assertNumbers(left, right, bottom, top, near, far)\n    assertInst(M4, result)\n    const m = result.m\n\n    m[0] = 2 / (right - left)\n    m[1] = 0\n    m[2] = 0\n    m[3] = -(right + left) / (right - left)\n\n    m[4] = 0\n    m[5] = 2 / (top - bottom)\n    m[6] = 0\n    m[7] = -(top + bottom) / (top - bottom)\n\n    m[8] = 0\n    m[9] = 0\n    m[10] = -2 / (far - near)\n    m[11] = -(far + near) / (far - near)\n\n    m[12] = 0\n    m[13] = 0\n    m[14] = 0\n    m[15] = 1\n\n    return result\n  }\n\n  /**\n   * This emulates the OpenGL function `glScale()`. You can optionally pass an\n   * existing matrix in `result` to avoid allocating a new matrix.\n   */\n  static scale(x: number, y: number, z?: number, result?: M4): M4\n\n  static scale(scale: number, result?: M4): M4\n\n  static scale(v: V3, result?: M4): M4\n\n  static scale(...args: any[]): M4 {\n    let x: number, y: number, z: number, result: M4\n    if (args[0] instanceof V3) {\n      assert(args.length <= 2)\n      ;({ x, y, z } = args[0])\n      result = args[1]\n    } else if (\"number\" != typeof args[1]) {\n      x = y = z = args[0]\n      result = args[1]\n    } else {\n      assert(args.length <= 4)\n      x = args[0]\n      y = args[1]\n      z = undefined != args[2] ? args[2] : 1\n      result = args[3]\n    }\n    undefined == result && (result = new M4())\n    assertInst(M4, result)\n    assertNumbers(x, y, z)\n\n    const m = result.m\n    m[0] = x\n    m[1] = 0\n    m[2] = 0\n    m[3] = 0\n\n    m[4] = 0\n    m[5] = y\n    m[6] = 0\n    m[7] = 0\n\n    m[8] = 0\n    m[9] = 0\n    m[10] = z\n    m[11] = 0\n\n    m[12] = 0\n    m[13] = 0\n    m[14] = 0\n    m[15] = 1\n\n    return result\n  }\n\n  /**\n   * This emulates the OpenGL function `glTranslate()`. You can optionally pass\n   * an existing matrix in `result` to avoid allocating a new matrix.\n   */\n  static translate(x: number, y?: number, z?: number, result?: M4): M4\n\n  static translate(v: V3, result?: M4): M4\n\n  static translate(...args: any[]): M4 {\n    let x, y, z, result\n    if (args[0] instanceof V3) {\n      assert(args.length <= 2)\n      ;({ x, y, z } = args[0])\n      result = args[1]\n    } else {\n      assert(args.length <= 4)\n      x = args[0]\n      y = undefined != args[1] ? args[1] : 0\n      z = undefined != args[2] ? args[2] : 0\n      result = args[3]\n    }\n    undefined == result && (result = new M4())\n    assertInst(M4, result)\n    assertNumbers(x, y, z)\n\n    const m = result.m\n\n    m[0] = 1\n    m[1] = 0\n    m[2] = 0\n    m[3] = x\n\n    m[4] = 0\n    m[5] = 1\n    m[6] = 0\n    m[7] = y\n\n    m[8] = 0\n    m[9] = 0\n    m[10] = 1\n    m[11] = z\n\n    m[12] = 0\n    m[13] = 0\n    m[14] = 0\n    m[15] = 1\n\n    return result\n  }\n\n  /**\n   * Returns a matrix that rotates by `a` degrees around the vector (x, y, z).\n   * You can optionally pass an existing matrix in `result` to avoid allocating\n   * a new matrix. This emulates the OpenGL function `glRotate()`.\n   */\n  //static rotation(radians: raddd, x: number, y: number, z: number, result?: M4): M4\n  static rotate(\n    radians: raddd,\n    v: { x: number; y: number; z: number },\n    result?: M4,\n  ): M4 {\n    undefined == result && (result = new M4())\n    assertInst(M4, result)\n    let { x, y, z } = v\n    assert(!new V3(x, y, z).likeO(), \"!V(x, y, z).likeO()\")\n    const m = result.m\n\n    const d = Math.sqrt(x * x + y * y + z * z)\n    x /= d\n    y /= d\n    z /= d\n    const cos = Math.cos(radians),\n      sin = Math.sin(radians),\n      t = 1 - cos\n\n    m[0] = x * x * t + cos\n    m[1] = x * y * t - z * sin\n    m[2] = x * z * t + y * sin\n    m[3] = 0\n\n    m[4] = y * x * t + z * sin\n    m[5] = y * y * t + cos\n    m[6] = y * z * t - x * sin\n    m[7] = 0\n\n    m[8] = z * x * t - y * sin\n    m[9] = z * y * t + x * sin\n    m[10] = z * z * t + cos\n    m[11] = 0\n\n    m[12] = 0\n    m[13] = 0\n    m[14] = 0\n    m[15] = 1\n\n    return result\n  }\n\n  /**\n   * Returns a matrix that puts the camera at the eye point `ex, ey, ez` looking\n   * toward the center point `cx, cy, cz` with an up direction of `ux, uy, uz`.\n   * You can optionally pass an existing matrix in `result` to avoid allocating\n   * a new matrix. This emulates the OpenGL function `gluLookAt()`.\n   */\n  static lookAt(eye: V3, focus: V3, up: V3, result: M4 = new M4()): M4 {\n    assertVectors(eye, focus, up)\n    assertInst(M4, result)\n\n    const m = result.m\n\n    const f = eye.minus(focus).unit()\n    const s = up.cross(f).unit()\n    const t = f.cross(s).unit()\n\n    m[0] = s.x\n    m[1] = s.y\n    m[2] = s.z\n    m[3] = -s.dot(eye)\n\n    m[4] = t.x\n    m[5] = t.y\n    m[6] = t.z\n    m[7] = -t.dot(eye)\n\n    m[8] = f.x\n    m[9] = f.y\n    m[10] = f.z\n    m[11] = -f.dot(eye)\n\n    m[12] = 0\n    m[13] = 0\n    m[14] = 0\n    m[15] = 1\n\n    return result\n  }\n\n  /** Create a rotation matrix for rotating around the X axis */\n  static rotateX(radians: raddd): M4 {\n    assertNumbers(radians)\n    const sin = Math.sin(radians),\n      cos = Math.cos(radians)\n    const els = [1, 0, 0, 0, 0, cos, -sin, 0, 0, sin, cos, 0, 0, 0, 0, 1]\n    return new M4(els)\n  }\n\n  /** Create a rotation matrix for rotating around the Y axis */\n  static rotateY(radians: raddd): M4 {\n    const sin = Math.sin(radians),\n      cos = Math.cos(radians)\n    const els = [cos, 0, sin, 0, 0, 1, 0, 0, -sin, 0, cos, 0, 0, 0, 0, 1]\n    return new M4(els)\n  }\n\n  /** Create a rotation matrix for rotating around the Z axis */\n  static rotateZ(radians: raddd): M4 {\n    const sin = Math.sin(radians),\n      cos = Math.cos(radians)\n    const els = [cos, -sin, 0, 0, sin, cos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]\n    return new M4(els)\n  }\n\n  /**\n   * New rotation matrix such that result.transformVector(a).isParallelTo(b)\n   * through smallest rotation. Performs no scaling.\n   */\n  static rotateAB(a: V3, b: V3, result: M4 = new M4()): M4 {\n    // see http://inside.mines.edu/fs_home/gmurray/ArbitraryAxisRotation/\n    assertVectors(a, b)\n    assertInst(M4, result)\n    const rotationAxis = a.cross(b),\n      rotationAxisLength = rotationAxis.length()\n    if (eq0(rotationAxisLength)) {\n      return M4.identity(result)\n    }\n    const radians = Math.atan2(rotationAxisLength, a.dot(b))\n    return M4.rotateLine(V3.O, rotationAxis, radians, result)\n  }\n\n  /**\n   * Matrix for rotation about arbitrary line defined by an anchor point and\n   * direction. rotationAxis does not need to be unit\n   */\n  static rotateLine(\n    rotationAnchor: V3,\n    rotationAxis: V3,\n    radians: raddd,\n    result: M4 = new M4(),\n  ): M4 {\n    // see http://inside.mines.edu/fs_home/gmurray/ArbitraryAxisRotation/\n    assertVectors(rotationAnchor, rotationAxis)\n    assertNumbers(radians)\n    assertInst(M4, result)\n    rotationAxis = rotationAxis.unit()\n\n    const ax = rotationAnchor.x,\n      ay = rotationAnchor.y,\n      az = rotationAnchor.z,\n      dx = rotationAxis.x,\n      dy = rotationAxis.y,\n      dz = rotationAxis.z\n    const m = result.m,\n      cos = Math.cos(radians),\n      sin = Math.sin(radians)\n\n    m[0] = dx * dx + (dy * dy + dz * dz) * cos\n    m[1] = dx * dy * (1 - cos) - dz * sin\n    m[2] = dx * dz * (1 - cos) + dy * sin\n    m[3] =\n      (ax * (dy * dy + dz * dz) - dx * (ay * dy + az * dz)) * (1 - cos) +\n      (ay * dz - az * dy) * sin\n\n    m[4] = dx * dy * (1 - cos) + dz * sin\n    m[5] = dy * dy + (dx * dx + dz * dz) * cos\n    m[6] = dy * dz * (1 - cos) - dx * sin\n    m[7] =\n      (ay * (dx * dx + dz * dz) - dy * (ax * dx + az * dz)) * (1 - cos) +\n      (az * dx - ax * dz) * sin\n\n    m[8] = dx * dz * (1 - cos) - dy * sin\n    m[9] = dy * dz * (1 - cos) + dx * sin\n    m[10] = dz * dz + (dx * dx + dy * dy) * cos\n    m[11] =\n      (az * (dx * dx + dy * dy) - dz * (ax * dx + ay * dy)) * (1 - cos) +\n      (ax * dy - ay * dx) * sin\n\n    m[12] = 0\n    m[13] = 0\n    m[14] = 0\n    m[15] = 1\n\n    return result\n  }\n\n  /** Create an affine matrix for mirroring into an arbitrary plane: */\n  static mirror(plane: { normal1: V3; w: number }, result: M4 = new M4()): M4 {\n    assertVectors(plane.normal1)\n    assertInst(M4, result)\n    const [nx, ny, nz] = plane.normal1\n    const w = plane.w\n    const m = result.m\n\n    m[0] = 1.0 - 2.0 * nx * nx\n    m[1] = -2.0 * ny * nx\n    m[2] = -2.0 * nz * nx\n    m[3] = 2.0 * nx * w\n\n    m[4] = -2.0 * nx * ny\n    m[5] = 1.0 - 2.0 * ny * ny\n    m[6] = -2.0 * nz * ny\n    m[7] = 2.0 * ny * w\n\n    m[8] = -2.0 * nx * nz\n    m[9] = -2.0 * ny * nz\n    m[10] = 1.0 - 2.0 * nz * nz\n    m[11] = 2.0 * nz * w\n\n    m[12] = 0\n    m[13] = 0\n    m[14] = 0\n    m[15] = 1\n    return result\n  }\n\n  /**\n   * @param plane\n   * @param dir Projection direction. Optional, if not specified plane normal1\n   *     will be used.\n   * @param result {@see M4}\n   */\n  static project(\n    plane: { normal1: V3; w: number },\n    dir: V3 = plane.normal1,\n    result: M4 = new M4(),\n  ): M4 {\n    // TODO: doc\n\n    // plane.normal1 DOT (p + lambda * dir) = w (1)\n    // extract lambda:\n    // plane.normal1 DOT p + lambda * plane.normal1 DOT dir = w\n    // lambda = (w - plane.normal1 DOT p) / plane.normal1 DOT dir\n    // result = p + lambda * dir\n    // result = p + dir * (w - plane.normal1 DOT p) / plane.normal1 DOT dir\n    // result =  w * dir / (plane.normal1 DOT dir) + p - plane.normal1 DOT p * dir / (plane.normal1 DOT dir) *\n\n    //  a + d * (w - n . a) / (nd)\n    //  a + dw - d * na\n    assertVectors(dir, plane.normal1)\n    assertInst(M4, result)\n    const w = plane.w\n    const m = result.m\n    const nd = plane.normal1.dot(dir)\n    const { x: nx, y: ny, z: nz } = plane.normal1\n    const { x: dx, y: dy, z: dz } = dir.div(nd)\n    /*\n     rejectedFrom: return this.minus(b.times(this.dot(b) / b.dot(b)))\n     return M4.forSys(\n     V3.X.rejectedFrom(plane.normal1),\n     V3.Y.rejectedFrom(plane.normal1),\n     V3.Z.rejectedFrom(plane.normal1),\n     plane.anchor,\n     result\n     )\n     */\n\n    m[0] = 1.0 - nx * dx\n    m[1] = -ny * dx\n    m[2] = -nz * dx\n    m[3] = dx * w\n\n    m[4] = -nx * dy\n    m[5] = 1.0 - ny * dy\n    m[6] = -nz * dy\n    m[7] = dy * w\n\n    m[8] = -nx * dz\n    m[9] = -ny * dz\n    m[10] = 1.0 - nz * dz\n    m[11] = dz * w\n\n    m[12] = 0\n    m[13] = 0\n    m[14] = 0\n    m[15] = 1\n\n    return result\n  }\n\n  static lineProjection(\n    line: { anchor: V3; dir1: V3 },\n    result: M4 = new M4(),\n  ): M4 {\n    assertVectors(line.anchor, line.dir1)\n    assertInst(M4, result)\n    const ax = line.anchor.x,\n      ay = line.anchor.y,\n      az = line.anchor.z\n    const dx = line.dir1.x,\n      dy = line.dir1.y,\n      dz = line.dir1.z\n    const m = result.m\n\n    /*\n     projectedOn: return b.times(this.dot(b) / b.dot(b))\n     */\n\n    m[0] = dx * dx\n    m[1] = dx * dy\n    m[2] = dx * dz\n    m[3] = ax\n\n    m[4] = dy * dx\n    m[5] = dy * dy\n    m[6] = dy * dz\n    m[7] = ay\n\n    m[8] = dz * dx\n    m[9] = dz * dy\n    m[10] = dz * dz\n    m[11] = az\n\n    m[12] = 0\n    m[13] = 0\n    m[14] = 0\n    m[15] = 1\n    return result\n  }\n\n  static pointInversion(p: V3, result: M4 = new M4()): M4 {\n    assertVectors(p)\n    assertInst(M4, result)\n    const m = result.m\n\n    m[0] = -1\n    m[1] = 0\n    m[2] = 0\n    m[3] = 2 * p.x\n\n    m[4] = 0\n    m[5] = -1\n    m[6] = 0\n    m[7] = 2 * p.y\n\n    m[8] = 0\n    m[9] = 0\n    m[10] = -1\n    m[11] = 2 * p.z\n\n    m[12] = 0\n    m[13] = 0\n    m[14] = 0\n    m[15] = 1\n    return result\n  }\n\n  protected static new(width: int, height: int, m: Float64Array) {\n    assert(4 == width && 4 == height)\n    return new M4(...m)\n  }\n\n  get X(): V3 {\n    return this.transformVector(V3.X)\n  }\n\n  get Y(): V3 {\n    return this.transformVector(V3.Y)\n  }\n\n  get Z(): V3 {\n    return this.transformVector(V3.Z)\n  }\n\n  get O(): V3 {\n    return this.getTranslation()\n  }\n\n  isMirror(precision = NLA_PRECISION) {\n    const m = this.m\n    const nx = Math.sqrt((1 - m[0]) / 2)\n    const ny = Math.sqrt((1 - m[5]) / 2)\n    const nz = Math.sqrt((1 - m[10]) / 2)\n\n    return (\n      eq(m[1], -2.0 * ny * nx, precision) &&\n      eq(m[2], -2.0 * nz * nx, precision) &&\n      eq(m[4], -2.0 * nx * ny, precision) &&\n      eq(m[6], -2.0 * nz * ny, precision) &&\n      eq(m[8], -2.0 * nx * nz, precision) &&\n      eq(m[9], -2.0 * ny * nz, precision) &&\n      eq(m[12], 0, precision) &&\n      eq(m[13], 0, precision) &&\n      eq(m[14], 0, precision) &&\n      eq(m[15], 1, precision) &&\n      eq(m[3] * ny, m[7] * nx, precision) &&\n      eq(m[7] * nz, m[11] * ny, precision) &&\n      eq(m[11] * nx, m[3] * nz, precision)\n    )\n  }\n\n  // ### GL.Matrix.frustum(left, right, bottom, top, near, far[, result])\n  //\n  // Sets up a viewing frustum, which is shaped like a truncated pyramid with the\n  // camera where the point of the pyramid would be. You can optionally pass an\n  // existing matrix in `result` to avoid allocating a new matrix. This emulates\n\n  /** Returns a new M4 which is equal to the inverse of this. */\n  inversed(result?: M4): M4 {\n    return M4.inverse(this, result)\n  }\n\n  /** Matrix trace is defined as the sum of the elements of the main diagonal. */\n  trace(): number {\n    return this.m[0] + this.m[5] + this.m[10] + this.m[15]\n  }\n\n  as3x3(result?: M4): M4 {\n    result = M4.copy<M4>(this, result)\n    const m = result.m\n\n    m[3] = m[7] = m[11] = m[12] = m[13] = m[14] = 0\n    m[15] = 1\n    return result\n  }\n\n  transform(m4: M4): this {\n    return m4.times(this) as this\n  }\n\n  realEigenValues3(): number[] {\n    const m = this.m\n    assert(0 == m[12] && 0 == m[13] && 0 == m[14])\n    // determinant of (this - I):\n    // | a-  b   c  |\n    // |  d  e-  f  | = -^3 + ^2 (a+e+i) +  (-a e-a i+b d+c g-e i+f h) + a(ei - fh) - b(di - fg) + c(dh - eg)\n    // |  g   h  i- |\n\n    const [a, b, c, , d, e, f, , g, h, i] = m\n    // det(this - I) = -^3 +^2 (a+e+i) +  (-a e-a i-b d+c g-e i+f h)+ (a e i-a f h-b d i+b f g+c d h-c e g)\n    const s = -1\n    const t = a + e + i // equivalent to trace of matrix\n    const u = -a * e - a * i + b * d + c * g - e * i + f * h // equivalent to 1/2 (trace(this) - trace(A))\n    const w = a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g) // equivalent to matrix determinant\n\n    console.log(s, t, u, w)\n    return solveCubicReal2(s, t, u, w)\n  }\n\n  realEigenVectors3(): V3[] {\n    const eigenValues = this.realEigenValues3()\n    const this3x3 = this.times(M4.IDENTITY3)\n    console.log(this.toString())\n    console.log(this3x3.toString())\n    let mats = eigenValues.map((ev) => M4.IDENTITY3.scale(-ev).plus(this3x3))\n    console.log(mats.map((m) => m.determinant3()))\n    console.log(mats.map((m) => \"\" + m.toString((v) => \"\" + v)).join(\"\\n\\n\"))\n    console.log(\n      mats\n        .map((m) => \"\" + m.luDecomposition().U.toString((v) => \"\" + v))\n        .join(\"\\n\\n\"),\n    )\n    console.log(\n      \"mats.map(m=>m.rank())\",\n      mats.map((m) => m.rank()),\n    )\n    if (1 == eigenValues.length) {\n      console.log(mats[0].toString())\n      assertf(() => 0 == mats[0].rank())\n      // col vectors\n      return arrayFromFunction(\n        3,\n        (col) => new V3(this.m[col], this.m[4 + col], this.m[8 + col]),\n      )\n    }\n    if (2 == eigenValues.length) {\n      // one matrix should have rank 1, the other rank 2\n      if (1 == mats[0].rank()) {\n        mats = [mats[1], mats[0]]\n      }\n      assertf(() => 2 == mats[0].rank())\n      assertf(() => 1 == mats[1].rank())\n\n      // mat[0] has rank 2, mat[1] has rank 1\n      const gauss0 = mats[0].luDecomposition().U\n      const eigenVector0 = gauss0.row(0).cross(gauss0.row(1)).V3().unit()\n\n      const planeNormal = mats[1].luDecomposition().U.row(0).V3()\n      const eigenVector1 = planeNormal.getPerpendicular().unit()\n      const eigenVector2 = eigenVector0\n        .cross(eigenVector1)\n        .rejectedFrom(planeNormal)\n\n      return [eigenVector0, eigenVector1, eigenVector2]\n    }\n    if (3 == eigenValues.length) {\n      mats.forEach((mat, i) => assert(2 == mat.rank(), i + \": \" + mat.rank()))\n      // the (A - lambda I) matrices map to a plane. This means, that there is an entire line in R which maps to\n      // the point V3.O\n      return mats.map((mat) => {\n        const gauss = mat.luDecomposition().U\n        return gauss.row(0).cross(gauss.row(1)).V3().unit()\n      })\n    }\n    throw new Error(\"there cannot be more than 3 eigen values\")\n  }\n\n  /**\n   * U * SIGMA * VSTAR = this\n   *\n   * U and VSTAR are orthogonal matrices\n   *\n   * SIGMA is a diagonal matrix\n   */\n  svd3(): { U: M4; SIGMA: M4; VSTAR: M4 } {\n    function matrixForCS(i: int, k: int, c: number, s: number) {\n      const m = M4.identity()\n      m.setEl(i, i, c)\n      m.setEl(k, k, c)\n      m.setEl(i, k, s)\n      m.setEl(k, i, -s)\n      return m\n    }\n\n    const A = this.as3x3()\n    let S = A.transposed().times(A),\n      V = M4.identity()\n    console.log(S.toString())\n    for (let it = 0; it < 16; it++) {\n      console.log(\"blahg\\n\", V.times(S).times(V.transposed()).toString())\n      assert(\n        V.times(S).times(V.transposed()).likeM4(A.transposed().times(A)),\n        V.times(S).times(V.transposed()).toString(),\n        A.transposed().times(A).toString(),\n      )\n      let maxOffDiagonal = 0,\n        maxOffDiagonalIndex = 1,\n        j = 10\n      while (j--) {\n        const val = Math.abs(S.m[j])\n        if (j % 4 != Math.floor(j / 4) && val > maxOffDiagonal) {\n          maxOffDiagonal = val\n          maxOffDiagonalIndex = j\n        }\n      }\n\n      const i = Math.floor(maxOffDiagonalIndex / 4),\n        k = maxOffDiagonalIndex % 4\n      const a_ii = S.m[5 * i],\n        a_kk = S.m[5 * k],\n        a_ik = S.m[maxOffDiagonalIndex]\n      const phi =\n        a_ii === a_kk ? PI / 4 : Math.atan((2 * a_ik) / (a_ii - a_kk)) / 2\n      console.log(maxOffDiagonalIndex, i, k, \"phi\", phi)\n      const cos = Math.cos(phi),\n        sin = Math.sin(phi)\n      const givensRotation = matrixForCS(i, k, cos, -sin)\n      assert(givensRotation.transposed().times(givensRotation).likeIdentity())\n      console.log(givensRotation.toString())\n      V = V.times(givensRotation)\n      S = M4.product(givensRotation.transposed(), S, givensRotation)\n      console.log(S.toString())\n    }\n\n    const sigma = S.map((el, elIndex) => (elIndex % 5 == 0 ? Math.sqrt(el) : 0))\n    return {\n      U: M4.product(\n        A,\n        V,\n        sigma.map((el, elIndex) => (elIndex % 5 == 0 ? 1 / el : 0)),\n      ),\n      SIGMA: sigma,\n      VSTAR: V.transposed(),\n    }\n  }\n\n  map(fn: (el: number, elIndex: number, array: Float64Array) => number): M4 {\n    return M4.fromFunction4((x, y, i) => fn(this.m[i], i, this.m))\n  }\n\n  likeM4(m4: M4): boolean {\n    assertInst(M4, m4)\n    return this.m.every((el, index) => eq(el, m4.m[index]))\n  }\n\n  /** Returns a new M4 equal to the transpose of this. */\n  transposed(result?: M4): M4 {\n    return M4.transpose(this, result)\n  }\n\n  /** Returns a new M4 which equal to (this * matrix) (in that order) */\n  times(matrix: M4): M4 {\n    return M4.multiply(this, matrix)\n  }\n\n  /**\n   * In a perspective projection, parallel lines meet in a vanishing point.\n   *\n   * Returns undefined if there is no vanishing point, either because this is\n   * not a perspective transform, or because the passed dir is perpendicular to\n   * the projections direction.\n   *\n   * @param dir\n   */\n  vanishingPoint(dir: V3) {\n    assertVectors(dir)\n    const m = this.m\n    const vx = dir.x,\n      vy = dir.y,\n      vz = dir.z\n    const w = vx * m[12] + vy * m[13] + vz * m[14]\n    if (eq0(w)) return undefined\n    const x = vx * m[0] + vy * m[1] + vz * m[2]\n    const y = vx * m[4] + vy * m[5] + vz * m[6]\n    const z = vx * m[8] + vy * m[9] + vz * m[10]\n    return new V3(x / w, y / w, z / w)\n  }\n\n  /**\n   * Transforms the vector as a point with a w coordinate of 1. This means\n   * translations will have an effect, for example.\n   */\n  transformPoint(v: V3): V3 {\n    assertVectors(v)\n    const m = this.m\n    const vx = v.x,\n      vy = v.y,\n      vz = v.z\n    const x = vx * m[0] + vy * m[1] + vz * m[2] + m[3]\n    const y = vx * m[4] + vy * m[5] + vz * m[6] + m[7]\n    const z = vx * m[8] + vy * m[9] + vz * m[10] + m[11]\n    const w = vx * m[12] + vy * m[13] + vz * m[14] + m[15]\n    // scale such that fourth element becomes 1:\n    return new V3(x / w, y / w, z / w)\n  }\n\n  /**\n   * Transforms the vector as a vector with a w coordinate of 0. This means\n   * translations will have no effect, for example. Will throw an exception if\n   * the calculated w component != 0. This occurs for example when attempting\n   * to transform a vector with a perspective matrix.\n   */\n  transformVector(v: V3, checkW = true): V3 {\n    assertVectors(v)\n    const m = this.m\n    const w = v.x * m[12] + v.y * m[13] + v.z * m[14]\n    checkW &&\n      assert(\n        eq0(w),\n        () =>\n          \"w === 0 needs to be true for this to make sense (w =\" +\n          w +\n          this.toString(),\n      )\n    return new V3(\n      m[0] * v.x + m[1] * v.y + m[2] * v.z,\n      m[4] * v.x + m[5] * v.y + m[6] * v.z,\n      m[8] * v.x + m[9] * v.y + m[10] * v.z,\n    )\n  }\n\n  transformVector2(v: V3, anchor: V3): V3 {\n    // v and anchor define a line(t) = anchor + t v\n    // we can view the calculation of the transformed vector as the derivative of the transformed line at t = 0\n    // d/dt (this * line(t)) (0)\n    assertVectors(v, anchor)\n    const transformedAnchor = this.timesVector(\n      VV(anchor.x, anchor.y, anchor.z, 1),\n    )\n    const transformedVector = this.timesVector(VV(v.x, v.y, v.z, 0))\n    return transformedVector\n      .times(transformedAnchor.w)\n      .minus(transformedAnchor.times(transformedVector.w))\n      .div(transformedAnchor.w ** 2)\n      .V3()\n  }\n\n  transformedPoints(vs: ReadonlyArray<V3>): V3[] {\n    return vs.map((v) => this.transformPoint(v))\n  }\n\n  transformedVectors(vs: ReadonlyArray<V3>): V3[] {\n    return vs.map((v) => this.transformVector(v))\n  }\n\n  new() {\n    return new M4() as this\n  }\n\n  isRegular(): boolean {\n    return !eq0(this.determinant())\n  }\n\n  isAxisAligned(): boolean {\n    const m = this.m\n    return (\n      1 >= +!eq0(m[0]) + +!eq0(m[1]) + +!eq0(m[2]) &&\n      1 >= +!eq0(m[4]) + +!eq0(m[5]) + +!eq0(m[6]) &&\n      1 >= +!eq0(m[8]) + +!eq0(m[9]) + +!eq0(m[10])\n    )\n  }\n\n  /**\n   * A matrix M is orthogonal iff M * M^T = I I being the identity matrix.\n   *\n   * @returns If this matrix is orthogonal or very close to it. Comparison of\n   *     the identity matrix and this * this^T is done with {@link #likeM4}\n   */\n  isOrthogonal(): boolean {\n    // return this.transposed().times(this).likeM4(M4.IDENTITY)\n    M4.transpose(this, M4.temp0)\n    M4.multiply(this, M4.temp0, M4.temp1)\n    return M4.IDENTITY.likeM4(M4.temp1)\n  }\n\n  /**\n   * A matrix M is symmetric iff M == M^T I being the identity matrix.\n   *\n   * @returns If this matrix is symmetric or very close to it. Comparison of the\n   *     identity matrix and this * this^T is done with {@link #likeM4}\n   */\n  isSymmetric(): boolean {\n    M4.transpose(this, M4.temp0)\n    return this.likeM4(M4.temp0)\n  }\n\n  /** A matrix M is skew symmetric iff M = -M^T */\n  isSkewSymmetric(precision?: number): boolean {\n    return (\n      eq0(this.m[0], precision) &&\n      eq0(this.m[5], precision) &&\n      eq0(this.m[10], precision) &&\n      eq0(this.m[15], precision) &&\n      eq(this.m[1], this.m[4], precision) &&\n      eq(this.m[2], this.m[8], precision) &&\n      eq(this.m[3], this.m[12], precision) &&\n      eq(this.m[6], this.m[9], precision) &&\n      eq(this.m[7], this.m[13], precision) &&\n      eq(this.m[11], this.m[14], precision)\n    )\n  }\n\n  /**\n   * A matrix M is normal1 iff M * M^-T == M^T * M TODO: ^-T? I being the identity matrix.\n   *\n   * @returns If this matrix is symmetric or very close to it. Comparison of the\n   *     identity matrix and this * this^T is done with {@link #likeM4}\n   */\n  isNormal(): boolean {\n    M4.transpose(this, M4.temp0) // temp0 = this^-T\n    M4.multiply(this, M4.temp0, M4.temp1) // temp1 = this * this^-T\n    M4.multiply(M4.temp0, this, M4.temp2) // temp2 = this^-T * this\n    return M4.temp1.likeM4(M4.temp2)\n  }\n\n  /**\n   * Determinant of matrix.\n   *\n   * Notes:\n   *     For matrices A and B\n   *     det(A * B) = det(A) * det(B)\n   *     det(A^-1) = 1 / det(A)\n   */\n  determinant(): number {\n    // | a b c d |\n    // | e f g h |\n    // | i j k l |\n    // | m n o p |\n    const $ = this.m,\n      a = $[0],\n      b = $[1],\n      c = $[2],\n      d = $[3],\n      e = $[4],\n      f = $[5],\n      g = $[6],\n      h = $[7],\n      i = $[8],\n      j = $[9],\n      k = $[10],\n      l = $[11],\n      m = $[12],\n      n = $[13],\n      o = $[14],\n      p = $[15],\n      klop = k * p - l * o,\n      jlnp = j * p - l * n,\n      jkno = j * o - k * n,\n      ilmp = i * p - l * m,\n      ikmo = i * o - k * m,\n      ijmn = i * n - j * m\n    return (\n      a * (f * klop - g * jlnp + h * jkno) -\n      b * (e * klop - g * ilmp + h * ikmo) +\n      c * (e * jlnp - f * ilmp + h * ijmn) -\n      d * (e * jkno - f * ikmo + g * ijmn)\n    )\n  }\n\n  determinant3(): number {\n    const [a, b, c, , d, e, f, , g, h, i] = this.m\n    return a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g)\n  }\n\n  /** Determine whether this matrix is a mirroring transformation */\n  isMirroring(): boolean {\n    /*\n     var u = V(this.m[0], this.m[4], this.m[8])\n     var v = V(this.m[1], this.m[5], this.m[9])\n     var w = V(this.m[2], this.m[6], this.m[10])\n\n     // for a true orthogonal, non-mirrored base, u.cross(v) == w\n     // If they have an opposite direction then we are mirroring\n     var mirrorvalue = u.cross(v).dot(w)\n     var ismirror = (mirrorvalue < 0)\n     return ismirror\n     */\n\n    return this.determinant() < 0 // TODO: also valid for 4x4?\n  }\n\n  /** Get the translation part of this matrix, i.e. the result of this.transformPoint(V3.O) */\n  getTranslation(): V3 {\n    const m = this.m,\n      w = m[15]\n    return new V3(m[3] / w, m[7] / w, m[11] / w)\n  }\n\n  /**\n   * Returns this matrix scaled so that the determinant is 1. det(c * A) = (c **\n   * n) * det(A) for n x n matrices, so we need to divide by the 4th root of\n   * the determinant\n   */\n  normalized(): M4 {\n    const detAbs = abs(this.determinant())\n    return 1 == detAbs ? this : this.divScalar(detAbs ** 0.25)\n  }\n\n  /** Returns this matrix scaled so that the bottom-right element is 1. */\n  normalized2(): M4 {\n    const div = this.m[15]\n    return 1 == div ? this : this.divScalar(div)\n  }\n\n  /**\n   * Returns if the matrix has the following form (within NLA_PRECISION): a b c\n   * 0 c d e 0 f g h 0 0 0 0 1\n   */\n  like3x3(): boolean {\n    const m = this.m\n    return (\n      eq(1, m[15]) &&\n      eq0(m[12]) &&\n      eq0(m[13]) &&\n      eq0(m[14]) &&\n      eq0(m[3]) &&\n      eq0(m[7]) &&\n      eq0(m[11])\n    )\n  }\n\n  isNoProj(): boolean {\n    const m = this.m\n    return 0 == m[12] && 0 == m[13] && 0 == m[14] && 1 == m[15]\n  }\n\n  likeIdentity(): boolean {\n    return this.m.every((val, i) =>\n      ((i / 4) | 0) == i % 4 ? eq(1, val) : eq0(val),\n    )\n  }\n\n  isIdentity(): boolean {\n    return this.m.every((val, i) =>\n      ((i / 4) | 0) == i % 4 ? 1 == val : 0 == val,\n    )\n  }\n\n  toString(\n    f: (number: number) => string = (v) =>\n      v.toFixed(6).replace(/([0.])(?=0*$)/g, \" \"),\n  ): string {\n    assert(typeof f(0) == \"string\", \"\" + typeof f(0))\n    // slice this.m to convert it to an Array (from TypeArray)\n    const rounded = Array.prototype.slice.call(this.m).map(f) as string[]\n    const colWidths = [0, 1, 2, 3].map((colIndex) =>\n      max(sliceStep(rounded, colIndex, 0, 4).map((x) => x.length)),\n    )\n    return [0, 1, 2, 3]\n      .map((rowIndex) =>\n        rounded\n          .slice(rowIndex * 4, rowIndex * 4 + 4) // select matrix row\n          .map((x, colIndex) => \" \".repeat(colWidths[colIndex] - x.length) + x) // pad numbers with\n          // spaces to col width\n          .join(\" \"),\n      )\n      .join(\"\\n\") // join rows\n  }\n\n  /**\n   * Wether this matrix is a translation matrix, i.e. of the form\n   *\n   *     1, 0, 0, x,\n   *     0, 1, 0, y,\n   *     0, 0, 1, z,\n   *     0, 0, 0, 1\n   */\n  isTranslation(): boolean {\n    // 2: any value, otherwise same value\n    // prettier-ignore\n    const mask = [\n      1, 0, 0, 2,\n      0, 1, 0, 2,\n      0, 0, 1, 2,\n      0, 0, 0, 1]\n    return mask.every(\n      (expected, index) => expected == 2 || expected == this.m[index],\n    )\n  }\n\n  /**\n   * Wether this matrix is a translation matrix, i.e. of the form\n   *\n   *     S, 0, 0, 0,\n   *     0, t, 0, 0,\n   *     0, 0, v, 0,\n   *     0, 0, 0, 1\n   */\n  isScaling(): boolean {\n    // prettier-ignore\n    const mask = [\n      2, 0, 0, 0,\n      0, 2, 0, 0,\n      0, 0, 2, 0,\n      0, 0, 0, 1]\n    return mask.every(\n      (expected, index) => expected == 2 || expected == this.m[index],\n    )\n  }\n\n  isZRotation(): boolean {\n    // prettier-ignore\n    const mask = [\n      2, 2, 0, 0,\n      2, 2, 0, 0,\n      0, 0, 1, 0,\n      0, 0, 0, 1]\n    return (\n      mask.every(\n        (expected, index) => expected == 2 || expected == this.m[index],\n      ) &&\n      eq(1, this.m[0] ** 2 + this.m[1] ** 2) &&\n      this.m[0] == this.m[5] &&\n      this.m[1] == -this.m[4]\n    )\n  }\n\n  toSource(): string {\n    const name = M4.NAMEMAP.get(this)\n    if (name) {\n      return name\n    } else if (this.isTranslation()) {\n      return callSource(\"M4.translate\", this.O)\n    } else if (this.isScaling()) {\n      return callSource(\"M4.scale\", this.m[0], this.m[5], this.m[10])\n    } else if (this.isNoProj()) {\n      return !this.O.equals(V3.O)\n        ? callSource(\"M4.forSys\", this.X, this.Y, this.Z, this.O)\n        : callSource(\"M4.forSys\", this.X, this.Y, this.Z)\n    } else if (this.isMirror(0)) {\n      const m = this.m\n      const nx = Math.sqrt((1 - m[0]) / 2)\n      const ny = Math.sqrt((1 - m[5]) / 2)\n      const nz = Math.sqrt((1 - m[10]) / 2)\n      const w = m[3] / 2.0 / nx\n      return callSource(\"M4.mirror\", { normal1: new V3(nx, ny, nz), w })\n    } else {\n      const m = this.m\n      return (\n        \"new M4(\" +\n        (\"\\n\\t\" + m[0] + \",\\t\" + m[1] + \",\\t\" + m[2] + \",\\t\" + m[3] + \",\") +\n        (\"\\n\\t\" + m[4] + \",\\t\" + m[5] + \",\\t\" + m[6] + \",\\t\" + m[7] + \",\") +\n        (\"\\n\\t\" + m[8] + \",\\t\" + m[9] + \",\\t\" + m[10] + \",\\t\" + m[11] + \",\") +\n        (\"\\n\\t\" + m[12] + \",\\t\" + m[13] + \",\\t\" + m[14] + \",\\t\" + m[15] + \")\")\n      )\n    }\n  }\n\n  xyAreaFactor(): number {\n    return this.transformVector(V3.X).cross(this.transformVector(V3.Y)).length()\n  }\n}\n\nM4.prototype.height = 4\nM4.prototype.width = 4\n\nexport interface M4 extends Transformable {}\n\naddOwnProperties(M4.prototype, Transformable.prototype, \"constructor\")\n","import {\n  ArrayLikeWriteAble,\n  FloatArray,\n  Matrix,\n  V3,\n  assert,\n  assertInst,\n  assertNumbers,\n  callSource,\n  clamp,\n  eq,\n  eq0,\n  int,\n} from \".\"\n\nexport class Vector {\n  constructor(readonly v: Float64Array) {\n    assertInst(Float64Array, v)\n  }\n\n  static fromFunction(dims: int, f: (dim: int) => number): Vector {\n    assertNumbers(dims)\n    const e = new Float64Array(dims)\n    let i = dims\n    while (i--) {\n      e[i] = f(i)\n    }\n    return new Vector(e)\n  }\n\n  static random(dims: int): Vector {\n    return Vector.fromFunction(dims, (_i) => Math.random())\n  }\n\n  static from(f64a: Float64Array): Vector\n  static from(...args: number[]): Vector\n  static from(...args: any[]): Vector {\n    assert(\n      args[0] instanceof Float64Array ||\n        args.every((a) => \"number\" == typeof a),\n      'args[0] instanceof Float64Array || args.every(a => \"number\" == typeof a)',\n    )\n    return new Vector(\n      args[0] instanceof Float64Array ? args[0] : Float64Array.from(args),\n    )\n  }\n\n  static Zero(dims: int): Vector {\n    assertNumbers(dims)\n    let i = 0\n    const n = new Float64Array(dims)\n    while (i--) {\n      n[i] = 0\n    }\n    return new Vector(n)\n  }\n\n  static Unit(dims: int, dir: int): Vector {\n    assertNumbers(dims, dir)\n    let i = 0\n    const n = new Float64Array(dims)\n    while (i--) {\n      n[i] = +(i == dir) // +true === 1, +false === 0\n    }\n    return new Vector(n)\n  }\n\n  /**\n   * Pack an array of Vectors into an array of numbers (Float32Array by default).\n   *\n   * @param vectors Source array\n   * @param dest Destination array. If provided, must be large enough to fit\n   *     v3count items.\n   * @param srcStart Starting index in source array\n   * @param destStart Starting index in destination array\n   * @param vectorCount Number of V3s to copy.\n   * @returns Packed array.\n   */\n  static pack<T extends FloatArray = Float32Array>(\n    vectors: ReadonlyArray<Vector>,\n    dest?: T,\n    srcStart: number = 0,\n    destStart: number = 0,\n    vectorCount: number = vectors.length - srcStart,\n  ): T {\n    //assert (v3arr.every(v3 => v3 instanceof V3), 'v3arr.every(v3 => v3 instanceof V3)')\n    const dim = vectors[0].dim()\n    const result = dest || (new Float32Array(dim * vectorCount) as any) // TODO\n    assert(\n      result.length - destStart >= vectorCount * dim,\n      \"dest.length - destStart >= v3count * 3\",\n      result.length,\n      destStart,\n      vectorCount * 3,\n    )\n\n    let i = vectorCount,\n      srcIndex = srcStart,\n      destIndex = destStart\n    while (i--) {\n      const v = vectors[srcIndex++]\n      for (let d = 0; d < dim; d++) {\n        result[destIndex++] = v.v[d]\n      }\n    }\n    return result\n  }\n\n  static lerp(a: Vector, b: Vector, t: number) {\n    assert(a.dim() == b.dim())\n    const n = new Float64Array(a.v.length)\n    let i = a.v.length\n    while (i--) {\n      n[i] = a.v[i] * (1 - t) + b.v[i] * t\n    }\n    return new Vector(n)\n  }\n\n  static add(...vs: Vector[]): Vector {\n    const dim = vs[0].v.length\n    const result = new Float64Array(dim)\n    let i = vs.length\n    while (i--) {\n      let d = dim\n      while (d--) {\n        result[d] += vs[i].v[d]\n      }\n    }\n    return new Vector(result)\n  }\n\n  /**\n   * Create a new 4D Vector from a V3 and a weight.\n   *\n   * @param v3\n   * @param weight\n   */\n  static fromV3AndWeight(v3: V3, weight: number) {\n    return new Vector(\n      new Float64Array([v3.x * weight, v3.y * weight, v3.z * weight, weight]),\n    )\n  }\n\n  get x() {\n    return this.v[0]\n  }\n  get y() {\n    return this.v[1]\n  }\n  get z() {\n    return this.v[2]\n  }\n  get w() {\n    return this.v[3]\n  }\n\n  [Symbol.iterator]() {\n    return this.v[Symbol.iterator]()\n  }\n\n  dim(): int {\n    return this.v.length\n  }\n\n  e(index: int): number {\n    if (0 > index || index >= this.v.length) {\n      throw new Error(\"array index out of bounds\")\n    }\n    return this.v[index]\n  }\n\n  plus(vector: Vector): Vector {\n    const u = this.v,\n      v = vector.v\n    const n = new Float64Array(u.length)\n    let i = u.length\n    while (i--) {\n      n[i] = u[i] + v[i]\n    }\n    return new Vector(n)\n  }\n\n  minus(vector: Vector): Vector {\n    const u = this.v,\n      v = vector.v\n    const n = new Float64Array(u.length)\n    let i = u.length\n    while (i--) {\n      n[i] = u[i] - v[i]\n    }\n    return new Vector(n)\n  }\n\n  times(factor: number): Vector {\n    const u = this.v\n    const n = new Float64Array(u.length)\n    let i = u.length\n    while (i--) {\n      n[i] = u[i] * factor\n    }\n    return new Vector(n)\n  }\n\n  div(val: number): Vector {\n    const u = this.v\n    const n = new Float64Array(u.length)\n    let i = u.length\n    while (i--) {\n      n[i] = u[i] / val\n    }\n    return new Vector(n)\n  }\n\n  dot(vector: Vector): number {\n    assert(this.dim == vector.dim, \"passed vector must have the same dim\")\n    let result = 0\n    const u = this.v,\n      v = vector.v\n    let i = u.length\n    while (i--) {\n      result += u[i] * v[i]\n    }\n    return result\n  }\n\n  cross(vector: Vector): Vector {\n    assertInst(Vector, vector)\n    const n = new Float64Array(3)\n    n[0] = this.v[1] * vector.v[2] - this.v[2] * vector.v[1]\n    n[1] = this.v[2] * vector.v[0] - this.v[0] * vector.v[2]\n    n[2] = this.v[0] * vector.v[1] - this.v[1] * vector.v[0]\n\n    return new Vector(n)\n  }\n\n  schur(vector: Vector): Vector {\n    assertInst(Vector, vector)\n    const u = this.v,\n      v = vector.v\n    const n = new Float64Array(u.length)\n    let i = u.length\n    while (i--) {\n      n[i] = u[i] * v[i]\n    }\n    return new Vector(n)\n  }\n\n  equals(obj: any): boolean {\n    if (obj === this) return true\n    if (obj.constructor !== Vector) return false\n    if (this.v.length != obj.v.length) return false\n    let i = this.v.length\n    while (i--) {\n      if (this.v[i] !== obj.v[i]) return false\n    }\n    return true\n  }\n\n  like(obj: any, precision?: number): boolean {\n    if (obj === this) return true\n    if (obj.constructor !== Vector) return false\n    if (this.v.length != obj.v.length) return false\n    let i = this.v.length\n    while (i--) {\n      if (!eq(this.v[i], obj.v[i], precision)) return false\n    }\n    return true\n  }\n\n  map(f: (el: number, dim: number) => number): Vector {\n    return new Vector(this.v.map(f))\n  }\n\n  toString(roundFunction?: (x: number) => any): string {\n    roundFunction = roundFunction || ((v) => +v.toFixed(6))\n    return \"Vector(\" + this.v.map(roundFunction).join(\", \") + \")\"\n  }\n\n  toSource() {\n    return callSource(\"VV\", ...this.v)\n  }\n\n  angleTo(vector: Vector): number {\n    assertInst(Vector, vector)\n    assert(!this.isZero(), \"!this.likeO()\")\n    assert(!vector.isZero(), \"!vector.likeO()\")\n    return Math.acos(\n      clamp(this.dot(vector) / this.length() / vector.length(), -1, 1),\n    )\n  }\n\n  /**\n   * Returns true iff this is parallel to vector, using eq Throw a DebugError -\n   * if vector is not a Vector or - if this has a length of 0 or - if vector\n   * has a length of 0\n   */\n  isParallelTo(vector: Vector): boolean {\n    assertInst(Vector, vector)\n    assert(!this.isZero(), \"!this.likeO()\")\n    assert(!vector.isZero(), \"!vector.likeO()\")\n    // a . b takes on values of +|a|*|b| (vectors same direction) to -|a|*|b| (opposite direction)\n    // in both cases the vectors are paralle, so check if abs(a . b) == |a|*|b|\n    return eq(\n      Math.sqrt(this.lengthSquared() * vector.lengthSquared()),\n      Math.abs(this.dot(vector)),\n    )\n  }\n\n  isPerpendicularTo(vector: Vector): boolean {\n    assertInst(Vector, vector)\n    assert(!this.isZero(), \"!this.likeO()\")\n    assert(!vector.isZero(), \"!vector.likeO()\")\n    return eq0(this.dot(vector))\n  }\n\n  /**\n   * Returns true iff the length of this vector is 0, as returned by NLA.isZero.\n   * Definition: Vector.prototype.isZero = () => NLA.isZero(this.length())\n   */\n  isZero(): boolean {\n    return eq0(this.length())\n  }\n\n  /*/ Returns the length of this Vector, i.e. the euclidian norm.*/\n  length(): number {\n    return Math.hypot.apply(undefined, (this.v as unknown) as number[])\n    //return Math.sqrt(this.lengthSquared())\n  }\n\n  lengthSquared(): number {\n    let result = 0\n    const u = this.v\n    let i = u.length\n    while (i--) {\n      result += u[i] * u[i]\n    }\n    return result\n  }\n\n  /**\n   * Returns a new unit Vector (.length() === 1) with the same direction as this\n   * vector. Throws a\n   */\n  unit(): Vector {\n    const length = this.length()\n    if (eq0(length)) {\n      throw new Error(\"cannot normalize zero vector\")\n    }\n    return this.div(this.length())\n  }\n\n  /** Documentation stub. You want {@link unit} */\n  normalized(): V3 {\n    throw new Error(\"documentation stub. use .unit()\")\n  }\n\n  asRowMatrix(): Matrix {\n    return new Matrix(this.v.length, 1, this.v)\n  }\n\n  asColMatrix(): Matrix {\n    return new Matrix(1, this.v.length, this.v)\n  }\n\n  /**\n   * Returns a new Vector which is the projection of this vector onto the passed vector.\n   *\n   * @example\n   *   VV(3, 4).projectedOn(VV(1, 0)) // VV(3, 0)\n   *   VV(3, 4).projectedOn(VV(2, 0)) // VV(3, 0)\n   *   VV(3, 4).projectedOn(VV(-1, 0)) // VV(-3, 0)\n   *   VV(3, 4).projectedOn(VV(0, 1)) // VV(0, 4)\n   *   VV(3, 4).projectedOn(VV(1, 1)) //\n   */\n  projectedOn(b: Vector): Vector {\n    assertInst(Vector, b)\n    // https://en.wikipedia.org/wiki/Vector_projection#Vector_projection_2\n    return b.times(this.dot(b) / b.dot(b))\n  }\n\n  rejectedOn(b: Vector): Vector {\n    assertInst(Vector, b)\n    // https://en.wikipedia.org/wiki/Vector_projection#Vector_projection_2\n    return this.minus(b.times(this.dot(b) / b.dot(b)))\n  }\n\n  to(a: Vector): Vector {\n    return a.minus(this)\n  }\n\n  /**\n   * Returns true iff the length() of this vector is equal to 'length', using equals\n   *\n   * @example\n   *   V(3, 4).hasLength(5) // true\n   *   V(1, 1).hasLength(1) // false\n   */\n  hasLength(length: number): boolean {\n    assertNumbers(length)\n    return eq(length, this.length())\n  }\n\n  V3(): V3 {\n    //assert(this.dim() == 3)\n    return new V3(this.v[0], this.v[1], this.v[2])\n  }\n\n  /** Project into 3 dimensions. */\n  p3(): V3 {\n    assert(this.v.length == 4)\n    const w = this.v[3]\n    return new V3(this.v[0] / w, this.v[1] / w, this.v[2] / w)\n  }\n\n  transposed() {\n    return new Matrix(this.v.length, 1, this.v)\n  }\n}\n\nexport function VV(...values: number[]) {\n  return new Vector(new Float64Array(values))\n}\n\nexport function vArrGet(vArr: ArrayLike<number>, dim: int, i: int) {\n  assert(vArr.length % dim == 0)\n  return new Vector(\n    Float64Array.prototype.slice.call(vArr, i * dim, (i + 1) * dim),\n  )\n}\n\nexport function vArrSet(\n  vArr: ArrayLikeWriteAble<number>,\n  i: int,\n  vector: Vector,\n) {\n  const dim = vector.dim()\n  assert(vArr.length % dim == 0)\n  let d = dim\n  while (d--) {\n    vArr[i * dim + d] = vector.v[d]\n  }\n}\n","import {\n  assert,\n  assertInst,\n  assertNumbers,\n  assertVectors,\n  callSource,\n  clamp,\n  lt,\n  M4,\n  NLA_PRECISION,\n  Transformable,\n  V3,\n} from \".\"\n\nexport class AABB extends Transformable {\n  constructor(public min: V3 = V3.INF, public max: V3 = V3.INF.negated()) {\n    super()\n    assertVectors(min, max)\n  }\n\n  static forXYZ(x: number, y: number, z: number): AABB {\n    return new AABB(V3.O, new V3(x, y, z))\n  }\n\n  static forAABBs(aabbs: Iterable<AABB>): AABB {\n    const result = new AABB()\n    for (const aabb of aabbs) {\n      result.addAABB(aabb)\n    }\n    return result\n  }\n\n  addPoint(p: V3): this {\n    assertVectors(p)\n    this.min = this.min.min(p)\n    this.max = this.max.max(p)\n    return this\n  }\n\n  addPoints(ps: V3[]): this {\n    ps.forEach((p) => this.addPoint(p))\n    return this\n  }\n\n  addAABB(aabb: AABB): this {\n    assertInst(AABB, aabb)\n    this.addPoint(aabb.min)\n    this.addPoint(aabb.max)\n    return this\n  }\n\n  /**\n   * Returns the largest AABB contained in this which doesn't overlap with aabb\n   *\n   * @param aabb\n   */\n  withoutAABB(aabb: AABB): AABB {\n    assertInst(AABB, aabb)\n    let min, max\n    const volume = this.volume(),\n      size = this.size()\n    let remainingVolume = -Infinity\n    for (let i = 0; i < 3; i++) {\n      const dim = [\"x\", \"y\", \"z\"][i] as \"x\" | \"y\" | \"z\"\n      const cond = aabb.min[dim] - this.min[dim] > this.max[dim] - aabb.max[dim]\n      const dimMin = cond\n        ? this.min[dim]\n        : Math.max(this.min[dim], aabb.max[dim])\n      const dimMax = !cond\n        ? this.max[dim]\n        : Math.min(this.max[dim], aabb.min[dim])\n      const newRemainingVolume = ((dimMax - dimMin) * volume) / size[dim]\n      if (newRemainingVolume > remainingVolume) {\n        remainingVolume = newRemainingVolume\n        min = this.min.withElement(dim, dimMin)\n        max = this.max.withElement(dim, dimMax)\n      }\n    }\n    return new AABB(min, max)\n  }\n\n  getIntersectionAABB(aabb: AABB): AABB {\n    assertInst(AABB, aabb)\n    return new AABB(this.min.max(aabb.min), this.max.min(aabb.max))\n  }\n\n  touchesAABB(aabb: AABB): boolean {\n    assertInst(AABB, aabb)\n    return !(\n      this.min.x > aabb.max.x ||\n      this.max.x < aabb.min.x ||\n      this.min.y > aabb.max.y ||\n      this.max.y < aabb.min.y ||\n      this.min.z > aabb.max.z ||\n      this.max.z < aabb.min.z\n    )\n  }\n\n  touchesAABBfuzzy(aabb: AABB, precisision = NLA_PRECISION): boolean {\n    assertInst(AABB, aabb)\n    return !(\n      lt(aabb.max.x, this.min.x, precisision) ||\n      lt(this.max.x, aabb.min.x, precisision) ||\n      lt(aabb.max.y, this.min.y, precisision) ||\n      lt(this.max.y, aabb.min.y, precisision) ||\n      lt(aabb.max.z, this.min.z, precisision) ||\n      lt(this.max.z, aabb.min.z, precisision)\n    )\n  }\n\n  intersectsAABB(aabb: AABB): boolean {\n    assertInst(AABB, aabb)\n    return !(\n      this.min.x >= aabb.max.x ||\n      this.max.x <= aabb.min.x ||\n      this.min.y >= aabb.max.y ||\n      this.max.y <= aabb.min.y ||\n      this.min.z >= aabb.max.z ||\n      this.max.z <= aabb.min.z\n    )\n  }\n\n  intersectsAABB2d(aabb: AABB): boolean {\n    assertInst(AABB, aabb)\n    return !(\n      this.min.x >= aabb.max.x ||\n      this.max.x <= aabb.min.x ||\n      this.min.y >= aabb.max.y ||\n      this.max.y <= aabb.min.y\n    )\n  }\n\n  containsPoint(p: V3): boolean {\n    assertVectors(p)\n    return (\n      this.min.x <= p.x &&\n      this.min.y <= p.y &&\n      this.min.z <= p.z &&\n      this.max.x >= p.x &&\n      this.max.y >= p.y &&\n      this.max.z >= p.z\n    )\n  }\n\n  containsSphere(center: V3, radius: number) {\n    assertVectors(center)\n    assertNumbers(radius)\n    return this.distanceToPoint(center) > radius\n  }\n\n  intersectsSphere(center: V3, radius: number) {\n    assertVectors(center)\n    assertNumbers(radius)\n    return this.distanceToPoint(center) <= radius\n  }\n\n  distanceToPoint(p: V3) {\n    assertVectors(p)\n    const x = p.x,\n      y = p.y,\n      z = p.z\n    const min = this.min,\n      max = this.max\n    if (this.containsPoint(p)) {\n      return Math.max(\n        min.x - x,\n        x - max.x,\n        min.y - y,\n        y - max.y,\n        min.z - z,\n        z - max.z,\n      )\n    }\n    return p.distanceTo(\n      new V3(\n        clamp(x, min.x, max.x),\n        clamp(y, min.y, max.y),\n        clamp(z, min.z, max.z),\n      ),\n    )\n  }\n\n  containsAABB(aabb: AABB) {\n    assertInst(AABB, aabb)\n    return this.containsPoint(aabb.min) && this.containsPoint(aabb.max)\n  }\n\n  likeAABB(aabb: AABB): boolean {\n    assertInst(AABB, aabb)\n    return this.min.like(aabb.min) && this.max.like(aabb.max)\n  }\n\n  intersectsLine(line: {\n    anchor: V3\n    dir1: V3\n    tMin: number\n    tMax: number\n  }): boolean {\n    assertVectors(line.anchor, line.dir1)\n    const dir = line.dir1.map((el) => el || Number.MIN_VALUE)\n    const minTs = this.min.minus(line.anchor).divv(dir)\n    const maxTs = this.max.minus(line.anchor).divv(dir)\n    const tMin = minTs.min(maxTs).maxElement(),\n      tMax = minTs.max(maxTs).minElement()\n    return tMin <= tMax && !(tMax < line.tMin || line.tMax < tMin)\n  }\n\n  hasVolume(): boolean {\n    return (\n      this.min.x <= this.max.x &&\n      this.min.y <= this.max.y &&\n      this.min.z <= this.max.z\n    )\n  }\n\n  volume(): number {\n    if (!this.hasVolume()) {\n      return -1\n    }\n    const v = this.max.minus(this.min)\n    return v.x * v.y * v.z\n  }\n\n  size(): V3 {\n    return this.max.minus(this.min)\n  }\n\n  getCenter(): V3 {\n    return this.min.plus(this.max).div(2)\n  }\n\n  transform(m4: M4): this {\n    assertInst(M4, m4)\n    assert(m4.isAxisAligned())\n    const aabb = new AABB()\n    aabb.addPoint(m4.transformPoint(this.min))\n    aabb.addPoint(m4.transformPoint(this.max))\n    return aabb as this\n  }\n\n  ofTransformed(m4: M4): AABB {\n    assertInst(M4, m4)\n    const aabb = new AABB()\n    aabb.addPoints(m4.transformedPoints(this.corners()))\n    return aabb\n  }\n\n  corners(): V3[] {\n    const { min, max } = this\n    return [\n      min,\n      new V3(min.x, min.y, max.z),\n      new V3(min.x, max.y, min.z),\n      new V3(min.x, max.y, max.z),\n\n      new V3(max.x, min.y, min.z),\n      new V3(max.x, min.y, max.z),\n      new V3(max.x, max.y, min.z),\n      max,\n    ]\n  }\n\n  toString(): string {\n    return callSource(\"new AABB\", this.min, this.max)\n  }\n\n  toSource(): string {\n    return this.toString()\n  }\n\n  /** Return the matrix which transforms the AABB from V3.O to V3.XYZ to this AABB. */\n  getM4(): M4 {\n    return M4.translate(this.min).times(M4.scale(this.size()))\n  }\n}\n"],"names":["JavaMap","constructor","Symbol","toStringTag","this","_map","Map","_size","toString","Array","from","entries2","map","key","value","join","forEach","callbackfn","thisArg","bucket","values","call","keys","iterator","entries","set","set2","val","hashCode","get","pairIndex","findIndex","pair","equals","push","has","undefined","some","find","getLike","hashCodes","canonVal","x","like","setLike","index","length","delete","splice","deleteLike","deleted","clear","size","KEYWORD_REGEXP","seen","toSource","o","indent","JSON","stringify","sce","Error","addToSourceMethodToPrototype","clazz","method","prototype","Object","defineProperty","writable","configurable","enumerable","Boolean","Function","Number","RegExp","Date","getTime","String","includes","result","i","replace","pop","sort","k","test","PI","Math","TAU","NLA_DEBUG","NLA_PRECISION","cons","assertInst","what","objs","name","assertNumbers","numbers","assertInts","assert","messages","message","assertf","f","lerp","a","b","t","lerpInv","originalNumberToString","radix","eq0","EPS","abs","eq","y","lt","decimalAdjust","exp","isNaN","NaN","vs","split","round10","bind","round","GOLDEN_RATIO","floor","ceil","clamp","min","max","addOwnProperties","target","props","exclude","getOwnPropertyNames","hasOwnProperty","console","warn","getOwnPropertyDescriptor","defaultRoundFunction","MINUS","floatHashCode","DEG","root","solveCubicReal2","c","d","p","q","discriminantX4","sqrt","pqFormula","divisor","pDiv3","pDiv3Pow3","qDiv2","discriminant","r","phi","acos","t1","cbrt","cos","u1","sd","callSource","params","assertVectors","vectors","arguments","V3","Vector","newtonIterate1d","xStart","steps","epsOrDf","fx","df","dfdx","log","newtonIterateWithDerivative","results","arraySwap","arr","j","temp","arrayCopy","src","sstart","dst","dstart","arrayCopyStep","sstep","dstep","count","srcIndex","dIndex","blockSize","arrayRange","startInclusive","endExclusive","step","arrLength","arrayFromFunction","elIndex","withMax","maxVal","el","unique","uniqueSet","Set","bagRemoveIndex","removeIndexes","indexes","dstPos","nextSkip","indexesPos","srcPos","context","capitalizeFirstLetter","charAt","toUpperCase","slice","[object Object]","z","random","parallel","dot","randomUnit","zRotation","zRadius","sin","fromAngles","theta","fromFunction","fromArray","angleBetween","angleTo","zip","args","apply","normalOnPoints","to","cross","add","sub","pack","v3arr","dest","srcStart","destStart","v3count","Float32Array","destIndex","v","unpack","packedArray","packXY","unpackXY","Infinity","perturbed","delta","polar","radius","sphere","longitude","latitude","inverseLerp","ab","squared","1","2","u","minus","factor","hypot","NAMEMAP","X","Y","Z","omega","times","plus","n","atan2","roundFunction","likeO","vector","normal1","hasLength","other","O","obj","div","newLength","b1","xAbs","yAbs","zAbs","dim","hc","eps","asin","V","parseFloat","Float64Array","CustomMap","XYZ","INF","P3YZ","w","P3ZX","P3XY","Transformable","plane","transform","M4","mirror","project","translate","scale","radians","rotateX","rotateY","rotateZ","rotationCenter","rotationAxis","rotateLine","rotateAB","alpha","beta","gamma","FOO","FOO_INV","visitor","proto","getPrototypeOf","Matrix","width","height","m","identityN","permutation","fromRowArrays","rowArrays","rowIndex","new","fromColVectors","colVectors","fromColArrays","forWidthHeight","colArrays","colIndex","product","ms","isArray","copy","reduce","jacobi","x0","fx0","EPSILON","setEl","s","scalar","colNames","rowNames","toFixed","rounded","rows","unshift","row","colWidths","padEnd","padStart","matrix","precision","isSquare","transposed","equalsMatrix","uRowArrays","asRowArrays","lRowArrays","pRowArrays","currentRowIndex","maxAbsValue","pivotRowIndex","numberOfNonZeroRows","l","colIndex2","L","U","P","R","matrixForCS","qTransposed","xi","e","xk","col2","x1","x2","Q","filter","asColArrays","col","isLowerUnitriangular","isUpperTriangular","isUpperTrapezoidal","luDecomposition","solveForwards","timesVector","solveBackwards","isLowerTrapezoidal","isLowerTriangular","rank","isZero","arrayConstructor","rowArray","colArray","firstColIndex","subWidth","firstRowIndex","subHeight","blockCount","arrayCopyBlocks","fn","inversed2","inversed3","inversed4","solveForwardsMatrix","solveBackwardsMatrix","det","canMultiply","dimString","nWidth","nHeight","nM","nRowIndex","nColIndex","tWidth","tHeight","tM","tRowIndex","tColIndex","h","vIndex","absSum","getTriangularDeterminant","isPermutation","searchIndexStart","searchIndex","gauss","dependents","uRowIndex","lRowIndex","lColIndex","indexMap","permutationAsIndexMap","var_args","flattened","newItems","concat","concatenated","super","inverse","permutation4","identity","transpose","multiply","left","right","m4s","temp0","temp1","getLast","forSys","e0","e1","e2","origin","forRows","n0","n1","n2","n3","fromFunction4","perspective","fovDegrees","aspect","near","far","perspectiveRad","fov","tan","frustum","perspectivePlane","vanishingPlane","bottom","top","projectPlanePoint","np","ortho","rotate","lookAt","eye","focus","up","unit","rotationAxisLength","rotationAnchor","ax","ay","az","dx","dy","dz","nx","ny","nz","dir","nd","lineProjection","line","anchor","dir1","pointInversion","transformVector","getTranslation","m4","g","eigenValues","realEigenValues3","this3x3","IDENTITY3","mats","ev","determinant3","gauss0","eigenVector0","planeNormal","eigenVector1","getPerpendicular","eigenVector2","rejectedFrom","mat","A","as3x3","S","it","likeM4","maxOffDiagonal","maxOffDiagonalIndex","a_ii","a_kk","a_ik","atan","givensRotation","likeIdentity","sigma","SIGMA","VSTAR","every","vx","vy","vz","checkW","transformedAnchor","VV","transformedVector","transformPoint","determinant","IDENTITY","temp2","$","klop","jlnp","jkno","ilmp","ikmo","ijmn","detAbs","divScalar","start","end","chunkSize","resultLength","sliceStep","repeat","expected","isTranslation","isScaling","isNoProj","isMirror","inversed","ZXY","YZX","dims","_i","Zero","Unit","vectorCount","fromV3AndWeight","v3","weight","lengthSquared","AABB","negated","forXYZ","forAABBs","aabbs","aabb","addAABB","ps","addPoint","volume","remainingVolume","cond","dimMin","dimMax","newRemainingVolume","withElement","precisision","center","distanceToPoint","containsPoint","distanceTo","minTs","divv","maxTs","tMin","maxElement","tMax","minElement","hasVolume","isAxisAligned","addPoints","transformedPoints","corners"],"sourceRoot":""}