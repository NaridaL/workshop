(window.webpackJsonp=window.webpackJsonp||[]).push([[1],{148:function(t,e,r){"use strict";r.d(e,"a",(function(){return a})),r.d(e,"b",(function(){return g})),r.d(e,"c",(function(){return T})),r.d(e,"d",(function(){return O})),r.d(e,"e",(function(){return _}));var i=r(143),s=r(171),n=r(170);const o=WebGLRenderingContext;class a{constructor(t,e){this.target=t,this.type=e,this.buffer=void 0,this.data=[],this.count=0,this.spacing=1,this.hasBeenCompiled=!1,Object(i.p)(t==o.ARRAY_BUFFER||t==o.ELEMENT_ARRAY_BUFFER,"target == WGL.ARRAY_BUFFER || target == WGL.ELEMENT_ARRAY_BUFFER"),Object(i.p)(e==Float32Array||e==Uint16Array||e==Uint32Array,"type == Float32Array || type == Uint16Array || type == Uint32Array"),Uint16Array==e?this.bindSize=o.UNSIGNED_SHORT:Uint32Array==e&&(this.bindSize=o.UNSIGNED_INT)}compile(t=o.STATIC_DRAW,e=F()){let r;if(Object(i.p)(o.STATIC_DRAW==t||o.DYNAMIC_DRAW==t,"WGL.STATIC_DRAW == type || WGL.DYNAMIC_DRAW == type"),this.buffer=this.buffer||e.createBuffer(),0==this.data.length&&console.warn("empty buffer "+this.name),0==this.data.length||this.data[0]instanceof i.k)Object(i.p)(!(this.data[0]instanceof i.k)||this.type==Float32Array),i.k.pack(this.data,r=new this.type(3*this.data.length)),this.spacing=3,this.count=this.data.length,this.maxValue=0;else{if(Array.isArray(this.data[0])){const t=this.data.length*this.data[0].length;r=new this.type(t);let e=this.data.length,s=t;for(;e--;){const t=this.data[e];let i=t.length;for(;i--;)r[--s]=t[i]}Object(i.p)(0==s)}else r=new this.type(this.data);const t=this.data.length?r.length/this.data.length:0;Object(i.p)(t%1==0,`buffer ${this.name} elements not of consistent size, average size is `+t),i.d&&(1e4<=r.length?this.maxValue=0:this.maxValue=Math.max.apply(void 0,r)),Object(i.p)([1,2,3,4].includes(t)),this.spacing=t,this.count=this.data.length}e.bindBuffer(this.target,this.buffer),e.bufferData(this.target,r,t),this.hasBeenCompiled=!0}}const{cos:c,sin:h,PI:f,min:u,max:d}=Math,l=WebGLRenderingContext,m=new i.c,p=new i.c;class g extends i.i{constructor(){super(),this.hasBeenCompiled=!1,this.vertexBuffers={},this.indexBuffers={},this.addVertexBuffer("vertices","ts_Vertex")}calcVolume(){let t=0,e=i.k.O,r=0;const s=this.TRIANGLES,n=this.vertices;for(let o=0;o<s.length;o+=3){const a=s[o+0],c=s[o+1],h=s[o+2],f=n[a],u=n[c],d=n[h],l=u.minus(f),m=d.minus(f),p=l.cross(m);t+=i.k.add(f,u,d).div(3).z*p.z,r+=p.length();const g=i.k.add(f.times(2*f.z+u.z+d.z),u.times(f.z+2*u.z+d.z),d.times(f.z+u.z+2*d.z)).times(p.z);e=e.plus(g)}const o=t/2;return{volume:o,centroid:Object(i.w)(o)?i.k.O:e.div(24*o).schur(new i.k(1,1,.5)),area:r/2}}addVertexBuffer(t,e){return Object(i.p)(!this.vertexBuffers[e],"Buffer "+e+" already exists."),this.hasBeenCompiled=!1,Object(i.p)("string"==typeof t),Object(i.p)("string"==typeof e),(this.vertexBuffers[e]=new a(l.ARRAY_BUFFER,Float32Array)).name=t,this[t]=[],this}addIndexBuffer(t,e=l.UNSIGNED_SHORT){this.hasBeenCompiled=!1;const r=l.UNSIGNED_SHORT==e?Uint16Array:Uint32Array;return(this.indexBuffers[t]=new a(l.ELEMENT_ARRAY_BUFFER,r)).name=t,this[t]=[],this}concat(...t){const e=new g,r=[this].concat(t);return Object.getOwnPropertyNames(this.vertexBuffers).forEach(s=>{Object(i.p)(t.every(t=>!!t.vertexBuffers[s]));const n=this.vertexBuffers[s].name;"ts_Vertex"!==s&&e.addVertexBuffer(n,s),e[n]=[].concat(...r.map(t=>t[n]))}),Object.getOwnPropertyNames(this.indexBuffers).forEach(s=>{Object(i.p)(t.every(t=>!!t.indexBuffers[s])),e.addIndexBuffer(s,this.indexBuffers[s].bindSize);const n=Array(r.reduce((t,e)=>t+e[s].length,0));let o=0,a=0;for(const t of r){for(const e of t[s])n[o++]=a+e;a+=t.vertices.length}e[s]=n}),e.compile(),e}compile(t=F()){let e=1/0;Object.getOwnPropertyNames(this.vertexBuffers).forEach(r=>{const i=this.vertexBuffers[r];i.data=this[i.name],i.compile(void 0,t),this[i.name].length<e&&(e=this[i.name].length)});for(const e in this.indexBuffers){const r=this.indexBuffers[e];r.data=this[r.name],r.compile(void 0,t)}return this.hasBeenCompiled=!0,this}static fromBinarySTL(t){return Object(s.a)(this,void 0,void 0,(function*(){return new Promise((e,r)=>{const s=(new g).addVertexBuffer("normals","ts_Normal"),n=new FileReader;n.onerror=r,n.onload=function(t){const r=new DataView(this.result),n=r.getUint32(80,!0);s.normals.length=3*n,s.vertices.length=3*n;let o=3*n,a=84;function c(){const t=r.getFloat32(a,!0);a+=4;const e=r.getFloat32(a,!0);a+=4;const s=r.getFloat32(a,!0);return a+=4,new i.k(t,e,s)}for(;o;){o-=3;const t=c();s.normals[o+0]=t,s.normals[o+1]=t,s.normals[o+2]=t,s.vertices[o+0]=c(),s.vertices[o+1]=c(),s.vertices[o+2]=c(),a+=2}e(s)},n.readAsArrayBuffer(t)})}))}toBinarySTL(){if(!this.TRIANGLES)throw Error("TRIANGLES must be defined.");const t=this.TRIANGLES,e=t.length/3,r=new ArrayBuffer(84+50*e),s=new DataView(r);s.setUint32(80,e,!0);let n=84,o=t.length;for(;o;){o-=3;const e=this.vertices[t[o]],r=this.vertices[t[o+1]],a=this.vertices[t[o+2]];[i.k.normalOnPoints(e,r,a),e,r,a].forEach(t=>{s.setFloat32(n,t.x,!0),n+=4,s.setFloat32(n,t.y,!0),n+=4,s.setFloat32(n,t.z,!0),n+=4}),n+=2}return Object(i.p)(n==r.byteLength,n+" "+r.byteLength),new Blob([r],{type:"application/octet-stream"})}transform(t){const e=new g;if(e.vertices=t.transformedPoints(this.vertices),this.normals){e.addVertexBuffer("normals","ts_Normal");const r=t.as3x3(m).inversed(p).transposed(m);e.normals=this.normals.map(t=>r.transformVector(t).unit())}for(const t in this.indexBuffers)e.addIndexBuffer(t),e[t]=this[t];for(const t in this.vertexBuffers)if("ts_Vertex"!==t&&"ts_Normal"!==t){const r=this.vertexBuffers[t].name;e.addVertexBuffer(r,t),e[r]=this[r]}return e}computeNormalsFromFlatTriangles(){this.normals||this.addVertexBuffer("normals","ts_Normal");const t=this.TRIANGLES,e=this.vertices,r=this.normals;r.length=e.length;for(let i=0;i<t.length;i+=3){const s=t[i],n=t[i+1],o=t[i+2],a=e[s],c=e[n],h=e[o],f=c.minus(a).cross(h.minus(a)).unit();r[s]=r[s]?r[s].plus(f):f,r[n]=r[n]?r[n].plus(f):f,r[o]=r[o]?r[o].plus(f):f}for(let t=0;t<e.length;t++)r[t]=r[t].unit();return this.hasBeenCompiled=!1,this}computeWireframeFromFlatTriangles(t="LINES"){if(!this.TRIANGLES)throw Error("TRIANGLES must be defined.");const e=new Set;function r(t,e){return u(t,e)<<16|d(t,e)}const i=this.TRIANGLES;for(let t=0;t<i.length;t+=3)e.add(r(i[t+0],i[t+1])),e.add(r(i[t+1],i[t+2])),e.add(r(i[t+2],i[t+0]));const s=t;return this[s]||this.addIndexBuffer(t),e.forEach(t=>this[s].push(t>>16,65535&t)),this.hasBeenCompiled=!1,this}computeWireframeFromFlatTrianglesClosedMesh(t="LINES"){if(!this.TRIANGLES)throw Error("TRIANGLES must be defined.");this.LINES||this.addIndexBuffer("LINES");const e=this.TRIANGLES;this[t]||this.addIndexBuffer(t);const r=this[t];for(let t=0;t<e.length;t+=3)e[t+0]<e[t+1]&&r.push(e[t+0],e[t+1]),e[t+1]<e[t+2]&&r.push(e[t+1],e[t+2]),e[t+2]<e[t+0]&&r.push(e[t+2],e[t+0]);return this.hasBeenCompiled=!1,this}computeNormalLines(t=1,e="LINES"){if(!this.normals)throw Error("normals must be defined.");const r=this.vertices,i=this.vertices.length;this[e]||this.addIndexBuffer(e);for(let s=0;s<this.normals.length;s++)r[i+s]=r[s].plus(this.normals[s].toLength(t)),this[e].push(i+s,s);return this.hasBeenCompiled=!1,this}getAABB(){return(new i.a).addPoints(this.vertices)}getBoundingSphere(){const t={center:this.getAABB().getCenter(),radius:0};for(let e=0;e<this.vertices.length;e++)t.radius=Math.max(t.radius,this.vertices[e].minus(t.center).length());return t}static plane(t={}){const e=t.detailX||t.detail||1,r=t.detailY||t.detail||1,s=t.startX||0,n=t.startY||0,o=t.width||1,a=t.height||1,c=(new g).addIndexBuffer("LINES").addIndexBuffer("TRIANGLES").addVertexBuffer("normals","ts_Normal").addVertexBuffer("coords","ts_TexCoord");for(let t=0;t<=r;t++){const h=t/r;for(let f=0;f<=e;f++){const u=f/e;if(c.vertices.push(new i.k(s+u*o,n+h*a,0)),c.coords.push([u,h]),c.normals.push(i.k.Z),f<e&&t<r){const r=f+t*(e+1);c.TRIANGLES.push(r,r+1,r+e+1,r+e+1,r+1,r+e+2)}}}for(let t=0;t<e;t++)c.LINES.push(t,t+1),c.LINES.push((e+1)*r+t,(e+1)*r+t+1);for(let t=0;t<r;t++)c.LINES.push(e*t,e*(t+1)+1),c.LINES.push(e*(t+1),e*(t+2)+1);return c.compile(),c}static box(t=1,e=1,r=1){const s=(new g).addIndexBuffer("LINES").addIndexBuffer("TRIANGLES").addVertexBuffer("normals","ts_Normal");s.vertices.length=s.normals.length=2*((t+1)*(e+1)+(e+1)*(r+1)+(r+1)*(t+1)),s.TRIANGLES.length=4*(t*e+e*r+r*t);let n=0,o=0;function a(t,e,r,a=0,c=1,h=0,f=1){const u=r.transformVector(i.k.Z);for(let d=0;d<=e;d++){const l=d/e;for(let m=0;m<=t;m++){const p=m/t;if(s.vertices[n]=r.transformPoint(new i.k(a+p*c,h+l*f,0)),s.normals[n]=u,n++,m<t&&d<e){const e=m+d*(t+1);s.TRIANGLES[o++]=e,s.TRIANGLES[o++]=e+t+1,s.TRIANGLES[o++]=e+1,s.TRIANGLES[o++]=e+t+1,s.TRIANGLES[o++]=e+t+2,s.TRIANGLES[o++]=e+1}}}}return a(e,t,i.c.forSys(i.k.Y,i.k.X,i.k.Z.negated())),a(t,e,i.c.translate(i.k.Z)),a(r,e,i.c.forSys(i.k.Z,i.k.Y,i.k.X.negated())),a(e,r,i.c.forSys(i.k.Y,i.k.Z,i.k.X,i.k.X)),a(t,r,i.c.forSys(i.k.X,i.k.Z,i.k.Y.negated())),a(r,t,i.c.forSys(i.k.Z,i.k.X,i.k.Y,i.k.Y)),s}static cube(){const t=(new g).addVertexBuffer("normals","ts_Normal").addIndexBuffer("TRIANGLES").addIndexBuffer("LINES"),e=[[0,4,6,2],[1,3,7,5],[0,1,5,4],[2,6,7,3],[0,2,3,1],[4,5,7,6]],r=[i.k.X.negated(),i.k.X,i.k.Y.negated(),i.k.Y,i.k.Z.negated(),i.k.Z];for(let i=0;i<6;i++)V(t.TRIANGLES,!0,t.vertices.length,t.vertices.length+1,t.vertices.length+3,t.vertices.length+2),t.vertices.push(...e[i].map(t=>g.UNIT_CUBE_CORNERS[t])),t.normals.push(r[i],r[i],r[i],r[i]);return t.LINES=[[0,1],[0,2],[1,3],[2,3],[0,4],[1,5],[2,6],[3,7],[4,5],[4,6],[5,7],[6,7]].flatMap(t=>t).map(t=>{let r=0;return 4*e.findIndex(e=>-1!=(r=e.indexOf(t)))+r}),t.compile(),t}static isocahedron(){return g.sphere(0)}static sphere2(t,e){const r=Object(i.m)(t,e=>{const r=e/(t-1)*f-f/2;return new i.k(0,c(r),h(r))}),s=Object(i.m)(t,e=>{const r=c(e/(t-1)*f-f/2);return[e/(t-1)*r,r]});return g.rotation(r,{anchor:i.k.O,dir1:i.k.Z},2*f,e,!0,r,s)}static sphere(t=3){const e=new i.k(1,1.618033988749895,0).unit(),r=e.x,s=e.y,n=[new i.k(-r,s,0),new i.k(r,s,0),new i.k(-r,-s,0),new i.k(r,-s,0),new i.k(0,-r,s),new i.k(0,r,s),new i.k(0,-r,-s),new i.k(0,r,-s),new i.k(s,0,-r),new i.k(s,0,r),new i.k(-s,0,-r),new i.k(-s,0,r)],o=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];function a(t,e,r,i,s,n,o,c,h,f){if(0==i)n.push(o,c,h),o<c&&f.push(o,c),c<h&&f.push(c,h),h<o&&f.push(h,o);else{const u=t.plus(e).toLength(1),d=e.plus(r).toLength(1),l=r.plus(t).toLength(1),m=s.length,p=m+1,g=m+2;s.push(u,d,l),a(u,d,l,i-1,s,n,m,p,g,f),a(t,u,l,i-1,s,n,o,m,g,f),a(e,d,u,i-1,s,n,c,p,m,f),a(r,l,d,i-1,s,n,h,g,p,f)}}const c=(new g).addVertexBuffer("normals","ts_Normal").addIndexBuffer("TRIANGLES").addIndexBuffer("LINES");c.vertices.push(...n),t=null==t?4:t;for(let e=0;e<20;e++){const[r,i,s]=o.slice(3*e,3*e+3);a(n[r],n[i],n[s],t,c.vertices,c.TRIANGLES,r,i,s,c.LINES)}return c.normals=c.vertices,c.compile(),c}static aabb(t){const e=i.c.product(i.c.translate(t.min),i.c.scale(t.size().max(new i.k(i.e,i.e,i.e)))),r=g.cube().transform(e);return r.computeNormalLines(20),r.compile(),r}static offsetVertices(t,e,r,s){i.r.apply(void 0,t),Object(i.r)(e);const n=(new g).addIndexBuffer("TRIANGLES").addVertexBuffer("coords","ts_TexCoord");s&&n.addVertexBuffer("normals","ts_Normal"),n.vertices=t.concat(t.map(t=>t.plus(e)));const o=t.length;n.coords=Object(i.m)(2*o,t=>[t%o/o,t/o|0]);const a=n.TRIANGLES;for(let e=0;e<t.length-1;e++)V(a,!1,e,e+1,t.length+e,t.length+e+1);return r&&V(a,!1,t.length-1,0,2*t.length-1,t.length),s&&(n.normals=s.concat(s)),n.compile(),n}static rotation(t,e,r,s,n=!0,o,a){const c=(new g).addIndexBuffer("TRIANGLES");o&&c.addVertexBuffer("normals","ts_Normal"),a&&c.addVertexBuffer("coordsUVQ","ts_TexCoordUVQ");const h=t.length,f=h*s,u=new i.c,d=c.TRIANGLES;for(let l=0;l<s;l++){const m=r*(l/s);if(i.c.rotateLine(e.anchor,e.dir1,m,u),c.vertices.push(...u.transformedPoints(t)),o&&c.normals.push(...u.transformedVectors(o)),a&&c.coordsUVQ.push(...a.map(([t,e])=>[l/s*e,t,e])),n||l!==s-1)for(let t=0;t<h-1;t++)V(d,!1,l*h+t+1,l*h+t,((l+1)*h+t+1)%f,((l+1)*h+t)%f)}return c.compile(),c}static spiral(t,e,r,s,n,o,a){const c=(new g).addIndexBuffer("TRIANGLES");o&&c.addVertexBuffer("normals","ts_Normal"),a&&c.addVertexBuffer("coordsUVQ","ts_TexCoordUVQ");const h=t.length,f=h*s,u=new i.c,d=c.TRIANGLES;for(let l=0;l<s;l++){const m=r*(l/s);if(i.c.rotateLine(e.anchor,e.dir1,m,u),c.vertices.push(...u.translate(e.dir1.toLength(r/i.h*(l/s)*n)).transformedPoints(t)),o&&c.normals.push(...u.transformedVectors(o)),a&&c.coordsUVQ.push(...a.map(([t,e])=>[l/s*e,t,e])),l!==s-1)for(let t=0;t<h-1;t++)V(d,!1,l*h+t+1,l*h+t,((l+1)*h+t+1)%f,((l+1)*h+t)%f)}return c.compile(),c}static parametric(t,e,r,s,n,o,a,c){const h=(new g).addIndexBuffer("TRIANGLES").addVertexBuffer("normals","ts_Normal");for(let f=0;f<=a;f++){const u=Object(i.x)(r,s,f/a);for(let r=0;r<=c;r++){const s=Object(i.x)(n,o,r/c);if(h.vertices.push(t(u,s)),e&&h.normals.push(e(u,s)),r<c&&f<a){const t=r+f*(c+1);V(h.TRIANGLES,!1,t,t+c+1,t+1,t+c+2)}}}return h}static load(t){const e=new g;if(!Array.isArray(t.vertices[0]))throw Error();return e.vertices=t.vertices.map(t=>Object(i.j)(t)),t.triangles&&(e.addIndexBuffer("TRIANGLES"),e.TRIANGLES=t.triangles),t.normals&&(e.addVertexBuffer("normals","ts_Normal"),e.normals=t.normals),e.compile(),e}toJSON(){return{vertices:this.vertices.map(t=>t.toArray()),TRIANGLES:this.TRIANGLES}}}g.UNIT_CUBE_CORNERS=[i.k.O,new i.k(0,0,1),new i.k(0,1,0),new i.k(0,1,1),new i.k(1,0,0),new i.k(1,0,1),new i.k(1,1,0),i.k.XYZ];const x=WebGLRenderingContext,E={[x.POINTS]:"POINTS",[x.LINES]:"LINES",[x.LINE_STRIP]:"LINE_STRIP",[x.LINE_LOOP]:"LINE_LOOP",[x.TRIANGLES]:"TRIANGLES",[x.TRIANGLE_STRIP]:"TRIANGLE_STRIP",[x.TRIANGLE_FAN]:"TRIANGLE_FAN"},w={[x.POINTS]:t=>!0,[x.LINES]:t=>0==t%2,[x.LINE_STRIP]:t=>t>2,[x.LINE_LOOP]:t=>t>2,[x.TRIANGLES]:t=>0==t%3,[x.TRIANGLE_STRIP]:t=>t>3,[x.TRIANGLE_FAN]:t=>t>3};function b(t){return Float32Array==t.constructor||Float64Array==t.constructor||Array.isArray(t)&&t.every(t=>"number"==typeof t)}function A(t){return!![Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array].some(e=>t instanceof e)||(t instanceof Float32Array||t instanceof Float64Array||Array.isArray(t))&&t.every(t=>Number.isInteger(t))}class T{constructor(t,e,r=F(),i){this.gl=r,this.name=i,this.projectionMatrixVersion=-1,this.modelViewMatrixVersion=-1,this.outputWarnings={};const s="\n\t\tuniform mat3 ts_NormalMatrix;\n\t\tuniform mat4 ts_ModelViewMatrix;\n\t\tuniform mat4 ts_ProjectionMatrix;\n\t\tuniform mat4 ts_ModelViewProjectionMatrix;\n\t\tuniform mat4 ts_ModelViewMatrixInverse;\n\t\tuniform mat4 ts_ProjectionMatrixInverse;\n\t\tuniform mat4 ts_ModelViewProjectionMatrixInverse;\n\t".match(/\bts_\w+/g);function n(t,e){const i=r.createShader(t);if(r.shaderSource(i,e),r.compileShader(i),!r.getShaderParameter(i,r.COMPILE_STATUS))throw Error("compile error: "+r.getShaderInfoLog(i));return i}if(this.program=r.createProgram(),r.attachShader(this.program,n(r.VERTEX_SHADER,t)),r.attachShader(this.program,n(r.FRAGMENT_SHADER,e)),r.linkProgram(this.program),!r.getProgramParameter(this.program,r.LINK_STATUS))throw Error("link error: "+r.getProgramInfoLog(this.program));this.attributeLocations={},this.uniformLocations={},this.constantAttributes={},this.activeMatrices={},s&&s.forEach(t=>{r.getUniformLocation(this.program,t)&&(this.activeMatrices[t]=!0)}),this.uniformInfos={};for(let t=r.getProgramParameter(this.program,r.ACTIVE_UNIFORMS);t-- >0;){const e=r.getActiveUniform(this.program,t);this.uniformInfos[e.name]=e}}static create(t,e,r,i){return new T(t,e,r,i)}uniforms(t){const e=this.gl;e.useProgram(this.program);for(const r in t){const s=this.uniformLocations[r]||e.getUniformLocation(this.program,r);if(!s)continue;this.uniformLocations[r]=s;let n=t[r];const o=this.uniformInfos[r];if(i.d){if(!o)throw Error(`uniform ${r} is not defined (available = ${Object.keys(this.uniformInfos).join(",")})`);e.SAMPLER_2D!=o.type&&e.SAMPLER_CUBE!=o.type&&e.INT!=o.type||(1==o.size?Object(i.p)(Number.isInteger(n)):Object(i.p)(A(n)&&n.length==o.size,"value must be int array if info.size != 1")),Object(i.p)(e.FLOAT!=o.type||1==o.size&&"number"==typeof n||b(n)),Object(i.p)(e.FLOAT_VEC3!=o.type||1==o.size&&n instanceof i.k||Array.isArray(n)&&o.size==n.length&&Object(i.r)(...n)),Object(i.p)(e.FLOAT_VEC4!=o.type||1!=o.size||b(n)&&4==n.length),Object(i.p)(e.FLOAT_MAT4!=o.type||n instanceof i.c,()=>n.toSource()),Object(i.p)(e.FLOAT_MAT3!=o.type||9==n.length||n instanceof i.c)}if(n instanceof i.k&&(n=n.toArray()),e.FLOAT_VEC4==o.type&&1!=o.size)n instanceof Float32Array||n instanceof Float64Array?e.uniform4fv(s,n instanceof Float32Array?n:Float32Array.from(n)):e.uniform4fv(s,n.flatMap(t=>t));else if(e.FLOAT==o.type&&1!=o.size)e.uniform1fv(s,n);else if(e.FLOAT_VEC3==o.type&&1!=o.size)e.uniform3fv(s,i.k.pack(n));else if(n.length)switch(n.length){case 1:e.uniform1fv(s,n);break;case 2:e.uniform2fv(s,n);break;case 3:e.uniform3fv(s,n);break;case 4:e.uniform4fv(s,n);break;case 9:e.uniformMatrix3fv(s,!1,new Float32Array([n[0],n[3],n[6],n[1],n[4],n[7],n[2],n[5],n[8]]));break;case 16:e.uniformMatrix4fv(s,!1,new Float32Array([n[0],n[4],n[8],n[12],n[1],n[5],n[9],n[13],n[2],n[6],n[10],n[14],n[3],n[7],n[11],n[15]]));break;default:throw Error("don't know how to load uniform \""+r+'" of length '+n.length)}else if("number"==typeof n)e.SAMPLER_2D==o.type||e.SAMPLER_CUBE==o.type||e.INT==o.type?e.uniform1i(s,n):e.uniform1f(s,n);else if("boolean"==typeof n)e.uniform1i(s,+n);else{if(!(n instanceof i.c))throw Error('attempted to set uniform "'+r+'" to invalid value '+n);{const t=n.m;if(e.FLOAT_MAT4==o.type)e.uniformMatrix4fv(s,!1,[t[0],t[4],t[8],t[12],t[1],t[5],t[9],t[13],t[2],t[6],t[10],t[14],t[3],t[7],t[11],t[15]]);else if(e.FLOAT_MAT3==o.type)e.uniformMatrix3fv(s,!1,[t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]]);else{if(e.FLOAT_MAT2!=o.type)throw Error("Can't assign M4 to "+o.type);e.uniformMatrix2fv(s,!1,new Float32Array([t[0],t[4],t[1],t[5]]))}}}}return this}attributes(t){const e=this.gl;e.useProgram(this.program);for(const r in t){const s=this.attributeLocations[r]||e.getAttribLocation(this.program,r);if(-1==s){r.startsWith("ts_")||console.warn(`[shader ${this.name}] Vertex buffer ${r} was not bound because the attribute is not active.`);continue}this.attributeLocations[r]=s,e.disableVertexAttribArray(s);let n=t[r];n instanceof i.k&&(n=n.toArray()),"number"==typeof n?e.vertexAttrib1f(s,n):e.vertexAttrib4fv(s,n),this.constantAttributes[r]=!0}return this}draw(t,e=x.TRIANGLES,r,s){Object(i.p)(t.hasBeenCompiled,"mesh.hasBeenCompiled"),Object(i.p)(null!=E[e]);const n=E[e];return this.drawBuffers(t.vertexBuffers,t.indexBuffers[n],e,r,s)}drawBuffers(t,e,r=x.TRIANGLES,s=0,n){const o=this.gl;Object(i.p)(null!=E[r]),Object(i.s)(()=>1<=Object.keys(t).length),Object.keys(t).forEach(e=>Object(i.q)(a,t[e]));const c=this.activeMatrices,h=(c.ts_ModelViewMatrixInverse||c.ts_NormalMatrix)&&o.modelViewMatrix.inversed(),f=c.ts_ProjectionMatrixInverse&&o.projectionMatrix.inversed(),u=(c.ts_ModelViewProjectionMatrix||c.ts_ModelViewProjectionMatrixInverse)&&o.projectionMatrix.times(o.modelViewMatrix),d={};c.ts_ModelViewMatrix&&this.modelViewMatrixVersion!=o.modelViewMatrixVersion&&(d.ts_ModelViewMatrix=o.modelViewMatrix),c.ts_ModelViewMatrixInverse&&(d.ts_ModelViewMatrixInverse=h),c.ts_ProjectionMatrix&&this.projectionMatrixVersion!=o.projectionMatrixVersion&&(d.ts_ProjectionMatrix=o.projectionMatrix),f&&(d.ts_ProjectionMatrixInverse=f),u&&(d.ts_ModelViewProjectionMatrix=u),u&&c.ts_ModelViewProjectionMatrixInverse&&(d.ts_ModelViewProjectionMatrixInverse=u.inversed()),c.ts_NormalMatrix&&this.modelViewMatrixVersion!=o.modelViewMatrixVersion&&(d.ts_NormalMatrix=h.transposed()),this.uniforms(d),this.projectionMatrixVersion=o.projectionMatrixVersion,this.modelViewMatrixVersion=o.modelViewMatrixVersion;let l=1/0;for(const e in t){const r=t[e];Object(i.p)(r.hasBeenCompiled);const s=this.attributeLocations[e]||o.getAttribLocation(this.program,e);-1!=s&&r.buffer?(this.attributeLocations[e]=s,o.bindBuffer(x.ARRAY_BUFFER,r.buffer),o.enableVertexAttribArray(s),o.vertexAttribPointer(s,r.spacing,x.FLOAT,!1,0,0),l=Math.min(l,r.count)):e.startsWith("ts_")||console.warn(`[shader ${this.name}] Vertex buffer ${e} was not bound because the attribute is not active.`)}for(const e in this.attributeLocations)e in t||o.disableVertexAttribArray(this.attributeLocations[e]);if(i.d){const t=o.getProgramParameter(this.program,o.ACTIVE_ATTRIBUTES);for(let e=0;e<t;++e)if(!o.getVertexAttrib(e,o.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING)){const t=o.getActiveAttrib(this.program,e);this.constantAttributes[t.name]||this.outputWarnings[t.name]||(this.outputWarnings[t.name]=!0,console.warn("No buffer is bound to attribute "+t.name+" and it was not set with .attributes()"))}}if(l){if(void 0===n&&(n=e?e.count:l),Object(i.p)(w[r](n),"count "+n+"doesn't fulfill requirement +"+w[r].toString()+" for mode "+E[r]),e){if(Object(i.p)(e.hasBeenCompiled),Object(i.p)(l>e.maxValue),Object(i.p)(n%e.spacing==0),Object(i.p)(s%e.spacing==0),s+n>e.count)throw Error("Buffer not long enough for passed parameters start/length/buffer length "+s+" "+n+" "+e.count);o.bindBuffer(x.ELEMENT_ARRAY_BUFFER,e.buffer),o.drawElements(r,n,e.bindSize,e.type.BYTES_PER_ELEMENT*s)}else{if(s+n>l)throw Error("invalid");o.drawArrays(r,s,n)}o.drawCallCount++}return this}}class _{constructor(t,e,r={},i=F()){this.gl=i,this.width=t,this.height=e,this.format=r.format||i.RGBA,this.internalFormat=r.internalFormat||i.RGBA,this.type=r.type||i.UNSIGNED_BYTE;const s=r.filter||r.magFilter||i.LINEAR,n=r.filter||r.minFilter||i.LINEAR;if(this.type===i.FLOAT){if(2!=i.version&&!i.getExtension("OES_texture_float"))throw Error("OES_texture_float is required but not supported");if((n!==i.NEAREST||s!==i.NEAREST)&&!i.getExtension("OES_texture_float_linear"))throw Error("OES_texture_float_linear is required but not supported")}else if(this.type===i.HALF_FLOAT_OES){if(!i.getExtension("OES_texture_half_float"))throw Error("OES_texture_half_float is required but not supported");if((n!==i.NEAREST||s!==i.NEAREST)&&!i.getExtension("OES_texture_half_float_linear"))throw Error("OES_texture_half_float_linear is required but not supported")}this.texture=i.createTexture(),i.bindTexture(i.TEXTURE_2D,this.texture),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MAG_FILTER,s),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MIN_FILTER,n),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_S,r.wrap||r.wrapS||i.CLAMP_TO_EDGE),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_T,r.wrap||r.wrapT||i.CLAMP_TO_EDGE),i.texImage2D(i.TEXTURE_2D,0,this.internalFormat,t,e,0,this.format,this.type,r.data)}setData(t){this.gl.bindTexture(this.gl.TEXTURE_2D,this.texture),this.gl.texImage2D(this.gl.TEXTURE_2D,0,this.internalFormat,this.width,this.height,0,this.format,this.type,t)}downloadData(t){if(!this.framebuffer)throw Error("No framebuffer. You need to draw to this texture before it makes sense to read from it.");const e=this.gl,r=e.getParameter(e.FRAMEBUFFER_BINDING);this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,this.framebuffer),this.gl.readPixels(0,0,this.width,this.height,this.format,this.type,t),r!==this.framebuffer&&e.bindFramebuffer(e.FRAMEBUFFER,r)}bind(t){this.gl.activeTexture(this.gl.TEXTURE0+t),this.gl.bindTexture(this.gl.TEXTURE_2D,this.texture)}unbind(t){this.gl.activeTexture(this.gl.TEXTURE0+t),this.gl.bindTexture(this.gl.TEXTURE_2D,null)}drawTo(t){const e=this.gl,r=e.getParameter(e.FRAMEBUFFER_BINDING);if(this.framebuffer)r!==this.framebuffer&&e.bindFramebuffer(e.FRAMEBUFFER,this.framebuffer);else{const t=e.getParameter(e.RENDERBUFFER_BINDING),r=e.createRenderbuffer();if(e.bindRenderbuffer(e.RENDERBUFFER,r),e.renderbufferStorage(e.RENDERBUFFER,e.DEPTH_COMPONENT16,this.width,this.height),e.bindRenderbuffer(e.RENDERBUFFER,t),this.framebuffer=e.createFramebuffer(),e.bindFramebuffer(e.FRAMEBUFFER,this.framebuffer),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,this.texture,0),e.framebufferRenderbuffer(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.RENDERBUFFER,r),e.checkFramebufferStatus(e.FRAMEBUFFER)!==e.FRAMEBUFFER_COMPLETE)throw Error("Rendering to this texture is not supported (incomplete this.framebuffer)")}const i=e.getParameter(e.VIEWPORT);e.viewport(0,0,this.width,this.height),t(e),r!==this.framebuffer&&e.bindFramebuffer(e.FRAMEBUFFER,r),e.viewport(i[0],i[1],i[2],i[3])}swapWith(t){let e;Object(i.p)(this.gl==t.gl),e=t.texture,t.texture=this.texture,this.texture=e,e=t.width,t.width=this.width,this.width=e,e=t.height,t.height=this.height,this.height=e,e=t.framebuffer,t.framebuffer=this.framebuffer,this.framebuffer=e}static fromImage(t,e={},r=F()){const i=new _(t.width,t.height,e,r);try{r.texImage2D(r.TEXTURE_2D,0,i.format,i.format,i.type,t)}catch(t){throw"file:"==location.protocol?Error('imgElement not loaded for security reasons (serve this page over "http://" instead)'):Error("imgElement not loaded for security reasons (imgElement must originate from the same domain as this page or use Cross-Origin Resource Sharing)")}return e.minFilter&&e.minFilter!=r.NEAREST&&e.minFilter!=r.LINEAR&&r.generateMipmap(r.TEXTURE_2D),i}static fromURLSwitch(t,e,r=F()){_.checkerBoardCanvas=_.checkerBoardCanvas||function(){const t=document.createElement("canvas").getContext("2d");if(!t)throw Error("Could not create 2d canvas.");t.canvas.width=t.canvas.height=128;for(let e=0;e<t.canvas.height;e+=16)for(let r=0;r<t.canvas.width;r+=16)t.fillStyle=16&(r^e)?"#FFF":"#DDD",t.fillRect(r,e,16,16);return t.canvas}();const i=_.fromImage(_.checkerBoardCanvas,e),s=new Image;return s.onload=()=>_.fromImage(s,e,r).swapWith(i),s.onerror=()=>{throw Error("Could not load image "+s.src+". 404?")},s.src=t,i}static fromURL(t,e,r=F()){return new Promise((i,s)=>{const n=new Image;n.onload=()=>i(_.fromImage(n,e,r)),n.onerror=t=>s("Could not load image "+n.src+". 404?"+t),n.src=t})}}WebGLRenderingContext;const R={enable:{1:{0:!0}},disable:{1:{0:!0}},getParameter:{1:{0:!0}},drawArrays:{3:{0:!0}},drawElements:{4:{0:!0,2:!0}},createShader:{1:{0:!0}},getShaderParameter:{2:{1:!0}},getProgramParameter:{2:{1:!0}},getShaderPrecisionFormat:{2:{0:!0,1:!0}},getVertexAttrib:{2:{1:!0}},vertexAttribPointer:{6:{2:!0}},bindTexture:{2:{0:!0}},activeTexture:{1:{0:!0}},getTexParameter:{2:{0:!0,1:!0}},texParameterf:{3:{0:!0,1:!0}},texParameteri:{3:{0:!0,1:!0,2:!0}},copyTexImage2D:{8:{0:!0,2:!0}},copyTexSubImage2D:{8:{0:!0}},generateMipmap:{1:{0:!0}},bindBuffer:{2:{0:!0}},getBufferParameter:{2:{0:!0,1:!0}},pixelStorei:{2:{0:!0,1:!0}},bindRenderbuffer:{2:{0:!0}},bindFramebuffer:{2:{0:!0}},checkFramebufferStatus:{1:{0:!0}},framebufferRenderbuffer:{4:{0:!0,1:!0,2:!0}},framebufferTexture2D:{5:{0:!0,1:!0,2:!0}},getFramebufferAttachmentParameter:{3:{0:!0,1:!0,2:!0}},getRenderbufferParameter:{2:{0:!0,1:!0}},renderbufferStorage:{4:{0:!0,1:!0}},clear:{1:{0:{enumBitwiseOr:["COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","STENCIL_BUFFER_BIT"]}}},depthFunc:{1:{0:!0}},blendFunc:{2:{0:!0,1:!0}},blendFuncSeparate:{4:{0:!0,1:!0,2:!0,3:!0}},blendEquation:{1:{0:!0}},blendEquationSeparate:{2:{0:!0,1:!0}},stencilFunc:{3:{0:!0}},stencilFuncSeparate:{4:{0:!0,1:!0}},stencilMaskSeparate:{2:{0:!0}},stencilOp:{3:{0:!0,1:!0,2:!0}},stencilOpSeparate:{4:{0:!0,1:!0,2:!0,3:!0}},cullFace:{1:{0:!0}},frontFace:{1:{0:!0}},drawArraysInstancedANGLE:{4:{0:!0}},drawElementsInstancedANGLE:{5:{0:!0,2:!0}},blendEquationEXT:{1:{0:!0}},bufferData:{3:{0:!0,2:!0},4:{0:!0,2:!0},5:{0:!0,2:!0}},bufferSubData:{3:{0:!0},4:{0:!0},5:{0:!0}},copyBufferSubData:{5:{0:!0,1:!0}},getBufferSubData:{3:{0:!0},4:{0:!0},5:{0:!0}},blitFramebuffer:{10:{8:{enumBitwiseOr:["COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","STENCIL_BUFFER_BIT"]},9:!0}},framebufferTextureLayer:{5:{0:!0,1:!0}},invalidateFramebuffer:{2:{0:!0}},invalidateSubFramebuffer:{6:{0:!0}},readBuffer:{1:{0:!0}},getInternalformatParameter:{3:{0:!0,1:!0,2:!0}},renderbufferStorageMultisample:{5:{0:!0,2:!0}},texStorage2D:{5:{0:!0,2:!0}},texStorage3D:{6:{0:!0,2:!0}},texImage2D:{9:{0:!0,2:!0,6:!0,7:!0},6:{0:!0,2:!0,3:!0,4:!0},10:{0:!0,2:!0,6:!0,7:!0}},texImage3D:{10:{0:!0,2:!0,7:!0,8:!0},11:{0:!0,2:!0,7:!0,8:!0}},texSubImage2D:{9:{0:!0,6:!0,7:!0},7:{0:!0,4:!0,5:!0},10:{0:!0,6:!0,7:!0}},texSubImage3D:{11:{0:!0,8:!0,9:!0},12:{0:!0,8:!0,9:!0}},copyTexSubImage3D:{9:{0:!0}},compressedTexImage2D:{7:{0:!0,2:!0},8:{0:!0,2:!0},9:{0:!0,2:!0}},compressedTexImage3D:{8:{0:!0,2:!0},9:{0:!0,2:!0},10:{0:!0,2:!0}},compressedTexSubImage2D:{8:{0:!0,6:!0},9:{0:!0,6:!0},10:{0:!0,6:!0}},compressedTexSubImage3D:{10:{0:!0,8:!0},11:{0:!0,8:!0},12:{0:!0,8:!0}},vertexAttribIPointer:{5:{2:!0}},drawArraysInstanced:{4:{0:!0}},drawElementsInstanced:{5:{0:!0,2:!0}},drawRangeElements:{6:{0:!0,4:!0}},readPixels:{7:{4:!0,5:!0},8:{4:!0,5:!0}},clearBufferfv:{3:{0:!0},4:{0:!0}},clearBufferiv:{3:{0:!0},4:{0:!0}},clearBufferuiv:{3:{0:!0},4:{0:!0}},clearBufferfi:{4:{0:!0}},beginQuery:{2:{0:!0}},endQuery:{1:{0:!0}},getQuery:{2:{0:!0,1:!0}},getQueryParameter:{2:{1:!0}},samplerParameteri:{3:{1:!0,2:!0}},samplerParameterf:{3:{1:!0}},getSamplerParameter:{2:{1:!0}},fenceSync:{2:{0:!0,1:{enumBitwiseOr:[]}}},clientWaitSync:{3:{1:{enumBitwiseOr:["SYNC_FLUSH_COMMANDS_BIT"]}}},waitSync:{3:{1:{enumBitwiseOr:[]}}},getSyncParameter:{2:{1:!0}},bindTransformFeedback:{2:{0:!0}},beginTransformFeedback:{1:{0:!0}},transformFeedbackVaryings:{3:{2:!0}},bindBufferBase:{3:{0:!0}},bindBufferRange:{5:{0:!0}},getIndexedParameter:{2:{0:!0}},getActiveUniforms:{3:{2:!0}},getActiveUniformBlockParameter:{3:{2:!0}}};let v=null,M=null;function I(){if(null===v){v={},M={};const t=window.WebGL2RenderingContext||window.WebGLRenderingContext;if(!t)throw Error("Neither WebGL2RenderingContext nor WebGLRenderingContext exists on window.");for(const e in t){const r=t[e];"number"==typeof r&&(v[r]=e,M[e]=r)}}}function S(t){I();var e=v[t];return void 0!==e?"gl."+e:"/*UNKNOWN WebGL ENUM*/ 0x"+t.toString(16)}function N(t,e,r,i){const s=R[t];if(void 0!==s){const t=s[e];if(void 0!==t){const e=t[r];if(e){if("object"==typeof e){const t=e.enumBitwiseOr,r=[];let s=0;for(let e=0;e<t.length;++e){const n=M[t[e]];0!=(i&n)&&(s|=n,r.push(S(n)))}return s===i?r.join(" | "):S(i)}return S(i)}}}return null===i?"null":void 0===i?"undefined":i.toString()}function L(t,e,r){t.__defineGetter__(r,(function(){return e[r]})),t.__defineSetter__(r,(function(t){e[r]=t}))}const y=[0,0,0,1];function F(){return B.gl}class B{constructor(t,e={mesh:(new g).addVertexBuffer("coords","ts_TexCoord").addVertexBuffer("colors","ts_Color"),mode:-1,coord:[0,0],color:[1,1,1,1],pointSize:1,shader:T.create("\n        attribute vec4 ts_Color;\n        attribute vec4 ts_Vertex;\n        uniform mat4 ts_ModelViewProjectionMatrix;\n        attribute vec2 ts_TexCoord;\n        uniform float pointSize;\n        varying vec4 color;\n        varying vec2 coord;\n        void main() {\n            color = ts_Color;\n            coord = ts_TexCoord;\n            gl_Position = ts_ModelViewProjectionMatrix * ts_Vertex;\n            gl_PointSize = pointSize;\n        }\n        ","\n        precision highp float;\n        uniform sampler2D texture;\n        uniform float pointSize;\n        // uniform bool useTexture;\n        varying vec4 color;\n        varying vec2 coord;\n        void main() {\n            gl_FragColor = color;\n            // if (useTexture) gl_FragColor *= texture2D(texture, coord.xy);\n        }\n        ",t)}){this.immediate=e,this.modelViewMatrix=i.c.identity(),this.projectionMatrix=i.c.identity(),this.tempMatrix=new i.c,this.resultMatrix=new i.c,this.modelViewStack=[],this.projectionStack=[],this.drawCallCount=0,this.projectionMatrixVersion=0,this.modelViewMatrixVersion=0,this.cachedSDFMeshes={},this.matrixMode(B.MODELVIEW)}matrixMode(t){switch(t){case this.MODELVIEW:this.currentMatrixName="modelViewMatrix",this.stack=this.modelViewStack;break;case this.PROJECTION:this.currentMatrixName="projectionMatrix",this.stack=this.projectionStack;break;default:throw Error("invalid matrix mode "+t)}}loadIdentity(){i.c.identity(this[this.currentMatrixName]),"projectionMatrix"==this.currentMatrixName?this.projectionMatrixVersion++:this.modelViewMatrixVersion++}loadMatrix(t){i.c.copy(t,this[this.currentMatrixName]),"projectionMatrix"==this.currentMatrixName?this.projectionMatrixVersion++:this.modelViewMatrixVersion++}multMatrix(t){i.c.multiply(this[this.currentMatrixName],t,this.resultMatrix);const e=this.resultMatrix;this.resultMatrix=this[this.currentMatrixName],this[this.currentMatrixName]=e,"projectionMatrix"==this.currentMatrixName?this.projectionMatrixVersion++:this.modelViewMatrixVersion++}mirror(t){this.multMatrix(i.c.mirror(t))}perspective(t,e,r,s){this.multMatrix(i.c.perspectiveRad(t*i.b,e,r,s,this.tempMatrix))}frustum(t,e,r,s,n,o){this.multMatrix(i.c.frustum(t,e,r,s,n,o,this.tempMatrix))}ortho(t,e,r,s,n,o){this.multMatrix(i.c.ortho(t,e,r,s,n,o,this.tempMatrix))}scale(...t){this.multMatrix(i.c.scale(...t,this.tempMatrix))}mirroredX(){this.multMatrix(i.c.mirror(i.f))}translate(t,e,r){void 0!==e?this.multMatrix(i.c.translate(t,e,r,this.tempMatrix)):this.multMatrix(i.c.translate(t,this.tempMatrix))}rotate(t,e,r,s){this.multMatrix(i.c.rotate(t*i.b,{x:e,y:r,z:s},this.tempMatrix))}lookAt(t,e,r){this.multMatrix(i.c.lookAt(t,e,r,this.tempMatrix))}pushMatrix(){this.stack.push(i.c.copy(this[this.currentMatrixName]))}popMatrix(){const t=this.stack.pop();Object(i.p)(void 0!==t),this[this.currentMatrixName]=t,"projectionMatrix"==this.currentMatrixName?this.projectionMatrixVersion++:this.modelViewMatrixVersion++}wcToWindowMatrix(){const t=this.getParameter(this.VIEWPORT),[e,r,s,n]=t,o=new i.c([s/2,0,0,e+s/2,n/2,0,0,r+n/2,0,0,1,0,0,0,0,1]);return i.c.product(o,this.projectionMatrix,this.modelViewMatrix)}pointSize(t){this.immediate.shader.uniforms({pointSize:t})}begin(t){if(-1!=this.immediate.mode)throw Error("mismatched viewerGL.begin() and viewerGL.end() calls");this.immediate.mode=t,this.immediate.mesh.colors=[],this.immediate.mesh.coords=[],this.immediate.mesh.vertices=[]}color(...t){this.immediate.color=1==t.length&&Array.isArray(t[0])?t[0]:1==t.length&&"number"==typeof t[0]?function(t){return[(t>>16)/255,(t>>8&255)/255,(255&t)/255,1]}(t[0]):1==t.length&&"string"==typeof t[0]?Object(n.a)(t[0]).gl():[t[0],t[1],t[2],t[3]||1]}texCoord(...t){this.immediate.coord=i.j.apply(void 0,t).toArray(2)}vertex(...t){this.immediate.mesh.colors.push(this.immediate.color),this.immediate.mesh.coords.push(this.immediate.coord),this.immediate.mesh.vertices.push(i.j.apply(void 0,t))}end(){if(-1==this.immediate.mode)throw Error("mismatched viewerGL.begin() and viewerGL.end() calls");this.immediate.mesh.compile(),this.immediate.shader.uniforms({useTexture:!!B.gl.getParameter(this.TEXTURE_BINDING_2D)}).drawBuffers(this.immediate.mesh.vertexBuffers,void 0,this.immediate.mode),this.immediate.mode=-1}makeCurrent(){B.gl=this}animate(t){const e=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||function(t){setTimeout(()=>t(performance.now()),1e3/60)};let r=performance.now(),i=!0;const s=n=>{i&&(t.call(this,n,n-r),r=n,e(s))};return e(s),()=>{i=!1}}fullscreen(t={}){const e=t.paddingTop||0,r=t.paddingLeft||0,i=t.paddingRight||0,s=t.paddingBottom||0;if(!document.body)throw Error("document.body doesn't exist yet (call viewerGL.fullscreen() from window.onload() or from inside the <body> tag)");return Object.assign(this.canvas.style,{position:"absolute",left:r+"px",top:e+"px",width:window.innerWidth-r-i+"px",height:window.innerHeight-e-s+"px"}),this.addResizeListener(),this}addResizeListener(t={}){const e=this;function r(){const r=e.canvas.getBoundingClientRect();e.canvas.width=r.width*window.devicePixelRatio,e.canvas.height=r.height*window.devicePixelRatio,e.viewport(0,0,e.canvas.width,e.canvas.height),t.camera&&(e.matrixMode(B.PROJECTION),e.loadIdentity(),e.perspective(t.fov||45,e.canvas.width/e.canvas.height,t.near||.1,t.far||1e3),e.matrixMode(B.MODELVIEW))}return window.addEventListener("resize",r),r(),this}getMouseLine(t,e){if(t instanceof MouseEvent)return this.getMouseLine(t.offsetX,t.offsetY);const r=Object(i.j)(2*t/this.canvas.offsetWidth-1,2*-e/this.canvas.offsetHeight+1,0),s=Object(i.j)(2*t/this.canvas.offsetWidth-1,2*-e/this.canvas.offsetHeight+1,1),n=this.projectionMatrix.inversed(),o=n.transformPoint(r);return{anchor:o,dir:n.transformPoint(s).minus(o)}}viewportFill(){this.viewport(0,0,this.canvas.width,this.canvas.height)}setupTextRendering(t,e){return Object(s.a)(this,void 0,void 0,(function*(){this.textRenderShader=T.create("attribute vec2 ts_TexCoord;attribute vec4 ts_Vertex;uniform mat4 ts_ModelViewProjectionMatrix;varying vec2 coord;void main(){coord=ts_TexCoord.xy;gl_Position=ts_ModelViewProjectionMatrix*ts_Vertex;}","precision mediump float;uniform sampler2D u_texture;uniform vec4 u_color;uniform float u_buffer;uniform float u_gamma;uniform float u_debug;varying vec2 coord;void main(){float dist=texture2D(u_texture,coord).r;if(u_debug>0.0){gl_FragColor=vec4(dist,dist,dist,1);}else{float alpha=smoothstep(u_buffer-u_gamma,u_buffer+u_gamma,dist);gl_FragColor=vec4(u_color.rgb,alpha*u_color.a);if(gl_FragColor.a==0.0){discard;}}}"),[this.textAtlas,this.textMetrics]=yield Promise.all([_.fromURL(t,{format:this.LUMINANCE,internalFormat:this.LUMINANCE,type:this.UNSIGNED_BYTE}),fetch(e).then(t=>t.json())])}))}getSDFMeshForString(t){return Object(i.p)(this.textMetrics),this.cachedSDFMeshes[t]||(this.cachedSDFMeshes[t]=function(t,e,r,s=1){const n=(new g).addIndexBuffer("TRIANGLES").addVertexBuffer("coords","ts_TexCoord");let o=0,a=0;function c(r){const s=t.chars[r];if(!s)return;const[c,h,f,u,d,l,m]=s,{size:p,buffer:g}=t,x=n.vertices.length;if(c>0&&h>0){const t=(o+f-g)/p,r=(o+f+c+g)/p,s=(u-h-g)/p,d=(u+g)/p;n.vertices.push(new i.k(t,s,a/p),new i.k(r,s,a/p),new i.k(t,d,a/p),new i.k(r,d,a/p));const E=l/e.width,w=(l+c+2*g)/e.width,b=(m+h+2*g)/e.height,A=m/e.height;n.coords.push([E,b],[w,b],[E,A],[w,A]),V(n.TRIANGLES,!1,x,x+1,x+2,x+3)}o+=d}for(let e=0;e<r.length;e++){const i=r[e];"\n"==i?(o=0,a+=s*t.size):c(i)}return Object.assign(n.compile(),{width:o/t.size,lineCount:a+1})}(this.textMetrics,this.textAtlas,t))}renderText(t,e,r=1,s="left",n="bottom",o=.05,a=1.2){const c=this.getSDFMeshForString(t);this.pushMatrix(),this.scale(r);const h={top:-this.textMetrics.ascender/this.textMetrics.size,middle:(-this.textMetrics.ascender-this.textMetrics.descender)/2/this.textMetrics.size,alphabetic:0,bottom:-this.textMetrics.descender/this.textMetrics.size};this.translate({left:0,center:-.5,right:-1}[s]*c.width,h[n],0),this.multMatrix(i.c.forSys(i.k.X,i.k.Y,new i.k(0,-a,0))),this.textAtlas.bind(0),this.textRenderShader.uniforms({texture:0,u_color:e,u_debug:0,u_gamma:o,u_buffer:.75}).draw(c),this.popMatrix()}static create(t={}){const e=t.canvas||document.createElement("canvas");let r;t.canvas||(e.width=800,e.height=600),"alpha"in t||(t.alpha=!1);try{r=e.getContext("webgl2",t),r&&(r.version=2),r||(r=e.getContext("webgl",t)||e.getContext("experimental-webgl",t),r&&(r.version=1))}catch(t){console.log(t,"Failed to get context")}if(!r)throw Error("WebGL not supported");return t.throwOnError&&(r=function t(e,r,i,s=e){I(),r=r||function(t,e,r){var i,s="",n=r.length;for(let t=0;t<n;++t)s+=(0==t?"":", ")+N(e,n,t,r[t]);i="WebGL error "+S(t)+" in "+e+"("+s+")",window.console&&window.console.error?window.console.error(i):function(t){window.console&&window.console.log&&window.console.log(t)}(i)};const n={};function o(t,e){return function(...o){i&&i(e,o);const a=t[e].apply(t,o),c=s.getError();return 0!=c&&(n[c]=!0,r(c,e,o)),a}}const a={};for(let n in e)if("function"==typeof e[n])if("getExtension"!=n)a[n]=o(e,n);else{let c=o(e,n);a[n]=function(){const n=c.apply(e,arguments);return n?t(n,r,i,s):null}}else L(a,e,n);return a.getError=function(){for(const t in n)if(n.hasOwnProperty(t)&&n[t])return n[t]=!1,parseInt(t);return e.NO_ERROR},a}(r,(t,e)=>{throw Error(S(t)+" was caused by "+e)})),B.gl=r,Object(i.l)(r,B.prototype),Object(i.l)(r,new B(r)),r}fixCanvasRes(t=1/0){this.canvas.width=this.canvas.clientWidth*Math.min(window.devicePixelRatio,t),this.canvas.height=this.canvas.clientHeight*Math.min(window.devicePixelRatio,t),this.viewport(0,0,this.canvas.width,this.canvas.height)}drawVector(t,e,r=y,s=1){if(t.likeO())return;this.pushMatrix();const n=4*s;if(n>t.length())return;const o=t.getPerpendicular().unit();this.multMatrix(i.c.forSys(t.unit(),o,t.cross(o).unit(),e)),this.scale(t.length()-n,s/2,s/2),this.shaders.singleColor.uniforms({color:r}).draw(this.meshes.vectorShaft),this.scale(1/(t.length()-n),1,1),this.translate(t.length()-n,0,0),this.scale(n/2,1,1),this.shaders.singleColor.draw(this.meshes.vectorHead),this.popMatrix()}}var O;function V(t,e,r,i,s,n){e?t.push(r,s,i,i,s,n):t.push(r,i,s,i,n,s)}B.MODELVIEW=0,B.PROJECTION=1,B.HALF_FLOAT_OES=36193,(O||(O={})).create=B.create,B.prototype.MODELVIEW=B.MODELVIEW,B.prototype.PROJECTION=B.PROJECTION,B.prototype.HALF_FLOAT_OES=B.HALF_FLOAT_OES}}]);