(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{113:function(e,n,o){"use strict";o.r(n),o.d(n,"quickhull",(function(){return h}));var t=o(143),i=o(148),s=o(149),l=o(0);const r="C:\\Users\\aval\\tsdev\\workshop\\src\\quickhull\\index.tsx";function c(e,n){return null!=e?e:n()}function a(e,n,o,t){const i=e.to(n).cross(e.to(o));return e.to(t).dot(i)}function f(e,n){const o=[];for(let t=0;t<e.length;t++)n(e[t],t,e)&&o.push(t);return o}function d(e,n){return e[0]===n[0]&&e[1]===n[1]||e[0]===n[1]&&e[1]===n[0]}const u=s.a("orange").gl();const g=s.a("blue").gl(),p=e=>new Promise((n,o)=>setTimeout(n,e));function h(e){const n=Object(t.m)(1e3,()=>t.k.randomUnit().plus(t.k.XYZ).times(.5));(new i.b).addIndexBuffer("TRIANGLES").addIndexBuffer("LINES").vertices=n;const o=[];!async function(){let e=(new i.b).addIndexBuffer("TRIANGLES").addIndexBuffer("LINES");for(const[s,l]of function*(e){yield["start",{triangles:[]}];const[n,o,i,s]=e,l=[];function r(n,o){const[t,i,s]=l[n].triangle;return a(e[t],e[i],e[s],o)}let c=0;l.push({triangle:[0,1,2],pointsAboveIndexes:[],fInfex:c++}),l.push({triangle:[1,0,3],pointsAboveIndexes:[],fInfex:c++}),l.push({triangle:[2,1,3],pointsAboveIndexes:[],fInfex:c++}),l.push({triangle:[0,2,3],pointsAboveIndexes:[],fInfex:c++}),console.log("glug",r(0,e[3])),r(0,e[3])>0&&l.forEach(e=>Object(t.o)(e.triangle,0,1)),yield["selecting first 4 points",{hp:[0,1,2,3]}];for(let n=0;n<4;n++){const o=l.slice(0,n+1).flatMap(e=>e.triangle);yield["creating base tetra",{triangles:o,hf:[n]}];const t=[];for(let o=0;o<e.length;o++){r(n,e[o])>0&&t.push(o)}l[n].pointsAboveIndexes=t,yield['finding points "above" facet',{triangles:o,hf:[n],hp:t,hpc:"yes"}]}for(let n=0;n<l.length;n++){const o=l[n];if(console.log("triangle",n,"pointsAbove",o.pointsAboveIndexes.length),yield["finding highest point above facet",{hf:[n],hp:o.pointsAboveIndexes}],0===o.pointsAboveIndexes.length)continue;const i=Object(t.B)(o.pointsAboveIndexes,o=>r(n,e[o]));yield["highet point above facet",{hf:[n],hp:[i]}];const s=e[i],a=f(l,(e,n)=>r(n,s)>0);yield["facets visible from highest point",{hf:a,hp:[i]}];const g=[];for(const e of a){const n=e=>{const n=g.findIndex(n=>d(n,e));-1===n?g.push(e):Object(t.t)(g,n)};n([l[e].triangle[0],l[e].triangle[1]]),n([l[e].triangle[1],l[e].triangle[2]]),n([l[e].triangle[2],l[e].triangle[0]])}for(const n of g){const o=l.length;l.push({triangle:[i,n[0],n[1]],pointsAboveIndexes:[],fInfex:c++}),l[o].pointsAboveIndexes=Object(t.A)(a.flatMap(n=>l[n].pointsAboveIndexes.filter(n=>r(o,e[n])>0))),yield["creating new facet",{triangles:l.flatMap(e=>e.triangle),hf:[o]}],yield['finding points "above" new facet',{hf:[o],hp:l[o].pointsAboveIndexes,hpc:"yes"}]}yield["delete old triangles",{hf:a,hfc:u}],console.log("removeIndexes",l.slice(),a),Object(t.y)(l,a),console.log(l.slice()),n-=a.filter(e=>e<=n).length,yield["delete old triangles",{triangles:l.flatMap(e=>e.triangle)}],console.log("visibleTriIndexes",a),console.log("facets",l)}return l.flatMap(e=>e.triangle)}(n))l.triangles&&(e=(new i.b).addIndexBuffer("TRIANGLES").addIndexBuffer("LINES"),e.vertices=n,e.TRIANGLES=l.triangles,e.computeWireframeFromFlatTriangles(),e.compile()),o.push({mesh:e,description:s,cd:l}),await p(100);console.log("finished doo")}(),console.log(o);let l=0;const r=i.c.create("\n    uniform mat4 ts_ModelViewProjectionMatrix;\n    attribute vec4 ts_Vertex;\n    uniform float pointSize;\n    varying vec4 foo;\n    void main() {\n      foo = vec4(1.0, 1.0, 1.0, 1.0);\n      gl_Position = ts_ModelViewProjectionMatrix * ts_Vertex;\n      gl_PointSize = pointSize;\n    }\n  ","\n    precision highp float;\n    uniform vec4 color;\n    varying vec4 bar;\n    void main() {\n      gl_FragColor = color;\n      if (length(gl_PointCoord - vec2(0.5, 0.5)) > 0.5) {\n        discard;\n      }\n    }\n  ");e.clearColor(1,1,1,0),e.cullFace(e.BACK),e.matrixMode(e.PROJECTION),e.loadIdentity(),e.perspective(70,e.canvas.width/e.canvas.height,.1,1e3),e.lookAt(Object(t.j)(0,-2,1.5),t.k.O,t.k.Z),e.matrixMode(e.MODELVIEW),e.pointSize(10),e.enable(e.CULL_FACE),e.enable(e.DEPTH_TEST),e.enable(e.BLEND),e.blendFunc(e.SRC_ALPHA,e.ONE_MINUS_SRC_ALPHA),console.log(e.canvas),e.canvas.contentEditable="true",e.canvas.focus(),e.canvas.onkeydown=function(e){console.log("keydown");const n=Object(t.u)(l+("j"===e.key?-1:"k"===e.key?1:0),0,o.length-1);n!=l&&(l=n,console.log(l,o[l].description,o[l].cd))};let h=t.k.O,v=t.c.IDENTITY;return e.canvas.onmousemove=function(e){console.log("onmousemove");const n=Object(t.j)(e.pageX,e.pageY),o=h.to(n);1&e.buttons&&(v=v.rotateZ(.25*o.x*t.b),v=v.rotateX(.25*o.y*t.b)),h=n},e.animate((function(n,t){l+1<o.length&&l++,e.clear(e.COLOR_BUFFER_BIT|e.DEPTH_BUFFER_BIT),e.loadIdentity(),e.multMatrix(v),e.scale(1.5),e.translate(-.5,-.5,-.5);const i=o[l].mesh,a=o[l].cd;e.projectionMatrix.m[11]-=1/(1<<20);for(const n of c(a.hp,()=>[])){const o="yes"===a.hpc?"lime":"no"===a.hpc?"red":"blue";r.uniforms({color:s.b(o).gl(),pointSize:12}).drawBuffers(i.vertexBuffers,void 0,e.POINTS,n,1)}for(const n of c(a.hf,()=>[]))r.uniforms({color:c(a.hfc,()=>g)}).draw(i,e.TRIANGLES,3*n,3);e.projectionMatrix.m[11]+=1/(1<<20),r.uniforms({color:s.b("grey").gl(),pointSize:10}).drawBuffers(i.vertexBuffers,void 0,e.POINTS),r.uniforms({color:[1,1,0,1]}).draw(i,e.LINES),r.uniforms({color:[0,0,0,.5]}).draw(i,e.TRIANGLES)}))}n.default=()=>{const e=Object(l.useRef)(null);return Object(l.useEffect)(()=>{const n=i.d.create({canvas:e.current});n.addResizeListener(),h(n)},[]),l.createElement("div",{style:{display:"flex",flexDirection:"column",height:"100%"},__self:void 0,__source:{fileName:r,lineNumber:538}},l.createElement("canvas",{ref:e,style:{flexGrow:1},tabIndex:0,__self:void 0,__source:{fileName:r,lineNumber:539}}))}}}]);