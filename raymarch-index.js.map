{"version":3,"file":"raymarch-index.js","mappings":"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","sources":["/dev/workshop/./src/raymarch/EGizmoController.ts?","/dev/workshop/./src/raymarch/renderHighRes.ts?","/dev/workshop/./src/raymarch/shaders.ts?","/dev/workshop/./src/raymarch/index.tsx?","/dev/workshop/./src/raymarch/ed.frag?","/dev/workshop/./src/raymarch/sdf.frag?","/dev/workshop/./src/raymarch/singleColor.frag?","/dev/workshop/./src/raymarch/singleColor.vert?"],"sourcesContent":[" function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }import * as chroma from \"chroma.ts\"\nimport { arrayRange, clamp, DEG, eq, eq0, M4, TAU, V, V3 } from \"ts3dutils\"\nimport { GL_COLOR_BLACK, Mesh, } from \"tsgl\"\n\nconst X_RED = chroma.color(\"red\").gl()\nconst Y_GREEN = chroma.color(\"green\").gl()\nconst Z_BLUE = chroma.color(\"blue\").gl()\nconst HIGHLIGHT = GL_COLOR_BLACK\nconst L3X = { anchor: V3.O, dir1: V3.X }\nconst L3Y = { anchor: V3.O, dir1: V3.Y }\nconst L3Z = { anchor: V3.O, dir1: V3.Z }\n\n \nexport const NONE = 0 ,\n  X = 1 ,\n  Y = 2 ,\n  Z = 3 ,\n  XROT = 4 ,\n  YROT = 5 ,\n  ZROT = 6 \n\nexport class EGizmoController {\n   __init() {this.meshes = {}}\n\n   __init2() {this.highlight = NONE}\n   __init3() {this.offsetGC = undefined}\n\n   __init4() {this.dragging = NONE}\n\n  \n\n  constructor(\n      gl,\n     pos,\n      onHover,\n      onStartDragging,\n      onStopDragging,\n      onChange,\n  ) {;this.gl = gl;this.pos = pos;this.onHover = onHover;this.onStartDragging = onStartDragging;this.onStopDragging = onStopDragging;this.onChange = onChange;EGizmoController.prototype.__init.call(this);EGizmoController.prototype.__init2.call(this);EGizmoController.prototype.__init3.call(this);EGizmoController.prototype.__init4.call(this);EGizmoController.prototype.__init5.call(this);EGizmoController.prototype.__init6.call(this);EGizmoController.prototype.__init7.call(this);\n    // this.meshes.vectorShaft = Mesh.rotation(\n    //   [V3.O, V3.Y, V3.XY],\n    //   L3X,\n    //   TAU,\n    //   8,\n    //   true,\n    // )\n    // this.meshes.vectorShaft.computeNormalsFromFlatTriangles()\n    // this.meshes.vectorShaft.compile()\n    // this.meshes.vectorHead = Mesh.rotation(\n    //   [V3.Y, V(0, 2, 0), V(2, 0, 0)],\n    //   L3X,\n    //   TAU,\n    //   8,\n    //   true,\n    // )\n    // this.meshes.vectorHead.computeNormalsFromFlatTriangles()\n    // this.meshes.vectorHead.compile()\n    this.meshes.vector = Mesh.rotation(\n      [V(0, 0.04), V(0.8, 0.04), V(0.85, 0.06), V(1, 0)],\n      L3X,\n      TAU,\n      8,\n      true,\n    )\n    this.meshes.vector.computeNormalsFromFlatTriangles()\n    this.meshes.vector.compile()\n    const rotateBaseVerticesTM = M4.rotateX(-90 * DEG).translate(V3.X)\n    this.meshes.rotater = Mesh.rotation(\n      arrayRange(0, 9).map((i) =>\n        rotateBaseVerticesTM.transformPoint(V3.polar(0.04, -(TAU * i) / 8)),\n      ),\n      { anchor: V3.O, dir1: V3.Z },\n      (9 / 8) * 90 * DEG,\n      8,\n      false,\n    )\n    this.meshes.rotater.computeNormalsFromFlatTriangles()\n    this.meshes.rotater.compile()\n  }\n\n  drawVector(vector, anchor, shader, size = 1) {\n    if (vector.likeO()) return\n\n    this.gl.pushMatrix()\n\n    const vT = vector.getPerpendicular().unit()\n    this.gl.multMatrix(\n      M4.forSys(vector.unit(), vT, vector.cross(vT).unit(), anchor),\n    )\n    shader.draw(this.meshes.vector)\n    this.gl.popMatrix()\n  }\n\n  render(shader) {\n    const gl = this.gl\n    gl.enable(gl.CULL_FACE)\n    gl.cullFace(gl.BACK)\n    gl.pushMatrix()\n    gl.multMatrix(this.pos)\n    gl.cullFace(gl.FRONT)\n\n    shader.uniforms({ color: HIGHLIGHT, normalOffset: 0.01 })\n    if (this.highlight === X || this.dragging === X)\n      this.drawVector(V3.X, V3.O, shader, 0.1)\n    if (this.highlight === Y || this.dragging === Y)\n      this.drawVector(V3.Y, V3.O, shader, 0.1)\n    if (this.highlight === Z || this.dragging === Z)\n      this.drawVector(V3.Z, V3.O, shader, 0.1)\n    gl.cullFace(gl.BACK)\n    shader.uniforms({ normalOffset: 0 })\n    this.drawVector(V3.X, V3.O, shader.uniforms({ color: X_RED }), 0.1)\n    this.drawVector(V3.Y, V3.O, shader.uniforms({ color: Y_GREEN }), 0.1)\n    this.drawVector(V3.Z, V3.O, shader.uniforms({ color: Z_BLUE }), 0.1)\n\n    shader.uniforms({ color: Z_BLUE }).draw(this.meshes.rotater)\n    gl.rotate(-90, 0, 1, 0)\n    shader.uniforms({ color: X_RED }).draw(this.meshes.rotater)\n    gl.rotate(-90, 1, 0, 0)\n    shader.uniforms({ color: Y_GREEN }).draw(this.meshes.rotater)\n    gl.popMatrix()\n  }\n\n  registerListeners(\n    mouseMoveTarget\n\n\n,\n    getCameraMatrix,\n  ) {\n    this.getCameraMatrix = getCameraMatrix\n    _optionalChain([this, 'access', _3 => _3.unregister, 'optionalCall', _4 => _4()])\n    mouseMoveTarget.addEventListener(\"mousemove\", this.mousemove)\n    mouseMoveTarget.addEventListener(\"mousedown\", this.mousedown)\n    mouseMoveTarget.addEventListener(\"mouseup\", this.mouseup)\n\n    return (this.unregister = () => {\n      mouseMoveTarget.removeEventListener(\"mousemove\", this.mousemove)\n      mouseMoveTarget.removeEventListener(\"mousedown\", this.mousedown)\n      mouseMoveTarget.removeEventListener(\"mouseup\", this.mouseup)\n    })\n  }\n\n  unregisterListeners() {\n    _optionalChain([this, 'access', _5 => _5.unregister, 'optionalCall', _6 => _6()])\n  }\n\n   __init5() {this.mousemove = (e) => {\n    const pagePos = V(e.offsetX, e.offsetY)\n\n    const boundingClientRect = (\n      e.target \n    ).getBoundingClientRect()\n    boundingClientRect.width\n    const mouseLineWC = getMouseLine(\n      pagePos,\n      boundingClientRect,\n      this.getCameraMatrix(),\n    )\n    if (this.dragging) {\n      const dir = [V3.O, V3.X, V3.Y, V3.Z][this.dragging]\n      const axis = {\n        anchor: this.pos.getTranslation(),\n        dir1: this.pos.transformVector(dir).unit(),\n      }\n      const info = infoClosestToLine(mouseLineWC, axis)\n      const offsetWC = this.pos.transformVector(this.offsetGC)\n      const targetPos = info.lineClosest.minus(offsetWC)\n      this.pos = this.pos.translate(this.pos.getTranslation().to(targetPos))\n      this.onChange(this.pos)\n    } else {\n      const gizmoInverse = this.pos.inversed()\n      const lineGC = {\n        anchor: gizmoInverse.transformPoint(mouseLineWC.anchor),\n        dir1: gizmoInverse.transformVector(mouseLineWC.dir1).unit(),\n      }\n      let lp = undefined\n\n      // eslint-disable-next-line no-inner-declarations\n      function measure(l) {\n        const info = infoClosestToLine(lineGC, l)\n        lp = at(l, clamp(info.lineT, 0, 1))\n        const realDistance = lp.distanceTo(info.thClosest)\n        return realDistance\n      }\n\n      const lastHighlight = this.highlight\n      if (measure(L3X) < 0.1) {\n        this.highlight = X\n        this.offsetGC = lp\n      } else if (measure(L3Y) < 0.1) {\n        this.highlight = Y\n        this.offsetGC = lp\n      } else if (measure(L3Z) < 0.1) {\n        this.highlight = Z\n        this.offsetGC = lp\n      } else {\n        this.highlight = NONE\n        this.offsetGC = undefined\n      }\n      if (this.highlight !== lastHighlight) {\n        _optionalChain([this, 'access', _7 => _7.onHover, 'optionalCall', _8 => _8(this.highlight)])\n      }\n    }\n  }}\n\n   __init6() {this.mousedown = (e) => {\n    if (this.highlight) {\n      this.dragging = this.highlight\n      this.onStartDragging()\n    }\n  }}\n\n   __init7() {this.mouseup = (e) => {\n    if (this.dragging) {\n      this.dragging = NONE\n      this.onStopDragging()\n    }\n  }}\n\n  \n}\n\n\n\nexport function getMouseLine(\n  pos,\n  canvas,\n  projectionMatrix,\n) {\n  const ndc1 = V(\n    (pos.x * 2) / canvas.width - 1,\n    (-pos.y * 2) / canvas.height + 1,\n    -1,\n  )\n  const ndc2 = V(\n    (pos.x * 2) / canvas.width - 1,\n    (-pos.y * 2) / canvas.height + 1,\n    1,\n  )\n  const inverseProjectionMatrix = projectionMatrix.inversed()\n  const anchor = inverseProjectionMatrix.transformPoint(ndc1)\n  const dir1 = inverseProjectionMatrix.transformPoint(ndc2).minus(anchor).unit()\n  return { anchor, dir1 }\n}\n\nfunction at(l, t) {\n  return l.anchor.plus(l.dir1.times(t))\n}\nfunction infoClosestToLine(\n  th,\n  line,\n)\n\n\n\n\n\n {\n  /*\n       line = a + s*b\n       this = c + t*d\n\n       (this - line) * b = 0\n       (this - line) * d = 0\n\n       (a + s*b - c - t*d) * b = 0\n       (a + s*b - c - t*d) * d = 0\n\n       (a - c + s*b - t*d) * b = 0\n       (a - c + s*b - t*d) * d = 0\n\n       (a - c)*b + (s*b - t*d)*b = 0\n       (a - c)*d + (s*b - t*d)*d = 0\n\n       (a - c)*b + s*(b*b) - t*(d*b) = 0\n       (a - c)*d + s*(b*d) - t*(d*d) = 0\n\n       s = (t*(d*b) - (a - c)*b) / (b*b)\n       =>\n       (a - c)*d + (t*(d*b) - (a - c)*b) / (b*b)*(b*d) - t*(d*d) = 0 | * (b*b)\n       (a - c)*d * (b*b) + (t*(d*b) - (a - c)*b)*(b*d) - t*(d*d) * (b*b) = 0\n       (a - c)*d * (b*b) + t*(d*b)*(b*d) - (a - c)*b*(b*d) - t*(d*d) * (b*b) = 0\n       t = ((a - c)*b*(b*d) - (a - c)*d * (b*b)) / ((d*b)*(b*d) - (d*d) * (b*b))\n       */\n  if (isParallelToLine(th, line)) {\n    return { t: NaN, s: NaN, distance: 10 }\n  }\n  const a = line.anchor,\n    b = line.dir1,\n    c = th.anchor,\n    d = th.dir1\n  const bd = b.dot(d),\n    bb = b.squared(),\n    dd = d.squared(),\n    ca = a.minus(c),\n    divisor = bd * bd - dd * bb\n  const thT = (ca.dot(b) * bd - ca.dot(d) * bb) / divisor\n  const lineT = (ca.dot(b) * dd - ca.dot(d) * bd) / divisor\n  return {\n    thT,\n    lineT,\n    thClosest: at(th, thT),\n    lineClosest: at(line, lineT),\n    distance: at(th, thT).distanceTo(at(line, lineT)),\n  }\n}\n\nfunction asSegmentDistanceToLine(\n  th,\n  line,\n  sStart,\n  sEnd,\n) {\n  const dirCross = th.dir1.cross(line.dir1)\n  const div = dirCross.squared()\n  if (eq0(div)) {\n    return undefined\n  } // lines parallel\n  const anchorDiff = line.anchor.minus(th.anchor)\n  // check if distance is zero (see also L3.distanceToLine)\n  if (!eq0(anchorDiff.dot(dirCross.unit()))) {\n    return undefined\n  }\n  let t = infoClosestToLine(th, line).t\n  t = clamp(t, sStart, sEnd)\n  return at(th, clamp(t, sStart, sEnd))\n}\n\nfunction isParallelToLine(th, line) {\n  // we know that 1 == this.dir1.length() == line.dir1.length(), we can check for parallelity simpler than\n  // isParallelTo()\n  return eq(1, Math.abs(th.dir1.dot(line.dir1)))\n}\n"," function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }import sleep from \"sleep-promise\"\nimport { TSGLContext } from \"tsgl\"\n\nexport async function renderHighRes(\n  [width, height],\n  setup,\n  render,\n  onProgress,\n) {\n  _optionalChain([onProgress, 'optionalCall', _ => _(0)])\n  await sleep(10)\n  const canvas = document.createElement(\"canvas\")\n  canvas.width = width\n  canvas.height = height\n\n  const step = 200\n  const gl = TSGLContext.create({ canvas })\n  gl.enable(gl.SCISSOR_TEST)\n  const shared = setup(gl)\n  let donePixels = 0\n  for (let x = 0; x < width; x += step) {\n    for (let y = 0; y < height; y += step) {\n      const scissorWidth = Math.min(step, width - x)\n      const scissorHeight = Math.min(step, height - y)\n      gl.scissor(x, y, scissorWidth, scissorHeight)\n      // console.time(\"render block\")\n      render(gl, shared)\n      // console.timeEnd(\"render block\")\n      await sleep(0)\n      donePixels += scissorWidth * scissorHeight\n      _optionalChain([onProgress, 'optionalCall', _2 => _2(donePixels / (width * height))])\n    }\n  }\n  return new Promise((resolve, reject) =>\n    canvas.toBlob((blob) => (blob ? resolve(blob) : reject(\"error\")), \"png\"),\n  )\n}\n","/* eslint-disable @typescript-eslint/no-var-requires */\nimport { Shader, } from \"tsgl\"\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function buildShaders(gl) {\n  return {\n    // temple: Shader.create(\n    //   require(\"../common/raymarch.vert\"),\n    //   require(`./demoTemple.frag`),\n    //   gl,\n    // ),\n    sdf: Shader.create(\n      require(\"../common/raymarch.vert\").default,\n      require(\"./sdf.frag\").default,\n      gl,\n    ),\n    // ed: Shader.create(\n    //   require(\"../common/raymarch.vert\"),\n    //   require(`./ed.frag`),\n    //   gl,\n    // ),\n    singleColor: Shader.create(\n      require(\"./singleColor.vert\").default,\n      require(\"./singleColor.frag\").default,\n      gl,\n    ),\n  }\n}\n"," function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }import Button from \"@mui/material/Button\"\nimport Card from \"@mui/material/Card\"\nimport CardContent from \"@mui/material/CardContent\"\nimport Grid from \"@mui/material/Grid\"\nimport MenuItem from \"@mui/material/MenuItem\"\nimport OutlinedInput from \"@mui/material/OutlinedInput\"\nimport Select, { } from \"@mui/material/Select\"\nimport { useTheme } from \"@mui/material/styles\"\nimport TextField from \"@mui/material/TextField\"\nimport aesthetically from \"aesthetically\"\nimport * as chroma from \"chroma.ts\"\nimport { debounce } from \"lodash\"\nimport * as React from \"react\"\nimport {\n\n\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\"\nimport { DEG, lerp, M4, PI, V3 } from \"ts3dutils\"\nimport { currentGL, Mesh, Shader, TSGLContext } from \"tsgl\"\n\nimport { BoundNumberField } from \"../common/BoundNumberField\"\nimport { FPSController } from \"../common/FPSController\"\nimport { useHashState } from \"../common/useHashState\"\nimport { openInNewTab } from \"../paperBox1/common\"\nimport edFragShader from \"./ed.frag\"\nimport { EGizmoController, NONE } from \"./EGizmoController\"\nimport { FlyCameraController } from \"./FlyCameraController\"\nimport {\n  OrbitCameraController,\n\n} from \"./OrbitCameraController\"\nimport { renderHighRes } from \"./renderHighRes\"\nimport { buildShaders } from \"./shaders\"\n\n/**\n * THE ART LIST\n *\n * - something isometric (chess?)\n * - something with dunes\n * - something with 3d fractals\n * - something with refraction (prism etc)\n */\n\nconst initialState = {\n  a: 0.2,\n  b: 0.2,\n  c: 0.2,\n  d: 0.2,\n  cam: \"999.999.999~-56.-58.-61~-44.-44.79\",\n}\n\n\nfunction raymarchSetup(gl) {\n  gl.makeCurrent()\n\n  const planeMesh = Mesh.plane({ startX: -1, startY: -1, width: 2, height: 2 })\n  // Mesh.plane generates tex coords [0,1] and we want [-1, 1] for rendering\n  planeMesh.coords = [\n    [-1, -1],\n    [1, -1],\n    [-1, 1],\n    [1, 1],\n  ]\n  planeMesh.compile()\n\n  return {\n    planeMesh,\n    shaders: buildShaders(gl),\n  }\n}\n\nfunction raymarchRender(\n  gl,\n  { shaders, planeMesh },\n  modelView,\n  colors,\n  dynamicState,\n  abs,\n  extra,\n) {\n  gl.makeCurrent()\n\n  const f = (abs / 1000 / 40) % 1\n  //        vec3 spherepos = fromPolar(mix(-6., 6., f), abs(mix(-10., 10.,\n  // f)) + PI / 2., 0.);\n  const campos = (f) =>\n    V3.polar(lerp(-6, 6, f), Math.abs(lerp(-10, 10, f)) + PI / 2, 0.5)\n\n  const llli = modelView.inversed()\n  shaders.sdf\n    .uniforms({\n      colorPrimary: colors.primary,\n      colorSecondary: colors.secondary,\n      colorBackground: colors.background,\n      highResTimeStamp: abs,\n      secs: abs / 1000,\n      gradients: 1,\n      extra,\n      ...dynamicState,\n      //campos,\n      lll: modelView,\n      llli,\n    })\n    .draw(planeMesh)\n}\n\nfunction raymarch(\n  gl,\n  colors,\n  dynamicState,\n  onFPSChange,\n  triggerRender,\n  onCamChange,\n  onHover,\n  setExtra,\n  startShader,\n) {\n  gl.canvas.addEventListener(\"keydown\", (e) => e.key === \"r\" && triggerRender())\n  const camController = new OrbitCameraController(onCamChange)\n  let camMatrix = M4.IDENTITY\n  const eGizmoController = new EGizmoController(\n    gl,\n    M4.rotateZ(20 * DEG).translate(5, 5, 1),\n    onHover,\n    () => (camController.pauseCam = true),\n    () => (camController.pauseCam = false),\n    setExtra,\n  )\n  eGizmoController.registerListeners(gl.canvas, () => camMatrix)\n\n  gl.clearColor(...colors.background)\n  gl.clearColor(0, 0, 0, 1)\n  gl.clear(gl.COLOR_BUFFER_BIT)\n  gl.cullFace(gl.BACK)\n\n  gl.pointSize(10)\n\n  //gl.enable(gl.CULL_FACE)\n  gl.disable(gl.CULL_FACE)\n  gl.disable(gl.DEPTH_TEST)\n\n  gl.disable(gl.BLEND)\n  gl.blendFunc(gl.ONE, gl.ONE)\n  gl.blendEquation(gl.FUNC_ADD)\n\n  gl.canvas.contentEditable = \"true\" // make canvas focusable\n  gl.canvas.focus()\n  camController.registerListeners(gl.canvas)\n\n  const fpsController = new FPSController(onFPSChange)\n\n  const shared = raymarchSetup(gl)\n  if (module.hot) {\n    module.hot.accept(\"./shaders\", () => {\n      console.clear()\n      try {\n        shared.shaders = buildShaders(currentGL())\n      } catch (e) {\n        console.error(e)\n      }\n    })\n  }\n\n  let it = 0\n\n  return {\n    updateShader(newShader) {\n      shared.shaders.ed = Shader.create(\n        // eslint-disable-next-line @typescript-eslint/no-var-requires\n        require(\"../common/raymarch.vert\").default,\n        newShader,\n      )\n    },\n    teardown: gl.animate(function (abs, _diff) {\n      gl.clear(gl.COLOR_BUFFER_BIT)\n      it++\n      // if (it % 30 !== 0) return\n      // gl.clear(gl.DEPTH_BUFFER_BIT)\n      // gl.clear(gl.COLOR_BUFFER_BIT)\n      if (it % 300 === 0) {\n        // gl.clear(gl.COLOR_BUFFER_BIT)\n      }\n      gl.makeCurrent()\n      camController.tick()\n      fpsController.tick(abs)\n\n      camMatrix = M4.product(\n        M4.perspective(\n          70,\n          gl.canvas.offsetWidth / gl.canvas.offsetHeight,\n          0.1,\n          50,\n        ),\n        camController.getLookAt(),\n      )\n\n      raymarchRender(\n        gl,\n        shared,\n        camMatrix,\n        colors,\n        dynamicState,\n        abs,\n        eGizmoController.pos.getTranslation(),\n      )\n\n      gl.matrixMode(gl.PROJECTION)\n      gl.loadMatrix(camMatrix)\n      gl.matrixMode(gl.MODELVIEW)\n      gl.loadIdentity()\n\n      eGizmoController.render(shared.shaders.singleColor)\n    }),\n    setCam: camController.setState,\n  }\n}\n\nfunction MatrixDisplay({\n  children,\n  label,\n  onFocus,\n  onBlur,\n}\n\n\n\n\n) {\n  return (\n    React.createElement(OutlinedInput, {\n      onFocus: onFocus,\n      onBlur: onBlur,\n      label: label,\n      inputComponent: \"textarea\",\n      value: children.toString(),}\n    )\n  )\n}\n\nfunction makeShader(desc) {\n  let di = 0\n\n  function float(n) {\n    const s = \"\" + n\n    return s.includes(\".\") ? s : s + \".0\"\n  }\n\n  function vec3([x, y, z]) {\n    return \"vec3(\" + float(x) + \", \" + float(y) + \", \" + float(z) + \")\"\n  }\n\n  function makePart(desc) {\n    let input\n    let output\n    let f\n\n    function gen(g) {\n      input = \"p\" + di++\n      output = \"d\" + di++\n      f = `float ${output} = ${g(input)};\\n`\n    }\n\n    for (const d of desc) {\n      if (d.type === \"sphere\") {\n        gen((input) => `sdSphere(${float(d.radius)}, ${input})`)\n      } else if (d.type === \"box\") {\n        gen((input) => `betterBox(${vec3(d.radius)}, ${input})`)\n      } else if (d.type === \"octahedron\") {\n        gen((input) => `sdOctahedron(${float(d.radius)}, ${input})`)\n      } else if (d.type === \"donut\") {\n        gen((input) => `sdTorus(${float(d.r0)}, ${float(d.r1)}, ${input})`)\n      } else if (d.type === \"translate\") {\n        const prevInput = input\n        input = \"p\" + di++\n        f = `vec3 ${prevInput} = ${input} + ${vec3(d.by)};\\n` + f\n      } else if (d.type === \"expand\") {\n        const prevOutput = output\n        output = \"d\" + di++\n        f = f + `float ${output} = ${prevOutput} - ${float(d.by)};\\n`\n      } else if (d.type === \"add\" || d.type === \"sub\") {\n        const [subf, subinput, suboutput] = makePart(d.what)\n        f =\n          f +\n          `vec3 ${subinput} = ${input};\\n` +\n          subf +\n          `${output} = ` +\n          (d.type === \"add\"\n            ? `min(${output}, ${suboutput})`\n            : `max(${output}, -${suboutput})`) +\n          `;\\n`\n      }\n    }\n    return [f, input, output]\n  }\n\n  const [f, input, output] = makePart(desc)\n  let result = `RMHit sdf(vec3 ${input}) {\\n`\n  result += f\n  result += `return RMHit(${output}, black);\\n`\n  result += \"}\\n\"\n  return result\n}\n\nfunction normfig(s) {\n  return aesthetically.format(s, \"monospace\")\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction SphereEditor({\n  value,\n  onChange,\n}\n\n\n) {\n  const onRadiusChange = useCallback(\n    (ev) => onChange({ ...value, radius: +ev.target.value }, value),\n    [onChange],\n  )\n  return (\n    React.createElement('div', null, \"Sphere\"\n      , \" \"\n      , React.createElement(TextField, {\n        value: value.radius,\n        onChange: onRadiusChange,\n        inputProps: { type: \"number\" },}\n      )\n    )\n  )\n}\n\nfunction BoxEditor({\n  value,\n  onChange,\n}\n\n\n) {\n  const onRadiusChange = useCallback(\n    (newRadius) => onChange({ ...value, radius: newRadius }, value),\n    [value, onChange],\n  )\n  return (\n    React.createElement('div', { style: { display: \"flex\" },}, \"Box \"\n       , React.createElement(Vec3Editor, { value: value.radius, onChange: onRadiusChange,} )\n    )\n  )\n}\n\nfunction ExpandEditor({\n  value,\n  onChange,\n}\n\n\n) {\n  const onByChange = useCallback(\n    (e) => onChange({ ...value, by: +e.target.value }, value),\n    [value, onChange],\n  )\n  return (\n    React.createElement('div', { style: { display: \"flex\" },}, \"Expand\"\n      , \" \"\n      , React.createElement(TextField, {\n        value: value.by,\n        onChange: onByChange,\n        type: \"number\",\n        inputProps: {},}\n      )\n    )\n  )\n}\n\nclass GizmoControl {\n  take(startPos, onChange) {\n    // TODO\n  }\n}\n\nfunction Vec3Editor({\n  value,\n  onChange,\n  gizmoControl,\n}\n\n\n\n) {\n  const onElChange = useCallback(\n    (e) => {\n      const newValue = value.slice() \n      newValue[e.target.name] = +e.target.value\n      onChange(newValue, value)\n    },\n    [value, onChange],\n  )\n  const gizmoClick = useCallback(\n    () => gizmoControl.take(value, onChange),\n    [gizmoControl, onChange, value],\n  )\n  return (\n    React.createElement(React.Fragment, null\n      , React.createElement(Button, { onClick: gizmoClick,}, \"X\")\n      , [0, 1, 2].map((i) => (\n        React.createElement(TextField, {\n          key: i,\n          name: \"\" + i,\n          value: value[i],\n          onChange: onElChange,\n          inputProps: { type: \"number\" },}\n        )\n      ))\n    )\n  )\n}\n\nfunction TranslateEditor({\n  value,\n  onChange,\n  gizmoControl,\n}\n\n\n\n) {\n  const onByChange = useCallback(\n    (newBy) => onChange({ ...value, by: newBy }, value),\n    [value, onChange],\n  )\n  return (\n    React.createElement('div', { style: { display: \"flex\" },}, \"Translate\"\n      , \" \"\n      , React.createElement(Vec3Editor, {\n        value: value.by,\n        onChange: onByChange,\n        gizmoControl: gizmoControl,}\n      )\n    )\n  )\n}\n\nfunction DonutEditor({\n  value,\n  onChange,\n  gizmoControl,\n}\n\n\n\n) {\n  const onElChange = useCallback(\n    (e) =>\n      onChange(\n        {\n          ...value,\n          [e.target.name]: +e.target.value,\n        },\n        value,\n      ),\n    [value, onChange],\n  )\n  return (\n    React.createElement('div', { style: { display: \"flex\" },}, \"Donut\"\n      , \" \"\n      , ([\"r0\", \"r1\"] ).map((i) => (\n        React.createElement(TextField, {\n          key: i,\n          name: i,\n          value: value[i],\n          onChange: onElChange,\n          inputProps: { type: \"number\" },}\n        )\n      ))\n    )\n  )\n}\nfunction OctahedronEditor({\n  value,\n  onChange,\n  gizmoControl,\n}\n\n\n\n) {\n  const onElChange = useCallback(\n    (e) =>\n      onChange(\n        {\n          ...value,\n          [e.target.name]: +e.target.value,\n        },\n        value,\n      ),\n    [value, onChange],\n  )\n  return (\n    React.createElement('div', { style: { display: \"flex\" },}, \"Octahedron\"\n      , \" \"\n      , [\"radius\"].map((i) => (\n        React.createElement(TextField, {\n          key: i,\n          name: i,\n          value: value[i],\n          onChange: onElChange,\n          inputProps: { type: \"number\" },}\n        )\n      ))\n    )\n  )\n}\n\nfunction AddEditor({\n  value,\n  onChange,\n  gizmoControl,\n}\n\n\n\n) {\n  const onTypeChange = useCallback(\n    (e) => onChange({ ...value, type: e.target.value }, value),\n    [value, onChange],\n  )\n  const onWhatChange = useCallback(\n    (newWhat) => onChange({ ...value, what: newWhat }, value),\n    [value, onChange],\n  )\n  return (\n    React.createElement('div', { style: { display: \"flex\" },}\n      , React.createElement(Select, { value: value.type, name: \"type\", onChange: onTypeChange,}\n        , React.createElement(MenuItem, { value: \"add\",}, \"Add\")\n        , React.createElement(MenuItem, { value: \"sub\",}, \"Sub\")\n      ), \" \"\n      , React.createElement(Ed, {\n        value: value.what,\n        onChange: onWhatChange,\n        gizmoControl: gizmoControl,}\n      )\n    )\n  )\n}\n\nfunction Ed({\n  value,\n  onChange,\n  gizmoControl,\n}\n\n\n\n) {\n  const onItemChange = useCallback(\n    (newValue, oldValue) =>\n      onChange(value.map((v) => (v === oldValue ? newValue : v))),\n    [onChange, value],\n  )\n  return (\n    React.createElement('div', null\n      , value.map((x, i) => {\n        const PEd = {\n          sphere: SphereEditor,\n          expand: ExpandEditor,\n          add: AddEditor,\n          sub: AddEditor,\n          box: BoxEditor,\n          donut: DonutEditor,\n          translate: TranslateEditor,\n          octahedron: OctahedronEditor,\n        }[x.type]\n        return (\n          PEd && (\n            React.createElement(PEd, {\n              key: i,\n              value: x,\n              onChange: onItemChange,\n              gizmoControl: gizmoControl,}\n            )\n          )\n        )\n      })\n    )\n  )\n}\n\nexport default () => {\n  const canvasRef = useRef(null)\n\n  const [renderProgress, setRenderProgress] = useState(\n    undefined ,\n  )\n  const [gp, setGp] = useState(M4.IDENTITY)\n  const [resolution, setResolution] = useState(512)\n  const [gpFocused, setGpFocused] = useState(false)\n  const [state, setState] = useHashState(initialState)\n  const setStatePartial = useCallback(\n    (o) => setState((s) => ({ ...s, ...o })),\n    [setState],\n  )\n  const [part, setPart] = useState(NONE)\n  const [fps, setFps] = useState(0)\n  const dynamic = useRef(Object.assign({}, state))\n  const raymarchRef = useRef()\n\n  const [model, setModel] = useState([\n    { type: \"sphere\", radius: 1 },\n    { type: \"translate\", by: [1, 2, 3] },\n    {\n      type: \"add\",\n      what: [\n        { type: \"box\", radius: [1, 2, 3] },\n        { type: \"translate\", by: [0.1, 0.1, 0.1] },\n        { type: \"expand\", by: 0.3 },\n      ],\n    },\n    {\n      type: \"add\",\n      what: [\n        { type: \"octahedron\", radius: 2 },\n        { type: \"translate\", by: [0.1, 0.1, 0.1] },\n      ],\n    },\n    {\n      type: \"add\",\n      what: [\n        { type: \"donut\", r0: 2, r1: 0.2 },\n        { type: \"translate\", by: [0.1, 0.1, 0.1] },\n      ],\n    },\n  ])\n\n  const theme = useTheme()\n  const colors = useMemo(\n    () => ({\n      background: chroma.css(theme.palette.background.default).gl(),\n      primary: chroma.css(theme.palette.primary.main).gl(),\n      secondary: chroma.css(theme.palette.secondary.main).gl(),\n    }),\n    [theme.palette],\n  )\n  const render = useCallback(\n    async ([width, height]) => {\n      const url = URL.createObjectURL(\n        await renderHighRes(\n          [width, height],\n          raymarchSetup,\n          (gl, shared) => {\n            const camMatrix = M4.product(\n              M4.perspective(70, width / height, 0.1, 50),\n              OrbitCameraController.getLookAt(\n                OrbitCameraController.fromShortString(state.cam),\n              ),\n            )\n\n            raymarchRender(\n              gl,\n              shared,\n              camMatrix,\n              colors,\n              state,\n              2000,\n              gp.getTranslation(),\n            )\n          },\n          setRenderProgress,\n        ),\n      )\n      setRenderProgress(undefined)\n      openInNewTab(url)\n    },\n    [gp, colors, state],\n  )\n  useEffect(() => {\n    console.log(\"creating context\")\n    const tsgl = TSGLContext.create({\n      canvas: canvasRef.current,\n      alpha: true,\n      premultipliedAlpha: true,\n      // antialias: true,\n      throwOnError: true,\n    })\n    console.log(tsgl.getParameter(tsgl.MAX_SAMPLES))\n    // tsgl.fixCanvasRes()\n    //tsgl.addResizeListener()\n    raymarchRef.current = raymarch(\n      tsgl,\n      colors,\n      dynamic.current,\n      setFps,\n      () => render([1920, 1080]),\n      debounce((cam) => {\n        setStatePartial({ cam: OrbitCameraController.toShortString(cam) })\n      }),\n      setPart,\n      setGp,\n    )\n\n    return () => {\n      _optionalChain([raymarchRef, 'access', _ => _.current, 'optionalAccess', _2 => _2.teardown, 'call', _3 => _3()])\n    }\n  }, [])\n  useEffect(() => {\n    // state.cam &&\n    //   raymarchRef.current?.setCam(\n    //     OrbitCameraController.fromShortString(state.cam),\n    //   )\n  }, [state.cam])\n  useEffect(() => {\n    _optionalChain([raymarchRef, 'access', _4 => _4.current, 'optionalAccess', _5 => _5.updateShader, 'call', _6 => _6(\n      edFragShader.replace(/RMHit sdf\\(vec3 p\\) {[\\s\\S]*?}/, makeShader(model)),\n    )])\n  }, [model])\n\n  useEffect(() => {\n    Object.assign(dynamic.current, state)\n  }, [state])\n\n  const RenderButton = useCallback(\n    ({ dim, children }) => (\n      React.createElement(Button, {\n        variant: \"contained\",\n        onClick: () => render(dim),\n        disabled: \"undefined\" !== typeof renderProgress,}\n\n        , \"undefined\" === typeof renderProgress\n          ? children\n          : \"Rendering... \" +\n            normfig(\"\" + Math.floor(renderProgress * 100)).padStart(\n              3,\n              \"\\u2007\",\n            ) +\n            \"%\"\n      )\n    ),\n    [render, renderProgress],\n  )\n\n  function setCam({ cam }) {\n    const m = FlyCameraController.fromShortString(cam)\n    setStatePartial({ cam: OrbitCameraController.toShortString(m) })\n  }\n\n  return (\n    React.createElement(Grid, { container: true, style: { height: \"99%\" },}\n      , React.createElement(Grid, { item: true, xs: 12, md: 9,}\n        , React.createElement('div', { style: { height: \"100%\" },}\n          , React.createElement('canvas', {\n            ref: canvasRef,\n            style: {\n              width: \"100%\",\n              height: \"100%\",\n              cursor: part === NONE ? \"move\" : \"grab\",\n            },\n            width: resolution,\n            height: resolution,\n            tabIndex: 0,}\n          )\n        )\n      )\n      , React.createElement(Grid, {\n        item: true,\n        xs: 12,\n        md: 3,\n        sx: {\n          display: \"flex\",\n          flexDirection: \"column\",\n          width: \"100%\",\n          padding: 2,\n          alignItems: \"stretch\",\n          gap: 2,\n        },}\n\n        , React.createElement(Card, null\n          , React.createElement(CardContent, null, \"Raymarching demo.\" )\n        )\n        , React.createElement(Select, {\n          onChange: (e) => setResolution(+(e.target.value )),\n          value: resolution,}\n\n          , React.createElement(MenuItem, { value: 256,}, \"256x256\")\n          , React.createElement(MenuItem, { value: 512,}, \"512x512\")\n        )\n        , React.createElement(BoundNumberField, {\n          ...{ state, setStatePartial },\n          prop: \"a\",\n          inputProps: { step: 0.05 },}\n        ), \" \"\n        , React.createElement(BoundNumberField, {\n          ...{ state, setStatePartial },\n          prop: \"b\",\n          inputProps: { step: 0.05 },}\n        )\n        , React.createElement(BoundNumberField, {\n          ...{ state, setStatePartial },\n          prop: \"c\",\n          inputProps: { step: 0.05 },}\n        ), \" \"\n        , React.createElement(BoundNumberField, {\n          ...{ state, setStatePartial },\n          prop: \"d\",\n          inputProps: { step: 0.05 },}\n        )\n        , React.createElement(RenderButton, { dim: [1920, 1080],}, \"render hd\" )\n        , React.createElement(RenderButton, { dim: [3840, 2160],}, \"render 4k\" )\n        , React.createElement(Button, {\n          color: \"secondary\",\n          variant: \"outlined\",\n          onClick: () => setCam({ cam: \"999.999.999~-56.-58.-61~-44.-44.79\" }),}\n, \"Cam 0\"\n\n        )\n        , React.createElement(Button, {\n          color: \"secondary\",\n          variant: \"outlined\",\n          onClick: () => setCam({ cam: \"57.427.96~1.-100.-8~7.-7.99\" }),}\n, \"Cam 1\"\n\n        )\n        , React.createElement(Button, {\n          color: \"secondary\",\n          variant: \"outlined\",\n          onClick: () => setCam({ cam: \"53.80.892~-9.-8.-100~-18.-99.8\" }),}\n, \"Cam 2\"\n\n        )\n        , React.createElement('div', null, \"cam: \" , state.cam)\n        , React.createElement('div', null, \"fps: \" , fps)\n        , React.createElement(MatrixDisplay, {\n          label: \"gp\",\n          onFocus: () => setEditing(true),\n          onBlur: () => setEditing(false),}\n\n          , gp\n        )\n        , React.createElement('div', null\n          , React.createElement(Ed, { value: model, onChange: setModel,} )\n        )\n        , React.createElement('div', null\n          , React.createElement('pre', null\n            , React.createElement('code', null, makeShader(model))\n          )\n        )\n      )\n    )\n  )\n}\n","\nexport default \"#version 300 es\\n\\nprecision highp float;\\n\\n// START ../common/banded.glsl\\nfloat banded(float bandCount, float t) {\\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\\n}\\nfloat banded(int bandCount, float t) {\\n  return banded(float(bandCount), t);\\n}\\n\\n// #pragma glslify: export(banded)\\n\\n\\n// END ../common/banded.glsl\\n// START ../common/between.glsl\\nbool between(float min, float max, float value) {\\n  return min <= value && value <= max;\\n}\\n\\n// #pragma glslify: export(between)\\n\\n\\n// END ../common/between.glsl\\n// START ../common/hexFns.glsl\\n// START ./max3.glsl\\nfloat max3(float a, float b, float c) {\\n  return max(a, max(b, c));\\n}\\nfloat max3(vec3 v) {\\n  return max(v.x, max(v.y, v.z));\\n}\\n\\n// #pragma glslify: export(max3)\\n\\n\\n// END ./max3.glsl\\n// START ./constants.glsl\\nconst float SQRT1_2 = 0.7071067811865476;\\nconst float SQRT1_3 = 0.57735026919;\\nconst float SQRT2 = 1.4142135623730951;\\nconst float SQRT3 = 1.732050807568877;\\n// sqrt(3)/2 = sin(60*)\\nconst float SQRT3_2 = 0.86602540378;\\nconst float GOLDEN_RATIO = 1.61803398875;\\nconst float PI = 3.141592653589793;\\nconst float TAU = 6.28318530718;\\n/**\\n * One degree in radians. Use like `sin(30 * DEG)`.\\n */\\nconst float DEGREE = 0.017453292519943295;\\n\\n// END ./constants.glsl\\n\\nvec3 hexRound(vec3 hex) {\\n  vec3 r = floor(hex + 0.5);\\n  vec3 diff = abs(r - hex);\\n\\n  if (diff.x > diff.y && diff.x > diff.z) {\\n    r.x = -(r.y + r.z);\\n  } else if (diff.y > diff.z) {\\n    r.y = -(r.x + r.z);\\n  } else {\\n    r.z = -(r.x + r.y);\\n  }\\n\\n  return r;\\n}\\nvec2 hex2Ra(vec3 hex) {\\n  float y = hex.t * SQRT3_2;\\n  float x = hex.s + hex.t / 2.0;\\n  return vec2(x, y);\\n}\\n\\nfloat hexSdf(vec3 hex) {\\n  return max3(abs(hex.yzx + hex.zxy / 2.0));\\n}\\nvec3 ra2Hex(vec2 xy) {\\n  float hex_t = xy.y / SQRT3_2;\\n  float hex_s = xy.x - hex_t / 2.0;\\n  return vec3(hex_s, hex_t, -(hex_s + hex_t));\\n}\\n\\n// END ../common/hexFns.glsl\\n// START ../common/matrices.glsl\\n\\nmat2 rot2(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat2(c, s, -s, c);\\n}\\nmat3 rotX(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\\n}\\nmat3 rotY(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\\n}\\nmat3 rotZ(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\\n}\\n/**\\n * Returns a matrix that puts the camera at the eye point `ex, ey, ez` looking\\n * toward the center point `cx, cy, cz` with an up direction of `ux, uy, uz`.\\n * This emulates the OpenGL function `gluLookAt()`.\\n */\\nmat4 lookAt(vec3 eye, vec3 focus, vec3 up) {\\n  vec3 f = normalize(eye - focus);\\n  vec3 s = normalize(cross(up, f));\\n  vec3 t = normalize(cross(f, s));\\n\\n  return mat4(\\n    vec4(s.x, t.x, f.x, 0.0),\\n    vec4(s.y, t.y, f.y, 0.0),\\n    vec4(s.z, t.z, f.z, 0.0),\\n    vec4(-dot(s, eye), -dot(t, eye), -dot(f, eye), 1)\\n  );\\n}\\n\\n// the OpenGL function `glFrustum()`.\\nmat4 frustum(\\n  float left,\\n  float right,\\n  float bottom,\\n  float top,\\n  float near,\\n  float far\\n) {\\n  return mat4(\\n    vec4(2.0 * near / (right - left), 0.0, 0.0, 0.0),\\n    vec4(0, 2.0 * near / (top - bottom), 0.0, 0.0),\\n    vec4(\\n      (right + left) / (right - left),\\n      (top + bottom) / (top - bottom),\\n      -(far + near) / (far - near),\\n      -1\\n    ),\\n    vec4(0.0, 0.0, -2.0 * far * near / (far - near), 0.0)\\n  );\\n}\\n\\nmat4 perspective(float fovDegrees, float aspect, float near, float far) {\\n  float y = tan(fovDegrees * DEGREE / 2.0) * near;\\n  float x = y * aspect;\\n  return frustum(-x, x, -y, y, near, far);\\n}\\nmat4 ortho(\\n  float left,\\n  float right,\\n  float bottom,\\n  float top,\\n  float near,\\n  float far\\n) {\\n  return mat4(\\n    vec4(2.0 / (right - left), 0.0, 0.0, 0.0),\\n    vec4(0.0, 2.0 / (top - bottom), 0.0, 0.0),\\n    vec4(0.0, 0.0, -2.0 / (far - near), 0.0),\\n    vec4(\\n      -(right + left) / (right - left),\\n      -(top + bottom) / (top - bottom),\\n      -(far + near) / (far - near),\\n      1.0\\n    )\\n  );\\n}\\n\\n// END ../common/matrices.glsl\\n// START ../common/perlin2DTexture.glsl\\nuniform sampler2D gradients;\\n/* Create random direction vector\\n */\\nvec2 randomGradient(vec2 i) {\\n  // Random float. No precomputed gradients mean this works for any number of grid coordinates\\n  float random =\\n    2920.0 *\\n    sin(float(i.x) * 2.1942 + float(i.y) * 1.71324 + 8.912) *\\n    cos(float(i.x) * 2.3157 * float(i.y) * 2.17832 + 9.758);\\n  //    random = (i.x + 1667.) * (i.x + 2083.) * (i.y + 2659.) * (i.y * 50.77 + .3769);\\n  //    random = sin(SQRT2 * i.x) + cos(GOLDEN_RATIO * i.y) + tan((i.x + i.y) * SQRT3);\\n  return vec2(cos(random), sin(random));\\n}\\nfloat dotGridGradient(vec2 cell, vec2 pos) {\\n  vec2 d = cell - pos;\\n\\n  //  vec2 gradient = texelFetch(gradients, ivec2(cell), 0).xy;\\n  vec2 gradient = randomGradient(vec2(cell));\\n\\n  return dot(gradient, d);\\n}\\n\\nfloat mixx(float a, float b, float t) {\\n  return mix(a, b, smoothstep(0.0, 1.0, t));\\n  //    return mix(a, b, t);\\n}\\n\\n// resulting range is [-0.68, 0.68]. Use unmix to normalize if necessary.\\nfloat perlin2D(vec2 xy) {\\n  float x0 = floor(xy.x);\\n  float x1 = x0 + 1.0;\\n  float y0 = floor(xy.y);\\n  float y1 = y0 + 1.0;\\n\\n  // Interpolate between grid point gradients\\n  float n00 = dotGridGradient(vec2(x0, y0), xy);\\n  float n10 = dotGridGradient(vec2(x1, y0), xy);\\n  float ny0 = mixx(n00, n10, xy.x - x0);\\n\\n  float n01 = dotGridGradient(vec2(x0, y1), xy);\\n  float n11 = dotGridGradient(vec2(x1, y1), xy);\\n  float ny1 = mixx(n01, n11, xy.x - x0);\\n\\n  return mixx(ny0, ny1, xy.y - y0);\\n}\\n\\n// #pragma glslify: export(perlin2D)\\n\\n\\n// END ../common/perlin2DTexture.glsl\\n// START ../common/polar.glsl\\n// START ../common/fromPolar.glsl\\n// START ./unmix.glsl\\nfloat unmix(float a, float b, float value) {\\n  return (value - a) / (b - a);\\n}\\n\\n// #pragma glslify: export(unmix)\\n\\n\\n// END ./unmix.glsl\\n\\nvec3 fromPolar(float radius, float phi, float z) {\\n  return vec3(radius * cos(phi), radius * sin(phi), z);\\n}\\n\\nvec2 fromPolar(float radius, float phi) {\\n  return vec2(radius * cos(phi), radius * sin(phi));\\n}\\n\\nvec2 fromPolar(vec2 polar) {\\n  return fromPolar(polar.x, polar.y);\\n}\\n\\n// #pragma glslify: export(fromPolar)\\n\\n\\n// END ../common/fromPolar.glsl\\n// START ../common/toPolar.glsl\\n\\nvec2 toPolar(vec2 xy) {\\n  return vec2(length(xy), atan(xy.y, xy.x));\\n}\\n\\nmat2 toPolarDerivate(vec2 xy) {\\n  return mat2(xy.x * xy.x, xy.y * xy.y, -xy.y, xy.x) / dot(xy, xy);\\n}\\n\\n// #pragma glslify: export(toPolar)\\n\\n\\n// END ../common/toPolar.glsl\\n\\n// END ../common/polar.glsl\\n// START ../common/remix.glsl\\n\\nfloat remix(float fromA, float fromB, float toA, float toB, float value) {\\n  return mix(toA, toB, unmix(fromA, fromB, value));\\n}\\n\\nvec4 remix(float fromA, float fromB, vec4 toA, vec4 toB, float value) {\\n  return mix(toA, toB, unmix(fromA, fromB, value));\\n}\\n\\n// #pragma glslify: export(remix)\\n\\n\\n// END ../common/remix.glsl\\n// START ../common/transform.glsl\\nvec3 transform(mat4 pm, vec3 p) {\\n  vec4 pStar = pm * vec4(p, 1);\\n  return pStar.xyz / pStar.w;\\n}\\n\\nvec2 transform(mat4 pm, vec2 p) {\\n  vec4 pStar = pm * vec4(p, 0, 1);\\n  return pStar.xy / pStar.w;\\n}\\n\\n// END ../common/transform.glsl\\n// START ../common/visualize.glsl\\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\\n  float isLow = float(t < 0.0);\\n  float isHigh = float(t > 1.0);\\n  float isMid = 1.0 - isLow - isHigh;\\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\\n}\\n\\nvec4 visualize(float t) {\\n  const vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\\n  const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\\n  return visualize(BLUE, RED, t);\\n}\\n\\n// #pragma glslify: export(visualize)\\n\\n\\n// END ../common/visualize.glsl\\n// START ../common/waves.glsl\\nfloat waves(vec4 color, vec2 position, vec2 direction, float highResTimeStamp) {\\n  return sin(\\n    dot(position, direction / pow(length(direction), 2.0)) +\\n      float(highResTimeStamp) / 200.0\\n  );\\n}\\n\\n// #pragma glslify: export(waves)\\n\\n\\n// END ../common/waves.glsl\\n\\n// START ../common/sdf3d/sdTorus.glsl\\nfloat sdTorus(float r0, float r1, vec3 p) {\\n  vec3 closestCenter = vec3(normalize(p.xy) * r0, 0.0);\\n  return distance(closestCenter, p) - r1;\\n}\\n\\n// #pragma glslify: export(sdTorus)\\n\\n\\n// END ../common/sdf3d/sdTorus.glsl\\n// START ../common/sdf3d/sdCapsule.glsl\\nfloat sdCapsule(vec3 a, vec3 b, float r, vec3 p) {\\n  vec3 pa = p - a;\\n  vec3 ba = b - a;\\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\\n  return length(pa - ba * h) - r;\\n}\\n// #pragma glslify: export(sdCapsule)\\n\\n// END ../common/sdf3d/sdCapsule.glsl\\n// START ../common/sdf3d/opElongate.glsl\\nvec3 opElongate(vec3 h, vec3 p) {\\n  return p - clamp(p, -h, h);\\n}\\n// #pragma glslify: export(opElongate)\\n\\n// END ../common/sdf3d/opElongate.glsl\\n// START ../common/sdf3d/sdSphere.glsl\\nfloat sdSphere(float radius, vec3 p) {\\n  return length(p) - radius;\\n}\\n\\n// #pragma glslify: export(sdSphere)\\n\\n\\n// END ../common/sdf3d/sdSphere.glsl\\n// START ../common/sdf3d/sdCylinder.glsl\\nfloat sdCylinder(float radius, float z, vec3 p) {\\n  vec2 d = vec2(length(p.xy), abs(p.z)) - vec2(radius, z);\\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\\n}\\n\\n// #pragma glslify: export(sdCylinder)\\n\\n\\n// END ../common/sdf3d/sdCylinder.glsl\\n// START ../common/sdf3d/sdCone.glsl\\n\\n/**\\n * Signed distance function (SDF) of a cone. The tip of the cone is at the\\n * origin and points towards +Z. q is a point on the rim of the cone.\\n */\\nfloat sdCone(vec2 c, float h, vec3 p) {\\n  vec2 q = h * vec2(c.x / c.y, -1.0);\\n  vec2 w = vec2(length(p.xz), p.y);\\n  vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);\\n  vec2 b = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0);\\n  float k = sign(q.y);\\n  float d = min(dot(a, a), dot(b, b));\\n  float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));\\n  return sqrt(d) * sign(s);\\n}\\n// #pragma glslify: export(sdBox)\\n\\nfloat sdConeB(vec2 c, float h, vec3 p) {\\n  float q = length(p.xz);\\n  return max(dot(c.xy, vec2(q, p.y)), -h - p.y);\\n}\\n\\n// END ../common/sdf3d/sdCone.glsl\\n// START ../common/sdf2d/addChamfer.glsl\\n\\nfloat addChamfer(float d, float a, float b) {\\n  // exact variant, but abs is larger when a and b aren't perpendicular\\n  // which is worse than underestimating, which is what the simple version does.\\n  //  vec2 p = vec2(a, b);\\n  //  if (p.x < d && p.y < d) {\\n  //    p = rot2(0.25 * PI) * p;\\n  //    p.y = abs(p.y);\\n  //    p.y -= min(p.y, d * SQRT1_2);\\n  //    p.x -= d * SQRT1_2;\\n  //    //    p -= vec2(SQRT1_2) * clamp(dot(p, vec2(SQRT1_2)), 0.0, d);\\n  //    float fillet = -length(p);\\n  //    return -sign(p.x) * fillet;\\n  //  } else {\\n  //  }\\n  float tillet = (a + b - d) * SQRT1_2;\\n  return min(tillet, min(a, b));\\n}\\n\\n// #pragma glslify: export(addChamfer)\\n\\n\\n// END ../common/sdf2d/addChamfer.glsl\\n// START ../common/sdf2d/addFillet.glsl\\nfloat addFillet(float r, float a, float b) {\\n  if (a < r && b < r) {\\n    return r - distance(vec2(a, b), vec2(r));\\n  } else {\\n    return min(a, b);\\n  }\\n}\\n\\n// #pragma glslify: export(addFillet)\\n\\n\\n// END ../common/sdf2d/addFillet.glsl\\n// START ../common/sdf3d/sdBox.glsl\\n\\nfloat sdBox(vec3 r, vec3 p) {\\n  vec3 q = abs(p) - r;\\n  return length(max(q, 0.0)) + min(max3(q), 0.0);\\n}\\n\\nfloat sdBox(vec3 r, float r2, vec3 p) {\\n  return sdBox(r - r2, p) - r2;\\n}\\n\\n// #pragma glslify: export(sdBox)\\n\\n\\n// END ../common/sdf3d/sdBox.glsl\\n// START ../common/sdf3d/sdOctahedron.glsl\\nfloat sdOctahedron(float s, vec3 p) {\\n  p = abs(p);\\n  float m = p.x + p.y + p.z - s;\\n  vec3 q;\\n  if (3.0 * p.x < m) q = p.xyz;\\n  else if (3.0 * p.y < m) q = p.yzx;\\n  else if (3.0 * p.z < m) q = p.zxy;\\n  else return m * 0.57735027;\\n\\n  float k = clamp(0.5 * (q.z - q.y + s), 0.0, s);\\n  return length(vec3(q.x, q.y - s + k, q.z - k));\\n}\\n// #pragma glslify: export(sdOctahedron)\\n\\nfloat sdOctahedron(vec3 p, float s) {\\n  p = abs(p);\\n\\n  float m = p.x + p.y + p.z - s;\\n  //find point on octohedron surf nearest to p\\n  vec3 projPoint = p - vec3(0.333333 * m); //project onto surface plane\\n  //now push projected point, if outside triangle edge, perpendicular to edge, to edge\\n  vec3 toMove = min(projPoint, 0.0); //if projpoint.x<0 move along (1.0,-0.5,-0.5) , etc\\n  float toMoveSum = dot(toMove, vec3(1.0)); //which is basically along (1.5,0,0) then vec3(-0.5)\\n\\n  vec3 movedPoint = projPoint + toMove * vec3(-1.5) + toMoveSum * vec3(0.5); //better to multiply toMove by a matrix (1s diagonal, 0.5 other)?\\n\\n  movedPoint = max(movedPoint, 0.0); //cap x,y,z to 0 then\\n  movedPoint *= s / dot(movedPoint, vec3(1.0)); //scale about 0,0,0\\n\\n  return length(p - movedPoint);\\n}\\n\\n// END ../common/sdf3d/sdOctahedron.glsl\\n// START ../common/sdf3d/add.glsl\\nfloat add(float a, float b) {\\n  return min(a, b);\\n}\\n\\n// #pragma glslify: export(add)\\n\\n\\n// END ../common/sdf3d/add.glsl\\n// START ../common/sdf3d/sub.glsl\\nfloat sub(float from, float what) {\\n  return max(from, -what);\\n}\\n\\n// #pragma glslify: export(sub)\\n\\n\\n// END ../common/sdf3d/sub.glsl\\n\\nuniform sampler2D texture;\\nuniform float secs;\\nuniform mat4 lll;\\nuniform mat4 llli;\\nuniform vec4 colorPrimary;\\nuniform vec4 colorSecondary;\\nuniform vec4 colorBackground;\\nuniform float a;\\nuniform float b;\\nuniform float c;\\nuniform float d;\\nuniform float highResTimeStamp;\\nuniform int bandCount;\\nuniform vec3 campos;\\nin float n;\\nin vec2 coord;\\nout vec4 fragColor;\\n\\n\\nconst vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\\nconst vec4 yellow = vec4(1.0, 1.0, 0.0, 1.0);\\nconst vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\\nconst vec4 blue = vec4(0.0, 0.0, 1.0, 1.0);\\nconst vec4 purple = vec4(0.5, 0.0, 0.5, 1.0);\\nconst vec4 red = vec4(1.0, 0.0, 0.0, 1.0);\\n\\nstruct RMHit {\\n  float distance;\\n  vec4 color;\\n};\\nRMHit mixa(RMHit a, RMHit b, float t) {\\n  return RMHit(mix(a.distance, b.distance, t), mix(a.color, b.color, t));\\n}\\nfloat skybox(vec3 p) {\\n  return 32.0 - max3(abs(p));\\n}\\n\\nfloat perlinSphere(float radius, vec3 p) {\\n  vec3 cp = normalize(p);\\n  float alpha = atan(cp.y, cp.x);\\n  float beta = asin(cp.z);\\n  return length(p) -\\n  radius +\\n  0.1 *\\n    perlin2D(vec2(0.0 / 100.0, 0.0) + (vec2(5.0) + vec2(alpha, beta)) * 8.0);\\n}\\n\\nfloat cylCircle(vec3 p) {\\n  float d = 10e9;\\n  for (int i = 0; i < 10; i++) {\\n    d = min(\\n      d,\\n      sdCylinder(0.2, 2.0, p + fromPolar(3.0, TAU * float(i) / 10.0, 1.0))\\n    );\\n  }\\n\\n  return d;\\n}\\n\\nfloat rblock(float r, out vec3 p) {\\n  return sdBox(vec3(r), p);\\n}\\n\\nRMHit add(RMHit a, RMHit b) {\\n  //    return a.distance < b.distance\\n  //        ? RMHit(a.distance, a.color)\\n  //        : RMHit(b.distance, b.color);\\n  return mixa(a, b, float(b.distance < a.distance));\\n}\\n\\nfloat wtf(vec3 p) {\\n  vec3 center = p - mod(p, 3.0) + vec3(1.5);\\n  return rblock(0.4 + 0.3 * sin(secs + center.x), center);\\n}\\n\\nRMHit addFillet(float r, RMHit a, RMHit b) {\\n  if (a.distance < r && b.distance < r) {\\n    return RMHit(\\n      r - distance(vec2(a.distance, b.distance), vec2(r)),\\n      mix(a.color, b.color, (a.distance - b.distance) / r * 0.5 + 0.5)\\n    );\\n  } else {\\n    return add(a, b);\\n  }\\n}\\n\\nRMHit addFillet(float r, RMHit a, RMHit b, vec4 tilletColor) {\\n  if (a.distance < r && b.distance < r) {\\n    return RMHit(\\n      r - distance(vec2(a.distance, b.distance), vec2(r)),\\n      tilletColor\\n    );\\n  } else {\\n    return add(a, b);\\n  }\\n}\\nRMHit addFillet2(float r, RMHit a, RMHit b) {\\n  float h = smoothstep(-r, r, a.distance - b.distance);\\n  return RMHit(\\n    mix(a.distance, b.distance, h) - r * h * (1.0 - h),\\n    mix(a.color, b.color, h)\\n  );\\n}\\n\\nRMHit neg(RMHit a) {\\n  return RMHit(-a.distance, a.color);\\n}\\nRMHit sub(RMHit from, RMHit what) {\\n  RMHit whatNeg = neg(what);\\n  return mixa(from, whatNeg, float(whatNeg.distance > from.distance));\\n}\\n\\nvec3 modv(vec3 v, vec3 dir1, float y) {\\n  float t = dot(v, dir1);\\n  return v - floor(t / y) * y * dir1;\\n}\\nvec3 modRotZ(vec3 p, float count) {\\n  vec2 polarXY = toPolar(p.xy);\\n  return fromPolar(polarXY.x, mod(polarXY.y, TAU / count), p.z);\\n}\\n\\nfloat sin01(float x) {\\n  return 0.5 + 0.5 * sin(x);\\n}\\nfloat cos01(float x) {\\n  return 0.5 + 0.5 * cos(x);\\n}\\n\\nfloat betterBox(vec3 r, vec3 p) {\\n  vec3 q = abs(p) - r;\\n  return length(max(q, 0.0)) + min(max3(q), 0.0);\\n  p = abs(p);\\n  return max3(p - r);\\n}\\n\\nfloat sdEllipsoidB(vec3 r, vec3 p) {\\n  float k0 = length(p / r);\\n  float k1 = length(p / (r * r));\\n  return k0 * (k0 - 1.0) / k1;\\n}\\nfloat sdOctahedronB(float s, vec3 p) {\\n  p = abs(p);\\n  return (p.x + p.y + p.z - s) * 0.57735027;\\n}\\nfloat donutc(float r0, float r1, vec3 p) {\\n  vec3 closestCenter = vec3(normalize(p.xy) * r0, 0.0);\\n  return distance(closestCenter, p) - r1;\\n}\\n\\nfloat smoothmin(float r, float a, float b) {\\n  float h = smoothstep(-r, r, a - b);\\n  return mix(a, b, h) - r * h * (1.0 - h);\\n}\\n\\nRMHit sdf(vec3 p) {\\n  return RMHit(0.0, black);\\n}\\n\\nfloat sdff(vec3 p) {\\n  return sdf(p).distance;\\n}\\n\\nstruct RMResult {\\n  float distance;\\n  vec3 pos;\\n  vec4 color;\\n};\\nRMResult raymarching2(vec3 start, vec3 dir1) {\\n  vec3 pos = start;\\n  RMHit hit;\\n  for (int i = 0; i < 200; i++) {\\n    hit = sdf(pos);\\n    if (hit.distance < 0.0001) break;\\n    pos = pos + dir1 * hit.distance;\\n  }\\n  return RMResult(hit.distance, pos, hit.color);\\n}\\n\\nfloat softshadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {\\n  float res = 1.0;\\n  float t = 0.1;\\n  for (int i = 0; i < 1000 && t < maxt; i++) {\\n    float h = sdff(ro + rd * t);\\n    if (h < 0.001) return 0.0;\\n    res = min(res, k * h / t);\\n    t += h;\\n  }\\n  return res;\\n}\\n\\nconst float eps = 1e-4;\\nvec3 sdfNormal1(vec3 p, float d) {\\n  return normalize(\\n    vec3(\\n      sdff(p + vec3(eps, 0.0, 0.0)),\\n      sdff(p + vec3(0.0, eps, 0.0)),\\n      sdff(p + vec3(0.0, 0.0, eps))\\n    ) -\\n      sdff(p)\\n  );\\n}\\n\\nfloat ambientOcclusion(vec3 pWC, vec3 n1WC) {\\n  float k = 1.0;\\n  float distance = sdff(pWC + n1WC * k);\\n  return clamp(distance / k, 0.0, 1.0);\\n}\\n\\n//layout (depth_greater) out float gl_FragDepth;\\nvoid main() {\\n  vec3 light = normalize(vec3(-1.0, -2.0, -2));\\n\\n  vec3 a = vec3(coord, -1.0);\\n  vec3 b = vec3(coord, 1.0);\\n  vec3 aWC = transform(llli, a);\\n  vec3 bWC = transform(llli, b);\\n  vec3 lookDir1 = normalize(bWC - aWC);\\n\\n  RMResult hitWC = raymarching2(aWC, lookDir1);\\n  vec3 hitn1 = sdfNormal1(hitWC.pos, hitWC.distance);\\n  float dWC = distance(aWC, hitWC.pos);\\n  vec3 hitNDC = transform(lll, hitWC.pos);\\n\\n  vec3 sunPoint = raymarching2(hitWC.pos + hitn1 * 0.1, -light).pos;\\n  //    float inSun = float(distance(hitWC.pos, sunPoint) > 30.);\\n  float inSun = softshadow(\\n    hitWC.pos + hitn1 * 0.05,\\n    -light,\\n    0.0001,\\n    300.0,\\n    8.0\\n  );\\n  //    float inSun=1.;\\n\\n  vec3 material = vec3(0.0, 0.2, 0.0);\\n  if (dWC > 100.0) {\\n    material = vec3(0.0, 0.0, 0.0);\\n  }\\n\\n  const vec3 sunlightColor = vec3(8.0, 6.0, 1.0);\\n\\n  float aOcc = ambientOcclusion(hitWC.pos, hitn1);\\n\\n  vec3 reflectionDirection = reflect(light, hitn1);\\n\\n  vec3 color = vec3(0.0);\\n  color += material * aOcc;\\n  color += inSun * sunlightColor * material * max(0.0, dot(-light, hitn1));\\n  //    color = (hitn1);\\n\\n  vec3 camPos = aWC;\\n\\n  vec3 eyeDirection = -lookDir1;\\n  float uMaterialShininess = 256.0;\\n  float specularLightWeighting = pow(\\n    max(dot(reflectionDirection, eyeDirection), 0.0),\\n    uMaterialShininess\\n  );\\n  color += specularLightWeighting;\\n  //    float lightIntensity = 0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.);\\n  //    float lightIntensity =\\n  //        0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.) + 0.3*specularLightWeighting;\\n  //    fragColor = visualize(blue, red, mix(0.5, 1.0, inSun) * lightIntensity);\\n  //    fragColor = mix(hitWC.color, colorBackground, mix(0.5, 1.0, inSun) * clamp(lightIntensity, 0., 1.));\\n  color = pow(color, vec3(1.0 / 2.2)); // gamma correction\\n  fragColor = vec4(color, 1.0);\\n  //    fragColor = visualize(hitWC.pos.x/10.);\\n  //    fragColor = hitWC.color;\\n  //    fragColor = visualize(blue, red, distance(hitWC, sunPoint)/20.);\\n  //    fragColor = vec4(coord,0.,1.);\\n  //    fragColor = vec4(aWC, 1.0);\\n  // remap [-1, 1] to [0, 1]\\n  // gl_FragDepth = hitNDC.z * 0.5 + 0.5;\\n  //    gl_FragDepth = .9999999;\\n}\\n\"\nconst sourceMap = {\"version\":3,\"sources\":[\"/home/runner/work/workshop/workshop/src/raymarch/ed.frag\",\"/home/runner/work/workshop/workshop/src/common/banded.glsl\",\"/home/runner/work/workshop/workshop/src/common/between.glsl\",\"/home/runner/work/workshop/workshop/src/common/max3.glsl\",\"/home/runner/work/workshop/workshop/src/common/constants.glsl\",\"/home/runner/work/workshop/workshop/src/common/hexFns.glsl\",\"/home/runner/work/workshop/workshop/src/common/matrices.glsl\",\"/home/runner/work/workshop/workshop/src/common/perlin2DTexture.glsl\",\"/home/runner/work/workshop/workshop/src/common/unmix.glsl\",\"/home/runner/work/workshop/workshop/src/common/fromPolar.glsl\",\"/home/runner/work/workshop/workshop/src/common/toPolar.glsl\",\"/home/runner/work/workshop/workshop/src/common/polar.glsl\",\"/home/runner/work/workshop/workshop/src/common/remix.glsl\",\"/home/runner/work/workshop/workshop/src/common/transform.glsl\",\"/home/runner/work/workshop/workshop/src/common/visualize.glsl\",\"/home/runner/work/workshop/workshop/src/common/waves.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdTorus.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdCapsule.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/opElongate.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdSphere.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdCylinder.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdCone.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf2d/addChamfer.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf2d/addFillet.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdBox.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdOctahedron.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/add.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sub.glsl\"],\"names\":[],\"mappings\":\"AAAA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AfOA;;AgBhBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACPA;AACA;AACA;AACA;AACA;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;;A3BwBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA\"}\nexport { sourceMap };\n","\nexport default \"#version 300 es\\n\\nprecision highp float;\\n\\n// START ../common/banded.glsl\\nfloat banded(float bandCount, float t) {\\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\\n}\\nfloat banded(int bandCount, float t) {\\n  return banded(float(bandCount), t);\\n}\\n\\n// #pragma glslify: export(banded)\\n\\n\\n// END ../common/banded.glsl\\n// START ../common/between.glsl\\nbool between(float min, float max, float value) {\\n  return min <= value && value <= max;\\n}\\n\\n// #pragma glslify: export(between)\\n\\n\\n// END ../common/between.glsl\\n// START ../common/hexFns.glsl\\n// START ./max3.glsl\\nfloat max3(float a, float b, float c) {\\n  return max(a, max(b, c));\\n}\\nfloat max3(vec3 v) {\\n  return max(v.x, max(v.y, v.z));\\n}\\n\\n// #pragma glslify: export(max3)\\n\\n\\n// END ./max3.glsl\\n// START ./constants.glsl\\nconst float SQRT1_2 = 0.7071067811865476;\\nconst float SQRT1_3 = 0.57735026919;\\nconst float SQRT2 = 1.4142135623730951;\\nconst float SQRT3 = 1.732050807568877;\\n// sqrt(3)/2 = sin(60*)\\nconst float SQRT3_2 = 0.86602540378;\\nconst float GOLDEN_RATIO = 1.61803398875;\\nconst float PI = 3.141592653589793;\\nconst float TAU = 6.28318530718;\\n/**\\n * One degree in radians. Use like `sin(30 * DEG)`.\\n */\\nconst float DEGREE = 0.017453292519943295;\\n\\n// END ./constants.glsl\\n\\nvec3 hexRound(vec3 hex) {\\n  vec3 r = floor(hex + 0.5);\\n  vec3 diff = abs(r - hex);\\n\\n  if (diff.x > diff.y && diff.x > diff.z) {\\n    r.x = -(r.y + r.z);\\n  } else if (diff.y > diff.z) {\\n    r.y = -(r.x + r.z);\\n  } else {\\n    r.z = -(r.x + r.y);\\n  }\\n\\n  return r;\\n}\\nvec2 hex2Ra(vec3 hex) {\\n  float y = hex.t * SQRT3_2;\\n  float x = hex.s + hex.t / 2.0;\\n  return vec2(x, y);\\n}\\n\\nfloat hexSdf(vec3 hex) {\\n  return max3(abs(hex.yzx + hex.zxy / 2.0));\\n}\\nvec3 ra2Hex(vec2 xy) {\\n  float hex_t = xy.y / SQRT3_2;\\n  float hex_s = xy.x - hex_t / 2.0;\\n  return vec3(hex_s, hex_t, -(hex_s + hex_t));\\n}\\n\\n// END ../common/hexFns.glsl\\n// START ../common/matrices.glsl\\n\\nmat2 rot2(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat2(c, s, -s, c);\\n}\\nmat3 rotX(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\\n}\\nmat3 rotY(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\\n}\\nmat3 rotZ(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\\n}\\n/**\\n * Returns a matrix that puts the camera at the eye point `ex, ey, ez` looking\\n * toward the center point `cx, cy, cz` with an up direction of `ux, uy, uz`.\\n * This emulates the OpenGL function `gluLookAt()`.\\n */\\nmat4 lookAt(vec3 eye, vec3 focus, vec3 up) {\\n  vec3 f = normalize(eye - focus);\\n  vec3 s = normalize(cross(up, f));\\n  vec3 t = normalize(cross(f, s));\\n\\n  return mat4(\\n    vec4(s.x, t.x, f.x, 0.0),\\n    vec4(s.y, t.y, f.y, 0.0),\\n    vec4(s.z, t.z, f.z, 0.0),\\n    vec4(-dot(s, eye), -dot(t, eye), -dot(f, eye), 1)\\n  );\\n}\\n\\n// the OpenGL function `glFrustum()`.\\nmat4 frustum(\\n  float left,\\n  float right,\\n  float bottom,\\n  float top,\\n  float near,\\n  float far\\n) {\\n  return mat4(\\n    vec4(2.0 * near / (right - left), 0.0, 0.0, 0.0),\\n    vec4(0, 2.0 * near / (top - bottom), 0.0, 0.0),\\n    vec4(\\n      (right + left) / (right - left),\\n      (top + bottom) / (top - bottom),\\n      -(far + near) / (far - near),\\n      -1\\n    ),\\n    vec4(0.0, 0.0, -2.0 * far * near / (far - near), 0.0)\\n  );\\n}\\n\\nmat4 perspective(float fovDegrees, float aspect, float near, float far) {\\n  float y = tan(fovDegrees * DEGREE / 2.0) * near;\\n  float x = y * aspect;\\n  return frustum(-x, x, -y, y, near, far);\\n}\\nmat4 ortho(\\n  float left,\\n  float right,\\n  float bottom,\\n  float top,\\n  float near,\\n  float far\\n) {\\n  return mat4(\\n    vec4(2.0 / (right - left), 0.0, 0.0, 0.0),\\n    vec4(0.0, 2.0 / (top - bottom), 0.0, 0.0),\\n    vec4(0.0, 0.0, -2.0 / (far - near), 0.0),\\n    vec4(\\n      -(right + left) / (right - left),\\n      -(top + bottom) / (top - bottom),\\n      -(far + near) / (far - near),\\n      1.0\\n    )\\n  );\\n}\\n\\n// END ../common/matrices.glsl\\n// START ../common/perlin2DTexture.glsl\\nuniform sampler2D gradients;\\n/* Create random direction vector\\n */\\nvec2 randomGradient(vec2 i) {\\n  // Random float. No precomputed gradients mean this works for any number of grid coordinates\\n  float random =\\n    2920.0 *\\n    sin(float(i.x) * 2.1942 + float(i.y) * 1.71324 + 8.912) *\\n    cos(float(i.x) * 2.3157 * float(i.y) * 2.17832 + 9.758);\\n  //    random = (i.x + 1667.) * (i.x + 2083.) * (i.y + 2659.) * (i.y * 50.77 + .3769);\\n  //    random = sin(SQRT2 * i.x) + cos(GOLDEN_RATIO * i.y) + tan((i.x + i.y) * SQRT3);\\n  return vec2(cos(random), sin(random));\\n}\\nfloat dotGridGradient(vec2 cell, vec2 pos) {\\n  vec2 d = cell - pos;\\n\\n  //  vec2 gradient = texelFetch(gradients, ivec2(cell), 0).xy;\\n  vec2 gradient = randomGradient(vec2(cell));\\n\\n  return dot(gradient, d);\\n}\\n\\nfloat mixx(float a, float b, float t) {\\n  return mix(a, b, smoothstep(0.0, 1.0, t));\\n  //    return mix(a, b, t);\\n}\\n\\n// resulting range is [-0.68, 0.68]. Use unmix to normalize if necessary.\\nfloat perlin2D(vec2 xy) {\\n  float x0 = floor(xy.x);\\n  float x1 = x0 + 1.0;\\n  float y0 = floor(xy.y);\\n  float y1 = y0 + 1.0;\\n\\n  // Interpolate between grid point gradients\\n  float n00 = dotGridGradient(vec2(x0, y0), xy);\\n  float n10 = dotGridGradient(vec2(x1, y0), xy);\\n  float ny0 = mixx(n00, n10, xy.x - x0);\\n\\n  float n01 = dotGridGradient(vec2(x0, y1), xy);\\n  float n11 = dotGridGradient(vec2(x1, y1), xy);\\n  float ny1 = mixx(n01, n11, xy.x - x0);\\n\\n  return mixx(ny0, ny1, xy.y - y0);\\n}\\n\\n// #pragma glslify: export(perlin2D)\\n\\n\\n// END ../common/perlin2DTexture.glsl\\n// START ../common/polar.glsl\\n// START ../common/fromPolar.glsl\\n// START ./unmix.glsl\\nfloat unmix(float a, float b, float value) {\\n  return (value - a) / (b - a);\\n}\\n\\n// #pragma glslify: export(unmix)\\n\\n\\n// END ./unmix.glsl\\n\\nvec3 fromPolar(float radius, float phi, float z) {\\n  return vec3(radius * cos(phi), radius * sin(phi), z);\\n}\\n\\nvec2 fromPolar(float radius, float phi) {\\n  return vec2(radius * cos(phi), radius * sin(phi));\\n}\\n\\nvec2 fromPolar(vec2 polar) {\\n  return fromPolar(polar.x, polar.y);\\n}\\n\\n// #pragma glslify: export(fromPolar)\\n\\n\\n// END ../common/fromPolar.glsl\\n// START ../common/toPolar.glsl\\n\\nvec2 toPolar(vec2 xy) {\\n  return vec2(length(xy), atan(xy.y, xy.x));\\n}\\n\\nmat2 toPolarDerivate(vec2 xy) {\\n  return mat2(xy.x * xy.x, xy.y * xy.y, -xy.y, xy.x) / dot(xy, xy);\\n}\\n\\n// #pragma glslify: export(toPolar)\\n\\n\\n// END ../common/toPolar.glsl\\n\\n// END ../common/polar.glsl\\n// START ../common/remix.glsl\\n\\nfloat remix(float fromA, float fromB, float toA, float toB, float value) {\\n  return mix(toA, toB, unmix(fromA, fromB, value));\\n}\\n\\nvec4 remix(float fromA, float fromB, vec4 toA, vec4 toB, float value) {\\n  return mix(toA, toB, unmix(fromA, fromB, value));\\n}\\n\\n// #pragma glslify: export(remix)\\n\\n\\n// END ../common/remix.glsl\\n// START ../common/transform.glsl\\nvec3 transform(mat4 pm, vec3 p) {\\n  vec4 pStar = pm * vec4(p, 1);\\n  return pStar.xyz / pStar.w;\\n}\\n\\nvec2 transform(mat4 pm, vec2 p) {\\n  vec4 pStar = pm * vec4(p, 0, 1);\\n  return pStar.xy / pStar.w;\\n}\\n\\n// END ../common/transform.glsl\\n// START ../common/visualize.glsl\\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\\n  float isLow = float(t < 0.0);\\n  float isHigh = float(t > 1.0);\\n  float isMid = 1.0 - isLow - isHigh;\\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\\n}\\n\\nvec4 visualize(float t) {\\n  const vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\\n  const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\\n  return visualize(BLUE, RED, t);\\n}\\n\\n// #pragma glslify: export(visualize)\\n\\n\\n// END ../common/visualize.glsl\\n// START ../common/waves.glsl\\nfloat waves(vec4 color, vec2 position, vec2 direction, float highResTimeStamp) {\\n  return sin(\\n    dot(position, direction / pow(length(direction), 2.0)) +\\n      float(highResTimeStamp) / 200.0\\n  );\\n}\\n\\n// #pragma glslify: export(waves)\\n\\n\\n// END ../common/waves.glsl\\n\\n// START ../common/sdf3d/add.glsl\\nfloat add(float a, float b) {\\n  return min(a, b);\\n}\\n\\n// #pragma glslify: export(add)\\n\\n\\n// END ../common/sdf3d/add.glsl\\n// START ../common/sdf2d/addChamfer.glsl\\n\\nfloat addChamfer(float d, float a, float b) {\\n  // exact variant, but abs is larger when a and b aren't perpendicular\\n  // which is worse than underestimating, which is what the simple version does.\\n  //  vec2 p = vec2(a, b);\\n  //  if (p.x < d && p.y < d) {\\n  //    p = rot2(0.25 * PI) * p;\\n  //    p.y = abs(p.y);\\n  //    p.y -= min(p.y, d * SQRT1_2);\\n  //    p.x -= d * SQRT1_2;\\n  //    //    p -= vec2(SQRT1_2) * clamp(dot(p, vec2(SQRT1_2)), 0.0, d);\\n  //    float fillet = -length(p);\\n  //    return -sign(p.x) * fillet;\\n  //  } else {\\n  //  }\\n  float tillet = (a + b - d) * SQRT1_2;\\n  return min(tillet, min(a, b));\\n}\\n\\n// #pragma glslify: export(addChamfer)\\n\\n\\n// END ../common/sdf2d/addChamfer.glsl\\n// START ../common/sdf2d/addFillet.glsl\\nfloat addFillet(float r, float a, float b) {\\n  if (a < r && b < r) {\\n    return r - distance(vec2(a, b), vec2(r));\\n  } else {\\n    return min(a, b);\\n  }\\n}\\n\\n// #pragma glslify: export(addFillet)\\n\\n\\n// END ../common/sdf2d/addFillet.glsl\\n// START ../common/sdf3d/opElongate.glsl\\nvec3 opElongate(vec3 h, vec3 p) {\\n  return p - clamp(p, -h, h);\\n}\\n// #pragma glslify: export(opElongate)\\n\\n// END ../common/sdf3d/opElongate.glsl\\n// START ../common/sdf3d/opRepLim.glsl\\nvec3 opRepLim(vec3 p, vec3 cellSize, vec3 limit) {\\n  return p - cellSize * clamp(round(p / cellSize), vec3(0.0), limit);\\n}\\nvec2 opRepLim(vec2 p, vec2 cellSize, vec2 limit) {\\n  return p - cellSize * clamp(round(p / cellSize), vec2(0.0), limit);\\n}\\nfloat opRepLim(float p, float cellSize, float limit) {\\n  return p - cellSize * clamp(round(p / cellSize), 0.0, limit);\\n}\\n\\n// #pragma glslify: export(opRepLim)\\n\\n\\n// END ../common/sdf3d/opRepLim.glsl\\n// START ../common/sdf3d/sdBox.glsl\\n\\nfloat sdBox(vec3 r, vec3 p) {\\n  vec3 q = abs(p) - r;\\n  return length(max(q, 0.0)) + min(max3(q), 0.0);\\n}\\n\\nfloat sdBox(vec3 r, float r2, vec3 p) {\\n  return sdBox(r - r2, p) - r2;\\n}\\n\\n// #pragma glslify: export(sdBox)\\n\\n\\n// END ../common/sdf3d/sdBox.glsl\\n// START ../common/sdf3d/sdCone.glsl\\n\\n/**\\n * Signed distance function (SDF) of a cone. The tip of the cone is at the\\n * origin and points towards +Z. q is a point on the rim of the cone.\\n */\\nfloat sdCone(vec2 c, float h, vec3 p) {\\n  vec2 q = h * vec2(c.x / c.y, -1.0);\\n  vec2 w = vec2(length(p.xz), p.y);\\n  vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);\\n  vec2 b = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0);\\n  float k = sign(q.y);\\n  float d = min(dot(a, a), dot(b, b));\\n  float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));\\n  return sqrt(d) * sign(s);\\n}\\n// #pragma glslify: export(sdBox)\\n\\nfloat sdConeB(vec2 c, float h, vec3 p) {\\n  float q = length(p.xz);\\n  return max(dot(c.xy, vec2(q, p.y)), -h - p.y);\\n}\\n\\n// END ../common/sdf3d/sdCone.glsl\\n// START ../common/sdf3d/sdCylinder.glsl\\nfloat sdCylinder(float radius, float z, vec3 p) {\\n  vec2 d = vec2(length(p.xy), abs(p.z)) - vec2(radius, z);\\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\\n}\\n\\n// #pragma glslify: export(sdCylinder)\\n\\n\\n// END ../common/sdf3d/sdCylinder.glsl\\n// START ../common/sdf3d/sdTorus.glsl\\nfloat sdTorus(float r0, float r1, vec3 p) {\\n  vec3 closestCenter = vec3(normalize(p.xy) * r0, 0.0);\\n  return distance(closestCenter, p) - r1;\\n}\\n\\n// #pragma glslify: export(sdTorus)\\n\\n\\n// END ../common/sdf3d/sdTorus.glsl\\n// START ../common/sdf3d/sdIcosahedron.glsl\\n\\n// signed distance function for icosahedron\\n// cf. https://en.wikipedia.org/wiki/Regular_icosahedron\\n// s: edge length\\n// p: point to evaluate function for\\nfloat sdIcosahedron(float s, vec3 p) {\\n  // NN = 1/GOLDEN_RATIO = GOLDEN_RATIO - 1\\n  const float K = GOLDEN_RATIO * 0.5;\\n  // the three vertices of the icosahedron triangle which\\n  // is fully inside the +++ octant. (edge length = 1)\\n  const vec3 a = vec3(0.5, K, 0.0);\\n  const vec3 b = vec3(0.0, 0.5, K);\\n  const vec3 c = vec3(K, 0.0, 0.5);\\n  const vec3 ab1 = b - a; // values chosen so edge length is 1\\n  const vec3 n1 = normalize(cross(a, b));\\n  const vec3 n2 = normalize(cross(b, c));\\n  const vec3 n3 = normalize(cross(c, a));\\n  const vec3 xyz1 = normalize(vec3(1.0));\\n  // for edge-length 1\\n  const float INSCRIBED_SPHERE_RADIUS = 0.7557613141;\\n\\n  // we use a rotation where the icosahedron is symmetric\\n  // in all three coordinate planes, and reduce the problem\\n  // to the +++ octant\\n  p = abs(p);\\n\\n  // there is one complete triangle in the +++ octant\\n  // mirror on planes which go through origin and the\\n  // complete triangles sides.\\n  if (dot(p, n1) < 0.0) {\\n    p += -2.0 * dot(p, n1) * n1;\\n  }\\n  if (dot(p, n2) < 0.0) {\\n    p += -2.0 * dot(p, n2) * n2;\\n  }\\n  if (dot(p, n3) < 0.0) {\\n    p += -2.0 * dot(p, n3) * n3;\\n  }\\n\\n  // rotate space around (1,1,1) vector so that all sides of the triangle\\n  // end up mapped on the ab side.\\n  vec3 dirs = vec3(-dot(n1, p), -dot(n2, p), -dot(n3, p));\\n  if (dirs.y > dirs.x && dirs.y > dirs.z) {\\n    p = p.yzx;\\n  } else if (dirs.z > dirs.x && dirs.z > dirs.y) {\\n    p = p.zxy;\\n  }\\n\\n  // check if the point is directly (perpendicular) above the triangle.\\n  // as we have rotated the space, we only need to check if it is\\n  // inside one edge.\\n  vec3 midAB = (a + b) / 2.0;\\n  vec3 pn = normalize(c - midAB);\\n  float w = dot(midAB, pn);\\n  if (dot(p, pn) > w * s) {\\n    // if not, return the distance to the plane the triangle is in\\n    return dot(xyz1, p) - INSCRIBED_SPHERE_RADIUS * s;\\n  }\\n\\n  // project the point onto segment ab, and return the distance to it\\n  float d3 = dot(ab1, p);\\n  d3 = clamp(d3, -0.5 * s, 0.5 * s);\\n  vec3 closestp = midAB * s + d3 * ab1;\\n  return distance(closestp, p);\\n}\\n// #pragma glslify: export(sdIcosahedron)\\n\\n// END ../common/sdf3d/sdIcosahedron.glsl\\n// START ../common/sdf3d/sdOctahedron.glsl\\nfloat sdOctahedron(float s, vec3 p) {\\n  p = abs(p);\\n  float m = p.x + p.y + p.z - s;\\n  vec3 q;\\n  if (3.0 * p.x < m) q = p.xyz;\\n  else if (3.0 * p.y < m) q = p.yzx;\\n  else if (3.0 * p.z < m) q = p.zxy;\\n  else return m * 0.57735027;\\n\\n  float k = clamp(0.5 * (q.z - q.y + s), 0.0, s);\\n  return length(vec3(q.x, q.y - s + k, q.z - k));\\n}\\n// #pragma glslify: export(sdOctahedron)\\n\\nfloat sdOctahedron(vec3 p, float s) {\\n  p = abs(p);\\n\\n  float m = p.x + p.y + p.z - s;\\n  //find point on octohedron surf nearest to p\\n  vec3 projPoint = p - vec3(0.333333 * m); //project onto surface plane\\n  //now push projected point, if outside triangle edge, perpendicular to edge, to edge\\n  vec3 toMove = min(projPoint, 0.0); //if projpoint.x<0 move along (1.0,-0.5,-0.5) , etc\\n  float toMoveSum = dot(toMove, vec3(1.0)); //which is basically along (1.5,0,0) then vec3(-0.5)\\n\\n  vec3 movedPoint = projPoint + toMove * vec3(-1.5) + toMoveSum * vec3(0.5); //better to multiply toMove by a matrix (1s diagonal, 0.5 other)?\\n\\n  movedPoint = max(movedPoint, 0.0); //cap x,y,z to 0 then\\n  movedPoint *= s / dot(movedPoint, vec3(1.0)); //scale about 0,0,0\\n\\n  return length(p - movedPoint);\\n}\\n\\n// END ../common/sdf3d/sdOctahedron.glsl\\n// START ../common/sdf3d/sdPyramid.glsl\\n// Pyramid with tip at (0,0,0), up = z\\n// c is the bottom corner. c.xy should be positive, c.z negative.\\nvec2 sdPyramid(vec3 c, vec3 p) {\\n  // pyramid is symmetric in XZ and YZ planes\\n  p.xy = abs(p.xy);\\n  bool flip = p.y * c.x > p.x * c.y; // p.y/p.x > c.y/c.x\\n  c.xy = flip ? c.yx : c.xy;\\n  p.xy = flip ? p.yx : p.xy;\\n  vec3 cc = c / dot(c, c);\\n  vec3 qx1 = normalize(vec3(-c.z, 0.0, c.x));\\n  vec3 pOnQx = p - qx1 * dot(p, qx1);\\n  float dx = dot(p, qx1);\\n  float maxY = c.y * (pOnQx.x / c.x);\\n  if (p.z <= c.z || pOnQx.z <= c.z) {\\n    if (p.x <= c.x) {\\n      // vertically underneath pyramid\\n      return vec2(-p.z + c.z, 2.0);\\n    } else {\\n      float aa = distance(p, vec3(c.x, min(c.y, p.y), c.z));\\n      return vec2(aa, 3.0);\\n    }\\n  } else if (pOnQx.y > maxY || pOnQx.z > 0.0) {\\n    float xx = dot(cc, p);\\n    float aa = length(p - clamp(xx, 0.0, 1.0) * c);\\n\\n    return vec2(aa, 1.0);\\n  } else {\\n    // need max for negativ values above base\\n    return vec2(max(dx, -p.z + c.z), 0.0);\\n  }\\n}\\n\\n// #pragma glslify: export(sdPyramid)\\n\\n\\n// END ../common/sdf3d/sdPyramid.glsl\\n// START ../common/sdf3d/sdSphere.glsl\\nfloat sdSphere(float radius, vec3 p) {\\n  return length(p) - radius;\\n}\\n\\n// #pragma glslify: export(sdSphere)\\n\\n\\n// END ../common/sdf3d/sdSphere.glsl\\n// START ../common/sdf3d/sub.glsl\\nfloat sub(float from, float what) {\\n  return max(from, -what);\\n}\\n\\n// #pragma glslify: export(sub)\\n\\n\\n// END ../common/sdf3d/sub.glsl\\n\\nuniform sampler2D texture;\\nuniform float secs;\\nuniform mat4 lll;\\nuniform mat4 llli;\\nuniform vec4 colorPrimary;\\nuniform vec4 colorSecondary;\\nuniform vec4 colorBackground;\\nuniform float a;\\nuniform float b;\\nuniform float c;\\nuniform float d;\\nuniform float highResTimeStamp;\\nuniform int bandCount;\\nuniform vec3 campos;\\nin float n;\\nin vec2 coord;\\nout vec4 fragColor;\\n\\n\\nconst vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\\nconst vec4 yellow = vec4(1.0, 1.0, 0.0, 1.0);\\nconst vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\\nconst vec4 blue = vec4(0.0, 0.0, 1.0, 1.0);\\nconst vec4 purple = vec4(0.5, 0.0, 0.5, 1.0);\\nconst vec4 red = vec4(1.0, 0.0, 0.0, 1.0);\\n\\nstruct RMHit {\\n  float distance;\\n  vec4 color;\\n};\\nRMHit mixa(RMHit a, RMHit b, float t) {\\n  return RMHit(mix(a.distance, b.distance, t), mix(a.color, b.color, t));\\n}\\nfloat skybox(vec3 p) {\\n  return 32.0 - max3(abs(p));\\n}\\n\\nfloat perlinSphere(float radius, vec3 p) {\\n  vec3 cp = normalize(p);\\n  float alpha = atan(cp.y, cp.x);\\n  float beta = asin(cp.z);\\n  return length(p) -\\n  radius +\\n  0.1 *\\n    perlin2D(vec2(0.0 / 100.0, 0.0) + (vec2(5.0) + vec2(alpha, beta)) * 8.0);\\n}\\n\\nfloat cylCircle(vec3 p) {\\n  float d = 10e9;\\n  for (int i = 0; i < 10; i++) {\\n    d = min(\\n      d,\\n      sdCylinder(0.2, 2.0, p + fromPolar(3.0, TAU * float(i) / 10.0, 1.0))\\n    );\\n  }\\n\\n  return d;\\n}\\n\\nfloat rblock(float r, vec3 p) {\\n  return sdBox(vec3(r), p);\\n}\\n\\nRMHit add(RMHit a, RMHit b) {\\n  //    return a.distance < b.distance\\n  //        ? RMHit(a.distance, a.color)\\n  //        : RMHit(b.distance, b.color);\\n  return mixa(a, b, float(b.distance < a.distance));\\n}\\n\\nfloat wtf(vec3 p) {\\n  vec3 center = p - mod(p, 3.0) + vec3(1.5);\\n  return rblock(0.4 + 0.3 * sin(secs + center.x), p - center);\\n}\\n\\nRMHit addFillet(float r, RMHit a, RMHit b) {\\n  if (a.distance < r && b.distance < r) {\\n    return RMHit(\\n      r - distance(vec2(a.distance, b.distance), vec2(r)),\\n      mix(a.color, b.color, (a.distance - b.distance) / r * 0.5 + 0.5)\\n    );\\n  } else {\\n    return add(a, b);\\n  }\\n}\\n\\nRMHit addFillet(float r, RMHit a, RMHit b, vec4 tilletColor) {\\n  if (a.distance < r && b.distance < r) {\\n    return RMHit(\\n      r - distance(vec2(a.distance, b.distance), vec2(r)),\\n      tilletColor\\n    );\\n  } else {\\n    return add(a, b);\\n  }\\n}\\nRMHit addFillet2(float r, RMHit a, RMHit b) {\\n  float h = smoothstep(-r, r, a.distance - b.distance);\\n  return RMHit(\\n    mix(a.distance, b.distance, h) - r * h * (1.0 - h),\\n    mix(a.color, b.color, h)\\n  );\\n}\\n\\nRMHit neg(RMHit a) {\\n  return RMHit(-a.distance, a.color);\\n}\\nRMHit sub(RMHit from, RMHit what) {\\n  RMHit whatNeg = neg(what);\\n  return mixa(from, whatNeg, float(whatNeg.distance > from.distance));\\n}\\n\\nvec3 modv(vec3 v, vec3 dir1, float y) {\\n  float t = dot(v, dir1);\\n  return v - floor(t / y) * y * dir1;\\n}\\nvec3 modRotZ(vec3 p, float count) {\\n  vec2 polarXY = toPolar(p.xy);\\n  return fromPolar(polarXY.x, mod(polarXY.y, TAU / count), p.z);\\n}\\n\\nfloat sin01(float x) {\\n  return 0.5 + 0.5 * sin(x);\\n}\\nfloat cos01(float x) {\\n  return 0.5 + 0.5 * cos(x);\\n}\\n\\nfloat betterBox(vec3 r, vec3 p) {\\n  vec3 q = abs(p) - r;\\n  return length(max(q, 0.0)) + min(max3(q), 0.0);\\n  p = abs(p);\\n  return max3(p - r);\\n}\\n\\nfloat roundedBlock(vec3 r, float cr, vec3 p) {\\n  return betterBox(r - vec3(cr), p) - cr;\\n}\\n\\nfloat sdCapsule(vec3 a, vec3 b, float r, vec3 p) {\\n  vec3 pa = p - a;\\n  vec3 ba = b - a;\\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\\n  return length(pa - ba * h) - r;\\n}\\nfloat sdEllipsoidB(vec3 r, vec3 p) {\\n  float k0 = length(p / r);\\n  float k1 = length(p / (r * r));\\n  return k0 * (k0 - 1.0) / k1;\\n}\\nfloat sdOctahedronB(float s, vec3 p) {\\n  p = abs(p);\\n  return (p.x + p.y + p.z - s) * 0.57735027;\\n}\\nfloat donutc(float r0, float r1, vec3 p) {\\n  vec3 closestCenter = vec3(normalize(p.xy) * r0, 0.0);\\n  return distance(closestCenter, p) - r1;\\n}\\n\\nfloat sdCappedCylinder(float h, float r, vec3 p) {\\n  vec2 d = vec2(length(p.xy), abs(p.z)) - vec2(r, h);\\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\\n}\\nfloat smoothmin(float r, float a, float b) {\\n  float h = smoothstep(-r, r, a - b);\\n  return mix(a, b, h) - r * h * (1.0 - h);\\n}\\nfloat queen(vec3 p) {\\n  float lxy = length(p.xy);\\n  float d;\\n  d = lxy - 1.1;\\n  d += 0.16 * p.z;\\n  d -= -c * (1.0 - pow(sin01(b + p.z * 2.5), 1.5));\\n  d += 0.1 * normalize(p.xy).x * smoothstep(2.0, 0.5, p.z);\\n  d +=\\n    0.02 * sin(15.0 * atan(p.y, p.x) - p.z * 5.0) * smoothstep(2.0, 0.5, p.z);\\n  //    float d = sdCappedCylinder(a, b, p);\\n  d = max(d, -p.z);\\n  d = max(d, p.z - 4.0);\\n\\n  float head = sdSphere(0.55, p - vec3(0.0, 0.0, 4.4));\\n  d = smoothmin(0.15, d, head);\\n  float crown = sdCone(\\n    fromPolar(vec2(1.0, 1.15)),\\n    1.0,\\n    -(p - vec3(0.0, 0.0, 4.5)).yzx\\n  );\\n  d = min(d, crown);\\n  d *= 0.5;\\n  return d;\\n}\\n\\nvec2 project(vec2 a, vec2 onto1) {\\n  return onto1 * (dot(a, onto1) / dot(onto1, onto1));\\n}\\n\\nvec3 reject(vec3 a, vec3 b1) {\\n  return a - b1 * dot(a, b1);\\n}\\n\\nRMHit sdf(vec3 p) {\\n  const vec4 red = vec4(0.2, 0.0, 0.0, 1.0);\\n  //  RMHit d = RMHit(block(vec3(-1.0, -1.0, -1.0), vec3(1.0, 1.0, 1.0), p), black);\\n  //    RMHit d = RMHit(sphere(2., p), black);\\n  //    RMHit d = RMHit(betterBox(vec3(1.), p), black);\\n  //    RMHit d = RMHit(roundedBlock(vec3(1.), 0.1, p), black);\\n  //    RMHit d = RMHit(donut(2., 0.5, p), black);\\n  //    RMHit d = RMHit(sdCapsule(vec3(-a,-a,0.), vec3(a,a,0.), b, p), black);\\n  //    RMHit d = RMHit(sdEllipsoidB(vec3(-a,-b,1.), p), black);\\n  //    RMHit d = RMHit(sdOctahedron(1., p)-a, red) ;\\n  //    RMHit d = RMHit(queen(p), black) ;\\n  //    RMHit d = RMHit(lego(p), black) ;\\n  //- vec3(0.0, 0.0, 1.0)\\n  vec3 h = vec3(0.5, 0.0, 0.0);\\n  vec3 q = abs(p) - h;\\n  //    vec2 pyr = sdPyramid(\\n  //        vec3(2.0, 2.0, -2.0),\\n  //        opElongate(h,\\n  //            rotZ(highResTimeStamp/1000.) *\\n  //                rotX(c) *\\n  //                opRepLim(p - vec3(-8., -8., 2.), vec3(8.), vec3(2., 2., 0.))));\\n  vec3 p2 = rotX(highResTimeStamp * 0.0) * p;\\n  vec2 xx = vec2(sdIcosahedron(d, p2) - c, 1.0);\\n  vec4 cc = red;\\n  cc.xyz = cc.xyz * xx.y * 0.1;\\n  RMHit d = RMHit(xx.x, cc);\\n  //    RMHit d = RMHit(sdCone(fromPolar(vec2(1., a)), b, p.yzx - vec3(0.,2., 0.)), black);\\n  //    d.distance = abs(d.distance) - 0.4;\\n  //    d.distance = abs(d.distance) - 0.1;\\n  //    d.distance = abs(d.distance) - 0.02;\\n  float s = length(p - vec3(1.0, 1.0, 0.0)) - 1.0;\\n  //    d.distance = s;\\n  //    d.distance = max(d.distance, -s);\\n\\n  vec3 color = 0.1 * sin(abs(vec3(0.0, PI, 0.0) + vec3(d.distance * PI * 2.0)));\\n  //    color.z = .1*xx.y;\\n  RMHit base = RMHit(sdBox(vec3(10.0, 10.0, 0.0), p), vec4(color, 1.0));\\n\\n  //    d = base;\\n  d = add(base, d);\\n  if (b > 1.0) {\\n    d = base;\\n  }\\n  //    d.distance *=0.5;\\n  return d;\\n}\\nfloat sdff(vec3 p) {\\n  return sdf(p).distance;\\n}\\nfloat ambientOcclusion(vec3 pWC, vec3 n1WC) {\\n  float k = 1.0;\\n  float distance = sdff(pWC + n1WC * k);\\n  return clamp(distance / k, 0.0, 1.0);\\n}\\n\\nstruct RMResult {\\n  float distance;\\n  vec3 pos;\\n  vec4 color;\\n};\\nRMResult raymarching2(vec3 start, vec3 dir1) {\\n  vec3 pos = start;\\n  RMHit hit;\\n  for (int i = 0; i < 200; i++) {\\n    hit = sdf(pos);\\n    if (hit.distance < 0.0001 * hit.distance) break;\\n    pos = pos + dir1 * hit.distance;\\n  }\\n  return RMResult(hit.distance, pos, hit.color);\\n}\\n\\nfloat softshadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {\\n  float res = 1.0;\\n  float t = 0.1;\\n  for (int i = 0; i < 1000 && t < maxt; i++) {\\n    float h = sdff(ro + rd * t);\\n    if (h < 0.001) return 0.0;\\n    res = min(res, k * h / t);\\n    t += h;\\n  }\\n  return res;\\n}\\n\\nconst float eps = 1e-4;\\nvec3 sdfNormal1(vec3 p, float d) {\\n  return normalize(\\n    vec3(\\n      sdff(p + vec3(eps, 0.0, 0.0)),\\n      sdff(p + vec3(0.0, eps, 0.0)),\\n      sdff(p + vec3(0.0, 0.0, eps))\\n    ) -\\n      vec3(sdff(p))\\n  );\\n}\\n\\n//layout (depth_greater) out float gl_FragDepth;\\nvoid main() {\\n  vec3 light = normalize(vec3(-1.0, -2.0, -2));\\n\\n  vec3 a = vec3(coord, -1.0);\\n  vec3 b = vec3(coord, 1.0);\\n  vec3 aWC = transform(llli, a);\\n  vec3 bWC = transform(llli, b);\\n  vec3 lookDir1 = normalize(bWC - aWC);\\n\\n  RMResult hitWC = raymarching2(aWC, lookDir1);\\n  vec3 hitn1 = sdfNormal1(hitWC.pos, hitWC.distance);\\n  float dWC = distance(aWC, hitWC.pos);\\n  vec3 hitNDC = transform(lll, hitWC.pos);\\n  vec3 p = hitWC.pos;\\n  float inSun = softshadow(\\n    hitWC.pos + hitn1 * 0.05,\\n    -light,\\n    0.0001,\\n    300.0,\\n    8.0\\n  );\\n  //    float inSun=1.;\\n\\n  vec3 material = hitWC.color.xyz;\\n  if (dWC > 100.0) {\\n    material = vec3(0.0, 0.0, 0.0);\\n    //    } else if (p.z >= 0.001) {\\n    //        material = vec3(0.2, 0.0, 0.0);\\n    //    } else {\\n    //        vec2 c = vec2(4.0, 2.0);\\n    //        vec2 id = floor(((p.xy - c * 0.5) / c) );\\n    //        material += .15 * cos(vec3(id.x, id.y + 2., id.x + id.y + 4.));\\n  }\\n\\n  const vec3 sunlightColor = vec3(8.0, 6.0, 1.0);\\n\\n  float aOcc = ambientOcclusion(hitWC.pos, hitn1);\\n\\n  vec3 reflectionDirection = reflect(light, hitn1);\\n\\n  vec3 color = vec3(0.0);\\n  color += material * aOcc;\\n  color += inSun * sunlightColor * material * max(0.0, dot(-light, hitn1));\\n  //    color = (hitn1);\\n\\n  vec3 camPos = aWC;\\n\\n  vec3 eyeDirection = -lookDir1;\\n  float uMaterialShininess = 256.0;\\n  float specularLightWeighting = pow(\\n    max(dot(reflectionDirection, eyeDirection), 0.0),\\n    uMaterialShininess\\n  );\\n  color += specularLightWeighting;\\n  //    float lightIntensity = 0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.);\\n  //    float lightIntensity =\\n  //        0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.) + 0.3*specularLightWeighting;\\n  //    fragColor = visualize(blue, red, mix(0.5, 1.0, inSun) * lightIntensity);\\n  //    fragColor = mix(hitWC.color, colorBackground, mix(0.5, 1.0, inSun) * clamp(lightIntensity, 0., 1.));\\n  color = pow(color, vec3(1.0 / 2.2)); // gamma correction\\n  fragColor = vec4(color, 1.0);\\n}\\n\"\nconst sourceMap = {\"version\":3,\"sources\":[\"/home/runner/work/workshop/workshop/src/raymarch/sdf.frag\",\"/home/runner/work/workshop/workshop/src/common/banded.glsl\",\"/home/runner/work/workshop/workshop/src/common/between.glsl\",\"/home/runner/work/workshop/workshop/src/common/max3.glsl\",\"/home/runner/work/workshop/workshop/src/common/constants.glsl\",\"/home/runner/work/workshop/workshop/src/common/hexFns.glsl\",\"/home/runner/work/workshop/workshop/src/common/matrices.glsl\",\"/home/runner/work/workshop/workshop/src/common/perlin2DTexture.glsl\",\"/home/runner/work/workshop/workshop/src/common/unmix.glsl\",\"/home/runner/work/workshop/workshop/src/common/fromPolar.glsl\",\"/home/runner/work/workshop/workshop/src/common/toPolar.glsl\",\"/home/runner/work/workshop/workshop/src/common/polar.glsl\",\"/home/runner/work/workshop/workshop/src/common/remix.glsl\",\"/home/runner/work/workshop/workshop/src/common/transform.glsl\",\"/home/runner/work/workshop/workshop/src/common/visualize.glsl\",\"/home/runner/work/workshop/workshop/src/common/waves.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/add.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf2d/addChamfer.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf2d/addFillet.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/opElongate.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/opRepLim.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdBox.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdCone.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdCylinder.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdTorus.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdIcosahedron.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdOctahedron.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdPyramid.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdSphere.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sub.glsl\"],\"names\":[],\"mappings\":\"AAAA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AfOA;;AgBhBA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACVA;AACA;AACA;AACA;AACA;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;;A7ByBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA\"}\nexport { sourceMap };\n","\nexport default \"#version 300 es\\n\\nprecision highp float;\\n\\n// START ../common/visualize.glsl\\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\\n  float isLow = float(t < 0.0);\\n  float isHigh = float(t > 1.0);\\n  float isMid = 1.0 - isLow - isHigh;\\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\\n}\\n\\nvec4 visualize(float t) {\\n  const vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\\n  const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\\n  return visualize(BLUE, RED, t);\\n}\\n\\n// #pragma glslify: export(visualize)\\n\\n\\n// END ../common/visualize.glsl\\n// START ../common/banded.glsl\\nfloat banded(float bandCount, float t) {\\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\\n}\\nfloat banded(int bandCount, float t) {\\n  return banded(float(bandCount), t);\\n}\\n\\n// #pragma glslify: export(banded)\\n\\n\\n// END ../common/banded.glsl\\n\\nuniform vec4 color;\\n\\nout vec4 fragColor;\\n\\nvoid main() {\\n  fragColor = color;\\n}\\n\"\nconst sourceMap = {\"version\":3,\"sources\":[\"/home/runner/work/workshop/workshop/src/raymarch/singleColor.frag\",\"/home/runner/work/workshop/workshop/src/common/visualize.glsl\",\"/home/runner/work/workshop/workshop/src/common/banded.glsl\"],\"names\":[],\"mappings\":\"AAAA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AFHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA\"}\nexport { sourceMap };\n","\nexport default \"#version 300 es\\nprecision highp float;\\n\\nuniform mat4 ts_ModelViewProjectionMatrix;\\nuniform float normalOffset;\\nin vec3 ts_Normal;\\nin vec4 ts_Vertex;\\n\\nvoid main() {\\n  gl_Position =\\n    ts_ModelViewProjectionMatrix *\\n    (ts_Vertex + normalOffset * vec4(ts_Normal, 0.0));\\n}\\n\"\nconst sourceMap = {\"version\":3,\"sources\":[\"/home/runner/work/workshop/workshop/src/raymarch/singleColor.vert\"],\"names\":[],\"mappings\":\"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA\"}\nexport { sourceMap };\n"],"names":["_optionalChain","ops","lastAccessLHS","value","i","length","op","fn","args","call","undefined","X_RED","gl","Y_GREEN","Z_BLUE","HIGHLIGHT","L3X","anchor","V3","O","dir1","X","L3Y","Y","L3Z","Z","EGizmoController","__init","this","meshes","__init2","highlight","__init3","offsetGC","__init4","dragging","constructor","pos","onHover","onStartDragging","onStopDragging","onChange","prototype","__init5","__init6","__init7","vector","rotation","V","computeNormalsFromFlatTriangles","compile","rotateBaseVerticesTM","M4","rotateX","translate","rotater","map","transformPoint","polar","drawVector","shader","size","likeO","pushMatrix","vT","getPerpendicular","unit","multMatrix","forSys","cross","draw","popMatrix","render","enable","CULL_FACE","cullFace","BACK","FRONT","uniforms","color","normalOffset","rotate","registerListeners","mouseMoveTarget","getCameraMatrix","_3","unregister","_4","addEventListener","mousemove","mousedown","mouseup","removeEventListener","unregisterListeners","_5","_6","e","pagePos","offsetX","offsetY","boundingClientRect","getBoundingClientRect","width","mouseLineWC","canvas","projectionMatrix","ndc1","x","y","height","ndc2","inverseProjectionMatrix","inversed","minus","getMouseLine","dir","info","infoClosestToLine","getTranslation","transformVector","offsetWC","targetPos","lineClosest","to","gizmoInverse","lineGC","lp","measure","l","at","lineT","distanceTo","thClosest","lastHighlight","_7","_8","t","plus","times","th","line","eq","Math","abs","dot","isParallelToLine","NaN","s","distance","a","b","c","d","bd","bb","squared","dd","ca","divisor","thT","buildShaders","sdf","create","singleColor","initialState","cam","raymarchSetup","makeCurrent","planeMesh","plane","startX","startY","coords","shaders","raymarchRender","modelView","colors","dynamicState","extra","llli","colorPrimary","primary","colorSecondary","secondary","colorBackground","background","highResTimeStamp","secs","gradients","lll","MatrixDisplay","children","label","onFocus","onBlur","OutlinedInput","inputComponent","toString","makeShader","desc","di","float","n","includes","vec3","z","f","input","output","makePart","gen","g","type","radius","r0","r1","prevInput","by","prevOutput","subf","subinput","suboutput","what","result","SphereEditor","onRadiusChange","useCallback","ev","target","TextField","inputProps","BoxEditor","newRadius","style","display","Vec3Editor","ExpandEditor","onByChange","gizmoControl","onElChange","newValue","slice","name","gizmoClick","take","Button","onClick","key","TranslateEditor","newBy","DonutEditor","OctahedronEditor","AddEditor","onTypeChange","onWhatChange","newWhat","Select","MenuItem","Ed","onItemChange","oldValue","v","PEd","sphere","expand","add","sub","box","donut","octahedron","canvasRef","useRef","renderProgress","setRenderProgress","useState","gp","setGp","IDENTITY","resolution","setResolution","gpFocused","setGpFocused","state","setState","useHashState","setStatePartial","o","part","setPart","fps","setFps","dynamic","Object","assign","raymarchRef","model","setModel","theme","useTheme","useMemo","palette","default","main","async","url","URL","createObjectURL","setup","onProgress","_","document","createElement","step","SCISSOR_TEST","shared","donePixels","scissorWidth","min","scissorHeight","scissor","_2","Promise","resolve","reject","toBlob","blob","renderHighRes","product","perspective","OrbitCameraController","getLookAt","fromShortString","useEffect","console","log","tsgl","current","alpha","premultipliedAlpha","throwOnError","getParameter","MAX_SAMPLES","onFPSChange","triggerRender","onCamChange","setExtra","startShader","camController","camMatrix","eGizmoController","rotateZ","pauseCam","clearColor","clear","COLOR_BUFFER_BIT","pointSize","disable","DEPTH_TEST","BLEND","blendFunc","ONE","blendEquation","FUNC_ADD","contentEditable","focus","fpsController","FPSController","updateShader","newShader","ed","teardown","animate","_diff","tick","offsetWidth","offsetHeight","matrixMode","PROJECTION","loadMatrix","MODELVIEW","loadIdentity","setCam","raymarch","debounce","toShortString","replace","RenderButton","dim","variant","disabled","floor","aesthetically","format","padStart","m","FlyCameraController","Grid","container","item","xs","md","ref","cursor","tabIndex","sx","flexDirection","padding","alignItems","gap","Card","CardContent","BoundNumberField","prop","setEditing"],"sourceRoot":""}