{"version":3,"file":"raymarch-index.js","mappings":"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","sources":["/dev/workshop/./src/common/BoundNumberField.tsx?","/dev/workshop/./src/common/FPSController.ts?","/dev/workshop/./src/common/useHashState.ts?","/dev/workshop/./src/paperBox1/common.tsx?","/dev/workshop/./src/raymarch/FlyCameraController.ts?","/dev/workshop/./src/raymarch/OrbitCameraController.ts?","/dev/workshop/./src/raymarch/EGizmoController.ts?","/dev/workshop/./src/raymarch/renderHighRes.ts?","/dev/workshop/./src/raymarch/shaders.ts?","/dev/workshop/./src/raymarch/index.tsx?","/dev/workshop/./src/raymarch/ed.frag?","/dev/workshop/./src/common/raymarch.vert?","/dev/workshop/./src/raymarch/sdf.frag?","/dev/workshop/./src/raymarch/singleColor.frag?","/dev/workshop/./src/raymarch/singleColor.vert?"],"sourcesContent":["import TextField, { } from \"@mui/material/TextField\"\nimport * as React from \"react\"\n\n\nexport function BoundNumberField({\n  state,\n  prop,\n  setStatePartial,\n  ...props\n}\n\n\n\n) {\n  return (\n    React.createElement(TextField, {\n      variant: \"outlined\",\n      size: \"small\",\n      type: \"number\",\n      value: state[prop],\n      onChange: (e) =>\n        setStatePartial({ [prop]: +e.target.value } )\n      ,\n      label: prop,\n      ...props,}\n    )\n  )\n}\n","/**\n * Helper class to count frames per second.\n */\nexport class FPSController {\n   __init() {this.count = 0}\n\n   __init2() {this.lastTime = performance.now()}\n  constructor(\n      notify,\n      window = 10,\n  ) {;this.notify = notify;this.window = window;FPSController.prototype.__init.call(this);FPSController.prototype.__init2.call(this);}\n\n  tick(time = performance.now()) {\n    const window = this.window\n    this.count = (this.count + 1) % window\n    if (this.count === 0) {\n      const fps = Math.floor((window * 1000) / (time - this.lastTime))\n      this.notify(fps)\n      this.lastTime = time\n    }\n  }\n}\n","import debounce from \"lodash/debounce\"\nimport mapValues from \"lodash/mapValues\"\nimport { useCallback, useEffect, useRef, useState } from \"react\"\n\nconst parseHash = (hash) => {\n  return !hash\n    ? {}\n    : hash\n        .substring(1)\n        .split(\"&\")\n        .map((part) => {\n          const [key, value] = part.split(\"=\")\n          return [decodeURIComponent(key), decodeURIComponent(value)]\n        })\n        .reduce((obj, [key, value]) => {\n          obj[key] = value\n          return obj\n        }, {} )\n}\nconst objectToHash = (o) => {\n  return (\n    \"#\" +\n    Object.entries(o)\n      .map(\n        ([key, value]) =>\n          encodeURIComponent(key) + \"=\" + encodeURIComponent(value),\n      )\n      .join(\"&\")\n  )\n}\n\nconst defaultDeserialize = (\n  x,\n) =>\n  mapValues(x, (v) => {\n    if (\"true\" === v) {\n      return true\n    } else if (\"false\" === v) {\n      return false\n    } else if (\"NaN\" === v) {\n      return NaN\n    } else if (\"undefined\" === v) {\n      return undefined\n    } else if (\"null\" === v) {\n      return null\n    } else if (\"\" === v) {\n      return \"\"\n    } else if (!isNaN(+v)) {\n      return +v\n    } else {\n      return v\n    }\n  })\nconst defaultSerialize = (x) =>\n  mapValues(x, (v) => \"\" + v)\n\nexport function useHashState(\n  initialState,\n  {\n    deserialize = defaultDeserialize,\n    serialize = defaultSerialize,\n    wait = 1000,\n  } = {},\n) {\n  const createInitialState = useCallback(() => {\n    const state =\n      \"function\" === typeof initialState\n        ? (initialState )()\n        : initialState\n    // hash overrides parameter\n    const mergedState = deserialize(\n      Object.assign(serialize(state), parseHash(document.location.hash)),\n    ) \n    history.pushState(\n      undefined,\n      document.title,\n      objectToHash(serialize(mergedState)),\n    )\n\n    return mergedState\n  }, [deserialize, initialState, serialize])\n  const [state, setState] = useState(createInitialState)\n  const updateHashRef = useRef()\n  if (!updateHashRef.current) {\n    updateHashRef.current = debounce(function (newState) {\n      history.pushState(\n        undefined,\n        document.title,\n        objectToHash(serialize(newState)),\n      )\n    }, wait)\n  }\n  useEffect(() => updateHashRef.current(state), [state])\n\n  useEffect(() => {\n    const onHashChange = () => {\n      setState(createInitialState())\n    }\n    window.addEventListener(\"hashchange\", onHashChange)\n    return () => {\n      window.removeEventListener(\"hashchange\", onHashChange)\n    }\n  }, [createInitialState])\n  return [state, setState]\n}\n"," function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } }import * as React from \"react\"\n\nimport { arrayRange, DEG, MINUS, round10, TAU, V3 } from \"ts3dutils\"\n\nexport const INCH = 25.4\nexport const fmtdeg = (x) => \"\" + round10(x / DEG, -1) + \"°\"\n \n\nexport const radiusFromSideWidth = (sides, sideWidth) =>\n  sideWidth / 2 / Math.sin(TAU / sides / 2)\nexport const sideWithFromRadius = (sides, radius) =>\n  radius * 2 * Math.sin(TAU / sides / 2)\nexport const centerToSideFromSideWidth = (\n  sides,\n  sideWidth,\n) => sideWidth / 2 / Math.tan(TAU / sides / 2)\nexport const radiusFromCenterToSide = (\n  sides,\n  centerToSide,\n) => centerToSide / Math.cos(TAU / sides / 2)\nexport const sideWidthFromCenterToSide = (\n  sides,\n  centerToSide,\n) => centerToSide * 2 * Math.tan(TAU / sides / 2)\n\nexport function RegularPolygon({\n  sides,\n  radius,\n  startAngle = 0,\n  sideLength = undefined,\n  ...props\n}\n\n\n\n\n) {\n  if ((undefined !== sideLength) === (undefined !== radius)) {\n    throw new Error(\"must set either sideLength or radius\")\n  }\n  if (undefined === radius) {\n    radius = radiusFromSideWidth(sides, sideLength)\n  }\n  const { x, y } = V3.polar(radius, startAngle)\n  return (\n    React.createElement('path', {\n      d: dTpl`\n        M${x},${y}\n        ${arrayRange(0, sides).map(\n          (i) => dTpl`L${V3.polar(radius, startAngle + i * (TAU / sides))}`,\n        )}Z`,\n      ...props,}\n    )\n  )\n}\n\nexport function RotStep({\n  id,\n  children,\n  count,\n  stepDeg,\n}\n\n\n\n\n) {\n  return (\n    React.createElement(React.Fragment, null\n      , React.createElement('g', { id: id,}, children)\n      , arrayRange(0, count - 1).map((i) => (\n        React.createElement('use', {\n          key: i,\n          xlinkHref: \"#\" + id,\n          transform: `rotate(${(i + 1) * stepDeg} 0 0)`,}\n        )\n      ))\n    )\n  )\n}\n\n \n// Always portrait orientation,\nexport const PAPER_SIZES = [\n  [841, 1189, \"A0\"],\n  [594, 841, \"A1\"],\n  [420, 594, \"A2\"],\n  [297, 420, \"A3\"],\n  [210, 297, \"A4\"],\n  [148, 210, \"A5\"],\n  [105, 148, \"A6\"],\n  [74, 105, \"A7\"],\n  [52, 74, \"A8\"],\n  [37, 52, \"A9\"],\n  [26, 37, \"A10\"],\n  [150, 150, \"Origami 15cm\"],\n  [100, 100, \"Origami 10cm\"],\n  [75, 75, \"Origami 7.5cm\"],\n  [215.9, 279.4, \"Letter\"],\n  [215.9, 355.6, \"Legal\"],\n]\n\nexport function PaperSizeFromString(str) {\n  const byName = PAPER_SIZES.find(([, , name]) => name === str)\n  if (byName) return byName\n  const [a, b] = str.split(\"x\")\n  return [+a, +b, \"Custom\"]\n}\nexport function PaperSizeFromDimensions(a, b) {\n  ;[a, b] = [a, b].sort(MINUS)\n  return _nullishCoalesce(PAPER_SIZES.find(([x, y]) => x === a && y === b), () => ( [a, b, \"Custom\"]))\n}\nexport function PaperSizeToString([a, b, name]) {\n  return name === \"Custom\" ? \"\" + a + \"x\" + b : name\n}\n\nexport const PAPER_SIZE_A4 = PAPER_SIZES.find(([, , name]) => name === \"A4\")\n\nexport function dTpl(\n  strings,\n  ...exps\n) {\n  const format = (x) =>\n    \"number\" === typeof x\n      ? \"\" + x\n      : \"string\" === typeof x\n      ? x\n      : Array.isArray(x)\n      ? x.map(format).join(\" \")\n      : x.x + \",\" + x.y\n  let result = strings[0]\n  for (let i = 0; i < exps.length; i++) {\n    result += format(exps[i])\n    result += strings[i + 1]\n  }\n  return result\n}\n\nexport const openInNewTab = (url) => {\n  const newWindow = window.open(url, \"_blank\", \"noopener,noreferrer\")\n  if (newWindow) newWindow.opener = null\n}\n"," function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }import { DEG, M4, V, V3 } from \"ts3dutils\"\n\n/**\n * You can't use the keyboard events directly to move the camera, as they are\n * not fired often enough. Instead, we track which keys are down and tick()\n * should be called in the render loop.\n */\nexport class FlyCameraController {\n   __init() {this.lastPos = V3.O}\n  \n\n   __init2() {this.pressedKeys = {}}\n   __init3() {this.pauseCam = false}\n\n  constructor(\n     state,\n      onChange,\n      lockUp,\n  ) {;this.state = state;this.onChange = onChange;this.lockUp = lockUp;FlyCameraController.prototype.__init.call(this);FlyCameraController.prototype.__init2.call(this);FlyCameraController.prototype.__init3.call(this);FlyCameraController.prototype.__init4.call(this);FlyCameraController.prototype.__init5.call(this);FlyCameraController.prototype.__init6.call(this);FlyCameraController.prototype.__init7.call(this);}\n\n  __init4() {this.setState = (m) => {\n    m !== this.state && M4.copy(m, this.state)\n  }}\n\n  registerListeners(\n    mouseMoveTarget\n\n\n,\n    keyUpDownTarget = mouseMoveTarget,\n  ) {\n    _optionalChain([this, 'access', _3 => _3.unregister, 'optionalCall', _4 => _4()])\n    mouseMoveTarget.addEventListener(\"mousemove\", this.mousemove)\n    keyUpDownTarget.addEventListener(\"keydown\", this.keydown)\n    keyUpDownTarget.addEventListener(\"keyup\", this.keyup)\n\n    return (this.unregister = () => {\n      mouseMoveTarget.removeEventListener(\"mousemove\", this.mousemove)\n      keyUpDownTarget.removeEventListener(\"keydown\", this.keydown)\n      keyUpDownTarget.removeEventListener(\"keyup\", this.keyup)\n    })\n  }\n\n  unregisterListeners() {\n    _optionalChain([this, 'access', _5 => _5.unregister, 'optionalCall', _6 => _6()])\n  }\n\n  tick() {\n    const speed = new V3(\n      +!!this.pressedKeys.a - +!!this.pressedKeys.d,\n      +!!this.pressedKeys.q +\n        +!!this.pressedKeys.Control -\n        +!!this.pressedKeys.e -\n        +!!this.pressedKeys[\" \"],\n      +!!this.pressedKeys.w - +!!this.pressedKeys.s,\n    )\n    if (!speed.likeO()) {\n      this.state = this.state.translate(speed.toLength(0.05))\n      _optionalChain([this, 'access', _7 => _7.onChange, 'optionalCall', _8 => _8(this.state)])\n    }\n  }\n\n   __init5() {this.mousemove = (e) => {\n    const pagePos = V(e.pageX, e.pageY)\n    const delta = this.lastPos.to(pagePos)\n    if (e.buttons & 1 && !this.pauseCam) {\n      // zRot -= delta.x * 0.25 * DEG\n      const rot = M4.rotateY(delta.x * 0.25 * DEG)\n        //\n        .rotateX(delta.y * 0.25 * DEG)\n      this.state = rot.times(this.state)\n      // rot = rot.rotate(V3.O, rot.X, delta.y * 0.25 * DEG)\n      // yRot = clamp(yRot - delta.y * 0.25 * DEG, -85 * DEG, 85 * DEG)\n      _optionalChain([this, 'access', _9 => _9.onChange, 'optionalCall', _10 => _10(this.state)])\n    }\n    this.lastPos = pagePos\n  }}\n\n   __init6() {this.keydown = (e) => {\n    this.pressedKeys[e.key] = true\n    e.preventDefault()\n  }}\n   __init7() {this.keyup = (e) => {\n    this.pressedKeys[e.key] = undefined\n    e.preventDefault()\n  }}\n\n  getLookAt() {\n    return this.state\n  }\n\n  static invertLookAt(m) {\n    const inverse = m.transposed().scale(-1)\n    return {\n      eye: inverse.transformVector(m.getTranslation(), false),\n      dir: inverse.transformVector(V3.Z, false),\n      up: inverse.transformVector(V3.Y.negated(), false),\n    }\n  }\n\n  static toShortString(lookAt, posFactor = 100) {\n    const coordString = (v, f) =>\n      [v.x, v.y, v.z].map((e) => Math.floor(e * f)).join(\".\")\n    const { eye, dir, up } = FlyCameraController.invertLookAt(lookAt)\n    return (\n      coordString(eye, posFactor) +\n      \"~\" +\n      coordString(dir.unit(), 100) +\n      \"~\" +\n      coordString(up, 100)\n    )\n  }\n\n  static fromShortString(cam, posFactor = 100) {\n    const coord = (s, f) =>\n      V(s.split(\".\").map((sp) => +sp / f) )\n    const [posStr, lookDirStr, upStr] = cam.split(\"~\")\n    const eye = coord(posStr, posFactor)\n    return M4.lookAt(eye, eye.plus(coord(lookDirStr, 100)), coord(upStr, 100))\n  }\n}\n"," function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }import { clamp, M4, V, V3 } from \"ts3dutils\"\n\n \n\nconst ACTIONS = [\"zoomIn\", \"zoomOut\", \"left\", \"right\", \"up\", \"down\"] \n\n/**\n * You can't use the keyboard events directly to move the camera, as they are\n * not fired often enough. Instead, we track which keys are down and tick()\n * should be called in the render loop.\n */\nexport class OrbitCameraController {\n   __init() {this.lastPos = V3.O}\n  \n\n   __init2() {this.pressedKeys = {\n    zoomIn: false,\n    zoomOut: false,\n    left: false,\n    right: false,\n    up: false,\n    down: false,\n  }}\n   __init3() {this.pauseCam = false}\n   __init4() {this.udRot = 0.1}\n   __init5() {this.rot = 0}\n   __init6() {this.dist = 10}\n\n  constructor(\n      onChange,\n      keys = {\n      zoomIn: \"w\",\n      zoomOut: \"s\",\n      left: \"a\",\n      right: \"d\",\n      up: \" \",\n      down: \"Control\",\n    },\n  ) {;this.onChange = onChange;this.keys = keys;OrbitCameraController.prototype.__init.call(this);OrbitCameraController.prototype.__init2.call(this);OrbitCameraController.prototype.__init3.call(this);OrbitCameraController.prototype.__init4.call(this);OrbitCameraController.prototype.__init5.call(this);OrbitCameraController.prototype.__init6.call(this);OrbitCameraController.prototype.__init7.call(this);OrbitCameraController.prototype.__init8.call(this);OrbitCameraController.prototype.__init9.call(this);OrbitCameraController.prototype.__init10.call(this);OrbitCameraController.prototype.__init11.call(this);OrbitCameraController.prototype.__init12.call(this);}\n\n  __init7() {this.setState = (m) => {\n    console.log(\"setStaet\")\n    ;[this.udRot, this.rot, this.dist] =\n      OrbitCameraController.toOrbitCameraState(m)\n  }}\n\n  static toOrbitCameraState(m) {\n    if (m instanceof M4) {\n      const eye = m\n        .transposed()\n        .scale(-1)\n        .transformVector(m.getTranslation(), false)\n      return [Math.atan(eye.z / eye.lengthXY()), eye.angleXY(), eye.length()]\n    } else {\n      return m\n    }\n  }\n\n  registerListeners(\n    mouseMoveTarget\n\n\n,\n    keyUpDownTarget = mouseMoveTarget,\n  ) {\n    _optionalChain([this, 'access', _5 => _5.unregister, 'optionalCall', _6 => _6()])\n    mouseMoveTarget.addEventListener(\"mousemove\", this.mousemove)\n    mouseMoveTarget.addEventListener(\"wheel\", this.wheel)\n    keyUpDownTarget.addEventListener(\"keydown\", this.keydown)\n    keyUpDownTarget.addEventListener(\"keyup\", this.keyup)\n    keyUpDownTarget.addEventListener(\"blur\", this.keyup)\n\n    return (this.unregister = () => {\n      mouseMoveTarget.removeEventListener(\"mousemove\", this.mousemove)\n      mouseMoveTarget.removeEventListener(\"wheel\", this.wheel)\n      keyUpDownTarget.removeEventListener(\"keydown\", this.keydown)\n      keyUpDownTarget.removeEventListener(\"keyup\", this.keyup)\n      keyUpDownTarget.removeEventListener(\"keyup\", this.keyup)\n    })\n  }\n\n  __init8() {this.blur = () => {\n    // TODO\n  }}\n\n  unregisterListeners() {\n    _optionalChain([this, 'access', _7 => _7.unregister, 'optionalCall', _8 => _8()])\n  }\n\n  tick() {\n    const dDist = (+this.pressedKeys.zoomOut - +this.pressedKeys.zoomIn) * 0.1\n    const dRot = (-+this.pressedKeys.left + +this.pressedKeys.right) * 0.1\n    const newUDRot = clamp(\n      this.udRot + (+this.pressedKeys.up - +this.pressedKeys.down) * 0.1,\n      -Math.PI * 0.5,\n      Math.PI * 0.5,\n    )\n    if (dDist !== 0 || dRot !== 0 || newUDRot !== this.udRot) {\n      this.dist += dDist\n      this.rot += dRot\n      this.udRot = newUDRot\n      _optionalChain([this, 'access', _9 => _9.onChange, 'optionalCall', _10 => _10(this.ss)])\n    }\n  }\n\n   __init9() {this.mousemove = (e) => {\n    const pagePos = V(e.pageX, e.pageY)\n    const delta = this.lastPos.to(pagePos)\n    if (e.buttons & 1 && !this.pauseCam) {\n      // zRot -= delta.x * 0.25 * DEG\n      const dRot = delta.x / 100\n      const newUDRot = clamp(\n        this.udRot + delta.y / 100,\n        -Math.PI * 0.5,\n        Math.PI * 0.5,\n      )\n      if (newUDRot !== this.udRot || dRot !== 0) {\n        this.udRot = newUDRot\n        this.rot += dRot\n        _optionalChain([this, 'access', _11 => _11.onChange, 'optionalCall', _12 => _12(this.ss)])\n        e.stopImmediatePropagation()\n        e.preventDefault()\n      }\n    }\n    this.lastPos = pagePos\n  }}\n\n   __init10() {this.wheel = (e) => {\n    const newDist = clamp(this.dist + e.deltaY, 0.1, 1000)\n    if (newDist !== this.dist) {\n      this.dist = newDist\n      e.stopImmediatePropagation()\n      e.preventDefault()\n      _optionalChain([this, 'access', _13 => _13.onChange, 'optionalCall', _14 => _14(this.ss)])\n    }\n  }}\n\n  get ss() {\n    return [this.udRot, this.rot, this.dist]\n  }\n\n   __init11() {this.keydown = (e) => {\n    for (const action of ACTIONS) {\n      if (this.keys[action] === e.key) {\n        this.pressedKeys[action] = true\n        e.stopImmediatePropagation()\n        e.preventDefault()\n        return\n      }\n    }\n  }}\n\n   __init12() {this.keyup = (e) => {\n    for (const action of ACTIONS) {\n      if (this.keys[action] === e.key) {\n        this.pressedKeys[action] = false\n        e.stopImmediatePropagation()\n        e.preventDefault()\n        return\n      }\n    }\n  }}\n\n  getLookAt() {\n    return OrbitCameraController.getLookAt(this.ss)\n  }\n\n  static getLookAt([udRot, rot, dist]) {\n    return M4.rotateZ(rot)\n      .rotateY(udRot)\n      .transform(M4.lookAt(V(dist, 0, 0), V3.O, V3.Z))\n  }\n\n  static invertLookAt(m) {\n    const inverse = m.transposed().scale(-1)\n    return {\n      eye: inverse.transformVector(m.getTranslation(), false),\n      dir: inverse.transformVector(V3.Z, false),\n      up: inverse.transformVector(V3.Y.negated(), false),\n    }\n  }\n\n  static toShortString(m, posFactor = 100) {\n    const [udRot, rot, dist] = this.toOrbitCameraState(m)\n    const coordString = (v, f) => Math.floor(v * f)\n    return (\n      coordString(udRot, 100) +\n      \"~\" +\n      coordString(rot, 100) +\n      \"~\" +\n      coordString(dist, 100)\n    )\n  }\n\n  static fromShortString(cam, posFactor = 100) {\n    const coord = (s, f) => +s / f\n    const [udRotStr, rotStr, distStr] = cam.split(\"~\")\n    return [coord(udRotStr, 100), coord(rotStr, 100), coord(distStr, 100)]\n  }\n}\n"," function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }import * as chroma from \"chroma.ts\"\nimport { arrayRange, clamp, DEG, eq, eq0, M4, TAU, V, V3 } from \"ts3dutils\"\nimport { GL_COLOR_BLACK, Mesh, } from \"tsgl\"\n\nconst X_RED = chroma.color(\"red\").gl()\nconst Y_GREEN = chroma.color(\"green\").gl()\nconst Z_BLUE = chroma.color(\"blue\").gl()\nconst HIGHLIGHT = GL_COLOR_BLACK\nconst L3X = { anchor: V3.O, dir1: V3.X }\nconst L3Y = { anchor: V3.O, dir1: V3.Y }\nconst L3Z = { anchor: V3.O, dir1: V3.Z }\n\n \nexport const NONE = 0 ,\n  X = 1 ,\n  Y = 2 ,\n  Z = 3 ,\n  XROT = 4 ,\n  YROT = 5 ,\n  ZROT = 6 \n\nexport class EGizmoController {\n   __init() {this.meshes = {}}\n\n   __init2() {this.highlight = NONE}\n   __init3() {this.offsetGC = undefined}\n\n   __init4() {this.dragging = NONE}\n\n  \n\n  constructor(\n      gl,\n     pos,\n      onHover,\n      onStartDragging,\n      onStopDragging,\n      onChange,\n  ) {;this.gl = gl;this.pos = pos;this.onHover = onHover;this.onStartDragging = onStartDragging;this.onStopDragging = onStopDragging;this.onChange = onChange;EGizmoController.prototype.__init.call(this);EGizmoController.prototype.__init2.call(this);EGizmoController.prototype.__init3.call(this);EGizmoController.prototype.__init4.call(this);EGizmoController.prototype.__init5.call(this);EGizmoController.prototype.__init6.call(this);EGizmoController.prototype.__init7.call(this);\n    // this.meshes.vectorShaft = Mesh.rotation(\n    //   [V3.O, V3.Y, V3.XY],\n    //   L3X,\n    //   TAU,\n    //   8,\n    //   true,\n    // )\n    // this.meshes.vectorShaft.computeNormalsFromFlatTriangles()\n    // this.meshes.vectorShaft.compile()\n    // this.meshes.vectorHead = Mesh.rotation(\n    //   [V3.Y, V(0, 2, 0), V(2, 0, 0)],\n    //   L3X,\n    //   TAU,\n    //   8,\n    //   true,\n    // )\n    // this.meshes.vectorHead.computeNormalsFromFlatTriangles()\n    // this.meshes.vectorHead.compile()\n    this.meshes.vector = Mesh.rotation(\n      [V(0, 0.04), V(0.8, 0.04), V(0.85, 0.06), V(1, 0)],\n      L3X,\n      TAU,\n      8,\n      true,\n    )\n    this.meshes.vector.computeNormalsFromFlatTriangles()\n    this.meshes.vector.compile()\n    const rotateBaseVerticesTM = M4.rotateX(-90 * DEG).translate(V3.X)\n    this.meshes.rotater = Mesh.rotation(\n      arrayRange(0, 9).map((i) =>\n        rotateBaseVerticesTM.transformPoint(V3.polar(0.04, -(TAU * i) / 8)),\n      ),\n      { anchor: V3.O, dir1: V3.Z },\n      (9 / 8) * 90 * DEG,\n      8,\n      false,\n    )\n    this.meshes.rotater.computeNormalsFromFlatTriangles()\n    this.meshes.rotater.compile()\n  }\n\n  drawVector(vector, anchor, shader, size = 1) {\n    if (vector.likeO()) return\n\n    this.gl.pushMatrix()\n\n    const vT = vector.getPerpendicular().unit()\n    this.gl.multMatrix(\n      M4.forSys(vector.unit(), vT, vector.cross(vT).unit(), anchor),\n    )\n    shader.draw(this.meshes.vector)\n    this.gl.popMatrix()\n  }\n\n  render(shader) {\n    const gl = this.gl\n    gl.enable(gl.CULL_FACE)\n    gl.cullFace(gl.BACK)\n    gl.pushMatrix()\n    gl.multMatrix(this.pos)\n    gl.cullFace(gl.FRONT)\n\n    shader.uniforms({ color: HIGHLIGHT, normalOffset: 0.01 })\n    if (this.highlight === X || this.dragging === X)\n      this.drawVector(V3.X, V3.O, shader, 0.1)\n    if (this.highlight === Y || this.dragging === Y)\n      this.drawVector(V3.Y, V3.O, shader, 0.1)\n    if (this.highlight === Z || this.dragging === Z)\n      this.drawVector(V3.Z, V3.O, shader, 0.1)\n    gl.cullFace(gl.BACK)\n    shader.uniforms({ normalOffset: 0 })\n    this.drawVector(V3.X, V3.O, shader.uniforms({ color: X_RED }), 0.1)\n    this.drawVector(V3.Y, V3.O, shader.uniforms({ color: Y_GREEN }), 0.1)\n    this.drawVector(V3.Z, V3.O, shader.uniforms({ color: Z_BLUE }), 0.1)\n\n    shader.uniforms({ color: Z_BLUE }).draw(this.meshes.rotater)\n    gl.rotate(-90, 0, 1, 0)\n    shader.uniforms({ color: X_RED }).draw(this.meshes.rotater)\n    gl.rotate(-90, 1, 0, 0)\n    shader.uniforms({ color: Y_GREEN }).draw(this.meshes.rotater)\n    gl.popMatrix()\n  }\n\n  registerListeners(\n    mouseMoveTarget\n\n\n,\n    getCameraMatrix,\n  ) {\n    this.getCameraMatrix = getCameraMatrix\n    _optionalChain([this, 'access', _3 => _3.unregister, 'optionalCall', _4 => _4()])\n    mouseMoveTarget.addEventListener(\"mousemove\", this.mousemove)\n    mouseMoveTarget.addEventListener(\"mousedown\", this.mousedown)\n    mouseMoveTarget.addEventListener(\"mouseup\", this.mouseup)\n\n    return (this.unregister = () => {\n      mouseMoveTarget.removeEventListener(\"mousemove\", this.mousemove)\n      mouseMoveTarget.removeEventListener(\"mousedown\", this.mousedown)\n      mouseMoveTarget.removeEventListener(\"mouseup\", this.mouseup)\n    })\n  }\n\n  unregisterListeners() {\n    _optionalChain([this, 'access', _5 => _5.unregister, 'optionalCall', _6 => _6()])\n  }\n\n   __init5() {this.mousemove = (e) => {\n    const pagePos = V(e.offsetX, e.offsetY)\n\n    const boundingClientRect = (\n      e.target \n    ).getBoundingClientRect()\n    boundingClientRect.width\n    const mouseLineWC = getMouseLine(\n      pagePos,\n      boundingClientRect,\n      this.getCameraMatrix(),\n    )\n    if (this.dragging) {\n      const dir = [V3.O, V3.X, V3.Y, V3.Z][this.dragging]\n      const axis = {\n        anchor: this.pos.getTranslation(),\n        dir1: this.pos.transformVector(dir).unit(),\n      }\n      const info = infoClosestToLine(mouseLineWC, axis)\n      const offsetWC = this.pos.transformVector(this.offsetGC)\n      const targetPos = info.lineClosest.minus(offsetWC)\n      this.pos = this.pos.translate(this.pos.getTranslation().to(targetPos))\n      this.onChange(this.pos)\n    } else {\n      const gizmoInverse = this.pos.inversed()\n      const lineGC = {\n        anchor: gizmoInverse.transformPoint(mouseLineWC.anchor),\n        dir1: gizmoInverse.transformVector(mouseLineWC.dir1).unit(),\n      }\n      let lp = undefined\n\n      // eslint-disable-next-line no-inner-declarations\n      function measure(l) {\n        const info = infoClosestToLine(lineGC, l)\n        lp = at(l, clamp(info.lineT, 0, 1))\n        const realDistance = lp.distanceTo(info.thClosest)\n        return realDistance\n      }\n\n      const lastHighlight = this.highlight\n      if (measure(L3X) < 0.1) {\n        this.highlight = X\n        this.offsetGC = lp\n      } else if (measure(L3Y) < 0.1) {\n        this.highlight = Y\n        this.offsetGC = lp\n      } else if (measure(L3Z) < 0.1) {\n        this.highlight = Z\n        this.offsetGC = lp\n      } else {\n        this.highlight = NONE\n        this.offsetGC = undefined\n      }\n      if (this.highlight !== lastHighlight) {\n        _optionalChain([this, 'access', _7 => _7.onHover, 'optionalCall', _8 => _8(this.highlight)])\n      }\n    }\n  }}\n\n   __init6() {this.mousedown = (e) => {\n    if (this.highlight) {\n      this.dragging = this.highlight\n      this.onStartDragging()\n    }\n  }}\n\n   __init7() {this.mouseup = (e) => {\n    if (this.dragging) {\n      this.dragging = NONE\n      this.onStopDragging()\n    }\n  }}\n\n  \n}\n\n\n\nexport function getMouseLine(\n  pos,\n  canvas,\n  projectionMatrix,\n) {\n  const ndc1 = V(\n    (pos.x * 2) / canvas.width - 1,\n    (-pos.y * 2) / canvas.height + 1,\n    -1,\n  )\n  const ndc2 = V(\n    (pos.x * 2) / canvas.width - 1,\n    (-pos.y * 2) / canvas.height + 1,\n    1,\n  )\n  const inverseProjectionMatrix = projectionMatrix.inversed()\n  const anchor = inverseProjectionMatrix.transformPoint(ndc1)\n  const dir1 = inverseProjectionMatrix.transformPoint(ndc2).minus(anchor).unit()\n  return { anchor, dir1 }\n}\n\nfunction at(l, t) {\n  return l.anchor.plus(l.dir1.times(t))\n}\nfunction infoClosestToLine(\n  th,\n  line,\n)\n\n\n\n\n\n {\n  /*\n       line = a + s*b\n       this = c + t*d\n\n       (this - line) * b = 0\n       (this - line) * d = 0\n\n       (a + s*b - c - t*d) * b = 0\n       (a + s*b - c - t*d) * d = 0\n\n       (a - c + s*b - t*d) * b = 0\n       (a - c + s*b - t*d) * d = 0\n\n       (a - c)*b + (s*b - t*d)*b = 0\n       (a - c)*d + (s*b - t*d)*d = 0\n\n       (a - c)*b + s*(b*b) - t*(d*b) = 0\n       (a - c)*d + s*(b*d) - t*(d*d) = 0\n\n       s = (t*(d*b) - (a - c)*b) / (b*b)\n       =>\n       (a - c)*d + (t*(d*b) - (a - c)*b) / (b*b)*(b*d) - t*(d*d) = 0 | * (b*b)\n       (a - c)*d * (b*b) + (t*(d*b) - (a - c)*b)*(b*d) - t*(d*d) * (b*b) = 0\n       (a - c)*d * (b*b) + t*(d*b)*(b*d) - (a - c)*b*(b*d) - t*(d*d) * (b*b) = 0\n       t = ((a - c)*b*(b*d) - (a - c)*d * (b*b)) / ((d*b)*(b*d) - (d*d) * (b*b))\n       */\n  if (isParallelToLine(th, line)) {\n    return { t: NaN, s: NaN, distance: 10 }\n  }\n  const a = line.anchor,\n    b = line.dir1,\n    c = th.anchor,\n    d = th.dir1\n  const bd = b.dot(d),\n    bb = b.squared(),\n    dd = d.squared(),\n    ca = a.minus(c),\n    divisor = bd * bd - dd * bb\n  const thT = (ca.dot(b) * bd - ca.dot(d) * bb) / divisor\n  const lineT = (ca.dot(b) * dd - ca.dot(d) * bd) / divisor\n  return {\n    thT,\n    lineT,\n    thClosest: at(th, thT),\n    lineClosest: at(line, lineT),\n    distance: at(th, thT).distanceTo(at(line, lineT)),\n  }\n}\n\nfunction asSegmentDistanceToLine(\n  th,\n  line,\n  sStart,\n  sEnd,\n) {\n  const dirCross = th.dir1.cross(line.dir1)\n  const div = dirCross.squared()\n  if (eq0(div)) {\n    return undefined\n  } // lines parallel\n  const anchorDiff = line.anchor.minus(th.anchor)\n  // check if distance is zero (see also L3.distanceToLine)\n  if (!eq0(anchorDiff.dot(dirCross.unit()))) {\n    return undefined\n  }\n  let t = infoClosestToLine(th, line).t\n  t = clamp(t, sStart, sEnd)\n  return at(th, clamp(t, sStart, sEnd))\n}\n\nfunction isParallelToLine(th, line) {\n  // we know that 1 == this.dir1.length() == line.dir1.length(), we can check for parallelity simpler than\n  // isParallelTo()\n  return eq(1, Math.abs(th.dir1.dot(line.dir1)))\n}\n"," function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }import sleep from \"sleep-promise\"\nimport { TSGLContext } from \"tsgl\"\n\nexport async function renderHighRes(\n  [width, height],\n  setup,\n  render,\n  onProgress,\n) {\n  _optionalChain([onProgress, 'optionalCall', _ => _(0)])\n  await sleep(10)\n  const canvas = document.createElement(\"canvas\")\n  canvas.width = width\n  canvas.height = height\n\n  const step = 200\n  const gl = TSGLContext.create({ canvas })\n  gl.enable(gl.SCISSOR_TEST)\n  const shared = setup(gl)\n  let donePixels = 0\n  for (let x = 0; x < width; x += step) {\n    for (let y = 0; y < height; y += step) {\n      const scissorWidth = Math.min(step, width - x)\n      const scissorHeight = Math.min(step, height - y)\n      gl.scissor(x, y, scissorWidth, scissorHeight)\n      // console.time(\"render block\")\n      render(gl, shared)\n      // console.timeEnd(\"render block\")\n      await sleep(0)\n      donePixels += scissorWidth * scissorHeight\n      _optionalChain([onProgress, 'optionalCall', _2 => _2(donePixels / (width * height))])\n    }\n  }\n  return new Promise((resolve, reject) =>\n    canvas.toBlob((blob) => (blob ? resolve(blob) : reject(\"error\")), \"png\"),\n  )\n}\n","/* eslint-disable @typescript-eslint/no-var-requires */\nimport { Shader, } from \"tsgl\"\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function buildShaders(gl) {\n  return {\n    // temple: Shader.create(\n    //   require(\"../common/raymarch.vert\"),\n    //   require(`./demoTemple.frag`),\n    //   gl,\n    // ),\n    sdf: Shader.create(\n      require(\"../common/raymarch.vert\").default,\n      require(\"./sdf.frag\").default,\n      gl,\n    ),\n    // ed: Shader.create(\n    //   require(\"../common/raymarch.vert\"),\n    //   require(`./ed.frag`),\n    //   gl,\n    // ),\n    singleColor: Shader.create(\n      require(\"./singleColor.vert\").default,\n      require(\"./singleColor.frag\").default,\n      gl,\n    ),\n  }\n}\n"," function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }import Button from \"@mui/material/Button\"\nimport Card from \"@mui/material/Card\"\nimport CardContent from \"@mui/material/CardContent\"\nimport Grid from \"@mui/material/Grid\"\nimport MenuItem from \"@mui/material/MenuItem\"\nimport OutlinedInput from \"@mui/material/OutlinedInput\"\nimport Select, { } from \"@mui/material/Select\"\nimport { useTheme } from \"@mui/material/styles\"\nimport TextField from \"@mui/material/TextField\"\nimport aesthetically from \"aesthetically\"\nimport * as chroma from \"chroma.ts\"\nimport { debounce } from \"lodash\"\nimport * as React from \"react\"\nimport {\n\n\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\"\nimport { DEG, lerp, M4, PI, V3 } from \"ts3dutils\"\nimport { currentGL, Mesh, Shader, TSGLContext } from \"tsgl\"\n\nimport { BoundNumberField } from \"../common/BoundNumberField\"\nimport { FPSController } from \"../common/FPSController\"\nimport { useHashState } from \"../common/useHashState\"\nimport { openInNewTab } from \"../paperBox1/common\"\nimport edFragShader from \"./ed.frag\"\nimport { EGizmoController, NONE } from \"./EGizmoController\"\nimport { FlyCameraController } from \"./FlyCameraController\"\nimport {\n  OrbitCameraController,\n\n} from \"./OrbitCameraController\"\nimport { renderHighRes } from \"./renderHighRes\"\nimport { buildShaders } from \"./shaders\"\n\n/**\n * THE ART LIST\n *\n * - something isometric (chess?)\n * - something with dunes\n * - something with 3d fractals\n * - something with refraction (prism etc)\n */\n\nconst initialState = {\n  a: 0.2,\n  b: 0.2,\n  c: 0.2,\n  d: 0.2,\n  cam: \"999.999.999~-56.-58.-61~-44.-44.79\",\n}\n\n\nfunction raymarchSetup(gl) {\n  gl.makeCurrent()\n\n  const planeMesh = Mesh.plane({ startX: -1, startY: -1, width: 2, height: 2 })\n  // Mesh.plane generates tex coords [0,1] and we want [-1, 1] for rendering\n  planeMesh.coords = [\n    [-1, -1],\n    [1, -1],\n    [-1, 1],\n    [1, 1],\n  ]\n  planeMesh.compile()\n\n  return {\n    planeMesh,\n    shaders: buildShaders(gl),\n  }\n}\n\nfunction raymarchRender(\n  gl,\n  { shaders, planeMesh },\n  modelView,\n  colors,\n  dynamicState,\n  abs,\n  extra,\n) {\n  gl.makeCurrent()\n\n  const f = (abs / 1000 / 40) % 1\n  //        vec3 spherepos = fromPolar(mix(-6., 6., f), abs(mix(-10., 10.,\n  // f)) + PI / 2., 0.);\n  const campos = (f) =>\n    V3.polar(lerp(-6, 6, f), Math.abs(lerp(-10, 10, f)) + PI / 2, 0.5)\n\n  const llli = modelView.inversed()\n  shaders.sdf\n    .uniforms({\n      colorPrimary: colors.primary,\n      colorSecondary: colors.secondary,\n      colorBackground: colors.background,\n      highResTimeStamp: abs,\n      secs: abs / 1000,\n      gradients: 1,\n      extra,\n      ...dynamicState,\n      //campos,\n      lll: modelView,\n      llli,\n    })\n    .draw(planeMesh)\n}\n\nfunction raymarch(\n  gl,\n  colors,\n  dynamicState,\n  onFPSChange,\n  triggerRender,\n  onCamChange,\n  onHover,\n  setExtra,\n  startShader,\n) {\n  gl.canvas.addEventListener(\"keydown\", (e) => e.key === \"r\" && triggerRender())\n  const camController = new OrbitCameraController(onCamChange)\n  let camMatrix = M4.IDENTITY\n  const eGizmoController = new EGizmoController(\n    gl,\n    M4.rotateZ(20 * DEG).translate(5, 5, 1),\n    onHover,\n    () => (camController.pauseCam = true),\n    () => (camController.pauseCam = false),\n    setExtra,\n  )\n  eGizmoController.registerListeners(gl.canvas, () => camMatrix)\n\n  gl.clearColor(...colors.background)\n  gl.clearColor(0, 0, 0, 1)\n  gl.clear(gl.COLOR_BUFFER_BIT)\n  gl.cullFace(gl.BACK)\n\n  gl.pointSize(10)\n\n  //gl.enable(gl.CULL_FACE)\n  gl.disable(gl.CULL_FACE)\n  gl.disable(gl.DEPTH_TEST)\n\n  gl.disable(gl.BLEND)\n  gl.blendFunc(gl.ONE, gl.ONE)\n  gl.blendEquation(gl.FUNC_ADD)\n\n  gl.canvas.contentEditable = \"true\" // make canvas focusable\n  gl.canvas.focus()\n  camController.registerListeners(gl.canvas)\n\n  const fpsController = new FPSController(onFPSChange)\n\n  const shared = raymarchSetup(gl)\n  if (module.hot) {\n    module.hot.accept(\"./shaders\", () => {\n      console.clear()\n      try {\n        shared.shaders = buildShaders(currentGL())\n      } catch (e) {\n        console.error(e)\n      }\n    })\n  }\n\n  let it = 0\n\n  return {\n    updateShader(newShader) {\n      shared.shaders.ed = Shader.create(\n        // eslint-disable-next-line @typescript-eslint/no-var-requires\n        require(\"../common/raymarch.vert\").default,\n        newShader,\n      )\n    },\n    teardown: gl.animate(function (abs, _diff) {\n      gl.clear(gl.COLOR_BUFFER_BIT)\n      it++\n      // if (it % 30 !== 0) return\n      // gl.clear(gl.DEPTH_BUFFER_BIT)\n      // gl.clear(gl.COLOR_BUFFER_BIT)\n      if (it % 300 === 0) {\n        // gl.clear(gl.COLOR_BUFFER_BIT)\n      }\n      gl.makeCurrent()\n      camController.tick()\n      fpsController.tick(abs)\n\n      camMatrix = M4.product(\n        M4.perspective(\n          70,\n          gl.canvas.offsetWidth / gl.canvas.offsetHeight,\n          0.1,\n          50,\n        ),\n        camController.getLookAt(),\n      )\n\n      raymarchRender(\n        gl,\n        shared,\n        camMatrix,\n        colors,\n        dynamicState,\n        abs,\n        eGizmoController.pos.getTranslation(),\n      )\n\n      gl.matrixMode(gl.PROJECTION)\n      gl.loadMatrix(camMatrix)\n      gl.matrixMode(gl.MODELVIEW)\n      gl.loadIdentity()\n\n      eGizmoController.render(shared.shaders.singleColor)\n    }),\n    setCam: camController.setState,\n  }\n}\n\nfunction MatrixDisplay({\n  children,\n  label,\n  onFocus,\n  onBlur,\n}\n\n\n\n\n) {\n  return (\n    React.createElement(OutlinedInput, {\n      onFocus: onFocus,\n      onBlur: onBlur,\n      label: label,\n      inputComponent: \"textarea\",\n      value: children.toString(),}\n    )\n  )\n}\n\nfunction makeShader(desc) {\n  let di = 0\n\n  function float(n) {\n    const s = \"\" + n\n    return s.includes(\".\") ? s : s + \".0\"\n  }\n\n  function vec3([x, y, z]) {\n    return \"vec3(\" + float(x) + \", \" + float(y) + \", \" + float(z) + \")\"\n  }\n\n  function makePart(desc) {\n    let input\n    let output\n    let f\n\n    function gen(g) {\n      input = \"p\" + di++\n      output = \"d\" + di++\n      f = `float ${output} = ${g(input)};\\n`\n    }\n\n    for (const d of desc) {\n      if (d.type === \"sphere\") {\n        gen((input) => `sdSphere(${float(d.radius)}, ${input})`)\n      } else if (d.type === \"box\") {\n        gen((input) => `betterBox(${vec3(d.radius)}, ${input})`)\n      } else if (d.type === \"octahedron\") {\n        gen((input) => `sdOctahedron(${float(d.radius)}, ${input})`)\n      } else if (d.type === \"donut\") {\n        gen((input) => `sdTorus(${float(d.r0)}, ${float(d.r1)}, ${input})`)\n      } else if (d.type === \"translate\") {\n        const prevInput = input\n        input = \"p\" + di++\n        f = `vec3 ${prevInput} = ${input} + ${vec3(d.by)};\\n` + f\n      } else if (d.type === \"expand\") {\n        const prevOutput = output\n        output = \"d\" + di++\n        f = f + `float ${output} = ${prevOutput} - ${float(d.by)};\\n`\n      } else if (d.type === \"add\" || d.type === \"sub\") {\n        const [subf, subinput, suboutput] = makePart(d.what)\n        f =\n          f +\n          `vec3 ${subinput} = ${input};\\n` +\n          subf +\n          `${output} = ` +\n          (d.type === \"add\"\n            ? `min(${output}, ${suboutput})`\n            : `max(${output}, -${suboutput})`) +\n          `;\\n`\n      }\n    }\n    return [f, input, output]\n  }\n\n  const [f, input, output] = makePart(desc)\n  let result = `RMHit sdf(vec3 ${input}) {\\n`\n  result += f\n  result += `return RMHit(${output}, black);\\n`\n  result += \"}\\n\"\n  return result\n}\n\nfunction normfig(s) {\n  return aesthetically.format(s, \"monospace\")\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction SphereEditor({\n  value,\n  onChange,\n}\n\n\n) {\n  const onRadiusChange = useCallback(\n    (ev) => onChange({ ...value, radius: +ev.target.value }, value),\n    [onChange],\n  )\n  return (\n    React.createElement('div', null, \"Sphere\"\n      , \" \"\n      , React.createElement(TextField, {\n        value: value.radius,\n        onChange: onRadiusChange,\n        inputProps: { type: \"number\" },}\n      )\n    )\n  )\n}\n\nfunction BoxEditor({\n  value,\n  onChange,\n}\n\n\n) {\n  const onRadiusChange = useCallback(\n    (newRadius) => onChange({ ...value, radius: newRadius }, value),\n    [value, onChange],\n  )\n  return (\n    React.createElement('div', { style: { display: \"flex\" },}, \"Box \"\n       , React.createElement(Vec3Editor, { value: value.radius, onChange: onRadiusChange,} )\n    )\n  )\n}\n\nfunction ExpandEditor({\n  value,\n  onChange,\n}\n\n\n) {\n  const onByChange = useCallback(\n    (e) => onChange({ ...value, by: +e.target.value }, value),\n    [value, onChange],\n  )\n  return (\n    React.createElement('div', { style: { display: \"flex\" },}, \"Expand\"\n      , \" \"\n      , React.createElement(TextField, {\n        value: value.by,\n        onChange: onByChange,\n        type: \"number\",\n        inputProps: {},}\n      )\n    )\n  )\n}\n\nclass GizmoControl {\n  take(startPos, onChange) {\n    // TODO\n  }\n}\n\nfunction Vec3Editor({\n  value,\n  onChange,\n  gizmoControl,\n}\n\n\n\n) {\n  const onElChange = useCallback(\n    (e) => {\n      const newValue = value.slice() \n      newValue[e.target.name] = +e.target.value\n      onChange(newValue, value)\n    },\n    [value, onChange],\n  )\n  const gizmoClick = useCallback(\n    () => gizmoControl.take(value, onChange),\n    [gizmoControl, onChange, value],\n  )\n  return (\n    React.createElement(React.Fragment, null\n      , React.createElement(Button, { onClick: gizmoClick,}, \"X\")\n      , [0, 1, 2].map((i) => (\n        React.createElement(TextField, {\n          key: i,\n          name: \"\" + i,\n          value: value[i],\n          onChange: onElChange,\n          inputProps: { type: \"number\" },}\n        )\n      ))\n    )\n  )\n}\n\nfunction TranslateEditor({\n  value,\n  onChange,\n  gizmoControl,\n}\n\n\n\n) {\n  const onByChange = useCallback(\n    (newBy) => onChange({ ...value, by: newBy }, value),\n    [value, onChange],\n  )\n  return (\n    React.createElement('div', { style: { display: \"flex\" },}, \"Translate\"\n      , \" \"\n      , React.createElement(Vec3Editor, {\n        value: value.by,\n        onChange: onByChange,\n        gizmoControl: gizmoControl,}\n      )\n    )\n  )\n}\n\nfunction DonutEditor({\n  value,\n  onChange,\n  gizmoControl,\n}\n\n\n\n) {\n  const onElChange = useCallback(\n    (e) =>\n      onChange(\n        {\n          ...value,\n          [e.target.name]: +e.target.value,\n        },\n        value,\n      ),\n    [value, onChange],\n  )\n  return (\n    React.createElement('div', { style: { display: \"flex\" },}, \"Donut\"\n      , \" \"\n      , ([\"r0\", \"r1\"] ).map((i) => (\n        React.createElement(TextField, {\n          key: i,\n          name: i,\n          value: value[i],\n          onChange: onElChange,\n          inputProps: { type: \"number\" },}\n        )\n      ))\n    )\n  )\n}\nfunction OctahedronEditor({\n  value,\n  onChange,\n  gizmoControl,\n}\n\n\n\n) {\n  const onElChange = useCallback(\n    (e) =>\n      onChange(\n        {\n          ...value,\n          [e.target.name]: +e.target.value,\n        },\n        value,\n      ),\n    [value, onChange],\n  )\n  return (\n    React.createElement('div', { style: { display: \"flex\" },}, \"Octahedron\"\n      , \" \"\n      , [\"radius\"].map((i) => (\n        React.createElement(TextField, {\n          key: i,\n          name: i,\n          value: value[i],\n          onChange: onElChange,\n          inputProps: { type: \"number\" },}\n        )\n      ))\n    )\n  )\n}\n\nfunction AddEditor({\n  value,\n  onChange,\n  gizmoControl,\n}\n\n\n\n) {\n  const onTypeChange = useCallback(\n    (e) => onChange({ ...value, type: e.target.value }, value),\n    [value, onChange],\n  )\n  const onWhatChange = useCallback(\n    (newWhat) => onChange({ ...value, what: newWhat }, value),\n    [value, onChange],\n  )\n  return (\n    React.createElement('div', { style: { display: \"flex\" },}\n      , React.createElement(Select, { value: value.type, name: \"type\", onChange: onTypeChange,}\n        , React.createElement(MenuItem, { value: \"add\",}, \"Add\")\n        , React.createElement(MenuItem, { value: \"sub\",}, \"Sub\")\n      ), \" \"\n      , React.createElement(Ed, {\n        value: value.what,\n        onChange: onWhatChange,\n        gizmoControl: gizmoControl,}\n      )\n    )\n  )\n}\n\nfunction Ed({\n  value,\n  onChange,\n  gizmoControl,\n}\n\n\n\n) {\n  const onItemChange = useCallback(\n    (newValue, oldValue) =>\n      onChange(value.map((v) => (v === oldValue ? newValue : v))),\n    [onChange, value],\n  )\n  return (\n    React.createElement('div', null\n      , value.map((x, i) => {\n        const PEd = {\n          sphere: SphereEditor,\n          expand: ExpandEditor,\n          add: AddEditor,\n          sub: AddEditor,\n          box: BoxEditor,\n          donut: DonutEditor,\n          translate: TranslateEditor,\n          octahedron: OctahedronEditor,\n        }[x.type]\n        return (\n          PEd && (\n            React.createElement(PEd, {\n              key: i,\n              value: x,\n              onChange: onItemChange,\n              gizmoControl: gizmoControl,}\n            )\n          )\n        )\n      })\n    )\n  )\n}\n\nexport default () => {\n  const canvasRef = useRef(null)\n\n  const [renderProgress, setRenderProgress] = useState(\n    undefined ,\n  )\n  const [gp, setGp] = useState(M4.IDENTITY)\n  const [resolution, setResolution] = useState(512)\n  const [gpFocused, setGpFocused] = useState(false)\n  const [state, setState] = useHashState(initialState)\n  const setStatePartial = useCallback(\n    (o) => setState((s) => ({ ...s, ...o })),\n    [setState],\n  )\n  const [part, setPart] = useState(NONE)\n  const [fps, setFps] = useState(0)\n  const dynamic = useRef(Object.assign({}, state))\n  const raymarchRef = useRef()\n\n  const [model, setModel] = useState([\n    { type: \"sphere\", radius: 1 },\n    { type: \"translate\", by: [1, 2, 3] },\n    {\n      type: \"add\",\n      what: [\n        { type: \"box\", radius: [1, 2, 3] },\n        { type: \"translate\", by: [0.1, 0.1, 0.1] },\n        { type: \"expand\", by: 0.3 },\n      ],\n    },\n    {\n      type: \"add\",\n      what: [\n        { type: \"octahedron\", radius: 2 },\n        { type: \"translate\", by: [0.1, 0.1, 0.1] },\n      ],\n    },\n    {\n      type: \"add\",\n      what: [\n        { type: \"donut\", r0: 2, r1: 0.2 },\n        { type: \"translate\", by: [0.1, 0.1, 0.1] },\n      ],\n    },\n  ])\n\n  const theme = useTheme()\n  const colors = useMemo(\n    () => ({\n      background: chroma.css(theme.palette.background.default).gl(),\n      primary: chroma.css(theme.palette.primary.main).gl(),\n      secondary: chroma.css(theme.palette.secondary.main).gl(),\n    }),\n    [theme.palette],\n  )\n  const render = useCallback(\n    async ([width, height]) => {\n      const url = URL.createObjectURL(\n        await renderHighRes(\n          [width, height],\n          raymarchSetup,\n          (gl, shared) => {\n            const camMatrix = M4.product(\n              M4.perspective(70, width / height, 0.1, 50),\n              OrbitCameraController.getLookAt(\n                OrbitCameraController.fromShortString(state.cam),\n              ),\n            )\n\n            raymarchRender(\n              gl,\n              shared,\n              camMatrix,\n              colors,\n              state,\n              2000,\n              gp.getTranslation(),\n            )\n          },\n          setRenderProgress,\n        ),\n      )\n      setRenderProgress(undefined)\n      openInNewTab(url)\n    },\n    [gp, colors, state],\n  )\n  useEffect(() => {\n    console.log(\"creating context\")\n    const tsgl = TSGLContext.create({\n      canvas: canvasRef.current,\n      alpha: true,\n      premultipliedAlpha: true,\n      // antialias: true,\n      throwOnError: true,\n    })\n    console.log(tsgl.getParameter(tsgl.MAX_SAMPLES))\n    // tsgl.fixCanvasRes()\n    //tsgl.addResizeListener()\n    raymarchRef.current = raymarch(\n      tsgl,\n      colors,\n      dynamic.current,\n      setFps,\n      () => render([1920, 1080]),\n      debounce((cam) => {\n        setStatePartial({ cam: OrbitCameraController.toShortString(cam) })\n      }),\n      setPart,\n      setGp,\n    )\n\n    return () => {\n      _optionalChain([raymarchRef, 'access', _ => _.current, 'optionalAccess', _2 => _2.teardown, 'call', _3 => _3()])\n    }\n  }, [])\n  useEffect(() => {\n    // state.cam &&\n    //   raymarchRef.current?.setCam(\n    //     OrbitCameraController.fromShortString(state.cam),\n    //   )\n  }, [state.cam])\n  useEffect(() => {\n    _optionalChain([raymarchRef, 'access', _4 => _4.current, 'optionalAccess', _5 => _5.updateShader, 'call', _6 => _6(\n      edFragShader.replace(/RMHit sdf\\(vec3 p\\) {[\\s\\S]*?}/, makeShader(model)),\n    )])\n  }, [model])\n\n  useEffect(() => {\n    Object.assign(dynamic.current, state)\n  }, [state])\n\n  const RenderButton = useCallback(\n    ({ dim, children }) => (\n      React.createElement(Button, {\n        variant: \"contained\",\n        onClick: () => render(dim),\n        disabled: \"undefined\" !== typeof renderProgress,}\n\n        , \"undefined\" === typeof renderProgress\n          ? children\n          : \"Rendering... \" +\n            normfig(\"\" + Math.floor(renderProgress * 100)).padStart(\n              3,\n              \"\\u2007\",\n            ) +\n            \"%\"\n      )\n    ),\n    [render, renderProgress],\n  )\n\n  function setCam({ cam }) {\n    const m = FlyCameraController.fromShortString(cam)\n    setStatePartial({ cam: OrbitCameraController.toShortString(m) })\n  }\n\n  return (\n    React.createElement(Grid, { container: true, style: { height: \"99%\" },}\n      , React.createElement(Grid, { item: true, xs: 12, md: 9,}\n        , React.createElement('div', { style: { height: \"100%\" },}\n          , React.createElement('canvas', {\n            ref: canvasRef,\n            style: {\n              width: \"100%\",\n              height: \"100%\",\n              cursor: part === NONE ? \"move\" : \"grab\",\n            },\n            width: resolution,\n            height: resolution,\n            tabIndex: 0,}\n          )\n        )\n      )\n      , React.createElement(Grid, {\n        item: true,\n        xs: 12,\n        md: 3,\n        sx: {\n          display: \"flex\",\n          flexDirection: \"column\",\n          width: \"100%\",\n          padding: 2,\n          alignItems: \"stretch\",\n          gap: 2,\n        },}\n\n        , React.createElement(Card, null\n          , React.createElement(CardContent, null, \"Raymarching demo.\" )\n        )\n        , React.createElement(Select, {\n          onChange: (e) => setResolution(+(e.target.value )),\n          value: resolution,}\n\n          , React.createElement(MenuItem, { value: 256,}, \"256x256\")\n          , React.createElement(MenuItem, { value: 512,}, \"512x512\")\n        )\n        , React.createElement(BoundNumberField, {\n          ...{ state, setStatePartial },\n          prop: \"a\",\n          inputProps: { step: 0.05 },}\n        ), \" \"\n        , React.createElement(BoundNumberField, {\n          ...{ state, setStatePartial },\n          prop: \"b\",\n          inputProps: { step: 0.05 },}\n        )\n        , React.createElement(BoundNumberField, {\n          ...{ state, setStatePartial },\n          prop: \"c\",\n          inputProps: { step: 0.05 },}\n        ), \" \"\n        , React.createElement(BoundNumberField, {\n          ...{ state, setStatePartial },\n          prop: \"d\",\n          inputProps: { step: 0.05 },}\n        )\n        , React.createElement(RenderButton, { dim: [1920, 1080],}, \"render hd\" )\n        , React.createElement(RenderButton, { dim: [3840, 2160],}, \"render 4k\" )\n        , React.createElement(Button, {\n          color: \"secondary\",\n          variant: \"outlined\",\n          onClick: () => setCam({ cam: \"999.999.999~-56.-58.-61~-44.-44.79\" }),}\n, \"Cam 0\"\n\n        )\n        , React.createElement(Button, {\n          color: \"secondary\",\n          variant: \"outlined\",\n          onClick: () => setCam({ cam: \"57.427.96~1.-100.-8~7.-7.99\" }),}\n, \"Cam 1\"\n\n        )\n        , React.createElement(Button, {\n          color: \"secondary\",\n          variant: \"outlined\",\n          onClick: () => setCam({ cam: \"53.80.892~-9.-8.-100~-18.-99.8\" }),}\n, \"Cam 2\"\n\n        )\n        , React.createElement('div', null, \"cam: \" , state.cam)\n        , React.createElement('div', null, \"fps: \" , fps)\n        , React.createElement(MatrixDisplay, {\n          label: \"gp\",\n          onFocus: () => setEditing(true),\n          onBlur: () => setEditing(false),}\n\n          , gp\n        )\n        , React.createElement('div', null\n          , React.createElement(Ed, { value: model, onChange: setModel,} )\n        )\n        , React.createElement('div', null\n          , React.createElement('pre', null\n            , React.createElement('code', null, makeShader(model))\n          )\n        )\n      )\n    )\n  )\n}\n","\nexport default \"#version 300 es\\n\\nprecision highp float;\\n\\n// START ../common/banded.glsl\\nfloat banded(float bandCount, float t) {\\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\\n}\\nfloat banded(int bandCount, float t) {\\n  return banded(float(bandCount), t);\\n}\\n\\n// #pragma glslify: export(banded)\\n\\n\\n// END ../common/banded.glsl\\n// START ../common/between.glsl\\nbool between(float min, float max, float value) {\\n  return min <= value && value <= max;\\n}\\n\\n// #pragma glslify: export(between)\\n\\n\\n// END ../common/between.glsl\\n// START ../common/hexFns.glsl\\n// START ./max3.glsl\\nfloat max3(float a, float b, float c) {\\n  return max(a, max(b, c));\\n}\\nfloat max3(vec3 v) {\\n  return max(v.x, max(v.y, v.z));\\n}\\n\\n// #pragma glslify: export(max3)\\n\\n\\n// END ./max3.glsl\\n// START ./constants.glsl\\nconst float SQRT1_2 = 0.7071067811865476;\\nconst float SQRT1_3 = 0.57735026919;\\nconst float SQRT2 = 1.4142135623730951;\\nconst float SQRT3 = 1.732050807568877;\\n// sqrt(3)/2 = sin(60*)\\nconst float SQRT3_2 = 0.86602540378;\\nconst float GOLDEN_RATIO = 1.61803398875;\\nconst float PI = 3.141592653589793;\\nconst float TAU = 6.28318530718;\\n/**\\n * One degree in radians. Use like `sin(30 * DEG)`.\\n */\\nconst float DEGREE = 0.017453292519943295;\\n\\n// END ./constants.glsl\\n\\nvec3 hexRound(vec3 hex) {\\n  vec3 r = floor(hex + 0.5);\\n  vec3 diff = abs(r - hex);\\n\\n  if (diff.x > diff.y && diff.x > diff.z) {\\n    r.x = -(r.y + r.z);\\n  } else if (diff.y > diff.z) {\\n    r.y = -(r.x + r.z);\\n  } else {\\n    r.z = -(r.x + r.y);\\n  }\\n\\n  return r;\\n}\\nvec2 hex2Ra(vec3 hex) {\\n  float y = hex.t * SQRT3_2;\\n  float x = hex.s + hex.t / 2.0;\\n  return vec2(x, y);\\n}\\n\\nfloat hexSdf(vec3 hex) {\\n  return max3(abs(hex.yzx + hex.zxy / 2.0));\\n}\\nvec3 ra2Hex(vec2 xy) {\\n  float hex_t = xy.y / SQRT3_2;\\n  float hex_s = xy.x - hex_t / 2.0;\\n  return vec3(hex_s, hex_t, -(hex_s + hex_t));\\n}\\n\\n// END ../common/hexFns.glsl\\n// START ../common/matrices.glsl\\n\\nmat2 rot2(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat2(c, s, -s, c);\\n}\\nmat3 rotX(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\\n}\\nmat3 rotY(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\\n}\\nmat3 rotZ(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\\n}\\n/**\\n * Returns a matrix that puts the camera at the eye point `ex, ey, ez` looking\\n * toward the center point `cx, cy, cz` with an up direction of `ux, uy, uz`.\\n * This emulates the OpenGL function `gluLookAt()`.\\n */\\nmat4 lookAt(vec3 eye, vec3 focus, vec3 up) {\\n  vec3 f = normalize(eye - focus);\\n  vec3 s = normalize(cross(up, f));\\n  vec3 t = normalize(cross(f, s));\\n\\n  return mat4(\\n    vec4(s.x, t.x, f.x, 0.0),\\n    vec4(s.y, t.y, f.y, 0.0),\\n    vec4(s.z, t.z, f.z, 0.0),\\n    vec4(-dot(s, eye), -dot(t, eye), -dot(f, eye), 1)\\n  );\\n}\\n\\n// the OpenGL function `glFrustum()`.\\nmat4 frustum(\\n  float left,\\n  float right,\\n  float bottom,\\n  float top,\\n  float near,\\n  float far\\n) {\\n  return mat4(\\n    vec4(2.0 * near / (right - left), 0.0, 0.0, 0.0),\\n    vec4(0, 2.0 * near / (top - bottom), 0.0, 0.0),\\n    vec4(\\n      (right + left) / (right - left),\\n      (top + bottom) / (top - bottom),\\n      -(far + near) / (far - near),\\n      -1\\n    ),\\n    vec4(0.0, 0.0, -2.0 * far * near / (far - near), 0.0)\\n  );\\n}\\n\\nmat4 perspective(float fovDegrees, float aspect, float near, float far) {\\n  float y = tan(fovDegrees * DEGREE / 2.0) * near;\\n  float x = y * aspect;\\n  return frustum(-x, x, -y, y, near, far);\\n}\\nmat4 ortho(\\n  float left,\\n  float right,\\n  float bottom,\\n  float top,\\n  float near,\\n  float far\\n) {\\n  return mat4(\\n    vec4(2.0 / (right - left), 0.0, 0.0, 0.0),\\n    vec4(0.0, 2.0 / (top - bottom), 0.0, 0.0),\\n    vec4(0.0, 0.0, -2.0 / (far - near), 0.0),\\n    vec4(\\n      -(right + left) / (right - left),\\n      -(top + bottom) / (top - bottom),\\n      -(far + near) / (far - near),\\n      1.0\\n    )\\n  );\\n}\\n\\n// END ../common/matrices.glsl\\n// START ../common/perlin2DTexture.glsl\\nuniform sampler2D gradients;\\n/* Create random direction vector\\n */\\nvec2 randomGradient(vec2 i) {\\n  // Random float. No precomputed gradients mean this works for any number of grid coordinates\\n  float random =\\n    2920.0 *\\n    sin(float(i.x) * 2.1942 + float(i.y) * 1.71324 + 8.912) *\\n    cos(float(i.x) * 2.3157 * float(i.y) * 2.17832 + 9.758);\\n  //    random = (i.x + 1667.) * (i.x + 2083.) * (i.y + 2659.) * (i.y * 50.77 + .3769);\\n  //    random = sin(SQRT2 * i.x) + cos(GOLDEN_RATIO * i.y) + tan((i.x + i.y) * SQRT3);\\n  return vec2(cos(random), sin(random));\\n}\\nfloat dotGridGradient(vec2 cell, vec2 pos) {\\n  vec2 d = cell - pos;\\n\\n  //  vec2 gradient = texelFetch(gradients, ivec2(cell), 0).xy;\\n  vec2 gradient = randomGradient(vec2(cell));\\n\\n  return dot(gradient, d);\\n}\\n\\nfloat mixx(float a, float b, float t) {\\n  return mix(a, b, smoothstep(0.0, 1.0, t));\\n  //    return mix(a, b, t);\\n}\\n\\n// resulting range is [-0.68, 0.68]. Use unmix to normalize if necessary.\\nfloat perlin2D(vec2 xy) {\\n  float x0 = floor(xy.x);\\n  float x1 = x0 + 1.0;\\n  float y0 = floor(xy.y);\\n  float y1 = y0 + 1.0;\\n\\n  // Interpolate between grid point gradients\\n  float n00 = dotGridGradient(vec2(x0, y0), xy);\\n  float n10 = dotGridGradient(vec2(x1, y0), xy);\\n  float ny0 = mixx(n00, n10, xy.x - x0);\\n\\n  float n01 = dotGridGradient(vec2(x0, y1), xy);\\n  float n11 = dotGridGradient(vec2(x1, y1), xy);\\n  float ny1 = mixx(n01, n11, xy.x - x0);\\n\\n  return mixx(ny0, ny1, xy.y - y0);\\n}\\n\\n// #pragma glslify: export(perlin2D)\\n\\n\\n// END ../common/perlin2DTexture.glsl\\n// START ../common/polar.glsl\\n// START ../common/fromPolar.glsl\\n// START ./unmix.glsl\\nfloat unmix(float a, float b, float value) {\\n  return (value - a) / (b - a);\\n}\\n\\n// #pragma glslify: export(unmix)\\n\\n\\n// END ./unmix.glsl\\n\\nvec3 fromPolar(float radius, float phi, float z) {\\n  return vec3(radius * cos(phi), radius * sin(phi), z);\\n}\\n\\nvec2 fromPolar(float radius, float phi) {\\n  return vec2(radius * cos(phi), radius * sin(phi));\\n}\\n\\nvec2 fromPolar(vec2 polar) {\\n  return fromPolar(polar.x, polar.y);\\n}\\n\\n// #pragma glslify: export(fromPolar)\\n\\n\\n// END ../common/fromPolar.glsl\\n// START ../common/toPolar.glsl\\n\\nvec2 toPolar(vec2 xy) {\\n  return vec2(length(xy), atan(xy.y, xy.x));\\n}\\n\\nmat2 toPolarDerivate(vec2 xy) {\\n  return mat2(xy.x * xy.x, xy.y * xy.y, -xy.y, xy.x) / dot(xy, xy);\\n}\\n\\n// #pragma glslify: export(toPolar)\\n\\n\\n// END ../common/toPolar.glsl\\n\\n// END ../common/polar.glsl\\n// START ../common/remix.glsl\\n\\nfloat remix(float fromA, float fromB, float toA, float toB, float value) {\\n  return mix(toA, toB, unmix(fromA, fromB, value));\\n}\\n\\nvec4 remix(float fromA, float fromB, vec4 toA, vec4 toB, float value) {\\n  return mix(toA, toB, unmix(fromA, fromB, value));\\n}\\n\\n// #pragma glslify: export(remix)\\n\\n\\n// END ../common/remix.glsl\\n// START ../common/transform.glsl\\nvec3 transform(mat4 pm, vec3 p) {\\n  vec4 pStar = pm * vec4(p, 1);\\n  return pStar.xyz / pStar.w;\\n}\\n\\nvec2 transform(mat4 pm, vec2 p) {\\n  vec4 pStar = pm * vec4(p, 0, 1);\\n  return pStar.xy / pStar.w;\\n}\\n\\n// END ../common/transform.glsl\\n// START ../common/visualize.glsl\\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\\n  float isLow = float(t < 0.0);\\n  float isHigh = float(t > 1.0);\\n  float isMid = 1.0 - isLow - isHigh;\\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\\n}\\n\\nvec4 visualize(float t) {\\n  const vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\\n  const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\\n  return visualize(BLUE, RED, t);\\n}\\n\\n// #pragma glslify: export(visualize)\\n\\n\\n// END ../common/visualize.glsl\\n// START ../common/waves.glsl\\nfloat waves(vec4 color, vec2 position, vec2 direction, float highResTimeStamp) {\\n  return sin(\\n    dot(position, direction / pow(length(direction), 2.0)) +\\n      float(highResTimeStamp) / 200.0\\n  );\\n}\\n\\n// #pragma glslify: export(waves)\\n\\n\\n// END ../common/waves.glsl\\n\\n// START ../common/sdf3d/sdTorus.glsl\\nfloat sdTorus(float r0, float r1, vec3 p) {\\n  vec3 closestCenter = vec3(normalize(p.xy) * r0, 0.0);\\n  return distance(closestCenter, p) - r1;\\n}\\n\\n// #pragma glslify: export(sdTorus)\\n\\n\\n// END ../common/sdf3d/sdTorus.glsl\\n// START ../common/sdf3d/sdCapsule.glsl\\nfloat sdCapsule(vec3 a, vec3 b, float r, vec3 p) {\\n  vec3 pa = p - a;\\n  vec3 ba = b - a;\\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\\n  return length(pa - ba * h) - r;\\n}\\n// #pragma glslify: export(sdCapsule)\\n\\n// END ../common/sdf3d/sdCapsule.glsl\\n// START ../common/sdf3d/opElongate.glsl\\nvec3 opElongate(vec3 h, vec3 p) {\\n  return p - clamp(p, -h, h);\\n}\\n// #pragma glslify: export(opElongate)\\n\\n// END ../common/sdf3d/opElongate.glsl\\n// START ../common/sdf3d/sdSphere.glsl\\nfloat sdSphere(float radius, vec3 p) {\\n  return length(p) - radius;\\n}\\n\\n// #pragma glslify: export(sdSphere)\\n\\n\\n// END ../common/sdf3d/sdSphere.glsl\\n// START ../common/sdf3d/sdCylinder.glsl\\nfloat sdCylinder(float radius, float z, vec3 p) {\\n  vec2 d = vec2(length(p.xy), abs(p.z)) - vec2(radius, z);\\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\\n}\\n\\n// #pragma glslify: export(sdCylinder)\\n\\n\\n// END ../common/sdf3d/sdCylinder.glsl\\n// START ../common/sdf3d/sdCone.glsl\\n\\n/**\\n * Signed distance function (SDF) of a cone. The tip of the cone is at the\\n * origin and points towards +Z. q is a point on the rim of the cone.\\n */\\nfloat sdCone(vec2 c, float h, vec3 p) {\\n  vec2 q = h * vec2(c.x / c.y, -1.0);\\n  vec2 w = vec2(length(p.xz), p.y);\\n  vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);\\n  vec2 b = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0);\\n  float k = sign(q.y);\\n  float d = min(dot(a, a), dot(b, b));\\n  float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));\\n  return sqrt(d) * sign(s);\\n}\\n// #pragma glslify: export(sdBox)\\n\\nfloat sdConeB(vec2 c, float h, vec3 p) {\\n  float q = length(p.xz);\\n  return max(dot(c.xy, vec2(q, p.y)), -h - p.y);\\n}\\n\\n// END ../common/sdf3d/sdCone.glsl\\n// START ../common/sdf2d/addChamfer.glsl\\n\\nfloat addChamfer(float d, float a, float b) {\\n  // exact variant, but abs is larger when a and b aren't perpendicular\\n  // which is worse than underestimating, which is what the simple version does.\\n  //  vec2 p = vec2(a, b);\\n  //  if (p.x < d && p.y < d) {\\n  //    p = rot2(0.25 * PI) * p;\\n  //    p.y = abs(p.y);\\n  //    p.y -= min(p.y, d * SQRT1_2);\\n  //    p.x -= d * SQRT1_2;\\n  //    //    p -= vec2(SQRT1_2) * clamp(dot(p, vec2(SQRT1_2)), 0.0, d);\\n  //    float fillet = -length(p);\\n  //    return -sign(p.x) * fillet;\\n  //  } else {\\n  //  }\\n  float tillet = (a + b - d) * SQRT1_2;\\n  return min(tillet, min(a, b));\\n}\\n\\n// #pragma glslify: export(addChamfer)\\n\\n\\n// END ../common/sdf2d/addChamfer.glsl\\n// START ../common/sdf2d/addFillet.glsl\\nfloat addFillet(float r, float a, float b) {\\n  if (a < r && b < r) {\\n    return r - distance(vec2(a, b), vec2(r));\\n  } else {\\n    return min(a, b);\\n  }\\n}\\n\\n// #pragma glslify: export(addFillet)\\n\\n\\n// END ../common/sdf2d/addFillet.glsl\\n// START ../common/sdf3d/sdBox.glsl\\n\\nfloat sdBox(vec3 r, vec3 p) {\\n  vec3 q = abs(p) - r;\\n  return length(max(q, 0.0)) + min(max3(q), 0.0);\\n}\\n\\nfloat sdBox(vec3 r, float r2, vec3 p) {\\n  return sdBox(r - r2, p) - r2;\\n}\\n\\n// #pragma glslify: export(sdBox)\\n\\n\\n// END ../common/sdf3d/sdBox.glsl\\n// START ../common/sdf3d/sdOctahedron.glsl\\nfloat sdOctahedron(float s, vec3 p) {\\n  p = abs(p);\\n  float m = p.x + p.y + p.z - s;\\n  vec3 q;\\n  if (3.0 * p.x < m) q = p.xyz;\\n  else if (3.0 * p.y < m) q = p.yzx;\\n  else if (3.0 * p.z < m) q = p.zxy;\\n  else return m * 0.57735027;\\n\\n  float k = clamp(0.5 * (q.z - q.y + s), 0.0, s);\\n  return length(vec3(q.x, q.y - s + k, q.z - k));\\n}\\n// #pragma glslify: export(sdOctahedron)\\n\\nfloat sdOctahedron(vec3 p, float s) {\\n  p = abs(p);\\n\\n  float m = p.x + p.y + p.z - s;\\n  //find point on octohedron surf nearest to p\\n  vec3 projPoint = p - vec3(0.333333 * m); //project onto surface plane\\n  //now push projected point, if outside triangle edge, perpendicular to edge, to edge\\n  vec3 toMove = min(projPoint, 0.0); //if projpoint.x<0 move along (1.0,-0.5,-0.5) , etc\\n  float toMoveSum = dot(toMove, vec3(1.0)); //which is basically along (1.5,0,0) then vec3(-0.5)\\n\\n  vec3 movedPoint = projPoint + toMove * vec3(-1.5) + toMoveSum * vec3(0.5); //better to multiply toMove by a matrix (1s diagonal, 0.5 other)?\\n\\n  movedPoint = max(movedPoint, 0.0); //cap x,y,z to 0 then\\n  movedPoint *= s / dot(movedPoint, vec3(1.0)); //scale about 0,0,0\\n\\n  return length(p - movedPoint);\\n}\\n\\n// END ../common/sdf3d/sdOctahedron.glsl\\n// START ../common/sdf3d/add.glsl\\nfloat add(float a, float b) {\\n  return min(a, b);\\n}\\n\\n// #pragma glslify: export(add)\\n\\n\\n// END ../common/sdf3d/add.glsl\\n// START ../common/sdf3d/sub.glsl\\nfloat sub(float from, float what) {\\n  return max(from, -what);\\n}\\n\\n// #pragma glslify: export(sub)\\n\\n\\n// END ../common/sdf3d/sub.glsl\\n\\nuniform sampler2D texture;\\nuniform float secs;\\nuniform mat4 lll;\\nuniform mat4 llli;\\nuniform vec4 colorPrimary;\\nuniform vec4 colorSecondary;\\nuniform vec4 colorBackground;\\nuniform float a;\\nuniform float b;\\nuniform float c;\\nuniform float d;\\nuniform float highResTimeStamp;\\nuniform int bandCount;\\nuniform vec3 campos;\\nin float n;\\nin vec2 coord;\\nout vec4 fragColor;\\n\\n\\nconst vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\\nconst vec4 yellow = vec4(1.0, 1.0, 0.0, 1.0);\\nconst vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\\nconst vec4 blue = vec4(0.0, 0.0, 1.0, 1.0);\\nconst vec4 purple = vec4(0.5, 0.0, 0.5, 1.0);\\nconst vec4 red = vec4(1.0, 0.0, 0.0, 1.0);\\n\\nstruct RMHit {\\n  float distance;\\n  vec4 color;\\n};\\nRMHit mixa(RMHit a, RMHit b, float t) {\\n  return RMHit(mix(a.distance, b.distance, t), mix(a.color, b.color, t));\\n}\\nfloat skybox(vec3 p) {\\n  return 32.0 - max3(abs(p));\\n}\\n\\nfloat perlinSphere(float radius, vec3 p) {\\n  vec3 cp = normalize(p);\\n  float alpha = atan(cp.y, cp.x);\\n  float beta = asin(cp.z);\\n  return length(p) -\\n  radius +\\n  0.1 *\\n    perlin2D(vec2(0.0 / 100.0, 0.0) + (vec2(5.0) + vec2(alpha, beta)) * 8.0);\\n}\\n\\nfloat cylCircle(vec3 p) {\\n  float d = 10e9;\\n  for (int i = 0; i < 10; i++) {\\n    d = min(\\n      d,\\n      sdCylinder(0.2, 2.0, p + fromPolar(3.0, TAU * float(i) / 10.0, 1.0))\\n    );\\n  }\\n\\n  return d;\\n}\\n\\nfloat rblock(float r, out vec3 p) {\\n  return sdBox(vec3(r), p);\\n}\\n\\nRMHit add(RMHit a, RMHit b) {\\n  //    return a.distance < b.distance\\n  //        ? RMHit(a.distance, a.color)\\n  //        : RMHit(b.distance, b.color);\\n  return mixa(a, b, float(b.distance < a.distance));\\n}\\n\\nfloat wtf(vec3 p) {\\n  vec3 center = p - mod(p, 3.0) + vec3(1.5);\\n  return rblock(0.4 + 0.3 * sin(secs + center.x), center);\\n}\\n\\nRMHit addFillet(float r, RMHit a, RMHit b) {\\n  if (a.distance < r && b.distance < r) {\\n    return RMHit(\\n      r - distance(vec2(a.distance, b.distance), vec2(r)),\\n      mix(a.color, b.color, (a.distance - b.distance) / r * 0.5 + 0.5)\\n    );\\n  } else {\\n    return add(a, b);\\n  }\\n}\\n\\nRMHit addFillet(float r, RMHit a, RMHit b, vec4 tilletColor) {\\n  if (a.distance < r && b.distance < r) {\\n    return RMHit(\\n      r - distance(vec2(a.distance, b.distance), vec2(r)),\\n      tilletColor\\n    );\\n  } else {\\n    return add(a, b);\\n  }\\n}\\nRMHit addFillet2(float r, RMHit a, RMHit b) {\\n  float h = smoothstep(-r, r, a.distance - b.distance);\\n  return RMHit(\\n    mix(a.distance, b.distance, h) - r * h * (1.0 - h),\\n    mix(a.color, b.color, h)\\n  );\\n}\\n\\nRMHit neg(RMHit a) {\\n  return RMHit(-a.distance, a.color);\\n}\\nRMHit sub(RMHit from, RMHit what) {\\n  RMHit whatNeg = neg(what);\\n  return mixa(from, whatNeg, float(whatNeg.distance > from.distance));\\n}\\n\\nvec3 modv(vec3 v, vec3 dir1, float y) {\\n  float t = dot(v, dir1);\\n  return v - floor(t / y) * y * dir1;\\n}\\nvec3 modRotZ(vec3 p, float count) {\\n  vec2 polarXY = toPolar(p.xy);\\n  return fromPolar(polarXY.x, mod(polarXY.y, TAU / count), p.z);\\n}\\n\\nfloat sin01(float x) {\\n  return 0.5 + 0.5 * sin(x);\\n}\\nfloat cos01(float x) {\\n  return 0.5 + 0.5 * cos(x);\\n}\\n\\nfloat betterBox(vec3 r, vec3 p) {\\n  vec3 q = abs(p) - r;\\n  return length(max(q, 0.0)) + min(max3(q), 0.0);\\n  p = abs(p);\\n  return max3(p - r);\\n}\\n\\nfloat sdEllipsoidB(vec3 r, vec3 p) {\\n  float k0 = length(p / r);\\n  float k1 = length(p / (r * r));\\n  return k0 * (k0 - 1.0) / k1;\\n}\\nfloat sdOctahedronB(float s, vec3 p) {\\n  p = abs(p);\\n  return (p.x + p.y + p.z - s) * 0.57735027;\\n}\\nfloat donutc(float r0, float r1, vec3 p) {\\n  vec3 closestCenter = vec3(normalize(p.xy) * r0, 0.0);\\n  return distance(closestCenter, p) - r1;\\n}\\n\\nfloat smoothmin(float r, float a, float b) {\\n  float h = smoothstep(-r, r, a - b);\\n  return mix(a, b, h) - r * h * (1.0 - h);\\n}\\n\\nRMHit sdf(vec3 p) {\\n  return RMHit(0.0, black);\\n}\\n\\nfloat sdff(vec3 p) {\\n  return sdf(p).distance;\\n}\\n\\nstruct RMResult {\\n  float distance;\\n  vec3 pos;\\n  vec4 color;\\n};\\nRMResult raymarching2(vec3 start, vec3 dir1) {\\n  vec3 pos = start;\\n  RMHit hit;\\n  for (int i = 0; i < 200; i++) {\\n    hit = sdf(pos);\\n    if (hit.distance < 0.0001) break;\\n    pos = pos + dir1 * hit.distance;\\n  }\\n  return RMResult(hit.distance, pos, hit.color);\\n}\\n\\nfloat softshadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {\\n  float res = 1.0;\\n  float t = 0.1;\\n  for (int i = 0; i < 1000 && t < maxt; i++) {\\n    float h = sdff(ro + rd * t);\\n    if (h < 0.001) return 0.0;\\n    res = min(res, k * h / t);\\n    t += h;\\n  }\\n  return res;\\n}\\n\\nconst float eps = 1e-4;\\nvec3 sdfNormal1(vec3 p, float d) {\\n  return normalize(\\n    vec3(\\n      sdff(p + vec3(eps, 0.0, 0.0)),\\n      sdff(p + vec3(0.0, eps, 0.0)),\\n      sdff(p + vec3(0.0, 0.0, eps))\\n    ) -\\n      sdff(p)\\n  );\\n}\\n\\nfloat ambientOcclusion(vec3 pWC, vec3 n1WC) {\\n  float k = 1.0;\\n  float distance = sdff(pWC + n1WC * k);\\n  return clamp(distance / k, 0.0, 1.0);\\n}\\n\\n//layout (depth_greater) out float gl_FragDepth;\\nvoid main() {\\n  vec3 light = normalize(vec3(-1.0, -2.0, -2));\\n\\n  vec3 a = vec3(coord, -1.0);\\n  vec3 b = vec3(coord, 1.0);\\n  vec3 aWC = transform(llli, a);\\n  vec3 bWC = transform(llli, b);\\n  vec3 lookDir1 = normalize(bWC - aWC);\\n\\n  RMResult hitWC = raymarching2(aWC, lookDir1);\\n  vec3 hitn1 = sdfNormal1(hitWC.pos, hitWC.distance);\\n  float dWC = distance(aWC, hitWC.pos);\\n  vec3 hitNDC = transform(lll, hitWC.pos);\\n\\n  vec3 sunPoint = raymarching2(hitWC.pos + hitn1 * 0.1, -light).pos;\\n  //    float inSun = float(distance(hitWC.pos, sunPoint) > 30.);\\n  float inSun = softshadow(\\n    hitWC.pos + hitn1 * 0.05,\\n    -light,\\n    0.0001,\\n    300.0,\\n    8.0\\n  );\\n  //    float inSun=1.;\\n\\n  vec3 material = vec3(0.0, 0.2, 0.0);\\n  if (dWC > 100.0) {\\n    material = vec3(0.0, 0.0, 0.0);\\n  }\\n\\n  const vec3 sunlightColor = vec3(8.0, 6.0, 1.0);\\n\\n  float aOcc = ambientOcclusion(hitWC.pos, hitn1);\\n\\n  vec3 reflectionDirection = reflect(light, hitn1);\\n\\n  vec3 color = vec3(0.0);\\n  color += material * aOcc;\\n  color += inSun * sunlightColor * material * max(0.0, dot(-light, hitn1));\\n  //    color = (hitn1);\\n\\n  vec3 camPos = aWC;\\n\\n  vec3 eyeDirection = -lookDir1;\\n  float uMaterialShininess = 256.0;\\n  float specularLightWeighting = pow(\\n    max(dot(reflectionDirection, eyeDirection), 0.0),\\n    uMaterialShininess\\n  );\\n  color += specularLightWeighting;\\n  //    float lightIntensity = 0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.);\\n  //    float lightIntensity =\\n  //        0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.) + 0.3*specularLightWeighting;\\n  //    fragColor = visualize(blue, red, mix(0.5, 1.0, inSun) * lightIntensity);\\n  //    fragColor = mix(hitWC.color, colorBackground, mix(0.5, 1.0, inSun) * clamp(lightIntensity, 0., 1.));\\n  color = pow(color, vec3(1.0 / 2.2)); // gamma correction\\n  fragColor = vec4(color, 1.0);\\n  //    fragColor = visualize(hitWC.pos.x/10.);\\n  //    fragColor = hitWC.color;\\n  //    fragColor = visualize(blue, red, distance(hitWC, sunPoint)/20.);\\n  //    fragColor = vec4(coord,0.,1.);\\n  //    fragColor = vec4(aWC, 1.0);\\n  // remap [-1, 1] to [0, 1]\\n  // gl_FragDepth = hitNDC.z * 0.5 + 0.5;\\n  //    gl_FragDepth = .9999999;\\n}\\n\"\nconst sourceMap = {\"version\":3,\"sources\":[\"/home/runner/work/workshop/workshop/src/raymarch/ed.frag\",\"/home/runner/work/workshop/workshop/src/common/banded.glsl\",\"/home/runner/work/workshop/workshop/src/common/between.glsl\",\"/home/runner/work/workshop/workshop/src/common/max3.glsl\",\"/home/runner/work/workshop/workshop/src/common/constants.glsl\",\"/home/runner/work/workshop/workshop/src/common/hexFns.glsl\",\"/home/runner/work/workshop/workshop/src/common/matrices.glsl\",\"/home/runner/work/workshop/workshop/src/common/perlin2DTexture.glsl\",\"/home/runner/work/workshop/workshop/src/common/unmix.glsl\",\"/home/runner/work/workshop/workshop/src/common/fromPolar.glsl\",\"/home/runner/work/workshop/workshop/src/common/toPolar.glsl\",\"/home/runner/work/workshop/workshop/src/common/polar.glsl\",\"/home/runner/work/workshop/workshop/src/common/remix.glsl\",\"/home/runner/work/workshop/workshop/src/common/transform.glsl\",\"/home/runner/work/workshop/workshop/src/common/visualize.glsl\",\"/home/runner/work/workshop/workshop/src/common/waves.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdTorus.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdCapsule.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/opElongate.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdSphere.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdCylinder.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdCone.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf2d/addChamfer.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf2d/addFillet.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdBox.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdOctahedron.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/add.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sub.glsl\"],\"names\":[],\"mappings\":\"AAAA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AfOA;;AgBhBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACPA;AACA;AACA;AACA;AACA;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;;A3BwBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA\"}\nexport { sourceMap };\n","\nexport default \"#version 300 es\\nprecision highp float;\\n\\nin vec4 ts_Vertex;\\nin vec2 ts_TexCoord;\\nout vec2 coord;\\nvoid main() {\\n  gl_Position = ts_Vertex;\\n  coord = ts_TexCoord;\\n}\\n\"\nconst sourceMap = {\"version\":3,\"sources\":[\"/home/runner/work/workshop/workshop/src/common/raymarch.vert\"],\"names\":[],\"mappings\":\"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA\"}\nexport { sourceMap };\n","\nexport default \"#version 300 es\\n\\nprecision highp float;\\n\\n// START ../common/banded.glsl\\nfloat banded(float bandCount, float t) {\\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\\n}\\nfloat banded(int bandCount, float t) {\\n  return banded(float(bandCount), t);\\n}\\n\\n// #pragma glslify: export(banded)\\n\\n\\n// END ../common/banded.glsl\\n// START ../common/between.glsl\\nbool between(float min, float max, float value) {\\n  return min <= value && value <= max;\\n}\\n\\n// #pragma glslify: export(between)\\n\\n\\n// END ../common/between.glsl\\n// START ../common/hexFns.glsl\\n// START ./max3.glsl\\nfloat max3(float a, float b, float c) {\\n  return max(a, max(b, c));\\n}\\nfloat max3(vec3 v) {\\n  return max(v.x, max(v.y, v.z));\\n}\\n\\n// #pragma glslify: export(max3)\\n\\n\\n// END ./max3.glsl\\n// START ./constants.glsl\\nconst float SQRT1_2 = 0.7071067811865476;\\nconst float SQRT1_3 = 0.57735026919;\\nconst float SQRT2 = 1.4142135623730951;\\nconst float SQRT3 = 1.732050807568877;\\n// sqrt(3)/2 = sin(60*)\\nconst float SQRT3_2 = 0.86602540378;\\nconst float GOLDEN_RATIO = 1.61803398875;\\nconst float PI = 3.141592653589793;\\nconst float TAU = 6.28318530718;\\n/**\\n * One degree in radians. Use like `sin(30 * DEG)`.\\n */\\nconst float DEGREE = 0.017453292519943295;\\n\\n// END ./constants.glsl\\n\\nvec3 hexRound(vec3 hex) {\\n  vec3 r = floor(hex + 0.5);\\n  vec3 diff = abs(r - hex);\\n\\n  if (diff.x > diff.y && diff.x > diff.z) {\\n    r.x = -(r.y + r.z);\\n  } else if (diff.y > diff.z) {\\n    r.y = -(r.x + r.z);\\n  } else {\\n    r.z = -(r.x + r.y);\\n  }\\n\\n  return r;\\n}\\nvec2 hex2Ra(vec3 hex) {\\n  float y = hex.t * SQRT3_2;\\n  float x = hex.s + hex.t / 2.0;\\n  return vec2(x, y);\\n}\\n\\nfloat hexSdf(vec3 hex) {\\n  return max3(abs(hex.yzx + hex.zxy / 2.0));\\n}\\nvec3 ra2Hex(vec2 xy) {\\n  float hex_t = xy.y / SQRT3_2;\\n  float hex_s = xy.x - hex_t / 2.0;\\n  return vec3(hex_s, hex_t, -(hex_s + hex_t));\\n}\\n\\n// END ../common/hexFns.glsl\\n// START ../common/matrices.glsl\\n\\nmat2 rot2(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat2(c, s, -s, c);\\n}\\nmat3 rotX(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\\n}\\nmat3 rotY(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\\n}\\nmat3 rotZ(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\\n}\\n/**\\n * Returns a matrix that puts the camera at the eye point `ex, ey, ez` looking\\n * toward the center point `cx, cy, cz` with an up direction of `ux, uy, uz`.\\n * This emulates the OpenGL function `gluLookAt()`.\\n */\\nmat4 lookAt(vec3 eye, vec3 focus, vec3 up) {\\n  vec3 f = normalize(eye - focus);\\n  vec3 s = normalize(cross(up, f));\\n  vec3 t = normalize(cross(f, s));\\n\\n  return mat4(\\n    vec4(s.x, t.x, f.x, 0.0),\\n    vec4(s.y, t.y, f.y, 0.0),\\n    vec4(s.z, t.z, f.z, 0.0),\\n    vec4(-dot(s, eye), -dot(t, eye), -dot(f, eye), 1)\\n  );\\n}\\n\\n// the OpenGL function `glFrustum()`.\\nmat4 frustum(\\n  float left,\\n  float right,\\n  float bottom,\\n  float top,\\n  float near,\\n  float far\\n) {\\n  return mat4(\\n    vec4(2.0 * near / (right - left), 0.0, 0.0, 0.0),\\n    vec4(0, 2.0 * near / (top - bottom), 0.0, 0.0),\\n    vec4(\\n      (right + left) / (right - left),\\n      (top + bottom) / (top - bottom),\\n      -(far + near) / (far - near),\\n      -1\\n    ),\\n    vec4(0.0, 0.0, -2.0 * far * near / (far - near), 0.0)\\n  );\\n}\\n\\nmat4 perspective(float fovDegrees, float aspect, float near, float far) {\\n  float y = tan(fovDegrees * DEGREE / 2.0) * near;\\n  float x = y * aspect;\\n  return frustum(-x, x, -y, y, near, far);\\n}\\nmat4 ortho(\\n  float left,\\n  float right,\\n  float bottom,\\n  float top,\\n  float near,\\n  float far\\n) {\\n  return mat4(\\n    vec4(2.0 / (right - left), 0.0, 0.0, 0.0),\\n    vec4(0.0, 2.0 / (top - bottom), 0.0, 0.0),\\n    vec4(0.0, 0.0, -2.0 / (far - near), 0.0),\\n    vec4(\\n      -(right + left) / (right - left),\\n      -(top + bottom) / (top - bottom),\\n      -(far + near) / (far - near),\\n      1.0\\n    )\\n  );\\n}\\n\\n// END ../common/matrices.glsl\\n// START ../common/perlin2DTexture.glsl\\nuniform sampler2D gradients;\\n/* Create random direction vector\\n */\\nvec2 randomGradient(vec2 i) {\\n  // Random float. No precomputed gradients mean this works for any number of grid coordinates\\n  float random =\\n    2920.0 *\\n    sin(float(i.x) * 2.1942 + float(i.y) * 1.71324 + 8.912) *\\n    cos(float(i.x) * 2.3157 * float(i.y) * 2.17832 + 9.758);\\n  //    random = (i.x + 1667.) * (i.x + 2083.) * (i.y + 2659.) * (i.y * 50.77 + .3769);\\n  //    random = sin(SQRT2 * i.x) + cos(GOLDEN_RATIO * i.y) + tan((i.x + i.y) * SQRT3);\\n  return vec2(cos(random), sin(random));\\n}\\nfloat dotGridGradient(vec2 cell, vec2 pos) {\\n  vec2 d = cell - pos;\\n\\n  //  vec2 gradient = texelFetch(gradients, ivec2(cell), 0).xy;\\n  vec2 gradient = randomGradient(vec2(cell));\\n\\n  return dot(gradient, d);\\n}\\n\\nfloat mixx(float a, float b, float t) {\\n  return mix(a, b, smoothstep(0.0, 1.0, t));\\n  //    return mix(a, b, t);\\n}\\n\\n// resulting range is [-0.68, 0.68]. Use unmix to normalize if necessary.\\nfloat perlin2D(vec2 xy) {\\n  float x0 = floor(xy.x);\\n  float x1 = x0 + 1.0;\\n  float y0 = floor(xy.y);\\n  float y1 = y0 + 1.0;\\n\\n  // Interpolate between grid point gradients\\n  float n00 = dotGridGradient(vec2(x0, y0), xy);\\n  float n10 = dotGridGradient(vec2(x1, y0), xy);\\n  float ny0 = mixx(n00, n10, xy.x - x0);\\n\\n  float n01 = dotGridGradient(vec2(x0, y1), xy);\\n  float n11 = dotGridGradient(vec2(x1, y1), xy);\\n  float ny1 = mixx(n01, n11, xy.x - x0);\\n\\n  return mixx(ny0, ny1, xy.y - y0);\\n}\\n\\n// #pragma glslify: export(perlin2D)\\n\\n\\n// END ../common/perlin2DTexture.glsl\\n// START ../common/polar.glsl\\n// START ../common/fromPolar.glsl\\n// START ./unmix.glsl\\nfloat unmix(float a, float b, float value) {\\n  return (value - a) / (b - a);\\n}\\n\\n// #pragma glslify: export(unmix)\\n\\n\\n// END ./unmix.glsl\\n\\nvec3 fromPolar(float radius, float phi, float z) {\\n  return vec3(radius * cos(phi), radius * sin(phi), z);\\n}\\n\\nvec2 fromPolar(float radius, float phi) {\\n  return vec2(radius * cos(phi), radius * sin(phi));\\n}\\n\\nvec2 fromPolar(vec2 polar) {\\n  return fromPolar(polar.x, polar.y);\\n}\\n\\n// #pragma glslify: export(fromPolar)\\n\\n\\n// END ../common/fromPolar.glsl\\n// START ../common/toPolar.glsl\\n\\nvec2 toPolar(vec2 xy) {\\n  return vec2(length(xy), atan(xy.y, xy.x));\\n}\\n\\nmat2 toPolarDerivate(vec2 xy) {\\n  return mat2(xy.x * xy.x, xy.y * xy.y, -xy.y, xy.x) / dot(xy, xy);\\n}\\n\\n// #pragma glslify: export(toPolar)\\n\\n\\n// END ../common/toPolar.glsl\\n\\n// END ../common/polar.glsl\\n// START ../common/remix.glsl\\n\\nfloat remix(float fromA, float fromB, float toA, float toB, float value) {\\n  return mix(toA, toB, unmix(fromA, fromB, value));\\n}\\n\\nvec4 remix(float fromA, float fromB, vec4 toA, vec4 toB, float value) {\\n  return mix(toA, toB, unmix(fromA, fromB, value));\\n}\\n\\n// #pragma glslify: export(remix)\\n\\n\\n// END ../common/remix.glsl\\n// START ../common/transform.glsl\\nvec3 transform(mat4 pm, vec3 p) {\\n  vec4 pStar = pm * vec4(p, 1);\\n  return pStar.xyz / pStar.w;\\n}\\n\\nvec2 transform(mat4 pm, vec2 p) {\\n  vec4 pStar = pm * vec4(p, 0, 1);\\n  return pStar.xy / pStar.w;\\n}\\n\\n// END ../common/transform.glsl\\n// START ../common/visualize.glsl\\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\\n  float isLow = float(t < 0.0);\\n  float isHigh = float(t > 1.0);\\n  float isMid = 1.0 - isLow - isHigh;\\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\\n}\\n\\nvec4 visualize(float t) {\\n  const vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\\n  const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\\n  return visualize(BLUE, RED, t);\\n}\\n\\n// #pragma glslify: export(visualize)\\n\\n\\n// END ../common/visualize.glsl\\n// START ../common/waves.glsl\\nfloat waves(vec4 color, vec2 position, vec2 direction, float highResTimeStamp) {\\n  return sin(\\n    dot(position, direction / pow(length(direction), 2.0)) +\\n      float(highResTimeStamp) / 200.0\\n  );\\n}\\n\\n// #pragma glslify: export(waves)\\n\\n\\n// END ../common/waves.glsl\\n\\n// START ../common/sdf3d/add.glsl\\nfloat add(float a, float b) {\\n  return min(a, b);\\n}\\n\\n// #pragma glslify: export(add)\\n\\n\\n// END ../common/sdf3d/add.glsl\\n// START ../common/sdf2d/addChamfer.glsl\\n\\nfloat addChamfer(float d, float a, float b) {\\n  // exact variant, but abs is larger when a and b aren't perpendicular\\n  // which is worse than underestimating, which is what the simple version does.\\n  //  vec2 p = vec2(a, b);\\n  //  if (p.x < d && p.y < d) {\\n  //    p = rot2(0.25 * PI) * p;\\n  //    p.y = abs(p.y);\\n  //    p.y -= min(p.y, d * SQRT1_2);\\n  //    p.x -= d * SQRT1_2;\\n  //    //    p -= vec2(SQRT1_2) * clamp(dot(p, vec2(SQRT1_2)), 0.0, d);\\n  //    float fillet = -length(p);\\n  //    return -sign(p.x) * fillet;\\n  //  } else {\\n  //  }\\n  float tillet = (a + b - d) * SQRT1_2;\\n  return min(tillet, min(a, b));\\n}\\n\\n// #pragma glslify: export(addChamfer)\\n\\n\\n// END ../common/sdf2d/addChamfer.glsl\\n// START ../common/sdf2d/addFillet.glsl\\nfloat addFillet(float r, float a, float b) {\\n  if (a < r && b < r) {\\n    return r - distance(vec2(a, b), vec2(r));\\n  } else {\\n    return min(a, b);\\n  }\\n}\\n\\n// #pragma glslify: export(addFillet)\\n\\n\\n// END ../common/sdf2d/addFillet.glsl\\n// START ../common/sdf3d/opElongate.glsl\\nvec3 opElongate(vec3 h, vec3 p) {\\n  return p - clamp(p, -h, h);\\n}\\n// #pragma glslify: export(opElongate)\\n\\n// END ../common/sdf3d/opElongate.glsl\\n// START ../common/sdf3d/opRepLim.glsl\\nvec3 opRepLim(vec3 p, vec3 cellSize, vec3 limit) {\\n  return p - cellSize * clamp(round(p / cellSize), vec3(0.0), limit);\\n}\\nvec2 opRepLim(vec2 p, vec2 cellSize, vec2 limit) {\\n  return p - cellSize * clamp(round(p / cellSize), vec2(0.0), limit);\\n}\\nfloat opRepLim(float p, float cellSize, float limit) {\\n  return p - cellSize * clamp(round(p / cellSize), 0.0, limit);\\n}\\n\\n// #pragma glslify: export(opRepLim)\\n\\n\\n// END ../common/sdf3d/opRepLim.glsl\\n// START ../common/sdf3d/sdBox.glsl\\n\\nfloat sdBox(vec3 r, vec3 p) {\\n  vec3 q = abs(p) - r;\\n  return length(max(q, 0.0)) + min(max3(q), 0.0);\\n}\\n\\nfloat sdBox(vec3 r, float r2, vec3 p) {\\n  return sdBox(r - r2, p) - r2;\\n}\\n\\n// #pragma glslify: export(sdBox)\\n\\n\\n// END ../common/sdf3d/sdBox.glsl\\n// START ../common/sdf3d/sdCone.glsl\\n\\n/**\\n * Signed distance function (SDF) of a cone. The tip of the cone is at the\\n * origin and points towards +Z. q is a point on the rim of the cone.\\n */\\nfloat sdCone(vec2 c, float h, vec3 p) {\\n  vec2 q = h * vec2(c.x / c.y, -1.0);\\n  vec2 w = vec2(length(p.xz), p.y);\\n  vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);\\n  vec2 b = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0);\\n  float k = sign(q.y);\\n  float d = min(dot(a, a), dot(b, b));\\n  float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));\\n  return sqrt(d) * sign(s);\\n}\\n// #pragma glslify: export(sdBox)\\n\\nfloat sdConeB(vec2 c, float h, vec3 p) {\\n  float q = length(p.xz);\\n  return max(dot(c.xy, vec2(q, p.y)), -h - p.y);\\n}\\n\\n// END ../common/sdf3d/sdCone.glsl\\n// START ../common/sdf3d/sdCylinder.glsl\\nfloat sdCylinder(float radius, float z, vec3 p) {\\n  vec2 d = vec2(length(p.xy), abs(p.z)) - vec2(radius, z);\\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\\n}\\n\\n// #pragma glslify: export(sdCylinder)\\n\\n\\n// END ../common/sdf3d/sdCylinder.glsl\\n// START ../common/sdf3d/sdTorus.glsl\\nfloat sdTorus(float r0, float r1, vec3 p) {\\n  vec3 closestCenter = vec3(normalize(p.xy) * r0, 0.0);\\n  return distance(closestCenter, p) - r1;\\n}\\n\\n// #pragma glslify: export(sdTorus)\\n\\n\\n// END ../common/sdf3d/sdTorus.glsl\\n// START ../common/sdf3d/sdIcosahedron.glsl\\n\\n// signed distance function for icosahedron\\n// cf. https://en.wikipedia.org/wiki/Regular_icosahedron\\n// s: edge length\\n// p: point to evaluate function for\\nfloat sdIcosahedron(float s, vec3 p) {\\n  // NN = 1/GOLDEN_RATIO = GOLDEN_RATIO - 1\\n  const float K = GOLDEN_RATIO * 0.5;\\n  // the three vertices of the icosahedron triangle which\\n  // is fully inside the +++ octant. (edge length = 1)\\n  const vec3 a = vec3(0.5, K, 0.0);\\n  const vec3 b = vec3(0.0, 0.5, K);\\n  const vec3 c = vec3(K, 0.0, 0.5);\\n  const vec3 ab1 = b - a; // values chosen so edge length is 1\\n  const vec3 n1 = normalize(cross(a, b));\\n  const vec3 n2 = normalize(cross(b, c));\\n  const vec3 n3 = normalize(cross(c, a));\\n  const vec3 xyz1 = normalize(vec3(1.0));\\n  // for edge-length 1\\n  const float INSCRIBED_SPHERE_RADIUS = 0.7557613141;\\n\\n  // we use a rotation where the icosahedron is symmetric\\n  // in all three coordinate planes, and reduce the problem\\n  // to the +++ octant\\n  p = abs(p);\\n\\n  // there is one complete triangle in the +++ octant\\n  // mirror on planes which go through origin and the\\n  // complete triangles sides.\\n  if (dot(p, n1) < 0.0) {\\n    p += -2.0 * dot(p, n1) * n1;\\n  }\\n  if (dot(p, n2) < 0.0) {\\n    p += -2.0 * dot(p, n2) * n2;\\n  }\\n  if (dot(p, n3) < 0.0) {\\n    p += -2.0 * dot(p, n3) * n3;\\n  }\\n\\n  // rotate space around (1,1,1) vector so that all sides of the triangle\\n  // end up mapped on the ab side.\\n  vec3 dirs = vec3(-dot(n1, p), -dot(n2, p), -dot(n3, p));\\n  if (dirs.y > dirs.x && dirs.y > dirs.z) {\\n    p = p.yzx;\\n  } else if (dirs.z > dirs.x && dirs.z > dirs.y) {\\n    p = p.zxy;\\n  }\\n\\n  // check if the point is directly (perpendicular) above the triangle.\\n  // as we have rotated the space, we only need to check if it is\\n  // inside one edge.\\n  vec3 midAB = (a + b) / 2.0;\\n  vec3 pn = normalize(c - midAB);\\n  float w = dot(midAB, pn);\\n  if (dot(p, pn) > w * s) {\\n    // if not, return the distance to the plane the triangle is in\\n    return dot(xyz1, p) - INSCRIBED_SPHERE_RADIUS * s;\\n  }\\n\\n  // project the point onto segment ab, and return the distance to it\\n  float d3 = dot(ab1, p);\\n  d3 = clamp(d3, -0.5 * s, 0.5 * s);\\n  vec3 closestp = midAB * s + d3 * ab1;\\n  return distance(closestp, p);\\n}\\n// #pragma glslify: export(sdIcosahedron)\\n\\n// END ../common/sdf3d/sdIcosahedron.glsl\\n// START ../common/sdf3d/sdOctahedron.glsl\\nfloat sdOctahedron(float s, vec3 p) {\\n  p = abs(p);\\n  float m = p.x + p.y + p.z - s;\\n  vec3 q;\\n  if (3.0 * p.x < m) q = p.xyz;\\n  else if (3.0 * p.y < m) q = p.yzx;\\n  else if (3.0 * p.z < m) q = p.zxy;\\n  else return m * 0.57735027;\\n\\n  float k = clamp(0.5 * (q.z - q.y + s), 0.0, s);\\n  return length(vec3(q.x, q.y - s + k, q.z - k));\\n}\\n// #pragma glslify: export(sdOctahedron)\\n\\nfloat sdOctahedron(vec3 p, float s) {\\n  p = abs(p);\\n\\n  float m = p.x + p.y + p.z - s;\\n  //find point on octohedron surf nearest to p\\n  vec3 projPoint = p - vec3(0.333333 * m); //project onto surface plane\\n  //now push projected point, if outside triangle edge, perpendicular to edge, to edge\\n  vec3 toMove = min(projPoint, 0.0); //if projpoint.x<0 move along (1.0,-0.5,-0.5) , etc\\n  float toMoveSum = dot(toMove, vec3(1.0)); //which is basically along (1.5,0,0) then vec3(-0.5)\\n\\n  vec3 movedPoint = projPoint + toMove * vec3(-1.5) + toMoveSum * vec3(0.5); //better to multiply toMove by a matrix (1s diagonal, 0.5 other)?\\n\\n  movedPoint = max(movedPoint, 0.0); //cap x,y,z to 0 then\\n  movedPoint *= s / dot(movedPoint, vec3(1.0)); //scale about 0,0,0\\n\\n  return length(p - movedPoint);\\n}\\n\\n// END ../common/sdf3d/sdOctahedron.glsl\\n// START ../common/sdf3d/sdPyramid.glsl\\n// Pyramid with tip at (0,0,0), up = z\\n// c is the bottom corner. c.xy should be positive, c.z negative.\\nvec2 sdPyramid(vec3 c, vec3 p) {\\n  // pyramid is symmetric in XZ and YZ planes\\n  p.xy = abs(p.xy);\\n  bool flip = p.y * c.x > p.x * c.y; // p.y/p.x > c.y/c.x\\n  c.xy = flip ? c.yx : c.xy;\\n  p.xy = flip ? p.yx : p.xy;\\n  vec3 cc = c / dot(c, c);\\n  vec3 qx1 = normalize(vec3(-c.z, 0.0, c.x));\\n  vec3 pOnQx = p - qx1 * dot(p, qx1);\\n  float dx = dot(p, qx1);\\n  float maxY = c.y * (pOnQx.x / c.x);\\n  if (p.z <= c.z || pOnQx.z <= c.z) {\\n    if (p.x <= c.x) {\\n      // vertically underneath pyramid\\n      return vec2(-p.z + c.z, 2.0);\\n    } else {\\n      float aa = distance(p, vec3(c.x, min(c.y, p.y), c.z));\\n      return vec2(aa, 3.0);\\n    }\\n  } else if (pOnQx.y > maxY || pOnQx.z > 0.0) {\\n    float xx = dot(cc, p);\\n    float aa = length(p - clamp(xx, 0.0, 1.0) * c);\\n\\n    return vec2(aa, 1.0);\\n  } else {\\n    // need max for negativ values above base\\n    return vec2(max(dx, -p.z + c.z), 0.0);\\n  }\\n}\\n\\n// #pragma glslify: export(sdPyramid)\\n\\n\\n// END ../common/sdf3d/sdPyramid.glsl\\n// START ../common/sdf3d/sdSphere.glsl\\nfloat sdSphere(float radius, vec3 p) {\\n  return length(p) - radius;\\n}\\n\\n// #pragma glslify: export(sdSphere)\\n\\n\\n// END ../common/sdf3d/sdSphere.glsl\\n// START ../common/sdf3d/sub.glsl\\nfloat sub(float from, float what) {\\n  return max(from, -what);\\n}\\n\\n// #pragma glslify: export(sub)\\n\\n\\n// END ../common/sdf3d/sub.glsl\\n\\nuniform sampler2D texture;\\nuniform float secs;\\nuniform mat4 lll;\\nuniform mat4 llli;\\nuniform vec4 colorPrimary;\\nuniform vec4 colorSecondary;\\nuniform vec4 colorBackground;\\nuniform float a;\\nuniform float b;\\nuniform float c;\\nuniform float d;\\nuniform float highResTimeStamp;\\nuniform int bandCount;\\nuniform vec3 campos;\\nin float n;\\nin vec2 coord;\\nout vec4 fragColor;\\n\\n\\nconst vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\\nconst vec4 yellow = vec4(1.0, 1.0, 0.0, 1.0);\\nconst vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\\nconst vec4 blue = vec4(0.0, 0.0, 1.0, 1.0);\\nconst vec4 purple = vec4(0.5, 0.0, 0.5, 1.0);\\nconst vec4 red = vec4(1.0, 0.0, 0.0, 1.0);\\n\\nstruct RMHit {\\n  float distance;\\n  vec4 color;\\n};\\nRMHit mixa(RMHit a, RMHit b, float t) {\\n  return RMHit(mix(a.distance, b.distance, t), mix(a.color, b.color, t));\\n}\\nfloat skybox(vec3 p) {\\n  return 32.0 - max3(abs(p));\\n}\\n\\nfloat perlinSphere(float radius, vec3 p) {\\n  vec3 cp = normalize(p);\\n  float alpha = atan(cp.y, cp.x);\\n  float beta = asin(cp.z);\\n  return length(p) -\\n  radius +\\n  0.1 *\\n    perlin2D(vec2(0.0 / 100.0, 0.0) + (vec2(5.0) + vec2(alpha, beta)) * 8.0);\\n}\\n\\nfloat cylCircle(vec3 p) {\\n  float d = 10e9;\\n  for (int i = 0; i < 10; i++) {\\n    d = min(\\n      d,\\n      sdCylinder(0.2, 2.0, p + fromPolar(3.0, TAU * float(i) / 10.0, 1.0))\\n    );\\n  }\\n\\n  return d;\\n}\\n\\nfloat rblock(float r, vec3 p) {\\n  return sdBox(vec3(r), p);\\n}\\n\\nRMHit add(RMHit a, RMHit b) {\\n  //    return a.distance < b.distance\\n  //        ? RMHit(a.distance, a.color)\\n  //        : RMHit(b.distance, b.color);\\n  return mixa(a, b, float(b.distance < a.distance));\\n}\\n\\nfloat wtf(vec3 p) {\\n  vec3 center = p - mod(p, 3.0) + vec3(1.5);\\n  return rblock(0.4 + 0.3 * sin(secs + center.x), p - center);\\n}\\n\\nRMHit addFillet(float r, RMHit a, RMHit b) {\\n  if (a.distance < r && b.distance < r) {\\n    return RMHit(\\n      r - distance(vec2(a.distance, b.distance), vec2(r)),\\n      mix(a.color, b.color, (a.distance - b.distance) / r * 0.5 + 0.5)\\n    );\\n  } else {\\n    return add(a, b);\\n  }\\n}\\n\\nRMHit addFillet(float r, RMHit a, RMHit b, vec4 tilletColor) {\\n  if (a.distance < r && b.distance < r) {\\n    return RMHit(\\n      r - distance(vec2(a.distance, b.distance), vec2(r)),\\n      tilletColor\\n    );\\n  } else {\\n    return add(a, b);\\n  }\\n}\\nRMHit addFillet2(float r, RMHit a, RMHit b) {\\n  float h = smoothstep(-r, r, a.distance - b.distance);\\n  return RMHit(\\n    mix(a.distance, b.distance, h) - r * h * (1.0 - h),\\n    mix(a.color, b.color, h)\\n  );\\n}\\n\\nRMHit neg(RMHit a) {\\n  return RMHit(-a.distance, a.color);\\n}\\nRMHit sub(RMHit from, RMHit what) {\\n  RMHit whatNeg = neg(what);\\n  return mixa(from, whatNeg, float(whatNeg.distance > from.distance));\\n}\\n\\nvec3 modv(vec3 v, vec3 dir1, float y) {\\n  float t = dot(v, dir1);\\n  return v - floor(t / y) * y * dir1;\\n}\\nvec3 modRotZ(vec3 p, float count) {\\n  vec2 polarXY = toPolar(p.xy);\\n  return fromPolar(polarXY.x, mod(polarXY.y, TAU / count), p.z);\\n}\\n\\nfloat sin01(float x) {\\n  return 0.5 + 0.5 * sin(x);\\n}\\nfloat cos01(float x) {\\n  return 0.5 + 0.5 * cos(x);\\n}\\n\\nfloat betterBox(vec3 r, vec3 p) {\\n  vec3 q = abs(p) - r;\\n  return length(max(q, 0.0)) + min(max3(q), 0.0);\\n  p = abs(p);\\n  return max3(p - r);\\n}\\n\\nfloat roundedBlock(vec3 r, float cr, vec3 p) {\\n  return betterBox(r - vec3(cr), p) - cr;\\n}\\n\\nfloat sdCapsule(vec3 a, vec3 b, float r, vec3 p) {\\n  vec3 pa = p - a;\\n  vec3 ba = b - a;\\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\\n  return length(pa - ba * h) - r;\\n}\\nfloat sdEllipsoidB(vec3 r, vec3 p) {\\n  float k0 = length(p / r);\\n  float k1 = length(p / (r * r));\\n  return k0 * (k0 - 1.0) / k1;\\n}\\nfloat sdOctahedronB(float s, vec3 p) {\\n  p = abs(p);\\n  return (p.x + p.y + p.z - s) * 0.57735027;\\n}\\nfloat donutc(float r0, float r1, vec3 p) {\\n  vec3 closestCenter = vec3(normalize(p.xy) * r0, 0.0);\\n  return distance(closestCenter, p) - r1;\\n}\\n\\nfloat sdCappedCylinder(float h, float r, vec3 p) {\\n  vec2 d = vec2(length(p.xy), abs(p.z)) - vec2(r, h);\\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\\n}\\nfloat smoothmin(float r, float a, float b) {\\n  float h = smoothstep(-r, r, a - b);\\n  return mix(a, b, h) - r * h * (1.0 - h);\\n}\\nfloat queen(vec3 p) {\\n  float lxy = length(p.xy);\\n  float d;\\n  d = lxy - 1.1;\\n  d += 0.16 * p.z;\\n  d -= -c * (1.0 - pow(sin01(b + p.z * 2.5), 1.5));\\n  d += 0.1 * normalize(p.xy).x * smoothstep(2.0, 0.5, p.z);\\n  d +=\\n    0.02 * sin(15.0 * atan(p.y, p.x) - p.z * 5.0) * smoothstep(2.0, 0.5, p.z);\\n  //    float d = sdCappedCylinder(a, b, p);\\n  d = max(d, -p.z);\\n  d = max(d, p.z - 4.0);\\n\\n  float head = sdSphere(0.55, p - vec3(0.0, 0.0, 4.4));\\n  d = smoothmin(0.15, d, head);\\n  float crown = sdCone(\\n    fromPolar(vec2(1.0, 1.15)),\\n    1.0,\\n    -(p - vec3(0.0, 0.0, 4.5)).yzx\\n  );\\n  d = min(d, crown);\\n  d *= 0.5;\\n  return d;\\n}\\n\\nvec2 project(vec2 a, vec2 onto1) {\\n  return onto1 * (dot(a, onto1) / dot(onto1, onto1));\\n}\\n\\nvec3 reject(vec3 a, vec3 b1) {\\n  return a - b1 * dot(a, b1);\\n}\\n\\nRMHit sdf(vec3 p) {\\n  const vec4 red = vec4(0.2, 0.0, 0.0, 1.0);\\n  //  RMHit d = RMHit(block(vec3(-1.0, -1.0, -1.0), vec3(1.0, 1.0, 1.0), p), black);\\n  //    RMHit d = RMHit(sphere(2., p), black);\\n  //    RMHit d = RMHit(betterBox(vec3(1.), p), black);\\n  //    RMHit d = RMHit(roundedBlock(vec3(1.), 0.1, p), black);\\n  //    RMHit d = RMHit(donut(2., 0.5, p), black);\\n  //    RMHit d = RMHit(sdCapsule(vec3(-a,-a,0.), vec3(a,a,0.), b, p), black);\\n  //    RMHit d = RMHit(sdEllipsoidB(vec3(-a,-b,1.), p), black);\\n  //    RMHit d = RMHit(sdOctahedron(1., p)-a, red) ;\\n  //    RMHit d = RMHit(queen(p), black) ;\\n  //    RMHit d = RMHit(lego(p), black) ;\\n  //- vec3(0.0, 0.0, 1.0)\\n  vec3 h = vec3(0.5, 0.0, 0.0);\\n  vec3 q = abs(p) - h;\\n  //    vec2 pyr = sdPyramid(\\n  //        vec3(2.0, 2.0, -2.0),\\n  //        opElongate(h,\\n  //            rotZ(highResTimeStamp/1000.) *\\n  //                rotX(c) *\\n  //                opRepLim(p - vec3(-8., -8., 2.), vec3(8.), vec3(2., 2., 0.))));\\n  vec3 p2 = rotX(highResTimeStamp * 0.0) * p;\\n  vec2 xx = vec2(sdIcosahedron(d, p2) - c, 1.0);\\n  vec4 cc = red;\\n  cc.xyz = cc.xyz * xx.y * 0.1;\\n  RMHit d = RMHit(xx.x, cc);\\n  //    RMHit d = RMHit(sdCone(fromPolar(vec2(1., a)), b, p.yzx - vec3(0.,2., 0.)), black);\\n  //    d.distance = abs(d.distance) - 0.4;\\n  //    d.distance = abs(d.distance) - 0.1;\\n  //    d.distance = abs(d.distance) - 0.02;\\n  float s = length(p - vec3(1.0, 1.0, 0.0)) - 1.0;\\n  //    d.distance = s;\\n  //    d.distance = max(d.distance, -s);\\n\\n  vec3 color = 0.1 * sin(abs(vec3(0.0, PI, 0.0) + vec3(d.distance * PI * 2.0)));\\n  //    color.z = .1*xx.y;\\n  RMHit base = RMHit(sdBox(vec3(10.0, 10.0, 0.0), p), vec4(color, 1.0));\\n\\n  //    d = base;\\n  d = add(base, d);\\n  if (b > 1.0) {\\n    d = base;\\n  }\\n  //    d.distance *=0.5;\\n  return d;\\n}\\nfloat sdff(vec3 p) {\\n  return sdf(p).distance;\\n}\\nfloat ambientOcclusion(vec3 pWC, vec3 n1WC) {\\n  float k = 1.0;\\n  float distance = sdff(pWC + n1WC * k);\\n  return clamp(distance / k, 0.0, 1.0);\\n}\\n\\nstruct RMResult {\\n  float distance;\\n  vec3 pos;\\n  vec4 color;\\n};\\nRMResult raymarching2(vec3 start, vec3 dir1) {\\n  vec3 pos = start;\\n  RMHit hit;\\n  for (int i = 0; i < 200; i++) {\\n    hit = sdf(pos);\\n    if (hit.distance < 0.0001 * hit.distance) break;\\n    pos = pos + dir1 * hit.distance;\\n  }\\n  return RMResult(hit.distance, pos, hit.color);\\n}\\n\\nfloat softshadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {\\n  float res = 1.0;\\n  float t = 0.1;\\n  for (int i = 0; i < 1000 && t < maxt; i++) {\\n    float h = sdff(ro + rd * t);\\n    if (h < 0.001) return 0.0;\\n    res = min(res, k * h / t);\\n    t += h;\\n  }\\n  return res;\\n}\\n\\nconst float eps = 1e-4;\\nvec3 sdfNormal1(vec3 p, float d) {\\n  return normalize(\\n    vec3(\\n      sdff(p + vec3(eps, 0.0, 0.0)),\\n      sdff(p + vec3(0.0, eps, 0.0)),\\n      sdff(p + vec3(0.0, 0.0, eps))\\n    ) -\\n      vec3(sdff(p))\\n  );\\n}\\n\\n//layout (depth_greater) out float gl_FragDepth;\\nvoid main() {\\n  vec3 light = normalize(vec3(-1.0, -2.0, -2));\\n\\n  vec3 a = vec3(coord, -1.0);\\n  vec3 b = vec3(coord, 1.0);\\n  vec3 aWC = transform(llli, a);\\n  vec3 bWC = transform(llli, b);\\n  vec3 lookDir1 = normalize(bWC - aWC);\\n\\n  RMResult hitWC = raymarching2(aWC, lookDir1);\\n  vec3 hitn1 = sdfNormal1(hitWC.pos, hitWC.distance);\\n  float dWC = distance(aWC, hitWC.pos);\\n  vec3 hitNDC = transform(lll, hitWC.pos);\\n  vec3 p = hitWC.pos;\\n  float inSun = softshadow(\\n    hitWC.pos + hitn1 * 0.05,\\n    -light,\\n    0.0001,\\n    300.0,\\n    8.0\\n  );\\n  //    float inSun=1.;\\n\\n  vec3 material = hitWC.color.xyz;\\n  if (dWC > 100.0) {\\n    material = vec3(0.0, 0.0, 0.0);\\n    //    } else if (p.z >= 0.001) {\\n    //        material = vec3(0.2, 0.0, 0.0);\\n    //    } else {\\n    //        vec2 c = vec2(4.0, 2.0);\\n    //        vec2 id = floor(((p.xy - c * 0.5) / c) );\\n    //        material += .15 * cos(vec3(id.x, id.y + 2., id.x + id.y + 4.));\\n  }\\n\\n  const vec3 sunlightColor = vec3(8.0, 6.0, 1.0);\\n\\n  float aOcc = ambientOcclusion(hitWC.pos, hitn1);\\n\\n  vec3 reflectionDirection = reflect(light, hitn1);\\n\\n  vec3 color = vec3(0.0);\\n  color += material * aOcc;\\n  color += inSun * sunlightColor * material * max(0.0, dot(-light, hitn1));\\n  //    color = (hitn1);\\n\\n  vec3 camPos = aWC;\\n\\n  vec3 eyeDirection = -lookDir1;\\n  float uMaterialShininess = 256.0;\\n  float specularLightWeighting = pow(\\n    max(dot(reflectionDirection, eyeDirection), 0.0),\\n    uMaterialShininess\\n  );\\n  color += specularLightWeighting;\\n  //    float lightIntensity = 0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.);\\n  //    float lightIntensity =\\n  //        0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.) + 0.3*specularLightWeighting;\\n  //    fragColor = visualize(blue, red, mix(0.5, 1.0, inSun) * lightIntensity);\\n  //    fragColor = mix(hitWC.color, colorBackground, mix(0.5, 1.0, inSun) * clamp(lightIntensity, 0., 1.));\\n  color = pow(color, vec3(1.0 / 2.2)); // gamma correction\\n  fragColor = vec4(color, 1.0);\\n}\\n\"\nconst sourceMap = {\"version\":3,\"sources\":[\"/home/runner/work/workshop/workshop/src/raymarch/sdf.frag\",\"/home/runner/work/workshop/workshop/src/common/banded.glsl\",\"/home/runner/work/workshop/workshop/src/common/between.glsl\",\"/home/runner/work/workshop/workshop/src/common/max3.glsl\",\"/home/runner/work/workshop/workshop/src/common/constants.glsl\",\"/home/runner/work/workshop/workshop/src/common/hexFns.glsl\",\"/home/runner/work/workshop/workshop/src/common/matrices.glsl\",\"/home/runner/work/workshop/workshop/src/common/perlin2DTexture.glsl\",\"/home/runner/work/workshop/workshop/src/common/unmix.glsl\",\"/home/runner/work/workshop/workshop/src/common/fromPolar.glsl\",\"/home/runner/work/workshop/workshop/src/common/toPolar.glsl\",\"/home/runner/work/workshop/workshop/src/common/polar.glsl\",\"/home/runner/work/workshop/workshop/src/common/remix.glsl\",\"/home/runner/work/workshop/workshop/src/common/transform.glsl\",\"/home/runner/work/workshop/workshop/src/common/visualize.glsl\",\"/home/runner/work/workshop/workshop/src/common/waves.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/add.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf2d/addChamfer.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf2d/addFillet.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/opElongate.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/opRepLim.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdBox.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdCone.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdCylinder.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdTorus.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdIcosahedron.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdOctahedron.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdPyramid.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdSphere.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sub.glsl\"],\"names\":[],\"mappings\":\"AAAA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AfOA;;AgBhBA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACVA;AACA;AACA;AACA;AACA;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;;A7ByBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA\"}\nexport { sourceMap };\n","\nexport default \"#version 300 es\\n\\nprecision highp float;\\n\\n// START ../common/visualize.glsl\\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\\n  float isLow = float(t < 0.0);\\n  float isHigh = float(t > 1.0);\\n  float isMid = 1.0 - isLow - isHigh;\\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\\n}\\n\\nvec4 visualize(float t) {\\n  const vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\\n  const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\\n  return visualize(BLUE, RED, t);\\n}\\n\\n// #pragma glslify: export(visualize)\\n\\n\\n// END ../common/visualize.glsl\\n// START ../common/banded.glsl\\nfloat banded(float bandCount, float t) {\\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\\n}\\nfloat banded(int bandCount, float t) {\\n  return banded(float(bandCount), t);\\n}\\n\\n// #pragma glslify: export(banded)\\n\\n\\n// END ../common/banded.glsl\\n\\nuniform vec4 color;\\n\\nout vec4 fragColor;\\n\\nvoid main() {\\n  fragColor = color;\\n}\\n\"\nconst sourceMap = {\"version\":3,\"sources\":[\"/home/runner/work/workshop/workshop/src/raymarch/singleColor.frag\",\"/home/runner/work/workshop/workshop/src/common/visualize.glsl\",\"/home/runner/work/workshop/workshop/src/common/banded.glsl\"],\"names\":[],\"mappings\":\"AAAA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AFHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA\"}\nexport { sourceMap };\n","\nexport default \"#version 300 es\\nprecision highp float;\\n\\nuniform mat4 ts_ModelViewProjectionMatrix;\\nuniform float normalOffset;\\nin vec3 ts_Normal;\\nin vec4 ts_Vertex;\\n\\nvoid main() {\\n  gl_Position =\\n    ts_ModelViewProjectionMatrix *\\n    (ts_Vertex + normalOffset * vec4(ts_Normal, 0.0));\\n}\\n\"\nconst sourceMap = {\"version\":3,\"sources\":[\"/home/runner/work/workshop/workshop/src/raymarch/singleColor.vert\"],\"names\":[],\"mappings\":\"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA\"}\nexport { sourceMap };\n"],"names":["BoundNumberField","state","prop","setStatePartial","props","variant","size","type","value","onChange","e","target","label","FPSController","__init","this","count","__init2","lastTime","performance","now","constructor","notify","window","prototype","call","tick","time","fps","Math","floor","parseHash","hash","substring","split","map","part","key","decodeURIComponent","reduce","obj","objectToHash","o","Object","entries","encodeURIComponent","join","defaultDeserialize","x","v","NaN","isNaN","defaultSerialize","useHashState","initialState","deserialize","serialize","wait","createInitialState","useCallback","mergedState","assign","document","location","history","pushState","undefined","title","setState","useState","updateHashRef","useRef","current","newState","useEffect","onHashChange","addEventListener","removeEventListener","INCH","fmtdeg","radiusFromSideWidth","sides","sideWidth","sin","sideWithFromRadius","radius","centerToSideFromSideWidth","tan","radiusFromCenterToSide","centerToSide","cos","sideWidthFromCenterToSide","RegularPolygon","startAngle","sideLength","Error","y","V3","polar","d","dTpl","i","RotStep","id","children","stepDeg","xlinkHref","transform","PAPER_SIZES","PaperSizeFromString","str","byName","find","name","a","b","PaperSizeFromDimensions","sort","lhs","rhsFn","PaperSizeToString","PAPER_SIZE_A4","strings","exps","format","Array","isArray","result","length","openInNewTab","url","newWindow","open","opener","_optionalChain","ops","lastAccessLHS","op","fn","args","FlyCameraController","lastPos","O","pressedKeys","__init3","pauseCam","lockUp","__init4","__init5","__init6","__init7","m","M4","copy","registerListeners","mouseMoveTarget","keyUpDownTarget","_3","unregister","_4","mousemove","keydown","keyup","unregisterListeners","_5","_6","speed","q","Control","w","s","likeO","translate","toLength","_7","_8","pagePos","V","pageX","pageY","delta","to","buttons","rot","rotateY","rotateX","times","_9","_10","preventDefault","getLookAt","static","inverse","transposed","scale","eye","transformVector","getTranslation","dir","Z","up","Y","negated","lookAt","posFactor","coordString","f","z","invertLookAt","unit","cam","coord","sp","posStr","lookDirStr","upStr","plus","ACTIONS","OrbitCameraController","zoomIn","zoomOut","left","right","down","udRot","dist","keys","__init8","__init9","__init10","__init11","__init12","console","log","toOrbitCameraState","atan","lengthXY","angleXY","wheel","blur","dDist","dRot","newUDRot","PI","ss","_11","_12","stopImmediatePropagation","newDist","deltaY","_13","_14","action","rotateZ","udRotStr","rotStr","distStr","X_RED","gl","Y_GREEN","Z_BLUE","HIGHLIGHT","L3X","anchor","dir1","X","L3Y","L3Z","EGizmoController","meshes","highlight","offsetGC","dragging","pos","onHover","onStartDragging","onStopDragging","vector","rotation","computeNormalsFromFlatTriangles","compile","rotateBaseVerticesTM","rotater","transformPoint","drawVector","shader","pushMatrix","vT","getPerpendicular","multMatrix","forSys","cross","draw","popMatrix","render","enable","CULL_FACE","cullFace","BACK","FRONT","uniforms","color","normalOffset","rotate","getCameraMatrix","mousedown","mouseup","offsetX","offsetY","boundingClientRect","getBoundingClientRect","width","mouseLineWC","canvas","projectionMatrix","ndc1","height","ndc2","inverseProjectionMatrix","inversed","minus","getMouseLine","info","infoClosestToLine","offsetWC","targetPos","lineClosest","gizmoInverse","lineGC","lp","measure","l","at","lineT","distanceTo","thClosest","lastHighlight","t","th","line","eq","abs","dot","isParallelToLine","distance","c","bd","bb","squared","dd","ca","divisor","thT","buildShaders","sdf","create","singleColor","raymarchSetup","makeCurrent","planeMesh","plane","startX","startY","coords","shaders","raymarchRender","modelView","colors","dynamicState","extra","llli","colorPrimary","primary","colorSecondary","secondary","colorBackground","background","highResTimeStamp","secs","gradients","lll","MatrixDisplay","onFocus","onBlur","OutlinedInput","inputComponent","toString","makeShader","desc","di","float","n","includes","vec3","input","output","makePart","gen","g","r0","r1","prevInput","by","prevOutput","subf","subinput","suboutput","what","SphereEditor","onRadiusChange","ev","TextField","inputProps","BoxEditor","newRadius","style","display","Vec3Editor","ExpandEditor","onByChange","gizmoControl","onElChange","newValue","slice","gizmoClick","take","Button","onClick","TranslateEditor","newBy","DonutEditor","OctahedronEditor","AddEditor","onTypeChange","onWhatChange","newWhat","Select","MenuItem","Ed","onItemChange","oldValue","PEd","sphere","expand","add","sub","box","donut","octahedron","canvasRef","renderProgress","setRenderProgress","gp","setGp","IDENTITY","resolution","setResolution","gpFocused","setGpFocused","setPart","setFps","dynamic","raymarchRef","model","setModel","theme","useTheme","useMemo","palette","default","main","async","URL","createObjectURL","setup","onProgress","_","createElement","step","SCISSOR_TEST","shared","donePixels","scissorWidth","min","scissorHeight","scissor","_2","Promise","resolve","reject","toBlob","blob","renderHighRes","product","perspective","fromShortString","tsgl","alpha","premultipliedAlpha","throwOnError","getParameter","MAX_SAMPLES","onFPSChange","triggerRender","onCamChange","setExtra","startShader","camController","camMatrix","eGizmoController","clearColor","clear","COLOR_BUFFER_BIT","pointSize","disable","DEPTH_TEST","BLEND","blendFunc","ONE","blendEquation","FUNC_ADD","contentEditable","focus","fpsController","updateShader","newShader","ed","teardown","animate","_diff","offsetWidth","offsetHeight","matrixMode","PROJECTION","loadMatrix","MODELVIEW","loadIdentity","setCam","raymarch","debounce","toShortString","replace","RenderButton","dim","disabled","aesthetically","padStart","Grid","container","item","xs","md","ref","cursor","tabIndex","sx","flexDirection","padding","alignItems","gap","Card","CardContent","setEditing"],"sourceRoot":""}