{"version":3,"file":"raymarch-index.js","mappings":"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","sources":["/dev/workshop/./src/common/BoundNumberField.tsx?","/dev/workshop/./src/common/FPSController.ts?","/dev/workshop/./src/common/useHashState.ts?","/dev/workshop/./src/paperBox1/PaperSize.tsx?","/dev/workshop/./src/paperBox1/common.tsx?","/dev/workshop/./src/raymarch/FlyCameraController.ts?","/dev/workshop/./src/raymarch/OrbitCameraController.ts?","/dev/workshop/./src/raymarch/EGizmoController.ts?","/dev/workshop/./src/raymarch/renderHighRes.ts?","/dev/workshop/./src/raymarch/shaders.ts?","/dev/workshop/./src/raymarch/index.tsx?","/dev/workshop/./src/raymarch/ed.frag?","/dev/workshop/./src/common/raymarch.vert?","/dev/workshop/./src/raymarch/sdf.frag?","/dev/workshop/./src/raymarch/singleColor.frag?","/dev/workshop/./src/raymarch/singleColor.vert?"],"sourcesContent":["import TextField, { } from \"@mui/material/TextField\"\nimport * as React from \"react\"\n\n\nexport function BoundNumberField({\n  state,\n  prop,\n  setStatePartial,\n  ...props\n}\n\n\n\n) {\n  return (\n    React.createElement(TextField, {\n      variant: \"outlined\",\n      size: \"small\",\n      type: \"number\",\n      value: state[prop],\n      onChange: (e) =>\n        setStatePartial({ [prop]: +e.target.value } )\n      ,\n      label: prop,\n      ...props,}\n    )\n  )\n}\n","/**\n * Helper class to count frames per second.\n */\nexport class FPSController {\n   __init() {this.count = 0}\n\n   __init2() {this.lastTime = performance.now()}\n  constructor(\n      notify,\n      window = 10,\n  ) {;this.notify = notify;this.window = window;FPSController.prototype.__init.call(this);FPSController.prototype.__init2.call(this);}\n\n  tick(time = performance.now()) {\n    const window = this.window\n    this.count = (this.count + 1) % window\n    if (this.count === 0) {\n      const fps = Math.floor((window * 1000) / (time - this.lastTime))\n      this.notify(fps)\n      this.lastTime = time\n    }\n  }\n}\n","import debounce from \"lodash/debounce\"\nimport mapValues from \"lodash/mapValues\"\nimport { useCallback, useEffect, useRef, useState } from \"react\"\nimport {\n  PAPER_SIZE_A4,\n\n  PaperSizeFromString,\n  PaperSizeToString,\n} from \"../paperBox1/PaperSize\"\n\nconst parseHash = (hash) => {\n  return !hash\n    ? {}\n    : hash\n        .substring(1)\n        .split(\"&\")\n        .map((part) => {\n          const [key, value] = part.split(\"=\")\n          return [decodeURIComponent(key), decodeURIComponent(value)]\n        })\n        .reduce((obj, [key, value]) => {\n          obj[key] = value\n          return obj\n        }, {} )\n}\nconst objectToHash = (o) => {\n  return (\n    \"#\" +\n    Object.entries(o)\n      .map(\n        ([key, value]) =>\n          encodeURIComponent(key) + \"=\" + encodeURIComponent(value),\n      )\n      .join(\"&\")\n  )\n}\n\nconst defaultDeserialize = (\n  x,\n) =>\n  mapValues(x, (v, key) => {\n    if (\"paperSize\" === key) {\n      try {\n        return PaperSizeFromString(v)\n      } catch (e) {\n        console.error(e)\n        return PAPER_SIZE_A4\n      }\n    } else if (\"true\" === v) {\n      return true\n    } else if (\"false\" === v) {\n      return false\n    } else if (\"NaN\" === v) {\n      return NaN\n    } else if (\"undefined\" === v) {\n      return undefined\n    } else if (\"null\" === v) {\n      return null\n    } else if (\"\" === v) {\n      return \"\"\n    } else if (!isNaN(+v)) {\n      return +v\n    } else {\n      return v\n    }\n  })\nconst defaultSerialize = (x) =>\n  mapValues(x, (v, key) =>\n    key === \"paperSize\" ? PaperSizeToString(v ) : \"\" + v,\n  )\n\nexport function useHashState(\n  initialState,\n  {\n    deserialize = defaultDeserialize,\n    serialize = defaultSerialize,\n    wait = 1000,\n  } = {},\n) {\n  const createInitialState = useCallback(() => {\n    const state =\n      \"function\" === typeof initialState\n        ? (initialState )()\n        : initialState\n    // hash overrides parameter\n    const mergedState = deserialize(\n      Object.assign(serialize(state), parseHash(document.location.hash)),\n    ) \n    history.pushState(\n      undefined,\n      document.title,\n      objectToHash(serialize(mergedState)),\n    )\n\n    return mergedState\n  }, [deserialize, initialState, serialize])\n  const [state, setState] = useState(createInitialState)\n  const updateHashRef = useRef()\n  if (!updateHashRef.current) {\n    updateHashRef.current = debounce(function (newState) {\n      history.pushState(\n        undefined,\n        document.title,\n        objectToHash(serialize(newState)),\n      )\n    }, wait)\n  }\n  useEffect(() => updateHashRef.current(state), [state])\n\n  useEffect(() => {\n    const onHashChange = () => {\n      setState(createInitialState())\n    }\n    window.addEventListener(\"hashchange\", onHashChange)\n    return () => {\n      window.removeEventListener(\"hashchange\", onHashChange)\n    }\n  }, [createInitialState])\n  return [state, setState]\n}\n"," function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } }import { MINUS } from \"ts3dutils\"\n\n \n// Always portrait orientation,\n\n// Always portrait orientation,\nexport const PAPER_SIZES_A = [\n  [841, 1189, \"A0\"],\n  [594, 841, \"A1\"],\n  [420, 594, \"A2\"],\n  [297, 420, \"A3\"],\n  [210, 297, \"A4\"],\n  [148, 210, \"A5\"],\n  [105, 148, \"A6\"],\n  [74, 105, \"A7\"],\n  [52, 74, \"A8\"],\n  [37, 52, \"A9\"],\n  [26, 37, \"A10\"],\n]\n\nexport function PaperSizeEquals([aw, ah], [bw, bh]) {\n  return aw === bw && bh === bw\n}\n\nexport const PAPER_SIZES_B = [\n  [1000, 1414, \"C0\"],\n  [707, 1000, \"C1\"],\n  [500, 707, \"C2\"],\n  [353, 500, \"C3\"],\n  [250, 353, \"C4\"],\n  [176, 250, \"C5\"],\n  [125, 176, \"C6\"],\n  [88, 125, \"C7\"],\n  [62, 88, \"C8\"],\n  [44, 62, \"C9\"],\n  [31, 44, \"C10\"],\n]\n\n// C size envelopes fit A size paper.\nexport const PAPER_SIZES_C = [\n  [917, 1297, \"C0\"],\n  [648, 917, \"C1\"],\n  [458, 648, \"C2\"],\n  [324, 458, \"C3\"],\n  [229, 324, \"C4\"],\n  [162, 229, \"C5\"],\n  [114, 162, \"C6\"],\n  [81, 114, \"C7\"],\n  [57, 81, \"C8\"],\n  [40, 57, \"C9\"],\n  [28, 40, \"C10\"],\n]\nexport const PAPER_SIZES = [\n  ...PAPER_SIZES_A,\n  [150, 150, \"Origami 15cm\"],\n  [100, 100, \"Origami 10cm\"],\n  [75, 75, \"Origami 7.5cm\"],\n  [215.9, 279.4, \"Letter\"],\n  [215.9, 355.6, \"Legal\"],\n]\n\nexport const ALL_PAPER_SIZES = [\n  ...PAPER_SIZES,\n  ...PAPER_SIZES_C,\n  ...PAPER_SIZES_B,\n]\n\nexport function PaperSizeFromString(str) {\n  const byName = PAPER_SIZES.find(([, , name]) => name === str)\n  if (byName) return byName\n  const [a, b] = str.split(\"x\")\n  return [+a, +b, \"Custom\"]\n}\nexport function PaperSizeFromDimensions(a, b) {\n  ;[a, b] = [a, b].sort(MINUS)\n  return _nullishCoalesce(PAPER_SIZES.find(([x, y]) => x === a && y === b), () => ( [a, b, \"Custom\"]))\n}\nexport function PaperSizeToString([a, b, name]) {\n  return name === \"Custom\" ? \"\" + a + \"x\" + b : name\n}\n\nexport const PAPER_SIZE_A4 = PAPER_SIZES_A[4]\n","import * as React from \"react\"\n\nimport { arrayRange, DEG, round10, TAU, V3 } from \"ts3dutils\"\n\nexport const INCH = 25.4\nexport const fmtdeg = (x) => \"\" + round10(x / DEG, -1) + \"Â°\"\n \n\nexport const radiusFromSideWidth = (sides, sideWidth) =>\n  sideWidth / 2 / Math.sin(TAU / sides / 2)\nexport const sideWithFromRadius = (sides, radius) =>\n  radius * 2 * Math.sin(TAU / sides / 2)\nexport const centerToSideFromSideWidth = (\n  sides,\n  sideWidth,\n) => sideWidth / 2 / Math.tan(TAU / sides / 2)\nexport const radiusFromCenterToSide = (\n  sides,\n  centerToSide,\n) => centerToSide / Math.cos(TAU / sides / 2)\nexport const sideWidthFromCenterToSide = (\n  sides,\n  centerToSide,\n) => centerToSide * 2 * Math.tan(TAU / sides / 2)\n\nexport function RegularPolygon({\n  sides,\n  radius,\n  startAngle = 0,\n  sideLength = undefined,\n  ...props\n}\n\n\n\n\n) {\n  if ((undefined !== sideLength) === (undefined !== radius)) {\n    throw new Error(\"must set either sideLength or radius\")\n  }\n  if (undefined === radius) {\n    radius = radiusFromSideWidth(sides, sideLength)\n  }\n  const { x, y } = V3.polar(radius, startAngle)\n  return (\n    React.createElement('path', {\n      d: dTpl`\n        M${x},${y}\n        ${arrayRange(0, sides).map(\n          (i) => dTpl`L${V3.polar(radius, startAngle + i * (TAU / sides))}`,\n        )}Z`,\n      ...props,}\n    )\n  )\n}\n\nexport function RotStep({\n  id,\n  children,\n  count,\n  stepDeg,\n}\n\n\n\n\n) {\n  return (\n    React.createElement(React.Fragment, null\n      , React.createElement('g', { id: id,}, children)\n      , arrayRange(0, count - 1).map((i) => (\n        React.createElement('use', {\n          key: i,\n          xlinkHref: \"#\" + id,\n          transform: `rotate(${(i + 1) * stepDeg} 0 0)`,}\n        )\n      ))\n    )\n  )\n}\n\nexport function dTpl(\n  strings,\n  ...exps\n) {\n  const format = (x) =>\n    \"number\" === typeof x\n      ? \"\" + x\n      : \"string\" === typeof x\n      ? x\n      : Array.isArray(x)\n      ? x.map(format).join(\" \")\n      : x.x + \",\" + x.y\n  let result = strings[0]\n  for (let i = 0; i < exps.length; i++) {\n    result += format(exps[i])\n    result += strings[i + 1]\n  }\n  return result\n}\n\nexport const openInNewTab = (url) => {\n  const newWindow = window.open(url, \"_blank\", \"noopener,noreferrer\")\n  if (newWindow) newWindow.opener = null\n}\n"," function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }import { DEG, M4, V, V3 } from \"ts3dutils\"\n\n/**\n * You can't use the keyboard events directly to move the camera, as they are\n * not fired often enough. Instead, we track which keys are down and tick()\n * should be called in the render loop.\n */\nexport class FlyCameraController {\n   __init() {this.lastPos = V3.O}\n  \n\n   __init2() {this.pressedKeys = {}}\n   __init3() {this.pauseCam = false}\n\n  constructor(\n     state,\n      onChange,\n      lockUp,\n  ) {;this.state = state;this.onChange = onChange;this.lockUp = lockUp;FlyCameraController.prototype.__init.call(this);FlyCameraController.prototype.__init2.call(this);FlyCameraController.prototype.__init3.call(this);FlyCameraController.prototype.__init4.call(this);FlyCameraController.prototype.__init5.call(this);FlyCameraController.prototype.__init6.call(this);FlyCameraController.prototype.__init7.call(this);}\n\n  __init4() {this.setState = (m) => {\n    m !== this.state && M4.copy(m, this.state)\n  }}\n\n  registerListeners(\n    mouseMoveTarget\n\n\n,\n    keyUpDownTarget = mouseMoveTarget,\n  ) {\n    _optionalChain([this, 'access', _3 => _3.unregister, 'optionalCall', _4 => _4()])\n    mouseMoveTarget.addEventListener(\"mousemove\", this.mousemove)\n    keyUpDownTarget.addEventListener(\"keydown\", this.keydown)\n    keyUpDownTarget.addEventListener(\"keyup\", this.keyup)\n\n    return (this.unregister = () => {\n      mouseMoveTarget.removeEventListener(\"mousemove\", this.mousemove)\n      keyUpDownTarget.removeEventListener(\"keydown\", this.keydown)\n      keyUpDownTarget.removeEventListener(\"keyup\", this.keyup)\n    })\n  }\n\n  unregisterListeners() {\n    _optionalChain([this, 'access', _5 => _5.unregister, 'optionalCall', _6 => _6()])\n  }\n\n  tick() {\n    const speed = new V3(\n      +!!this.pressedKeys.a - +!!this.pressedKeys.d,\n      +!!this.pressedKeys.q +\n        +!!this.pressedKeys.Control -\n        +!!this.pressedKeys.e -\n        +!!this.pressedKeys[\" \"],\n      +!!this.pressedKeys.w - +!!this.pressedKeys.s,\n    )\n    if (!speed.likeO()) {\n      this.state = this.state.translate(speed.toLength(0.05))\n      _optionalChain([this, 'access', _7 => _7.onChange, 'optionalCall', _8 => _8(this.state)])\n    }\n  }\n\n   __init5() {this.mousemove = (e) => {\n    const pagePos = V(e.pageX, e.pageY)\n    const delta = this.lastPos.to(pagePos)\n    if (e.buttons & 1 && !this.pauseCam) {\n      // zRot -= delta.x * 0.25 * DEG\n      const rot = M4.rotateY(delta.x * 0.25 * DEG)\n        //\n        .rotateX(delta.y * 0.25 * DEG)\n      this.state = rot.times(this.state)\n      // rot = rot.rotate(V3.O, rot.X, delta.y * 0.25 * DEG)\n      // yRot = clamp(yRot - delta.y * 0.25 * DEG, -85 * DEG, 85 * DEG)\n      _optionalChain([this, 'access', _9 => _9.onChange, 'optionalCall', _10 => _10(this.state)])\n    }\n    this.lastPos = pagePos\n  }}\n\n   __init6() {this.keydown = (e) => {\n    this.pressedKeys[e.key] = true\n    e.preventDefault()\n  }}\n   __init7() {this.keyup = (e) => {\n    this.pressedKeys[e.key] = undefined\n    e.preventDefault()\n  }}\n\n  getLookAt() {\n    return this.state\n  }\n\n  static invertLookAt(m) {\n    const inverse = m.transposed().scale(-1)\n    return {\n      eye: inverse.transformVector(m.getTranslation(), false),\n      dir: inverse.transformVector(V3.Z, false),\n      up: inverse.transformVector(V3.Y.negated(), false),\n    }\n  }\n\n  static toShortString(lookAt, posFactor = 100) {\n    const coordString = (v, f) =>\n      [v.x, v.y, v.z].map((e) => Math.floor(e * f)).join(\".\")\n    const { eye, dir, up } = FlyCameraController.invertLookAt(lookAt)\n    return (\n      coordString(eye, posFactor) +\n      \"~\" +\n      coordString(dir.unit(), 100) +\n      \"~\" +\n      coordString(up, 100)\n    )\n  }\n\n  static fromShortString(cam, posFactor = 100) {\n    const coord = (s, f) =>\n      V(s.split(\".\").map((sp) => +sp / f) )\n    const [posStr, lookDirStr, upStr] = cam.split(\"~\")\n    const eye = coord(posStr, posFactor)\n    return M4.lookAt(eye, eye.plus(coord(lookDirStr, 100)), coord(upStr, 100))\n  }\n}\n"," function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }import { clamp, M4, V, V3 } from \"ts3dutils\"\n\n \n\nconst ACTIONS = [\"zoomIn\", \"zoomOut\", \"left\", \"right\", \"up\", \"down\"] \n\n/**\n * You can't use the keyboard events directly to move the camera, as they are\n * not fired often enough. Instead, we track which keys are down and tick()\n * should be called in the render loop.\n */\nexport class OrbitCameraController {\n   __init() {this.lastPos = V3.O}\n  \n\n   __init2() {this.pressedKeys = {\n    zoomIn: false,\n    zoomOut: false,\n    left: false,\n    right: false,\n    up: false,\n    down: false,\n  }}\n   __init3() {this.pauseCam = false}\n   __init4() {this.udRot = 0.1}\n   __init5() {this.rot = 0}\n   __init6() {this.dist = 10}\n\n  constructor(\n      onChange,\n      keys = {\n      zoomIn: \"w\",\n      zoomOut: \"s\",\n      left: \"a\",\n      right: \"d\",\n      up: \" \",\n      down: \"Control\",\n    },\n  ) {;this.onChange = onChange;this.keys = keys;OrbitCameraController.prototype.__init.call(this);OrbitCameraController.prototype.__init2.call(this);OrbitCameraController.prototype.__init3.call(this);OrbitCameraController.prototype.__init4.call(this);OrbitCameraController.prototype.__init5.call(this);OrbitCameraController.prototype.__init6.call(this);OrbitCameraController.prototype.__init7.call(this);OrbitCameraController.prototype.__init8.call(this);OrbitCameraController.prototype.__init9.call(this);OrbitCameraController.prototype.__init10.call(this);OrbitCameraController.prototype.__init11.call(this);OrbitCameraController.prototype.__init12.call(this);}\n\n  __init7() {this.setState = (m) => {\n    console.log(\"setStaet\")\n    ;[this.udRot, this.rot, this.dist] =\n      OrbitCameraController.toOrbitCameraState(m)\n  }}\n\n  static toOrbitCameraState(m) {\n    if (m instanceof M4) {\n      const eye = m\n        .transposed()\n        .scale(-1)\n        .transformVector(m.getTranslation(), false)\n      return [Math.atan(eye.z / eye.lengthXY()), eye.angleXY(), eye.length()]\n    } else {\n      return m\n    }\n  }\n\n  registerListeners(\n    mouseMoveTarget\n\n\n,\n    keyUpDownTarget = mouseMoveTarget,\n  ) {\n    _optionalChain([this, 'access', _5 => _5.unregister, 'optionalCall', _6 => _6()])\n    mouseMoveTarget.addEventListener(\"mousemove\", this.mousemove)\n    mouseMoveTarget.addEventListener(\"wheel\", this.wheel)\n    keyUpDownTarget.addEventListener(\"keydown\", this.keydown)\n    keyUpDownTarget.addEventListener(\"keyup\", this.keyup)\n    keyUpDownTarget.addEventListener(\"blur\", this.keyup)\n\n    return (this.unregister = () => {\n      mouseMoveTarget.removeEventListener(\"mousemove\", this.mousemove)\n      mouseMoveTarget.removeEventListener(\"wheel\", this.wheel)\n      keyUpDownTarget.removeEventListener(\"keydown\", this.keydown)\n      keyUpDownTarget.removeEventListener(\"keyup\", this.keyup)\n      keyUpDownTarget.removeEventListener(\"keyup\", this.keyup)\n    })\n  }\n\n  __init8() {this.blur = () => {\n    // TODO\n  }}\n\n  unregisterListeners() {\n    _optionalChain([this, 'access', _7 => _7.unregister, 'optionalCall', _8 => _8()])\n  }\n\n  tick() {\n    const dDist = (+this.pressedKeys.zoomOut - +this.pressedKeys.zoomIn) * 0.1\n    const dRot = (-+this.pressedKeys.left + +this.pressedKeys.right) * 0.1\n    const newUDRot = clamp(\n      this.udRot + (+this.pressedKeys.up - +this.pressedKeys.down) * 0.1,\n      -Math.PI * 0.5,\n      Math.PI * 0.5,\n    )\n    if (dDist !== 0 || dRot !== 0 || newUDRot !== this.udRot) {\n      this.dist += dDist\n      this.rot += dRot\n      this.udRot = newUDRot\n      _optionalChain([this, 'access', _9 => _9.onChange, 'optionalCall', _10 => _10(this.ss)])\n    }\n  }\n\n   __init9() {this.mousemove = (e) => {\n    const pagePos = V(e.pageX, e.pageY)\n    const delta = this.lastPos.to(pagePos)\n    if (e.buttons & 1 && !this.pauseCam) {\n      // zRot -= delta.x * 0.25 * DEG\n      const dRot = delta.x / 100\n      const newUDRot = clamp(\n        this.udRot + delta.y / 100,\n        -Math.PI * 0.5,\n        Math.PI * 0.5,\n      )\n      if (newUDRot !== this.udRot || dRot !== 0) {\n        this.udRot = newUDRot\n        this.rot += dRot\n        _optionalChain([this, 'access', _11 => _11.onChange, 'optionalCall', _12 => _12(this.ss)])\n        e.stopImmediatePropagation()\n        e.preventDefault()\n      }\n    }\n    this.lastPos = pagePos\n  }}\n\n   __init10() {this.wheel = (e) => {\n    const newDist = clamp(this.dist + e.deltaY, 0.1, 1000)\n    if (newDist !== this.dist) {\n      this.dist = newDist\n      e.stopImmediatePropagation()\n      e.preventDefault()\n      _optionalChain([this, 'access', _13 => _13.onChange, 'optionalCall', _14 => _14(this.ss)])\n    }\n  }}\n\n  get ss() {\n    return [this.udRot, this.rot, this.dist]\n  }\n\n   __init11() {this.keydown = (e) => {\n    for (const action of ACTIONS) {\n      if (this.keys[action] === e.key) {\n        this.pressedKeys[action] = true\n        e.stopImmediatePropagation()\n        e.preventDefault()\n        return\n      }\n    }\n  }}\n\n   __init12() {this.keyup = (e) => {\n    for (const action of ACTIONS) {\n      if (this.keys[action] === e.key) {\n        this.pressedKeys[action] = false\n        e.stopImmediatePropagation()\n        e.preventDefault()\n        return\n      }\n    }\n  }}\n\n  getLookAt() {\n    return OrbitCameraController.getLookAt(this.ss)\n  }\n\n  static getLookAt([udRot, rot, dist]) {\n    return M4.rotateZ(rot)\n      .rotateY(udRot)\n      .transform(M4.lookAt(V(dist, 0, 0), V3.O, V3.Z))\n  }\n\n  static invertLookAt(m) {\n    const inverse = m.transposed().scale(-1)\n    return {\n      eye: inverse.transformVector(m.getTranslation(), false),\n      dir: inverse.transformVector(V3.Z, false),\n      up: inverse.transformVector(V3.Y.negated(), false),\n    }\n  }\n\n  static toShortString(m, posFactor = 100) {\n    const [udRot, rot, dist] = this.toOrbitCameraState(m)\n    const coordString = (v, f) => Math.floor(v * f)\n    return (\n      coordString(udRot, 100) +\n      \"~\" +\n      coordString(rot, 100) +\n      \"~\" +\n      coordString(dist, 100)\n    )\n  }\n\n  static fromShortString(cam, posFactor = 100) {\n    const coord = (s, f) => +s / f\n    const [udRotStr, rotStr, distStr] = cam.split(\"~\")\n    return [coord(udRotStr, 100), coord(rotStr, 100), coord(distStr, 100)]\n  }\n}\n"," function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }import * as chroma from \"chroma.ts\"\nimport { arrayRange, clamp, DEG, eq, eq0, M4, TAU, V, V3 } from \"ts3dutils\"\nimport { GL_COLOR_BLACK, Mesh, } from \"tsgl\"\n\nconst X_RED = chroma.color(\"red\").gl()\nconst Y_GREEN = chroma.color(\"green\").gl()\nconst Z_BLUE = chroma.color(\"blue\").gl()\nconst HIGHLIGHT = GL_COLOR_BLACK\nconst L3X = { anchor: V3.O, dir1: V3.X }\nconst L3Y = { anchor: V3.O, dir1: V3.Y }\nconst L3Z = { anchor: V3.O, dir1: V3.Z }\n\n \nexport const NONE = 0 ,\n  X = 1 ,\n  Y = 2 ,\n  Z = 3 ,\n  XROT = 4 ,\n  YROT = 5 ,\n  ZROT = 6 \n\nexport class EGizmoController {\n   __init() {this.meshes = {}}\n\n   __init2() {this.highlight = NONE}\n   __init3() {this.offsetGC = undefined}\n\n   __init4() {this.dragging = NONE}\n\n  \n\n  constructor(\n      gl,\n     pos,\n      onHover,\n      onStartDragging,\n      onStopDragging,\n      onChange,\n  ) {;this.gl = gl;this.pos = pos;this.onHover = onHover;this.onStartDragging = onStartDragging;this.onStopDragging = onStopDragging;this.onChange = onChange;EGizmoController.prototype.__init.call(this);EGizmoController.prototype.__init2.call(this);EGizmoController.prototype.__init3.call(this);EGizmoController.prototype.__init4.call(this);EGizmoController.prototype.__init5.call(this);EGizmoController.prototype.__init6.call(this);EGizmoController.prototype.__init7.call(this);\n    // this.meshes.vectorShaft = Mesh.rotation(\n    //   [V3.O, V3.Y, V3.XY],\n    //   L3X,\n    //   TAU,\n    //   8,\n    //   true,\n    // )\n    // this.meshes.vectorShaft.computeNormalsFromFlatTriangles()\n    // this.meshes.vectorShaft.compile()\n    // this.meshes.vectorHead = Mesh.rotation(\n    //   [V3.Y, V(0, 2, 0), V(2, 0, 0)],\n    //   L3X,\n    //   TAU,\n    //   8,\n    //   true,\n    // )\n    // this.meshes.vectorHead.computeNormalsFromFlatTriangles()\n    // this.meshes.vectorHead.compile()\n    this.meshes.vector = Mesh.rotation(\n      [V(0, 0.04), V(0.8, 0.04), V(0.85, 0.06), V(1, 0)],\n      L3X,\n      TAU,\n      8,\n      true,\n    )\n    this.meshes.vector.computeNormalsFromFlatTriangles()\n    this.meshes.vector.compile()\n    const rotateBaseVerticesTM = M4.rotateX(-90 * DEG).translate(V3.X)\n    this.meshes.rotater = Mesh.rotation(\n      arrayRange(0, 9).map((i) =>\n        rotateBaseVerticesTM.transformPoint(V3.polar(0.04, -(TAU * i) / 8)),\n      ),\n      { anchor: V3.O, dir1: V3.Z },\n      (9 / 8) * 90 * DEG,\n      8,\n      false,\n    )\n    this.meshes.rotater.computeNormalsFromFlatTriangles()\n    this.meshes.rotater.compile()\n  }\n\n  drawVector(vector, anchor, shader, size = 1) {\n    if (vector.likeO()) return\n\n    this.gl.pushMatrix()\n\n    const vT = vector.getPerpendicular().unit()\n    this.gl.multMatrix(\n      M4.forSys(vector.unit(), vT, vector.cross(vT).unit(), anchor),\n    )\n    shader.draw(this.meshes.vector)\n    this.gl.popMatrix()\n  }\n\n  render(shader) {\n    const gl = this.gl\n    gl.enable(gl.CULL_FACE)\n    gl.cullFace(gl.BACK)\n    gl.pushMatrix()\n    gl.multMatrix(this.pos)\n    gl.cullFace(gl.FRONT)\n\n    shader.uniforms({ color: HIGHLIGHT, normalOffset: 0.01 })\n    if (this.highlight === X || this.dragging === X)\n      this.drawVector(V3.X, V3.O, shader, 0.1)\n    if (this.highlight === Y || this.dragging === Y)\n      this.drawVector(V3.Y, V3.O, shader, 0.1)\n    if (this.highlight === Z || this.dragging === Z)\n      this.drawVector(V3.Z, V3.O, shader, 0.1)\n    gl.cullFace(gl.BACK)\n    shader.uniforms({ normalOffset: 0 })\n    this.drawVector(V3.X, V3.O, shader.uniforms({ color: X_RED }), 0.1)\n    this.drawVector(V3.Y, V3.O, shader.uniforms({ color: Y_GREEN }), 0.1)\n    this.drawVector(V3.Z, V3.O, shader.uniforms({ color: Z_BLUE }), 0.1)\n\n    shader.uniforms({ color: Z_BLUE }).draw(this.meshes.rotater)\n    gl.rotate(-90, 0, 1, 0)\n    shader.uniforms({ color: X_RED }).draw(this.meshes.rotater)\n    gl.rotate(-90, 1, 0, 0)\n    shader.uniforms({ color: Y_GREEN }).draw(this.meshes.rotater)\n    gl.popMatrix()\n  }\n\n  registerListeners(\n    mouseMoveTarget\n\n\n,\n    getCameraMatrix,\n  ) {\n    this.getCameraMatrix = getCameraMatrix\n    _optionalChain([this, 'access', _3 => _3.unregister, 'optionalCall', _4 => _4()])\n    mouseMoveTarget.addEventListener(\"mousemove\", this.mousemove)\n    mouseMoveTarget.addEventListener(\"mousedown\", this.mousedown)\n    mouseMoveTarget.addEventListener(\"mouseup\", this.mouseup)\n\n    return (this.unregister = () => {\n      mouseMoveTarget.removeEventListener(\"mousemove\", this.mousemove)\n      mouseMoveTarget.removeEventListener(\"mousedown\", this.mousedown)\n      mouseMoveTarget.removeEventListener(\"mouseup\", this.mouseup)\n    })\n  }\n\n  unregisterListeners() {\n    _optionalChain([this, 'access', _5 => _5.unregister, 'optionalCall', _6 => _6()])\n  }\n\n   __init5() {this.mousemove = (e) => {\n    const pagePos = V(e.offsetX, e.offsetY)\n\n    const boundingClientRect = (\n      e.target \n    ).getBoundingClientRect()\n    boundingClientRect.width\n    const mouseLineWC = getMouseLine(\n      pagePos,\n      boundingClientRect,\n      this.getCameraMatrix(),\n    )\n    if (this.dragging) {\n      const dir = [V3.O, V3.X, V3.Y, V3.Z][this.dragging]\n      const axis = {\n        anchor: this.pos.getTranslation(),\n        dir1: this.pos.transformVector(dir).unit(),\n      }\n      const info = infoClosestToLine(mouseLineWC, axis)\n      const offsetWC = this.pos.transformVector(this.offsetGC)\n      const targetPos = info.lineClosest.minus(offsetWC)\n      this.pos = this.pos.translate(this.pos.getTranslation().to(targetPos))\n      this.onChange(this.pos)\n    } else {\n      const gizmoInverse = this.pos.inversed()\n      const lineGC = {\n        anchor: gizmoInverse.transformPoint(mouseLineWC.anchor),\n        dir1: gizmoInverse.transformVector(mouseLineWC.dir1).unit(),\n      }\n      let lp = undefined\n\n      // eslint-disable-next-line no-inner-declarations\n      function measure(l) {\n        const info = infoClosestToLine(lineGC, l)\n        lp = at(l, clamp(info.lineT, 0, 1))\n        const realDistance = lp.distanceTo(info.thClosest)\n        return realDistance\n      }\n\n      const lastHighlight = this.highlight\n      if (measure(L3X) < 0.1) {\n        this.highlight = X\n        this.offsetGC = lp\n      } else if (measure(L3Y) < 0.1) {\n        this.highlight = Y\n        this.offsetGC = lp\n      } else if (measure(L3Z) < 0.1) {\n        this.highlight = Z\n        this.offsetGC = lp\n      } else {\n        this.highlight = NONE\n        this.offsetGC = undefined\n      }\n      if (this.highlight !== lastHighlight) {\n        _optionalChain([this, 'access', _7 => _7.onHover, 'optionalCall', _8 => _8(this.highlight)])\n      }\n    }\n  }}\n\n   __init6() {this.mousedown = (e) => {\n    if (this.highlight) {\n      this.dragging = this.highlight\n      this.onStartDragging()\n    }\n  }}\n\n   __init7() {this.mouseup = (e) => {\n    if (this.dragging) {\n      this.dragging = NONE\n      this.onStopDragging()\n    }\n  }}\n\n  \n}\n\n\n\nexport function getMouseLine(\n  pos,\n  canvas,\n  projectionMatrix,\n) {\n  const ndc1 = V(\n    (pos.x * 2) / canvas.width - 1,\n    (-pos.y * 2) / canvas.height + 1,\n    -1,\n  )\n  const ndc2 = V(\n    (pos.x * 2) / canvas.width - 1,\n    (-pos.y * 2) / canvas.height + 1,\n    1,\n  )\n  const inverseProjectionMatrix = projectionMatrix.inversed()\n  const anchor = inverseProjectionMatrix.transformPoint(ndc1)\n  const dir1 = inverseProjectionMatrix.transformPoint(ndc2).minus(anchor).unit()\n  return { anchor, dir1 }\n}\n\nfunction at(l, t) {\n  return l.anchor.plus(l.dir1.times(t))\n}\nfunction infoClosestToLine(\n  th,\n  line,\n)\n\n\n\n\n\n {\n  /*\n       line = a + s*b\n       this = c + t*d\n\n       (this - line) * b = 0\n       (this - line) * d = 0\n\n       (a + s*b - c - t*d) * b = 0\n       (a + s*b - c - t*d) * d = 0\n\n       (a - c + s*b - t*d) * b = 0\n       (a - c + s*b - t*d) * d = 0\n\n       (a - c)*b + (s*b - t*d)*b = 0\n       (a - c)*d + (s*b - t*d)*d = 0\n\n       (a - c)*b + s*(b*b) - t*(d*b) = 0\n       (a - c)*d + s*(b*d) - t*(d*d) = 0\n\n       s = (t*(d*b) - (a - c)*b) / (b*b)\n       =>\n       (a - c)*d + (t*(d*b) - (a - c)*b) / (b*b)*(b*d) - t*(d*d) = 0 | * (b*b)\n       (a - c)*d * (b*b) + (t*(d*b) - (a - c)*b)*(b*d) - t*(d*d) * (b*b) = 0\n       (a - c)*d * (b*b) + t*(d*b)*(b*d) - (a - c)*b*(b*d) - t*(d*d) * (b*b) = 0\n       t = ((a - c)*b*(b*d) - (a - c)*d * (b*b)) / ((d*b)*(b*d) - (d*d) * (b*b))\n       */\n  if (isParallelToLine(th, line)) {\n    return { t: NaN, s: NaN, distance: 10 }\n  }\n  const a = line.anchor,\n    b = line.dir1,\n    c = th.anchor,\n    d = th.dir1\n  const bd = b.dot(d),\n    bb = b.squared(),\n    dd = d.squared(),\n    ca = a.minus(c),\n    divisor = bd * bd - dd * bb\n  const thT = (ca.dot(b) * bd - ca.dot(d) * bb) / divisor\n  const lineT = (ca.dot(b) * dd - ca.dot(d) * bd) / divisor\n  return {\n    thT,\n    lineT,\n    thClosest: at(th, thT),\n    lineClosest: at(line, lineT),\n    distance: at(th, thT).distanceTo(at(line, lineT)),\n  }\n}\n\nfunction asSegmentDistanceToLine(\n  th,\n  line,\n  sStart,\n  sEnd,\n) {\n  const dirCross = th.dir1.cross(line.dir1)\n  const div = dirCross.squared()\n  if (eq0(div)) {\n    return undefined\n  } // lines parallel\n  const anchorDiff = line.anchor.minus(th.anchor)\n  // check if distance is zero (see also L3.distanceToLine)\n  if (!eq0(anchorDiff.dot(dirCross.unit()))) {\n    return undefined\n  }\n  let t = infoClosestToLine(th, line).t\n  t = clamp(t, sStart, sEnd)\n  return at(th, clamp(t, sStart, sEnd))\n}\n\nfunction isParallelToLine(th, line) {\n  // we know that 1 == this.dir1.length() == line.dir1.length(), we can check for parallelity simpler than\n  // isParallelTo()\n  return eq(1, Math.abs(th.dir1.dot(line.dir1)))\n}\n"," function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }import sleep from \"sleep-promise\"\nimport { TSGLContext } from \"tsgl\"\n\nexport async function renderHighRes(\n  [width, height],\n  setup,\n  render,\n  onProgress,\n) {\n  _optionalChain([onProgress, 'optionalCall', _ => _(0)])\n  await sleep(10)\n  const canvas = document.createElement(\"canvas\")\n  canvas.width = width\n  canvas.height = height\n\n  const step = 200\n  const gl = TSGLContext.create({ canvas })\n  gl.enable(gl.SCISSOR_TEST)\n  const shared = setup(gl)\n  let donePixels = 0\n  for (let x = 0; x < width; x += step) {\n    for (let y = 0; y < height; y += step) {\n      const scissorWidth = Math.min(step, width - x)\n      const scissorHeight = Math.min(step, height - y)\n      gl.scissor(x, y, scissorWidth, scissorHeight)\n      // console.time(\"render block\")\n      render(gl, shared)\n      // console.timeEnd(\"render block\")\n      await sleep(0)\n      donePixels += scissorWidth * scissorHeight\n      _optionalChain([onProgress, 'optionalCall', _2 => _2(donePixels / (width * height))])\n    }\n  }\n  return new Promise((resolve, reject) =>\n    canvas.toBlob((blob) => (blob ? resolve(blob) : reject(\"error\")), \"png\"),\n  )\n}\n","/* eslint-disable @typescript-eslint/no-var-requires */\nimport { Shader, } from \"tsgl\"\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function buildShaders(gl) {\n  return {\n    // temple: Shader.create(\n    //   require(\"../common/raymarch.vert\"),\n    //   require(`./demoTemple.frag`),\n    //   gl,\n    // ),\n    sdf: Shader.create(\n      require(\"../common/raymarch.vert\").default,\n      require(\"./sdf.frag\").default,\n      gl,\n    ),\n    // ed: Shader.create(\n    //   require(\"../common/raymarch.vert\"),\n    //   require(`./ed.frag`),\n    //   gl,\n    // ),\n    singleColor: Shader.create(\n      require(\"./singleColor.vert\").default,\n      require(\"./singleColor.frag\").default,\n      gl,\n    ),\n  }\n}\n"," function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }import Button from \"@mui/material/Button\"\nimport Card from \"@mui/material/Card\"\nimport CardContent from \"@mui/material/CardContent\"\nimport Grid from \"@mui/material/Grid\"\nimport MenuItem from \"@mui/material/MenuItem\"\nimport OutlinedInput from \"@mui/material/OutlinedInput\"\nimport Select, { } from \"@mui/material/Select\"\nimport { useTheme } from \"@mui/material/styles\"\nimport TextField from \"@mui/material/TextField\"\nimport aesthetically from \"aesthetically\"\nimport * as chroma from \"chroma.ts\"\nimport { debounce } from \"lodash\"\nimport * as React from \"react\"\nimport {\n\n\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\"\nimport { DEG, lerp, M4, PI, V3 } from \"ts3dutils\"\nimport { currentGL, Mesh, Shader, TSGLContext } from \"tsgl\"\n\nimport { BoundNumberField } from \"../common/BoundNumberField\"\nimport { FPSController } from \"../common/FPSController\"\nimport { useHashState } from \"../common/useHashState\"\nimport { openInNewTab } from \"../paperBox1/common\"\nimport edFragShader from \"./ed.frag\"\nimport { EGizmoController, NONE } from \"./EGizmoController\"\nimport { FlyCameraController } from \"./FlyCameraController\"\nimport {\n  OrbitCameraController,\n\n} from \"./OrbitCameraController\"\nimport { renderHighRes } from \"./renderHighRes\"\nimport { buildShaders } from \"./shaders\"\n\n/**\n * THE ART LIST\n *\n * - something isometric (chess?)\n * - something with dunes\n * - something with 3d fractals\n * - something with refraction (prism etc)\n */\n\nconst initialState = {\n  a: 0.2,\n  b: 0.2,\n  c: 0.2,\n  d: 0.2,\n  cam: \"999.999.999~-56.-58.-61~-44.-44.79\",\n}\n\n\nfunction raymarchSetup(gl) {\n  gl.makeCurrent()\n\n  const planeMesh = Mesh.plane({ startX: -1, startY: -1, width: 2, height: 2 })\n  // Mesh.plane generates tex coords [0,1] and we want [-1, 1] for rendering\n  planeMesh.coords = [\n    [-1, -1],\n    [1, -1],\n    [-1, 1],\n    [1, 1],\n  ]\n  planeMesh.compile()\n\n  return {\n    planeMesh,\n    shaders: buildShaders(gl),\n  }\n}\n\nfunction raymarchRender(\n  gl,\n  { shaders, planeMesh },\n  modelView,\n  colors,\n  dynamicState,\n  abs,\n  extra,\n) {\n  gl.makeCurrent()\n\n  const f = (abs / 1000 / 40) % 1\n  //        vec3 spherepos = fromPolar(mix(-6., 6., f), abs(mix(-10., 10.,\n  // f)) + PI / 2., 0.);\n  const campos = (f) =>\n    V3.polar(lerp(-6, 6, f), Math.abs(lerp(-10, 10, f)) + PI / 2, 0.5)\n\n  const llli = modelView.inversed()\n  shaders.sdf\n    .uniforms({\n      colorPrimary: colors.primary,\n      colorSecondary: colors.secondary,\n      colorBackground: colors.background,\n      highResTimeStamp: abs,\n      secs: abs / 1000,\n      gradients: 1,\n      extra,\n      ...dynamicState,\n      //campos,\n      lll: modelView,\n      llli,\n    })\n    .draw(planeMesh)\n}\n\nfunction raymarch(\n  gl,\n  colors,\n  dynamicState,\n  onFPSChange,\n  triggerRender,\n  onCamChange,\n  onHover,\n  setExtra,\n  startShader,\n) {\n  gl.canvas.addEventListener(\"keydown\", (e) => e.key === \"r\" && triggerRender())\n  const camController = new OrbitCameraController(onCamChange)\n  let camMatrix = M4.IDENTITY\n  const eGizmoController = new EGizmoController(\n    gl,\n    M4.rotateZ(20 * DEG).translate(5, 5, 1),\n    onHover,\n    () => (camController.pauseCam = true),\n    () => (camController.pauseCam = false),\n    setExtra,\n  )\n  eGizmoController.registerListeners(gl.canvas, () => camMatrix)\n\n  gl.clearColor(...colors.background)\n  gl.clearColor(0, 0, 0, 1)\n  gl.clear(gl.COLOR_BUFFER_BIT)\n  gl.cullFace(gl.BACK)\n\n  gl.pointSize(10)\n\n  //gl.enable(gl.CULL_FACE)\n  gl.disable(gl.CULL_FACE)\n  gl.disable(gl.DEPTH_TEST)\n\n  gl.disable(gl.BLEND)\n  gl.blendFunc(gl.ONE, gl.ONE)\n  gl.blendEquation(gl.FUNC_ADD)\n\n  gl.canvas.contentEditable = \"true\" // make canvas focusable\n  gl.canvas.focus()\n  camController.registerListeners(gl.canvas)\n\n  const fpsController = new FPSController(onFPSChange)\n\n  const shared = raymarchSetup(gl)\n  if (module.hot) {\n    module.hot.accept(\"./shaders\", () => {\n      console.clear()\n      try {\n        shared.shaders = buildShaders(currentGL())\n      } catch (e) {\n        console.error(e)\n      }\n    })\n  }\n\n  let it = 0\n\n  return {\n    updateShader(newShader) {\n      shared.shaders.ed = Shader.create(\n        // eslint-disable-next-line @typescript-eslint/no-var-requires\n        require(\"../common/raymarch.vert\").default,\n        newShader,\n      )\n    },\n    teardown: gl.animate(function (abs, _diff) {\n      gl.clear(gl.COLOR_BUFFER_BIT)\n      it++\n      // if (it % 30 !== 0) return\n      // gl.clear(gl.DEPTH_BUFFER_BIT)\n      // gl.clear(gl.COLOR_BUFFER_BIT)\n      if (it % 300 === 0) {\n        // gl.clear(gl.COLOR_BUFFER_BIT)\n      }\n      gl.makeCurrent()\n      camController.tick()\n      fpsController.tick(abs)\n\n      camMatrix = M4.product(\n        M4.perspective(\n          70,\n          gl.canvas.offsetWidth / gl.canvas.offsetHeight,\n          0.1,\n          50,\n        ),\n        camController.getLookAt(),\n      )\n\n      raymarchRender(\n        gl,\n        shared,\n        camMatrix,\n        colors,\n        dynamicState,\n        abs,\n        eGizmoController.pos.getTranslation(),\n      )\n\n      gl.matrixMode(gl.PROJECTION)\n      gl.loadMatrix(camMatrix)\n      gl.matrixMode(gl.MODELVIEW)\n      gl.loadIdentity()\n\n      eGizmoController.render(shared.shaders.singleColor)\n    }),\n    setCam: camController.setState,\n  }\n}\n\nfunction MatrixDisplay({\n  children,\n  label,\n  onFocus,\n  onBlur,\n}\n\n\n\n\n) {\n  return (\n    React.createElement(OutlinedInput, {\n      onFocus: onFocus,\n      onBlur: onBlur,\n      label: label,\n      inputComponent: \"textarea\",\n      value: children.toString(),}\n    )\n  )\n}\n\nfunction makeShader(desc) {\n  let di = 0\n\n  function float(n) {\n    const s = \"\" + n\n    return s.includes(\".\") ? s : s + \".0\"\n  }\n\n  function vec3([x, y, z]) {\n    return \"vec3(\" + float(x) + \", \" + float(y) + \", \" + float(z) + \")\"\n  }\n\n  function makePart(desc) {\n    let input\n    let output\n    let f\n\n    function gen(g) {\n      input = \"p\" + di++\n      output = \"d\" + di++\n      f = `float ${output} = ${g(input)};\\n`\n    }\n\n    for (const d of desc) {\n      if (d.type === \"sphere\") {\n        gen((input) => `sdSphere(${float(d.radius)}, ${input})`)\n      } else if (d.type === \"box\") {\n        gen((input) => `betterBox(${vec3(d.radius)}, ${input})`)\n      } else if (d.type === \"octahedron\") {\n        gen((input) => `sdOctahedron(${float(d.radius)}, ${input})`)\n      } else if (d.type === \"donut\") {\n        gen((input) => `sdTorus(${float(d.r0)}, ${float(d.r1)}, ${input})`)\n      } else if (d.type === \"translate\") {\n        const prevInput = input\n        input = \"p\" + di++\n        f = `vec3 ${prevInput} = ${input} + ${vec3(d.by)};\\n` + f\n      } else if (d.type === \"expand\") {\n        const prevOutput = output\n        output = \"d\" + di++\n        f = f + `float ${output} = ${prevOutput} - ${float(d.by)};\\n`\n      } else if (d.type === \"add\" || d.type === \"sub\") {\n        const [subf, subinput, suboutput] = makePart(d.what)\n        f =\n          f +\n          `vec3 ${subinput} = ${input};\\n` +\n          subf +\n          `${output} = ` +\n          (d.type === \"add\"\n            ? `min(${output}, ${suboutput})`\n            : `max(${output}, -${suboutput})`) +\n          `;\\n`\n      }\n    }\n    return [f, input, output]\n  }\n\n  const [f, input, output] = makePart(desc)\n  let result = `RMHit sdf(vec3 ${input}) {\\n`\n  result += f\n  result += `return RMHit(${output}, black);\\n`\n  result += \"}\\n\"\n  return result\n}\n\nfunction normfig(s) {\n  return aesthetically.format(s, \"monospace\")\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction SphereEditor({\n  value,\n  onChange,\n}\n\n\n) {\n  const onRadiusChange = useCallback(\n    (ev) => onChange({ ...value, radius: +ev.target.value }, value),\n    [onChange],\n  )\n  return (\n    React.createElement('div', null, \"Sphere\"\n      , \" \"\n      , React.createElement(TextField, {\n        value: value.radius,\n        onChange: onRadiusChange,\n        inputProps: { type: \"number\" },}\n      )\n    )\n  )\n}\n\nfunction BoxEditor({\n  value,\n  onChange,\n}\n\n\n) {\n  const onRadiusChange = useCallback(\n    (newRadius) => onChange({ ...value, radius: newRadius }, value),\n    [value, onChange],\n  )\n  return (\n    React.createElement('div', { style: { display: \"flex\" },}, \"Box \"\n       , React.createElement(Vec3Editor, { value: value.radius, onChange: onRadiusChange,} )\n    )\n  )\n}\n\nfunction ExpandEditor({\n  value,\n  onChange,\n}\n\n\n) {\n  const onByChange = useCallback(\n    (e) => onChange({ ...value, by: +e.target.value }, value),\n    [value, onChange],\n  )\n  return (\n    React.createElement('div', { style: { display: \"flex\" },}, \"Expand\"\n      , \" \"\n      , React.createElement(TextField, {\n        value: value.by,\n        onChange: onByChange,\n        type: \"number\",\n        inputProps: {},}\n      )\n    )\n  )\n}\n\nclass GizmoControl {\n  take(startPos, onChange) {\n    // TODO\n  }\n}\n\nfunction Vec3Editor({\n  value,\n  onChange,\n  gizmoControl,\n}\n\n\n\n) {\n  const onElChange = useCallback(\n    (e) => {\n      const newValue = value.slice() \n      newValue[e.target.name] = +e.target.value\n      onChange(newValue, value)\n    },\n    [value, onChange],\n  )\n  const gizmoClick = useCallback(\n    () => gizmoControl.take(value, onChange),\n    [gizmoControl, onChange, value],\n  )\n  return (\n    React.createElement(React.Fragment, null\n      , React.createElement(Button, { onClick: gizmoClick,}, \"X\")\n      , [0, 1, 2].map((i) => (\n        React.createElement(TextField, {\n          key: i,\n          name: \"\" + i,\n          value: value[i],\n          onChange: onElChange,\n          inputProps: { type: \"number\" },}\n        )\n      ))\n    )\n  )\n}\n\nfunction TranslateEditor({\n  value,\n  onChange,\n  gizmoControl,\n}\n\n\n\n) {\n  const onByChange = useCallback(\n    (newBy) => onChange({ ...value, by: newBy }, value),\n    [value, onChange],\n  )\n  return (\n    React.createElement('div', { style: { display: \"flex\" },}, \"Translate\"\n      , \" \"\n      , React.createElement(Vec3Editor, {\n        value: value.by,\n        onChange: onByChange,\n        gizmoControl: gizmoControl,}\n      )\n    )\n  )\n}\n\nfunction DonutEditor({\n  value,\n  onChange,\n  gizmoControl,\n}\n\n\n\n) {\n  const onElChange = useCallback(\n    (e) =>\n      onChange(\n        {\n          ...value,\n          [e.target.name]: +e.target.value,\n        },\n        value,\n      ),\n    [value, onChange],\n  )\n  return (\n    React.createElement('div', { style: { display: \"flex\" },}, \"Donut\"\n      , \" \"\n      , ([\"r0\", \"r1\"] ).map((i) => (\n        React.createElement(TextField, {\n          key: i,\n          name: i,\n          value: value[i],\n          onChange: onElChange,\n          inputProps: { type: \"number\" },}\n        )\n      ))\n    )\n  )\n}\nfunction OctahedronEditor({\n  value,\n  onChange,\n  gizmoControl,\n}\n\n\n\n) {\n  const onElChange = useCallback(\n    (e) =>\n      onChange(\n        {\n          ...value,\n          [e.target.name]: +e.target.value,\n        },\n        value,\n      ),\n    [value, onChange],\n  )\n  return (\n    React.createElement('div', { style: { display: \"flex\" },}, \"Octahedron\"\n      , \" \"\n      , [\"radius\"].map((i) => (\n        React.createElement(TextField, {\n          key: i,\n          name: i,\n          value: value[i],\n          onChange: onElChange,\n          inputProps: { type: \"number\" },}\n        )\n      ))\n    )\n  )\n}\n\nfunction AddEditor({\n  value,\n  onChange,\n  gizmoControl,\n}\n\n\n\n) {\n  const onTypeChange = useCallback(\n    (e) => onChange({ ...value, type: e.target.value }, value),\n    [value, onChange],\n  )\n  const onWhatChange = useCallback(\n    (newWhat) => onChange({ ...value, what: newWhat }, value),\n    [value, onChange],\n  )\n  return (\n    React.createElement('div', { style: { display: \"flex\" },}\n      , React.createElement(Select, { value: value.type, name: \"type\", onChange: onTypeChange,}\n        , React.createElement(MenuItem, { value: \"add\",}, \"Add\")\n        , React.createElement(MenuItem, { value: \"sub\",}, \"Sub\")\n      ), \" \"\n      , React.createElement(Ed, {\n        value: value.what,\n        onChange: onWhatChange,\n        gizmoControl: gizmoControl,}\n      )\n    )\n  )\n}\n\nfunction Ed({\n  value,\n  onChange,\n  gizmoControl,\n}\n\n\n\n) {\n  const onItemChange = useCallback(\n    (newValue, oldValue) =>\n      onChange(value.map((v) => (v === oldValue ? newValue : v))),\n    [onChange, value],\n  )\n  return (\n    React.createElement('div', null\n      , value.map((x, i) => {\n        const PEd = {\n          sphere: SphereEditor,\n          expand: ExpandEditor,\n          add: AddEditor,\n          sub: AddEditor,\n          box: BoxEditor,\n          donut: DonutEditor,\n          translate: TranslateEditor,\n          octahedron: OctahedronEditor,\n        }[x.type]\n        return (\n          PEd && (\n            React.createElement(PEd, {\n              key: i,\n              value: x,\n              onChange: onItemChange,\n              gizmoControl: gizmoControl,}\n            )\n          )\n        )\n      })\n    )\n  )\n}\n\nexport default () => {\n  const canvasRef = useRef(null)\n\n  const [renderProgress, setRenderProgress] = useState(\n    undefined ,\n  )\n  const [gp, setGp] = useState(M4.IDENTITY)\n  const [resolution, setResolution] = useState(512)\n  const [gpFocused, setGpFocused] = useState(false)\n  const [state, setState] = useHashState(initialState)\n  const setStatePartial = useCallback(\n    (o) => setState((s) => ({ ...s, ...o })),\n    [setState],\n  )\n  const [part, setPart] = useState(NONE)\n  const [fps, setFps] = useState(0)\n  const dynamic = useRef(Object.assign({}, state))\n  const raymarchRef = useRef()\n\n  const [model, setModel] = useState([\n    { type: \"sphere\", radius: 1 },\n    { type: \"translate\", by: [1, 2, 3] },\n    {\n      type: \"add\",\n      what: [\n        { type: \"box\", radius: [1, 2, 3] },\n        { type: \"translate\", by: [0.1, 0.1, 0.1] },\n        { type: \"expand\", by: 0.3 },\n      ],\n    },\n    {\n      type: \"add\",\n      what: [\n        { type: \"octahedron\", radius: 2 },\n        { type: \"translate\", by: [0.1, 0.1, 0.1] },\n      ],\n    },\n    {\n      type: \"add\",\n      what: [\n        { type: \"donut\", r0: 2, r1: 0.2 },\n        { type: \"translate\", by: [0.1, 0.1, 0.1] },\n      ],\n    },\n  ])\n\n  const theme = useTheme()\n  const colors = useMemo(\n    () => ({\n      background: chroma.css(theme.palette.background.default).gl(),\n      primary: chroma.css(theme.palette.primary.main).gl(),\n      secondary: chroma.css(theme.palette.secondary.main).gl(),\n    }),\n    [theme.palette],\n  )\n  const render = useCallback(\n    async ([width, height]) => {\n      const url = URL.createObjectURL(\n        await renderHighRes(\n          [width, height],\n          raymarchSetup,\n          (gl, shared) => {\n            const camMatrix = M4.product(\n              M4.perspective(70, width / height, 0.1, 50),\n              OrbitCameraController.getLookAt(\n                OrbitCameraController.fromShortString(state.cam),\n              ),\n            )\n\n            raymarchRender(\n              gl,\n              shared,\n              camMatrix,\n              colors,\n              state,\n              2000,\n              gp.getTranslation(),\n            )\n          },\n          setRenderProgress,\n        ),\n      )\n      setRenderProgress(undefined)\n      openInNewTab(url)\n    },\n    [gp, colors, state],\n  )\n  useEffect(() => {\n    console.log(\"creating context\")\n    const tsgl = TSGLContext.create({\n      canvas: canvasRef.current,\n      alpha: true,\n      premultipliedAlpha: true,\n      // antialias: true,\n      throwOnError: true,\n    })\n    console.log(tsgl.getParameter(tsgl.MAX_SAMPLES))\n    // tsgl.fixCanvasRes()\n    //tsgl.addResizeListener()\n    raymarchRef.current = raymarch(\n      tsgl,\n      colors,\n      dynamic.current,\n      setFps,\n      () => render([1920, 1080]),\n      debounce((cam) => {\n        setStatePartial({ cam: OrbitCameraController.toShortString(cam) })\n      }),\n      setPart,\n      setGp,\n    )\n\n    return () => {\n      _optionalChain([raymarchRef, 'access', _ => _.current, 'optionalAccess', _2 => _2.teardown, 'call', _3 => _3()])\n    }\n  }, [])\n  useEffect(() => {\n    // state.cam &&\n    //   raymarchRef.current?.setCam(\n    //     OrbitCameraController.fromShortString(state.cam),\n    //   )\n  }, [state.cam])\n  useEffect(() => {\n    _optionalChain([raymarchRef, 'access', _4 => _4.current, 'optionalAccess', _5 => _5.updateShader, 'call', _6 => _6(\n      edFragShader.replace(/RMHit sdf\\(vec3 p\\) {[\\s\\S]*?}/, makeShader(model)),\n    )])\n  }, [model])\n\n  useEffect(() => {\n    Object.assign(dynamic.current, state)\n  }, [state])\n\n  const RenderButton = useCallback(\n    ({ dim, children }) => (\n      React.createElement(Button, {\n        variant: \"contained\",\n        onClick: () => render(dim),\n        disabled: \"undefined\" !== typeof renderProgress,}\n\n        , \"undefined\" === typeof renderProgress\n          ? children\n          : \"Rendering... \" +\n            normfig(\"\" + Math.floor(renderProgress * 100)).padStart(\n              3,\n              \"\\u2007\",\n            ) +\n            \"%\"\n      )\n    ),\n    [render, renderProgress],\n  )\n\n  function setCam({ cam }) {\n    const m = FlyCameraController.fromShortString(cam)\n    setStatePartial({ cam: OrbitCameraController.toShortString(m) })\n  }\n\n  return (\n    React.createElement(Grid, { container: true, style: { height: \"99%\" },}\n      , React.createElement(Grid, { item: true, xs: 12, md: 9,}\n        , React.createElement('div', { style: { height: \"100%\" },}\n          , React.createElement('canvas', {\n            ref: canvasRef,\n            style: {\n              width: \"100%\",\n              height: \"100%\",\n              cursor: part === NONE ? \"move\" : \"grab\",\n            },\n            width: resolution,\n            height: resolution,\n            tabIndex: 0,}\n          )\n        )\n      )\n      , React.createElement(Grid, {\n        item: true,\n        xs: 12,\n        md: 3,\n        sx: {\n          display: \"flex\",\n          flexDirection: \"column\",\n          width: \"100%\",\n          padding: 2,\n          alignItems: \"stretch\",\n          gap: 2,\n        },}\n\n        , React.createElement(Card, null\n          , React.createElement(CardContent, null, \"Raymarching demo.\" )\n        )\n        , React.createElement(Select, {\n          onChange: (e) => setResolution(+(e.target.value )),\n          value: resolution,}\n\n          , React.createElement(MenuItem, { value: 256,}, \"256x256\")\n          , React.createElement(MenuItem, { value: 512,}, \"512x512\")\n        )\n        , React.createElement(BoundNumberField, {\n          ...{ state, setStatePartial },\n          prop: \"a\",\n          inputProps: { step: 0.05 },}\n        ), \" \"\n        , React.createElement(BoundNumberField, {\n          ...{ state, setStatePartial },\n          prop: \"b\",\n          inputProps: { step: 0.05 },}\n        )\n        , React.createElement(BoundNumberField, {\n          ...{ state, setStatePartial },\n          prop: \"c\",\n          inputProps: { step: 0.05 },}\n        ), \" \"\n        , React.createElement(BoundNumberField, {\n          ...{ state, setStatePartial },\n          prop: \"d\",\n          inputProps: { step: 0.05 },}\n        )\n        , React.createElement(RenderButton, { dim: [1920, 1080],}, \"render hd\" )\n        , React.createElement(RenderButton, { dim: [3840, 2160],}, \"render 4k\" )\n        , React.createElement(Button, {\n          color: \"secondary\",\n          variant: \"outlined\",\n          onClick: () => setCam({ cam: \"999.999.999~-56.-58.-61~-44.-44.79\" }),}\n, \"Cam 0\"\n\n        )\n        , React.createElement(Button, {\n          color: \"secondary\",\n          variant: \"outlined\",\n          onClick: () => setCam({ cam: \"57.427.96~1.-100.-8~7.-7.99\" }),}\n, \"Cam 1\"\n\n        )\n        , React.createElement(Button, {\n          color: \"secondary\",\n          variant: \"outlined\",\n          onClick: () => setCam({ cam: \"53.80.892~-9.-8.-100~-18.-99.8\" }),}\n, \"Cam 2\"\n\n        )\n        , React.createElement('div', null, \"cam: \" , state.cam)\n        , React.createElement('div', null, \"fps: \" , fps)\n        , React.createElement(MatrixDisplay, {\n          label: \"gp\",\n          onFocus: () => setEditing(true),\n          onBlur: () => setEditing(false),}\n\n          , gp\n        )\n        , React.createElement('div', null\n          , React.createElement(Ed, { value: model, onChange: setModel,} )\n        )\n        , React.createElement('div', null\n          , React.createElement('pre', null\n            , React.createElement('code', null, makeShader(model))\n          )\n        )\n      )\n    )\n  )\n}\n","\nexport default \"#version 300 es\\n\\nprecision highp float;\\n\\n// START ../common/banded.glsl\\nfloat banded(float bandCount, float t) {\\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\\n}\\nfloat banded(int bandCount, float t) {\\n  return banded(float(bandCount), t);\\n}\\n\\n// #pragma glslify: export(banded)\\n\\n\\n// END ../common/banded.glsl\\n// START ../common/between.glsl\\nbool between(float min, float max, float value) {\\n  return min <= value && value <= max;\\n}\\n\\n// #pragma glslify: export(between)\\n\\n\\n// END ../common/between.glsl\\n// START ../common/hexFns.glsl\\n// START ./max3.glsl\\nfloat max3(float a, float b, float c) {\\n  return max(a, max(b, c));\\n}\\nfloat max3(vec3 v) {\\n  return max(v.x, max(v.y, v.z));\\n}\\n\\n// #pragma glslify: export(max3)\\n\\n\\n// END ./max3.glsl\\n// START ./constants.glsl\\nconst float SQRT1_2 = 0.7071067811865476;\\nconst float SQRT1_3 = 0.57735026919;\\nconst float SQRT2 = 1.4142135623730951;\\nconst float SQRT3 = 1.732050807568877;\\n// sqrt(3)/2 = sin(60*)\\nconst float SQRT3_2 = 0.86602540378;\\nconst float GOLDEN_RATIO = 1.61803398875;\\nconst float PI = 3.141592653589793;\\nconst float TAU = 6.28318530718;\\n/**\\n * One degree in radians. Use like `sin(30 * DEG)`.\\n */\\nconst float DEGREE = 0.017453292519943295;\\n\\n// END ./constants.glsl\\n\\nvec3 hexRound(vec3 hex) {\\n  vec3 r = floor(hex + 0.5);\\n  vec3 diff = abs(r - hex);\\n\\n  if (diff.x > diff.y && diff.x > diff.z) {\\n    r.x = -(r.y + r.z);\\n  } else if (diff.y > diff.z) {\\n    r.y = -(r.x + r.z);\\n  } else {\\n    r.z = -(r.x + r.y);\\n  }\\n\\n  return r;\\n}\\nvec2 hex2Ra(vec3 hex) {\\n  float y = hex.t * SQRT3_2;\\n  float x = hex.s + hex.t / 2.0;\\n  return vec2(x, y);\\n}\\n\\nfloat hexSdf(vec3 hex) {\\n  return max3(abs(hex.yzx + hex.zxy / 2.0));\\n}\\nvec3 ra2Hex(vec2 xy) {\\n  float hex_t = xy.y / SQRT3_2;\\n  float hex_s = xy.x - hex_t / 2.0;\\n  return vec3(hex_s, hex_t, -(hex_s + hex_t));\\n}\\n\\n// END ../common/hexFns.glsl\\n// START ../common/matrices.glsl\\n\\nmat2 rot2(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat2(c, s, -s, c);\\n}\\nmat3 rotX(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\\n}\\nmat3 rotY(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\\n}\\nmat3 rotZ(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\\n}\\n/**\\n * Returns a matrix that puts the camera at the eye point `ex, ey, ez` looking\\n * toward the center point `cx, cy, cz` with an up direction of `ux, uy, uz`.\\n * This emulates the OpenGL function `gluLookAt()`.\\n */\\nmat4 lookAt(vec3 eye, vec3 focus, vec3 up) {\\n  vec3 f = normalize(eye - focus);\\n  vec3 s = normalize(cross(up, f));\\n  vec3 t = normalize(cross(f, s));\\n\\n  return mat4(\\n    vec4(s.x, t.x, f.x, 0.0),\\n    vec4(s.y, t.y, f.y, 0.0),\\n    vec4(s.z, t.z, f.z, 0.0),\\n    vec4(-dot(s, eye), -dot(t, eye), -dot(f, eye), 1)\\n  );\\n}\\n\\n// the OpenGL function `glFrustum()`.\\nmat4 frustum(\\n  float left,\\n  float right,\\n  float bottom,\\n  float top,\\n  float near,\\n  float far\\n) {\\n  return mat4(\\n    vec4(2.0 * near / (right - left), 0.0, 0.0, 0.0),\\n    vec4(0, 2.0 * near / (top - bottom), 0.0, 0.0),\\n    vec4(\\n      (right + left) / (right - left),\\n      (top + bottom) / (top - bottom),\\n      -(far + near) / (far - near),\\n      -1\\n    ),\\n    vec4(0.0, 0.0, -2.0 * far * near / (far - near), 0.0)\\n  );\\n}\\n\\nmat4 perspective(float fovDegrees, float aspect, float near, float far) {\\n  float y = tan(fovDegrees * DEGREE / 2.0) * near;\\n  float x = y * aspect;\\n  return frustum(-x, x, -y, y, near, far);\\n}\\nmat4 ortho(\\n  float left,\\n  float right,\\n  float bottom,\\n  float top,\\n  float near,\\n  float far\\n) {\\n  return mat4(\\n    vec4(2.0 / (right - left), 0.0, 0.0, 0.0),\\n    vec4(0.0, 2.0 / (top - bottom), 0.0, 0.0),\\n    vec4(0.0, 0.0, -2.0 / (far - near), 0.0),\\n    vec4(\\n      -(right + left) / (right - left),\\n      -(top + bottom) / (top - bottom),\\n      -(far + near) / (far - near),\\n      1.0\\n    )\\n  );\\n}\\n\\n// END ../common/matrices.glsl\\n// START ../common/perlin2DTexture.glsl\\nuniform sampler2D gradients;\\n/* Create random direction vector\\n */\\nvec2 randomGradient(vec2 i) {\\n  // Random float. No precomputed gradients mean this works for any number of grid coordinates\\n  float random =\\n    2920.0 *\\n    sin(float(i.x) * 2.1942 + float(i.y) * 1.71324 + 8.912) *\\n    cos(float(i.x) * 2.3157 * float(i.y) * 2.17832 + 9.758);\\n  //    random = (i.x + 1667.) * (i.x + 2083.) * (i.y + 2659.) * (i.y * 50.77 + .3769);\\n  //    random = sin(SQRT2 * i.x) + cos(GOLDEN_RATIO * i.y) + tan((i.x + i.y) * SQRT3);\\n  return vec2(cos(random), sin(random));\\n}\\nfloat dotGridGradient(vec2 cell, vec2 pos) {\\n  vec2 d = cell - pos;\\n\\n  //  vec2 gradient = texelFetch(gradients, ivec2(cell), 0).xy;\\n  vec2 gradient = randomGradient(vec2(cell));\\n\\n  return dot(gradient, d);\\n}\\n\\nfloat mixx(float a, float b, float t) {\\n  return mix(a, b, smoothstep(0.0, 1.0, t));\\n  //    return mix(a, b, t);\\n}\\n\\n// resulting range is [-0.68, 0.68]. Use unmix to normalize if necessary.\\nfloat perlin2D(vec2 xy) {\\n  float x0 = floor(xy.x);\\n  float x1 = x0 + 1.0;\\n  float y0 = floor(xy.y);\\n  float y1 = y0 + 1.0;\\n\\n  // Interpolate between grid point gradients\\n  float n00 = dotGridGradient(vec2(x0, y0), xy);\\n  float n10 = dotGridGradient(vec2(x1, y0), xy);\\n  float ny0 = mixx(n00, n10, xy.x - x0);\\n\\n  float n01 = dotGridGradient(vec2(x0, y1), xy);\\n  float n11 = dotGridGradient(vec2(x1, y1), xy);\\n  float ny1 = mixx(n01, n11, xy.x - x0);\\n\\n  return mixx(ny0, ny1, xy.y - y0);\\n}\\n\\n// #pragma glslify: export(perlin2D)\\n\\n\\n// END ../common/perlin2DTexture.glsl\\n// START ../common/polar.glsl\\n// START ../common/fromPolar.glsl\\n// START ./unmix.glsl\\nfloat unmix(float a, float b, float value) {\\n  return (value - a) / (b - a);\\n}\\n\\n// #pragma glslify: export(unmix)\\n\\n\\n// END ./unmix.glsl\\n\\nvec3 fromPolar(float radius, float phi, float z) {\\n  return vec3(radius * cos(phi), radius * sin(phi), z);\\n}\\n\\nvec2 fromPolar(float radius, float phi) {\\n  return vec2(radius * cos(phi), radius * sin(phi));\\n}\\n\\nvec2 fromPolar(vec2 polar) {\\n  return fromPolar(polar.x, polar.y);\\n}\\n\\n// #pragma glslify: export(fromPolar)\\n\\n\\n// END ../common/fromPolar.glsl\\n// START ../common/toPolar.glsl\\n\\nvec2 toPolar(vec2 xy) {\\n  return vec2(length(xy), atan(xy.y, xy.x));\\n}\\n\\nmat2 toPolarDerivate(vec2 xy) {\\n  return mat2(xy.x * xy.x, xy.y * xy.y, -xy.y, xy.x) / dot(xy, xy);\\n}\\n\\n// #pragma glslify: export(toPolar)\\n\\n\\n// END ../common/toPolar.glsl\\n\\n// END ../common/polar.glsl\\n// START ../common/remix.glsl\\n\\nfloat remix(float fromA, float fromB, float toA, float toB, float value) {\\n  return mix(toA, toB, unmix(fromA, fromB, value));\\n}\\n\\nvec4 remix(float fromA, float fromB, vec4 toA, vec4 toB, float value) {\\n  return mix(toA, toB, unmix(fromA, fromB, value));\\n}\\n\\n// #pragma glslify: export(remix)\\n\\n\\n// END ../common/remix.glsl\\n// START ../common/transform.glsl\\nvec3 transform(mat4 pm, vec3 p) {\\n  vec4 pStar = pm * vec4(p, 1);\\n  return pStar.xyz / pStar.w;\\n}\\n\\nvec2 transform(mat4 pm, vec2 p) {\\n  vec4 pStar = pm * vec4(p, 0, 1);\\n  return pStar.xy / pStar.w;\\n}\\n\\n// END ../common/transform.glsl\\n// START ../common/visualize.glsl\\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\\n  float isLow = float(t < 0.0);\\n  float isHigh = float(t > 1.0);\\n  float isMid = 1.0 - isLow - isHigh;\\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\\n}\\n\\nvec4 visualize(float t) {\\n  const vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\\n  const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\\n  return visualize(BLUE, RED, t);\\n}\\n\\n// #pragma glslify: export(visualize)\\n\\n\\n// END ../common/visualize.glsl\\n// START ../common/waves.glsl\\nfloat waves(vec4 color, vec2 position, vec2 direction, float highResTimeStamp) {\\n  return sin(\\n    dot(position, direction / pow(length(direction), 2.0)) +\\n      float(highResTimeStamp) / 200.0\\n  );\\n}\\n\\n// #pragma glslify: export(waves)\\n\\n\\n// END ../common/waves.glsl\\n\\n// START ../common/sdf3d/sdTorus.glsl\\nfloat sdTorus(float r0, float r1, vec3 p) {\\n  vec3 closestCenter = vec3(normalize(p.xy) * r0, 0.0);\\n  return distance(closestCenter, p) - r1;\\n}\\n\\n// #pragma glslify: export(sdTorus)\\n\\n\\n// END ../common/sdf3d/sdTorus.glsl\\n// START ../common/sdf3d/sdCapsule.glsl\\nfloat sdCapsule(vec3 a, vec3 b, float r, vec3 p) {\\n  vec3 pa = p - a;\\n  vec3 ba = b - a;\\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\\n  return length(pa - ba * h) - r;\\n}\\n// #pragma glslify: export(sdCapsule)\\n\\n// END ../common/sdf3d/sdCapsule.glsl\\n// START ../common/sdf3d/opElongate.glsl\\nvec3 opElongate(vec3 h, vec3 p) {\\n  return p - clamp(p, -h, h);\\n}\\n// #pragma glslify: export(opElongate)\\n\\n// END ../common/sdf3d/opElongate.glsl\\n// START ../common/sdf3d/sdSphere.glsl\\nfloat sdSphere(float radius, vec3 p) {\\n  return length(p) - radius;\\n}\\n\\n// #pragma glslify: export(sdSphere)\\n\\n\\n// END ../common/sdf3d/sdSphere.glsl\\n// START ../common/sdf3d/sdCylinder.glsl\\nfloat sdCylinder(float radius, float z, vec3 p) {\\n  vec2 d = vec2(length(p.xy), abs(p.z)) - vec2(radius, z);\\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\\n}\\n\\n// #pragma glslify: export(sdCylinder)\\n\\n\\n// END ../common/sdf3d/sdCylinder.glsl\\n// START ../common/sdf3d/sdCone.glsl\\n\\n/**\\n * Signed distance function (SDF) of a cone. The tip of the cone is at the\\n * origin and points towards +Z. q is a point on the rim of the cone.\\n */\\nfloat sdCone(vec2 c, float h, vec3 p) {\\n  vec2 q = h * vec2(c.x / c.y, -1.0);\\n  vec2 w = vec2(length(p.xz), p.y);\\n  vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);\\n  vec2 b = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0);\\n  float k = sign(q.y);\\n  float d = min(dot(a, a), dot(b, b));\\n  float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));\\n  return sqrt(d) * sign(s);\\n}\\n// #pragma glslify: export(sdBox)\\n\\nfloat sdConeB(vec2 c, float h, vec3 p) {\\n  float q = length(p.xz);\\n  return max(dot(c.xy, vec2(q, p.y)), -h - p.y);\\n}\\n\\n// END ../common/sdf3d/sdCone.glsl\\n// START ../common/sdf2d/addChamfer.glsl\\n\\nfloat addChamfer(float d, float a, float b) {\\n  // exact variant, but abs is larger when a and b aren't perpendicular\\n  // which is worse than underestimating, which is what the simple version does.\\n  //  vec2 p = vec2(a, b);\\n  //  if (p.x < d && p.y < d) {\\n  //    p = rot2(0.25 * PI) * p;\\n  //    p.y = abs(p.y);\\n  //    p.y -= min(p.y, d * SQRT1_2);\\n  //    p.x -= d * SQRT1_2;\\n  //    //    p -= vec2(SQRT1_2) * clamp(dot(p, vec2(SQRT1_2)), 0.0, d);\\n  //    float fillet = -length(p);\\n  //    return -sign(p.x) * fillet;\\n  //  } else {\\n  //  }\\n  float tillet = (a + b - d) * SQRT1_2;\\n  return min(tillet, min(a, b));\\n}\\n\\n// #pragma glslify: export(addChamfer)\\n\\n\\n// END ../common/sdf2d/addChamfer.glsl\\n// START ../common/sdf2d/addFillet.glsl\\nfloat addFillet(float r, float a, float b) {\\n  if (a < r && b < r) {\\n    return r - distance(vec2(a, b), vec2(r));\\n  } else {\\n    return min(a, b);\\n  }\\n}\\n\\n// #pragma glslify: export(addFillet)\\n\\n\\n// END ../common/sdf2d/addFillet.glsl\\n// START ../common/sdf3d/sdBox.glsl\\n\\nfloat sdBox(vec3 r, vec3 p) {\\n  vec3 q = abs(p) - r;\\n  return length(max(q, 0.0)) + min(max3(q), 0.0);\\n}\\n\\nfloat sdBox(vec3 r, float r2, vec3 p) {\\n  return sdBox(r - r2, p) - r2;\\n}\\n\\n// #pragma glslify: export(sdBox)\\n\\n\\n// END ../common/sdf3d/sdBox.glsl\\n// START ../common/sdf3d/sdOctahedron.glsl\\nfloat sdOctahedron(float s, vec3 p) {\\n  p = abs(p);\\n  float m = p.x + p.y + p.z - s;\\n  vec3 q;\\n  if (3.0 * p.x < m) q = p.xyz;\\n  else if (3.0 * p.y < m) q = p.yzx;\\n  else if (3.0 * p.z < m) q = p.zxy;\\n  else return m * 0.57735027;\\n\\n  float k = clamp(0.5 * (q.z - q.y + s), 0.0, s);\\n  return length(vec3(q.x, q.y - s + k, q.z - k));\\n}\\n// #pragma glslify: export(sdOctahedron)\\n\\nfloat sdOctahedron(vec3 p, float s) {\\n  p = abs(p);\\n\\n  float m = p.x + p.y + p.z - s;\\n  //find point on octohedron surf nearest to p\\n  vec3 projPoint = p - vec3(0.333333 * m); //project onto surface plane\\n  //now push projected point, if outside triangle edge, perpendicular to edge, to edge\\n  vec3 toMove = min(projPoint, 0.0); //if projpoint.x<0 move along (1.0,-0.5,-0.5) , etc\\n  float toMoveSum = dot(toMove, vec3(1.0)); //which is basically along (1.5,0,0) then vec3(-0.5)\\n\\n  vec3 movedPoint = projPoint + toMove * vec3(-1.5) + toMoveSum * vec3(0.5); //better to multiply toMove by a matrix (1s diagonal, 0.5 other)?\\n\\n  movedPoint = max(movedPoint, 0.0); //cap x,y,z to 0 then\\n  movedPoint *= s / dot(movedPoint, vec3(1.0)); //scale about 0,0,0\\n\\n  return length(p - movedPoint);\\n}\\n\\n// END ../common/sdf3d/sdOctahedron.glsl\\n// START ../common/sdf3d/add.glsl\\nfloat add(float a, float b) {\\n  return min(a, b);\\n}\\n\\n// #pragma glslify: export(add)\\n\\n\\n// END ../common/sdf3d/add.glsl\\n// START ../common/sdf3d/sub.glsl\\nfloat sub(float from, float what) {\\n  return max(from, -what);\\n}\\n\\n// #pragma glslify: export(sub)\\n\\n\\n// END ../common/sdf3d/sub.glsl\\n\\nuniform sampler2D texture;\\nuniform float secs;\\nuniform mat4 lll;\\nuniform mat4 llli;\\nuniform vec4 colorPrimary;\\nuniform vec4 colorSecondary;\\nuniform vec4 colorBackground;\\nuniform float a;\\nuniform float b;\\nuniform float c;\\nuniform float d;\\nuniform float highResTimeStamp;\\nuniform int bandCount;\\nuniform vec3 campos;\\nin float n;\\nin vec2 coord;\\nout vec4 fragColor;\\n\\n\\nconst vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\\nconst vec4 yellow = vec4(1.0, 1.0, 0.0, 1.0);\\nconst vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\\nconst vec4 blue = vec4(0.0, 0.0, 1.0, 1.0);\\nconst vec4 purple = vec4(0.5, 0.0, 0.5, 1.0);\\nconst vec4 red = vec4(1.0, 0.0, 0.0, 1.0);\\n\\nstruct RMHit {\\n  float distance;\\n  vec4 color;\\n};\\nRMHit mixa(RMHit a, RMHit b, float t) {\\n  return RMHit(mix(a.distance, b.distance, t), mix(a.color, b.color, t));\\n}\\nfloat skybox(vec3 p) {\\n  return 32.0 - max3(abs(p));\\n}\\n\\nfloat perlinSphere(float radius, vec3 p) {\\n  vec3 cp = normalize(p);\\n  float alpha = atan(cp.y, cp.x);\\n  float beta = asin(cp.z);\\n  return length(p) -\\n  radius +\\n  0.1 *\\n    perlin2D(vec2(0.0 / 100.0, 0.0) + (vec2(5.0) + vec2(alpha, beta)) * 8.0);\\n}\\n\\nfloat cylCircle(vec3 p) {\\n  float d = 10e9;\\n  for (int i = 0; i < 10; i++) {\\n    d = min(\\n      d,\\n      sdCylinder(0.2, 2.0, p + fromPolar(3.0, TAU * float(i) / 10.0, 1.0))\\n    );\\n  }\\n\\n  return d;\\n}\\n\\nfloat rblock(float r, out vec3 p) {\\n  return sdBox(vec3(r), p);\\n}\\n\\nRMHit add(RMHit a, RMHit b) {\\n  //    return a.distance < b.distance\\n  //        ? RMHit(a.distance, a.color)\\n  //        : RMHit(b.distance, b.color);\\n  return mixa(a, b, float(b.distance < a.distance));\\n}\\n\\nfloat wtf(vec3 p) {\\n  vec3 center = p - mod(p, 3.0) + vec3(1.5);\\n  return rblock(0.4 + 0.3 * sin(secs + center.x), center);\\n}\\n\\nRMHit addFillet(float r, RMHit a, RMHit b) {\\n  if (a.distance < r && b.distance < r) {\\n    return RMHit(\\n      r - distance(vec2(a.distance, b.distance), vec2(r)),\\n      mix(a.color, b.color, (a.distance - b.distance) / r * 0.5 + 0.5)\\n    );\\n  } else {\\n    return add(a, b);\\n  }\\n}\\n\\nRMHit addFillet(float r, RMHit a, RMHit b, vec4 tilletColor) {\\n  if (a.distance < r && b.distance < r) {\\n    return RMHit(\\n      r - distance(vec2(a.distance, b.distance), vec2(r)),\\n      tilletColor\\n    );\\n  } else {\\n    return add(a, b);\\n  }\\n}\\nRMHit addFillet2(float r, RMHit a, RMHit b) {\\n  float h = smoothstep(-r, r, a.distance - b.distance);\\n  return RMHit(\\n    mix(a.distance, b.distance, h) - r * h * (1.0 - h),\\n    mix(a.color, b.color, h)\\n  );\\n}\\n\\nRMHit neg(RMHit a) {\\n  return RMHit(-a.distance, a.color);\\n}\\nRMHit sub(RMHit from, RMHit what) {\\n  RMHit whatNeg = neg(what);\\n  return mixa(from, whatNeg, float(whatNeg.distance > from.distance));\\n}\\n\\nvec3 modv(vec3 v, vec3 dir1, float y) {\\n  float t = dot(v, dir1);\\n  return v - floor(t / y) * y * dir1;\\n}\\nvec3 modRotZ(vec3 p, float count) {\\n  vec2 polarXY = toPolar(p.xy);\\n  return fromPolar(polarXY.x, mod(polarXY.y, TAU / count), p.z);\\n}\\n\\nfloat sin01(float x) {\\n  return 0.5 + 0.5 * sin(x);\\n}\\nfloat cos01(float x) {\\n  return 0.5 + 0.5 * cos(x);\\n}\\n\\nfloat betterBox(vec3 r, vec3 p) {\\n  vec3 q = abs(p) - r;\\n  return length(max(q, 0.0)) + min(max3(q), 0.0);\\n  p = abs(p);\\n  return max3(p - r);\\n}\\n\\nfloat sdEllipsoidB(vec3 r, vec3 p) {\\n  float k0 = length(p / r);\\n  float k1 = length(p / (r * r));\\n  return k0 * (k0 - 1.0) / k1;\\n}\\nfloat sdOctahedronB(float s, vec3 p) {\\n  p = abs(p);\\n  return (p.x + p.y + p.z - s) * 0.57735027;\\n}\\nfloat donutc(float r0, float r1, vec3 p) {\\n  vec3 closestCenter = vec3(normalize(p.xy) * r0, 0.0);\\n  return distance(closestCenter, p) - r1;\\n}\\n\\nfloat smoothmin(float r, float a, float b) {\\n  float h = smoothstep(-r, r, a - b);\\n  return mix(a, b, h) - r * h * (1.0 - h);\\n}\\n\\nRMHit sdf(vec3 p) {\\n  return RMHit(0.0, black);\\n}\\n\\nfloat sdff(vec3 p) {\\n  return sdf(p).distance;\\n}\\n\\nstruct RMResult {\\n  float distance;\\n  vec3 pos;\\n  vec4 color;\\n};\\nRMResult raymarching2(vec3 start, vec3 dir1) {\\n  vec3 pos = start;\\n  RMHit hit;\\n  for (int i = 0; i < 200; i++) {\\n    hit = sdf(pos);\\n    if (hit.distance < 0.0001) break;\\n    pos = pos + dir1 * hit.distance;\\n  }\\n  return RMResult(hit.distance, pos, hit.color);\\n}\\n\\nfloat softshadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {\\n  float res = 1.0;\\n  float t = 0.1;\\n  for (int i = 0; i < 1000 && t < maxt; i++) {\\n    float h = sdff(ro + rd * t);\\n    if (h < 0.001) return 0.0;\\n    res = min(res, k * h / t);\\n    t += h;\\n  }\\n  return res;\\n}\\n\\nconst float eps = 1e-4;\\nvec3 sdfNormal1(vec3 p, float d) {\\n  return normalize(\\n    vec3(\\n      sdff(p + vec3(eps, 0.0, 0.0)),\\n      sdff(p + vec3(0.0, eps, 0.0)),\\n      sdff(p + vec3(0.0, 0.0, eps))\\n    ) -\\n      sdff(p)\\n  );\\n}\\n\\nfloat ambientOcclusion(vec3 pWC, vec3 n1WC) {\\n  float k = 1.0;\\n  float distance = sdff(pWC + n1WC * k);\\n  return clamp(distance / k, 0.0, 1.0);\\n}\\n\\n//layout (depth_greater) out float gl_FragDepth;\\nvoid main() {\\n  vec3 light = normalize(vec3(-1.0, -2.0, -2));\\n\\n  vec3 a = vec3(coord, -1.0);\\n  vec3 b = vec3(coord, 1.0);\\n  vec3 aWC = transform(llli, a);\\n  vec3 bWC = transform(llli, b);\\n  vec3 lookDir1 = normalize(bWC - aWC);\\n\\n  RMResult hitWC = raymarching2(aWC, lookDir1);\\n  vec3 hitn1 = sdfNormal1(hitWC.pos, hitWC.distance);\\n  float dWC = distance(aWC, hitWC.pos);\\n  vec3 hitNDC = transform(lll, hitWC.pos);\\n\\n  vec3 sunPoint = raymarching2(hitWC.pos + hitn1 * 0.1, -light).pos;\\n  //    float inSun = float(distance(hitWC.pos, sunPoint) > 30.);\\n  float inSun = softshadow(\\n    hitWC.pos + hitn1 * 0.05,\\n    -light,\\n    0.0001,\\n    300.0,\\n    8.0\\n  );\\n  //    float inSun=1.;\\n\\n  vec3 material = vec3(0.0, 0.2, 0.0);\\n  if (dWC > 100.0) {\\n    material = vec3(0.0, 0.0, 0.0);\\n  }\\n\\n  const vec3 sunlightColor = vec3(8.0, 6.0, 1.0);\\n\\n  float aOcc = ambientOcclusion(hitWC.pos, hitn1);\\n\\n  vec3 reflectionDirection = reflect(light, hitn1);\\n\\n  vec3 color = vec3(0.0);\\n  color += material * aOcc;\\n  color += inSun * sunlightColor * material * max(0.0, dot(-light, hitn1));\\n  //    color = (hitn1);\\n\\n  vec3 camPos = aWC;\\n\\n  vec3 eyeDirection = -lookDir1;\\n  float uMaterialShininess = 256.0;\\n  float specularLightWeighting = pow(\\n    max(dot(reflectionDirection, eyeDirection), 0.0),\\n    uMaterialShininess\\n  );\\n  color += specularLightWeighting;\\n  //    float lightIntensity = 0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.);\\n  //    float lightIntensity =\\n  //        0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.) + 0.3*specularLightWeighting;\\n  //    fragColor = visualize(blue, red, mix(0.5, 1.0, inSun) * lightIntensity);\\n  //    fragColor = mix(hitWC.color, colorBackground, mix(0.5, 1.0, inSun) * clamp(lightIntensity, 0., 1.));\\n  color = pow(color, vec3(1.0 / 2.2)); // gamma correction\\n  fragColor = vec4(color, 1.0);\\n  //    fragColor = visualize(hitWC.pos.x/10.);\\n  //    fragColor = hitWC.color;\\n  //    fragColor = visualize(blue, red, distance(hitWC, sunPoint)/20.);\\n  //    fragColor = vec4(coord,0.,1.);\\n  //    fragColor = vec4(aWC, 1.0);\\n  // remap [-1, 1] to [0, 1]\\n  // gl_FragDepth = hitNDC.z * 0.5 + 0.5;\\n  //    gl_FragDepth = .9999999;\\n}\\n\"\nconst sourceMap = {\"version\":3,\"sources\":[\"/home/runner/work/workshop/workshop/src/raymarch/ed.frag\",\"/home/runner/work/workshop/workshop/src/common/banded.glsl\",\"/home/runner/work/workshop/workshop/src/common/between.glsl\",\"/home/runner/work/workshop/workshop/src/common/max3.glsl\",\"/home/runner/work/workshop/workshop/src/common/constants.glsl\",\"/home/runner/work/workshop/workshop/src/common/hexFns.glsl\",\"/home/runner/work/workshop/workshop/src/common/matrices.glsl\",\"/home/runner/work/workshop/workshop/src/common/perlin2DTexture.glsl\",\"/home/runner/work/workshop/workshop/src/common/unmix.glsl\",\"/home/runner/work/workshop/workshop/src/common/fromPolar.glsl\",\"/home/runner/work/workshop/workshop/src/common/toPolar.glsl\",\"/home/runner/work/workshop/workshop/src/common/polar.glsl\",\"/home/runner/work/workshop/workshop/src/common/remix.glsl\",\"/home/runner/work/workshop/workshop/src/common/transform.glsl\",\"/home/runner/work/workshop/workshop/src/common/visualize.glsl\",\"/home/runner/work/workshop/workshop/src/common/waves.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdTorus.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdCapsule.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/opElongate.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdSphere.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdCylinder.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdCone.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf2d/addChamfer.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf2d/addFillet.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdBox.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdOctahedron.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/add.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sub.glsl\"],\"names\":[],\"mappings\":\"AAAA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AfOA;;AgBhBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACPA;AACA;AACA;AACA;AACA;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;;A3BwBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA\"}\nexport { sourceMap };\n","\nexport default \"#version 300 es\\nprecision highp float;\\n\\nin vec4 ts_Vertex;\\nin vec2 ts_TexCoord;\\nout vec2 coord;\\nvoid main() {\\n  gl_Position = ts_Vertex;\\n  coord = ts_TexCoord;\\n}\\n\"\nconst sourceMap = {\"version\":3,\"sources\":[\"/home/runner/work/workshop/workshop/src/common/raymarch.vert\"],\"names\":[],\"mappings\":\"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA\"}\nexport { sourceMap };\n","\nexport default \"#version 300 es\\n\\nprecision highp float;\\n\\n// START ../common/banded.glsl\\nfloat banded(float bandCount, float t) {\\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\\n}\\nfloat banded(int bandCount, float t) {\\n  return banded(float(bandCount), t);\\n}\\n\\n// #pragma glslify: export(banded)\\n\\n\\n// END ../common/banded.glsl\\n// START ../common/between.glsl\\nbool between(float min, float max, float value) {\\n  return min <= value && value <= max;\\n}\\n\\n// #pragma glslify: export(between)\\n\\n\\n// END ../common/between.glsl\\n// START ../common/hexFns.glsl\\n// START ./max3.glsl\\nfloat max3(float a, float b, float c) {\\n  return max(a, max(b, c));\\n}\\nfloat max3(vec3 v) {\\n  return max(v.x, max(v.y, v.z));\\n}\\n\\n// #pragma glslify: export(max3)\\n\\n\\n// END ./max3.glsl\\n// START ./constants.glsl\\nconst float SQRT1_2 = 0.7071067811865476;\\nconst float SQRT1_3 = 0.57735026919;\\nconst float SQRT2 = 1.4142135623730951;\\nconst float SQRT3 = 1.732050807568877;\\n// sqrt(3)/2 = sin(60*)\\nconst float SQRT3_2 = 0.86602540378;\\nconst float GOLDEN_RATIO = 1.61803398875;\\nconst float PI = 3.141592653589793;\\nconst float TAU = 6.28318530718;\\n/**\\n * One degree in radians. Use like `sin(30 * DEG)`.\\n */\\nconst float DEGREE = 0.017453292519943295;\\n\\n// END ./constants.glsl\\n\\nvec3 hexRound(vec3 hex) {\\n  vec3 r = floor(hex + 0.5);\\n  vec3 diff = abs(r - hex);\\n\\n  if (diff.x > diff.y && diff.x > diff.z) {\\n    r.x = -(r.y + r.z);\\n  } else if (diff.y > diff.z) {\\n    r.y = -(r.x + r.z);\\n  } else {\\n    r.z = -(r.x + r.y);\\n  }\\n\\n  return r;\\n}\\nvec2 hex2Ra(vec3 hex) {\\n  float y = hex.t * SQRT3_2;\\n  float x = hex.s + hex.t / 2.0;\\n  return vec2(x, y);\\n}\\n\\nfloat hexSdf(vec3 hex) {\\n  return max3(abs(hex.yzx + hex.zxy / 2.0));\\n}\\nvec3 ra2Hex(vec2 xy) {\\n  float hex_t = xy.y / SQRT3_2;\\n  float hex_s = xy.x - hex_t / 2.0;\\n  return vec3(hex_s, hex_t, -(hex_s + hex_t));\\n}\\n\\n// END ../common/hexFns.glsl\\n// START ../common/matrices.glsl\\n\\nmat2 rot2(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat2(c, s, -s, c);\\n}\\nmat3 rotX(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\\n}\\nmat3 rotY(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\\n}\\nmat3 rotZ(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\\n}\\n/**\\n * Returns a matrix that puts the camera at the eye point `ex, ey, ez` looking\\n * toward the center point `cx, cy, cz` with an up direction of `ux, uy, uz`.\\n * This emulates the OpenGL function `gluLookAt()`.\\n */\\nmat4 lookAt(vec3 eye, vec3 focus, vec3 up) {\\n  vec3 f = normalize(eye - focus);\\n  vec3 s = normalize(cross(up, f));\\n  vec3 t = normalize(cross(f, s));\\n\\n  return mat4(\\n    vec4(s.x, t.x, f.x, 0.0),\\n    vec4(s.y, t.y, f.y, 0.0),\\n    vec4(s.z, t.z, f.z, 0.0),\\n    vec4(-dot(s, eye), -dot(t, eye), -dot(f, eye), 1)\\n  );\\n}\\n\\n// the OpenGL function `glFrustum()`.\\nmat4 frustum(\\n  float left,\\n  float right,\\n  float bottom,\\n  float top,\\n  float near,\\n  float far\\n) {\\n  return mat4(\\n    vec4(2.0 * near / (right - left), 0.0, 0.0, 0.0),\\n    vec4(0, 2.0 * near / (top - bottom), 0.0, 0.0),\\n    vec4(\\n      (right + left) / (right - left),\\n      (top + bottom) / (top - bottom),\\n      -(far + near) / (far - near),\\n      -1\\n    ),\\n    vec4(0.0, 0.0, -2.0 * far * near / (far - near), 0.0)\\n  );\\n}\\n\\nmat4 perspective(float fovDegrees, float aspect, float near, float far) {\\n  float y = tan(fovDegrees * DEGREE / 2.0) * near;\\n  float x = y * aspect;\\n  return frustum(-x, x, -y, y, near, far);\\n}\\nmat4 ortho(\\n  float left,\\n  float right,\\n  float bottom,\\n  float top,\\n  float near,\\n  float far\\n) {\\n  return mat4(\\n    vec4(2.0 / (right - left), 0.0, 0.0, 0.0),\\n    vec4(0.0, 2.0 / (top - bottom), 0.0, 0.0),\\n    vec4(0.0, 0.0, -2.0 / (far - near), 0.0),\\n    vec4(\\n      -(right + left) / (right - left),\\n      -(top + bottom) / (top - bottom),\\n      -(far + near) / (far - near),\\n      1.0\\n    )\\n  );\\n}\\n\\n// END ../common/matrices.glsl\\n// START ../common/perlin2DTexture.glsl\\nuniform sampler2D gradients;\\n/* Create random direction vector\\n */\\nvec2 randomGradient(vec2 i) {\\n  // Random float. No precomputed gradients mean this works for any number of grid coordinates\\n  float random =\\n    2920.0 *\\n    sin(float(i.x) * 2.1942 + float(i.y) * 1.71324 + 8.912) *\\n    cos(float(i.x) * 2.3157 * float(i.y) * 2.17832 + 9.758);\\n  //    random = (i.x + 1667.) * (i.x + 2083.) * (i.y + 2659.) * (i.y * 50.77 + .3769);\\n  //    random = sin(SQRT2 * i.x) + cos(GOLDEN_RATIO * i.y) + tan((i.x + i.y) * SQRT3);\\n  return vec2(cos(random), sin(random));\\n}\\nfloat dotGridGradient(vec2 cell, vec2 pos) {\\n  vec2 d = cell - pos;\\n\\n  //  vec2 gradient = texelFetch(gradients, ivec2(cell), 0).xy;\\n  vec2 gradient = randomGradient(vec2(cell));\\n\\n  return dot(gradient, d);\\n}\\n\\nfloat mixx(float a, float b, float t) {\\n  return mix(a, b, smoothstep(0.0, 1.0, t));\\n  //    return mix(a, b, t);\\n}\\n\\n// resulting range is [-0.68, 0.68]. Use unmix to normalize if necessary.\\nfloat perlin2D(vec2 xy) {\\n  float x0 = floor(xy.x);\\n  float x1 = x0 + 1.0;\\n  float y0 = floor(xy.y);\\n  float y1 = y0 + 1.0;\\n\\n  // Interpolate between grid point gradients\\n  float n00 = dotGridGradient(vec2(x0, y0), xy);\\n  float n10 = dotGridGradient(vec2(x1, y0), xy);\\n  float ny0 = mixx(n00, n10, xy.x - x0);\\n\\n  float n01 = dotGridGradient(vec2(x0, y1), xy);\\n  float n11 = dotGridGradient(vec2(x1, y1), xy);\\n  float ny1 = mixx(n01, n11, xy.x - x0);\\n\\n  return mixx(ny0, ny1, xy.y - y0);\\n}\\n\\n// #pragma glslify: export(perlin2D)\\n\\n\\n// END ../common/perlin2DTexture.glsl\\n// START ../common/polar.glsl\\n// START ../common/fromPolar.glsl\\n// START ./unmix.glsl\\nfloat unmix(float a, float b, float value) {\\n  return (value - a) / (b - a);\\n}\\n\\n// #pragma glslify: export(unmix)\\n\\n\\n// END ./unmix.glsl\\n\\nvec3 fromPolar(float radius, float phi, float z) {\\n  return vec3(radius * cos(phi), radius * sin(phi), z);\\n}\\n\\nvec2 fromPolar(float radius, float phi) {\\n  return vec2(radius * cos(phi), radius * sin(phi));\\n}\\n\\nvec2 fromPolar(vec2 polar) {\\n  return fromPolar(polar.x, polar.y);\\n}\\n\\n// #pragma glslify: export(fromPolar)\\n\\n\\n// END ../common/fromPolar.glsl\\n// START ../common/toPolar.glsl\\n\\nvec2 toPolar(vec2 xy) {\\n  return vec2(length(xy), atan(xy.y, xy.x));\\n}\\n\\nmat2 toPolarDerivate(vec2 xy) {\\n  return mat2(xy.x * xy.x, xy.y * xy.y, -xy.y, xy.x) / dot(xy, xy);\\n}\\n\\n// #pragma glslify: export(toPolar)\\n\\n\\n// END ../common/toPolar.glsl\\n\\n// END ../common/polar.glsl\\n// START ../common/remix.glsl\\n\\nfloat remix(float fromA, float fromB, float toA, float toB, float value) {\\n  return mix(toA, toB, unmix(fromA, fromB, value));\\n}\\n\\nvec4 remix(float fromA, float fromB, vec4 toA, vec4 toB, float value) {\\n  return mix(toA, toB, unmix(fromA, fromB, value));\\n}\\n\\n// #pragma glslify: export(remix)\\n\\n\\n// END ../common/remix.glsl\\n// START ../common/transform.glsl\\nvec3 transform(mat4 pm, vec3 p) {\\n  vec4 pStar = pm * vec4(p, 1);\\n  return pStar.xyz / pStar.w;\\n}\\n\\nvec2 transform(mat4 pm, vec2 p) {\\n  vec4 pStar = pm * vec4(p, 0, 1);\\n  return pStar.xy / pStar.w;\\n}\\n\\n// END ../common/transform.glsl\\n// START ../common/visualize.glsl\\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\\n  float isLow = float(t < 0.0);\\n  float isHigh = float(t > 1.0);\\n  float isMid = 1.0 - isLow - isHigh;\\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\\n}\\n\\nvec4 visualize(float t) {\\n  const vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\\n  const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\\n  return visualize(BLUE, RED, t);\\n}\\n\\n// #pragma glslify: export(visualize)\\n\\n\\n// END ../common/visualize.glsl\\n// START ../common/waves.glsl\\nfloat waves(vec4 color, vec2 position, vec2 direction, float highResTimeStamp) {\\n  return sin(\\n    dot(position, direction / pow(length(direction), 2.0)) +\\n      float(highResTimeStamp) / 200.0\\n  );\\n}\\n\\n// #pragma glslify: export(waves)\\n\\n\\n// END ../common/waves.glsl\\n\\n// START ../common/sdf3d/add.glsl\\nfloat add(float a, float b) {\\n  return min(a, b);\\n}\\n\\n// #pragma glslify: export(add)\\n\\n\\n// END ../common/sdf3d/add.glsl\\n// START ../common/sdf2d/addChamfer.glsl\\n\\nfloat addChamfer(float d, float a, float b) {\\n  // exact variant, but abs is larger when a and b aren't perpendicular\\n  // which is worse than underestimating, which is what the simple version does.\\n  //  vec2 p = vec2(a, b);\\n  //  if (p.x < d && p.y < d) {\\n  //    p = rot2(0.25 * PI) * p;\\n  //    p.y = abs(p.y);\\n  //    p.y -= min(p.y, d * SQRT1_2);\\n  //    p.x -= d * SQRT1_2;\\n  //    //    p -= vec2(SQRT1_2) * clamp(dot(p, vec2(SQRT1_2)), 0.0, d);\\n  //    float fillet = -length(p);\\n  //    return -sign(p.x) * fillet;\\n  //  } else {\\n  //  }\\n  float tillet = (a + b - d) * SQRT1_2;\\n  return min(tillet, min(a, b));\\n}\\n\\n// #pragma glslify: export(addChamfer)\\n\\n\\n// END ../common/sdf2d/addChamfer.glsl\\n// START ../common/sdf2d/addFillet.glsl\\nfloat addFillet(float r, float a, float b) {\\n  if (a < r && b < r) {\\n    return r - distance(vec2(a, b), vec2(r));\\n  } else {\\n    return min(a, b);\\n  }\\n}\\n\\n// #pragma glslify: export(addFillet)\\n\\n\\n// END ../common/sdf2d/addFillet.glsl\\n// START ../common/sdf3d/opElongate.glsl\\nvec3 opElongate(vec3 h, vec3 p) {\\n  return p - clamp(p, -h, h);\\n}\\n// #pragma glslify: export(opElongate)\\n\\n// END ../common/sdf3d/opElongate.glsl\\n// START ../common/sdf3d/opRepLim.glsl\\nvec3 opRepLim(vec3 p, vec3 cellSize, vec3 limit) {\\n  return p - cellSize * clamp(round(p / cellSize), vec3(0.0), limit);\\n}\\nvec2 opRepLim(vec2 p, vec2 cellSize, vec2 limit) {\\n  return p - cellSize * clamp(round(p / cellSize), vec2(0.0), limit);\\n}\\nfloat opRepLim(float p, float cellSize, float limit) {\\n  return p - cellSize * clamp(round(p / cellSize), 0.0, limit);\\n}\\n\\n// #pragma glslify: export(opRepLim)\\n\\n\\n// END ../common/sdf3d/opRepLim.glsl\\n// START ../common/sdf3d/sdBox.glsl\\n\\nfloat sdBox(vec3 r, vec3 p) {\\n  vec3 q = abs(p) - r;\\n  return length(max(q, 0.0)) + min(max3(q), 0.0);\\n}\\n\\nfloat sdBox(vec3 r, float r2, vec3 p) {\\n  return sdBox(r - r2, p) - r2;\\n}\\n\\n// #pragma glslify: export(sdBox)\\n\\n\\n// END ../common/sdf3d/sdBox.glsl\\n// START ../common/sdf3d/sdCone.glsl\\n\\n/**\\n * Signed distance function (SDF) of a cone. The tip of the cone is at the\\n * origin and points towards +Z. q is a point on the rim of the cone.\\n */\\nfloat sdCone(vec2 c, float h, vec3 p) {\\n  vec2 q = h * vec2(c.x / c.y, -1.0);\\n  vec2 w = vec2(length(p.xz), p.y);\\n  vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);\\n  vec2 b = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0);\\n  float k = sign(q.y);\\n  float d = min(dot(a, a), dot(b, b));\\n  float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));\\n  return sqrt(d) * sign(s);\\n}\\n// #pragma glslify: export(sdBox)\\n\\nfloat sdConeB(vec2 c, float h, vec3 p) {\\n  float q = length(p.xz);\\n  return max(dot(c.xy, vec2(q, p.y)), -h - p.y);\\n}\\n\\n// END ../common/sdf3d/sdCone.glsl\\n// START ../common/sdf3d/sdCylinder.glsl\\nfloat sdCylinder(float radius, float z, vec3 p) {\\n  vec2 d = vec2(length(p.xy), abs(p.z)) - vec2(radius, z);\\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\\n}\\n\\n// #pragma glslify: export(sdCylinder)\\n\\n\\n// END ../common/sdf3d/sdCylinder.glsl\\n// START ../common/sdf3d/sdTorus.glsl\\nfloat sdTorus(float r0, float r1, vec3 p) {\\n  vec3 closestCenter = vec3(normalize(p.xy) * r0, 0.0);\\n  return distance(closestCenter, p) - r1;\\n}\\n\\n// #pragma glslify: export(sdTorus)\\n\\n\\n// END ../common/sdf3d/sdTorus.glsl\\n// START ../common/sdf3d/sdIcosahedron.glsl\\n\\n// signed distance function for icosahedron\\n// cf. https://en.wikipedia.org/wiki/Regular_icosahedron\\n// s: edge length\\n// p: point to evaluate function for\\nfloat sdIcosahedron(float s, vec3 p) {\\n  // NN = 1/GOLDEN_RATIO = GOLDEN_RATIO - 1\\n  const float K = GOLDEN_RATIO * 0.5;\\n  // the three vertices of the icosahedron triangle which\\n  // is fully inside the +++ octant. (edge length = 1)\\n  const vec3 a = vec3(0.5, K, 0.0);\\n  const vec3 b = vec3(0.0, 0.5, K);\\n  const vec3 c = vec3(K, 0.0, 0.5);\\n  const vec3 ab1 = b - a; // values chosen so edge length is 1\\n  const vec3 n1 = normalize(cross(a, b));\\n  const vec3 n2 = normalize(cross(b, c));\\n  const vec3 n3 = normalize(cross(c, a));\\n  const vec3 xyz1 = normalize(vec3(1.0));\\n  // for edge-length 1\\n  const float INSCRIBED_SPHERE_RADIUS = 0.7557613141;\\n\\n  // we use a rotation where the icosahedron is symmetric\\n  // in all three coordinate planes, and reduce the problem\\n  // to the +++ octant\\n  p = abs(p);\\n\\n  // there is one complete triangle in the +++ octant\\n  // mirror on planes which go through origin and the\\n  // complete triangles sides.\\n  if (dot(p, n1) < 0.0) {\\n    p += -2.0 * dot(p, n1) * n1;\\n  }\\n  if (dot(p, n2) < 0.0) {\\n    p += -2.0 * dot(p, n2) * n2;\\n  }\\n  if (dot(p, n3) < 0.0) {\\n    p += -2.0 * dot(p, n3) * n3;\\n  }\\n\\n  // rotate space around (1,1,1) vector so that all sides of the triangle\\n  // end up mapped on the ab side.\\n  vec3 dirs = vec3(-dot(n1, p), -dot(n2, p), -dot(n3, p));\\n  if (dirs.y > dirs.x && dirs.y > dirs.z) {\\n    p = p.yzx;\\n  } else if (dirs.z > dirs.x && dirs.z > dirs.y) {\\n    p = p.zxy;\\n  }\\n\\n  // check if the point is directly (perpendicular) above the triangle.\\n  // as we have rotated the space, we only need to check if it is\\n  // inside one edge.\\n  vec3 midAB = (a + b) / 2.0;\\n  vec3 pn = normalize(c - midAB);\\n  float w = dot(midAB, pn);\\n  if (dot(p, pn) > w * s) {\\n    // if not, return the distance to the plane the triangle is in\\n    return dot(xyz1, p) - INSCRIBED_SPHERE_RADIUS * s;\\n  }\\n\\n  // project the point onto segment ab, and return the distance to it\\n  float d3 = dot(ab1, p);\\n  d3 = clamp(d3, -0.5 * s, 0.5 * s);\\n  vec3 closestp = midAB * s + d3 * ab1;\\n  return distance(closestp, p);\\n}\\n// #pragma glslify: export(sdIcosahedron)\\n\\n// END ../common/sdf3d/sdIcosahedron.glsl\\n// START ../common/sdf3d/sdOctahedron.glsl\\nfloat sdOctahedron(float s, vec3 p) {\\n  p = abs(p);\\n  float m = p.x + p.y + p.z - s;\\n  vec3 q;\\n  if (3.0 * p.x < m) q = p.xyz;\\n  else if (3.0 * p.y < m) q = p.yzx;\\n  else if (3.0 * p.z < m) q = p.zxy;\\n  else return m * 0.57735027;\\n\\n  float k = clamp(0.5 * (q.z - q.y + s), 0.0, s);\\n  return length(vec3(q.x, q.y - s + k, q.z - k));\\n}\\n// #pragma glslify: export(sdOctahedron)\\n\\nfloat sdOctahedron(vec3 p, float s) {\\n  p = abs(p);\\n\\n  float m = p.x + p.y + p.z - s;\\n  //find point on octohedron surf nearest to p\\n  vec3 projPoint = p - vec3(0.333333 * m); //project onto surface plane\\n  //now push projected point, if outside triangle edge, perpendicular to edge, to edge\\n  vec3 toMove = min(projPoint, 0.0); //if projpoint.x<0 move along (1.0,-0.5,-0.5) , etc\\n  float toMoveSum = dot(toMove, vec3(1.0)); //which is basically along (1.5,0,0) then vec3(-0.5)\\n\\n  vec3 movedPoint = projPoint + toMove * vec3(-1.5) + toMoveSum * vec3(0.5); //better to multiply toMove by a matrix (1s diagonal, 0.5 other)?\\n\\n  movedPoint = max(movedPoint, 0.0); //cap x,y,z to 0 then\\n  movedPoint *= s / dot(movedPoint, vec3(1.0)); //scale about 0,0,0\\n\\n  return length(p - movedPoint);\\n}\\n\\n// END ../common/sdf3d/sdOctahedron.glsl\\n// START ../common/sdf3d/sdPyramid.glsl\\n// Pyramid with tip at (0,0,0), up = z\\n// c is the bottom corner. c.xy should be positive, c.z negative.\\nvec2 sdPyramid(vec3 c, vec3 p) {\\n  // pyramid is symmetric in XZ and YZ planes\\n  p.xy = abs(p.xy);\\n  bool flip = p.y * c.x > p.x * c.y; // p.y/p.x > c.y/c.x\\n  c.xy = flip ? c.yx : c.xy;\\n  p.xy = flip ? p.yx : p.xy;\\n  vec3 cc = c / dot(c, c);\\n  vec3 qx1 = normalize(vec3(-c.z, 0.0, c.x));\\n  vec3 pOnQx = p - qx1 * dot(p, qx1);\\n  float dx = dot(p, qx1);\\n  float maxY = c.y * (pOnQx.x / c.x);\\n  if (p.z <= c.z || pOnQx.z <= c.z) {\\n    if (p.x <= c.x) {\\n      // vertically underneath pyramid\\n      return vec2(-p.z + c.z, 2.0);\\n    } else {\\n      float aa = distance(p, vec3(c.x, min(c.y, p.y), c.z));\\n      return vec2(aa, 3.0);\\n    }\\n  } else if (pOnQx.y > maxY || pOnQx.z > 0.0) {\\n    float xx = dot(cc, p);\\n    float aa = length(p - clamp(xx, 0.0, 1.0) * c);\\n\\n    return vec2(aa, 1.0);\\n  } else {\\n    // need max for negativ values above base\\n    return vec2(max(dx, -p.z + c.z), 0.0);\\n  }\\n}\\n\\n// #pragma glslify: export(sdPyramid)\\n\\n\\n// END ../common/sdf3d/sdPyramid.glsl\\n// START ../common/sdf3d/sdSphere.glsl\\nfloat sdSphere(float radius, vec3 p) {\\n  return length(p) - radius;\\n}\\n\\n// #pragma glslify: export(sdSphere)\\n\\n\\n// END ../common/sdf3d/sdSphere.glsl\\n// START ../common/sdf3d/sub.glsl\\nfloat sub(float from, float what) {\\n  return max(from, -what);\\n}\\n\\n// #pragma glslify: export(sub)\\n\\n\\n// END ../common/sdf3d/sub.glsl\\n\\nuniform sampler2D texture;\\nuniform float secs;\\nuniform mat4 lll;\\nuniform mat4 llli;\\nuniform vec4 colorPrimary;\\nuniform vec4 colorSecondary;\\nuniform vec4 colorBackground;\\nuniform float a;\\nuniform float b;\\nuniform float c;\\nuniform float d;\\nuniform float highResTimeStamp;\\nuniform int bandCount;\\nuniform vec3 campos;\\nin float n;\\nin vec2 coord;\\nout vec4 fragColor;\\n\\n\\nconst vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\\nconst vec4 yellow = vec4(1.0, 1.0, 0.0, 1.0);\\nconst vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\\nconst vec4 blue = vec4(0.0, 0.0, 1.0, 1.0);\\nconst vec4 purple = vec4(0.5, 0.0, 0.5, 1.0);\\nconst vec4 red = vec4(1.0, 0.0, 0.0, 1.0);\\n\\nstruct RMHit {\\n  float distance;\\n  vec4 color;\\n};\\nRMHit mixa(RMHit a, RMHit b, float t) {\\n  return RMHit(mix(a.distance, b.distance, t), mix(a.color, b.color, t));\\n}\\nfloat skybox(vec3 p) {\\n  return 32.0 - max3(abs(p));\\n}\\n\\nfloat perlinSphere(float radius, vec3 p) {\\n  vec3 cp = normalize(p);\\n  float alpha = atan(cp.y, cp.x);\\n  float beta = asin(cp.z);\\n  return length(p) -\\n  radius +\\n  0.1 *\\n    perlin2D(vec2(0.0 / 100.0, 0.0) + (vec2(5.0) + vec2(alpha, beta)) * 8.0);\\n}\\n\\nfloat cylCircle(vec3 p) {\\n  float d = 10e9;\\n  for (int i = 0; i < 10; i++) {\\n    d = min(\\n      d,\\n      sdCylinder(0.2, 2.0, p + fromPolar(3.0, TAU * float(i) / 10.0, 1.0))\\n    );\\n  }\\n\\n  return d;\\n}\\n\\nfloat rblock(float r, vec3 p) {\\n  return sdBox(vec3(r), p);\\n}\\n\\nRMHit add(RMHit a, RMHit b) {\\n  //    return a.distance < b.distance\\n  //        ? RMHit(a.distance, a.color)\\n  //        : RMHit(b.distance, b.color);\\n  return mixa(a, b, float(b.distance < a.distance));\\n}\\n\\nfloat wtf(vec3 p) {\\n  vec3 center = p - mod(p, 3.0) + vec3(1.5);\\n  return rblock(0.4 + 0.3 * sin(secs + center.x), p - center);\\n}\\n\\nRMHit addFillet(float r, RMHit a, RMHit b) {\\n  if (a.distance < r && b.distance < r) {\\n    return RMHit(\\n      r - distance(vec2(a.distance, b.distance), vec2(r)),\\n      mix(a.color, b.color, (a.distance - b.distance) / r * 0.5 + 0.5)\\n    );\\n  } else {\\n    return add(a, b);\\n  }\\n}\\n\\nRMHit addFillet(float r, RMHit a, RMHit b, vec4 tilletColor) {\\n  if (a.distance < r && b.distance < r) {\\n    return RMHit(\\n      r - distance(vec2(a.distance, b.distance), vec2(r)),\\n      tilletColor\\n    );\\n  } else {\\n    return add(a, b);\\n  }\\n}\\nRMHit addFillet2(float r, RMHit a, RMHit b) {\\n  float h = smoothstep(-r, r, a.distance - b.distance);\\n  return RMHit(\\n    mix(a.distance, b.distance, h) - r * h * (1.0 - h),\\n    mix(a.color, b.color, h)\\n  );\\n}\\n\\nRMHit neg(RMHit a) {\\n  return RMHit(-a.distance, a.color);\\n}\\nRMHit sub(RMHit from, RMHit what) {\\n  RMHit whatNeg = neg(what);\\n  return mixa(from, whatNeg, float(whatNeg.distance > from.distance));\\n}\\n\\nvec3 modv(vec3 v, vec3 dir1, float y) {\\n  float t = dot(v, dir1);\\n  return v - floor(t / y) * y * dir1;\\n}\\nvec3 modRotZ(vec3 p, float count) {\\n  vec2 polarXY = toPolar(p.xy);\\n  return fromPolar(polarXY.x, mod(polarXY.y, TAU / count), p.z);\\n}\\n\\nfloat sin01(float x) {\\n  return 0.5 + 0.5 * sin(x);\\n}\\nfloat cos01(float x) {\\n  return 0.5 + 0.5 * cos(x);\\n}\\n\\nfloat betterBox(vec3 r, vec3 p) {\\n  vec3 q = abs(p) - r;\\n  return length(max(q, 0.0)) + min(max3(q), 0.0);\\n  p = abs(p);\\n  return max3(p - r);\\n}\\n\\nfloat roundedBlock(vec3 r, float cr, vec3 p) {\\n  return betterBox(r - vec3(cr), p) - cr;\\n}\\n\\nfloat sdCapsule(vec3 a, vec3 b, float r, vec3 p) {\\n  vec3 pa = p - a;\\n  vec3 ba = b - a;\\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\\n  return length(pa - ba * h) - r;\\n}\\nfloat sdEllipsoidB(vec3 r, vec3 p) {\\n  float k0 = length(p / r);\\n  float k1 = length(p / (r * r));\\n  return k0 * (k0 - 1.0) / k1;\\n}\\nfloat sdOctahedronB(float s, vec3 p) {\\n  p = abs(p);\\n  return (p.x + p.y + p.z - s) * 0.57735027;\\n}\\nfloat donutc(float r0, float r1, vec3 p) {\\n  vec3 closestCenter = vec3(normalize(p.xy) * r0, 0.0);\\n  return distance(closestCenter, p) - r1;\\n}\\n\\nfloat sdCappedCylinder(float h, float r, vec3 p) {\\n  vec2 d = vec2(length(p.xy), abs(p.z)) - vec2(r, h);\\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\\n}\\nfloat smoothmin(float r, float a, float b) {\\n  float h = smoothstep(-r, r, a - b);\\n  return mix(a, b, h) - r * h * (1.0 - h);\\n}\\nfloat queen(vec3 p) {\\n  float lxy = length(p.xy);\\n  float d;\\n  d = lxy - 1.1;\\n  d += 0.16 * p.z;\\n  d -= -c * (1.0 - pow(sin01(b + p.z * 2.5), 1.5));\\n  d += 0.1 * normalize(p.xy).x * smoothstep(2.0, 0.5, p.z);\\n  d +=\\n    0.02 * sin(15.0 * atan(p.y, p.x) - p.z * 5.0) * smoothstep(2.0, 0.5, p.z);\\n  //    float d = sdCappedCylinder(a, b, p);\\n  d = max(d, -p.z);\\n  d = max(d, p.z - 4.0);\\n\\n  float head = sdSphere(0.55, p - vec3(0.0, 0.0, 4.4));\\n  d = smoothmin(0.15, d, head);\\n  float crown = sdCone(\\n    fromPolar(vec2(1.0, 1.15)),\\n    1.0,\\n    -(p - vec3(0.0, 0.0, 4.5)).yzx\\n  );\\n  d = min(d, crown);\\n  d *= 0.5;\\n  return d;\\n}\\n\\nvec2 project(vec2 a, vec2 onto1) {\\n  return onto1 * (dot(a, onto1) / dot(onto1, onto1));\\n}\\n\\nvec3 reject(vec3 a, vec3 b1) {\\n  return a - b1 * dot(a, b1);\\n}\\n\\nRMHit sdf(vec3 p) {\\n  const vec4 red = vec4(0.2, 0.0, 0.0, 1.0);\\n  //  RMHit d = RMHit(block(vec3(-1.0, -1.0, -1.0), vec3(1.0, 1.0, 1.0), p), black);\\n  //    RMHit d = RMHit(sphere(2., p), black);\\n  //    RMHit d = RMHit(betterBox(vec3(1.), p), black);\\n  //    RMHit d = RMHit(roundedBlock(vec3(1.), 0.1, p), black);\\n  //    RMHit d = RMHit(donut(2., 0.5, p), black);\\n  //    RMHit d = RMHit(sdCapsule(vec3(-a,-a,0.), vec3(a,a,0.), b, p), black);\\n  //    RMHit d = RMHit(sdEllipsoidB(vec3(-a,-b,1.), p), black);\\n  //    RMHit d = RMHit(sdOctahedron(1., p)-a, red) ;\\n  //    RMHit d = RMHit(queen(p), black) ;\\n  //    RMHit d = RMHit(lego(p), black) ;\\n  //- vec3(0.0, 0.0, 1.0)\\n  vec3 h = vec3(0.5, 0.0, 0.0);\\n  vec3 q = abs(p) - h;\\n  //    vec2 pyr = sdPyramid(\\n  //        vec3(2.0, 2.0, -2.0),\\n  //        opElongate(h,\\n  //            rotZ(highResTimeStamp/1000.) *\\n  //                rotX(c) *\\n  //                opRepLim(p - vec3(-8., -8., 2.), vec3(8.), vec3(2., 2., 0.))));\\n  vec3 p2 = rotX(highResTimeStamp * 0.0) * p;\\n  vec2 xx = vec2(sdIcosahedron(d, p2) - c, 1.0);\\n  vec4 cc = red;\\n  cc.xyz = cc.xyz * xx.y * 0.1;\\n  RMHit d = RMHit(xx.x, cc);\\n  //    RMHit d = RMHit(sdCone(fromPolar(vec2(1., a)), b, p.yzx - vec3(0.,2., 0.)), black);\\n  //    d.distance = abs(d.distance) - 0.4;\\n  //    d.distance = abs(d.distance) - 0.1;\\n  //    d.distance = abs(d.distance) - 0.02;\\n  float s = length(p - vec3(1.0, 1.0, 0.0)) - 1.0;\\n  //    d.distance = s;\\n  //    d.distance = max(d.distance, -s);\\n\\n  vec3 color = 0.1 * sin(abs(vec3(0.0, PI, 0.0) + vec3(d.distance * PI * 2.0)));\\n  //    color.z = .1*xx.y;\\n  RMHit base = RMHit(sdBox(vec3(10.0, 10.0, 0.0), p), vec4(color, 1.0));\\n\\n  //    d = base;\\n  d = add(base, d);\\n  if (b > 1.0) {\\n    d = base;\\n  }\\n  //    d.distance *=0.5;\\n  return d;\\n}\\nfloat sdff(vec3 p) {\\n  return sdf(p).distance;\\n}\\nfloat ambientOcclusion(vec3 pWC, vec3 n1WC) {\\n  float k = 1.0;\\n  float distance = sdff(pWC + n1WC * k);\\n  return clamp(distance / k, 0.0, 1.0);\\n}\\n\\nstruct RMResult {\\n  float distance;\\n  vec3 pos;\\n  vec4 color;\\n};\\nRMResult raymarching2(vec3 start, vec3 dir1) {\\n  vec3 pos = start;\\n  RMHit hit;\\n  for (int i = 0; i < 200; i++) {\\n    hit = sdf(pos);\\n    if (hit.distance < 0.0001 * hit.distance) break;\\n    pos = pos + dir1 * hit.distance;\\n  }\\n  return RMResult(hit.distance, pos, hit.color);\\n}\\n\\nfloat softshadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {\\n  float res = 1.0;\\n  float t = 0.1;\\n  for (int i = 0; i < 1000 && t < maxt; i++) {\\n    float h = sdff(ro + rd * t);\\n    if (h < 0.001) return 0.0;\\n    res = min(res, k * h / t);\\n    t += h;\\n  }\\n  return res;\\n}\\n\\nconst float eps = 1e-4;\\nvec3 sdfNormal1(vec3 p, float d) {\\n  return normalize(\\n    vec3(\\n      sdff(p + vec3(eps, 0.0, 0.0)),\\n      sdff(p + vec3(0.0, eps, 0.0)),\\n      sdff(p + vec3(0.0, 0.0, eps))\\n    ) -\\n      vec3(sdff(p))\\n  );\\n}\\n\\n//layout (depth_greater) out float gl_FragDepth;\\nvoid main() {\\n  vec3 light = normalize(vec3(-1.0, -2.0, -2));\\n\\n  vec3 a = vec3(coord, -1.0);\\n  vec3 b = vec3(coord, 1.0);\\n  vec3 aWC = transform(llli, a);\\n  vec3 bWC = transform(llli, b);\\n  vec3 lookDir1 = normalize(bWC - aWC);\\n\\n  RMResult hitWC = raymarching2(aWC, lookDir1);\\n  vec3 hitn1 = sdfNormal1(hitWC.pos, hitWC.distance);\\n  float dWC = distance(aWC, hitWC.pos);\\n  vec3 hitNDC = transform(lll, hitWC.pos);\\n  vec3 p = hitWC.pos;\\n  float inSun = softshadow(\\n    hitWC.pos + hitn1 * 0.05,\\n    -light,\\n    0.0001,\\n    300.0,\\n    8.0\\n  );\\n  //    float inSun=1.;\\n\\n  vec3 material = hitWC.color.xyz;\\n  if (dWC > 100.0) {\\n    material = vec3(0.0, 0.0, 0.0);\\n    //    } else if (p.z >= 0.001) {\\n    //        material = vec3(0.2, 0.0, 0.0);\\n    //    } else {\\n    //        vec2 c = vec2(4.0, 2.0);\\n    //        vec2 id = floor(((p.xy - c * 0.5) / c) );\\n    //        material += .15 * cos(vec3(id.x, id.y + 2., id.x + id.y + 4.));\\n  }\\n\\n  const vec3 sunlightColor = vec3(8.0, 6.0, 1.0);\\n\\n  float aOcc = ambientOcclusion(hitWC.pos, hitn1);\\n\\n  vec3 reflectionDirection = reflect(light, hitn1);\\n\\n  vec3 color = vec3(0.0);\\n  color += material * aOcc;\\n  color += inSun * sunlightColor * material * max(0.0, dot(-light, hitn1));\\n  //    color = (hitn1);\\n\\n  vec3 camPos = aWC;\\n\\n  vec3 eyeDirection = -lookDir1;\\n  float uMaterialShininess = 256.0;\\n  float specularLightWeighting = pow(\\n    max(dot(reflectionDirection, eyeDirection), 0.0),\\n    uMaterialShininess\\n  );\\n  color += specularLightWeighting;\\n  //    float lightIntensity = 0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.);\\n  //    float lightIntensity =\\n  //        0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.) + 0.3*specularLightWeighting;\\n  //    fragColor = visualize(blue, red, mix(0.5, 1.0, inSun) * lightIntensity);\\n  //    fragColor = mix(hitWC.color, colorBackground, mix(0.5, 1.0, inSun) * clamp(lightIntensity, 0., 1.));\\n  color = pow(color, vec3(1.0 / 2.2)); // gamma correction\\n  fragColor = vec4(color, 1.0);\\n}\\n\"\nconst sourceMap = {\"version\":3,\"sources\":[\"/home/runner/work/workshop/workshop/src/raymarch/sdf.frag\",\"/home/runner/work/workshop/workshop/src/common/banded.glsl\",\"/home/runner/work/workshop/workshop/src/common/between.glsl\",\"/home/runner/work/workshop/workshop/src/common/max3.glsl\",\"/home/runner/work/workshop/workshop/src/common/constants.glsl\",\"/home/runner/work/workshop/workshop/src/common/hexFns.glsl\",\"/home/runner/work/workshop/workshop/src/common/matrices.glsl\",\"/home/runner/work/workshop/workshop/src/common/perlin2DTexture.glsl\",\"/home/runner/work/workshop/workshop/src/common/unmix.glsl\",\"/home/runner/work/workshop/workshop/src/common/fromPolar.glsl\",\"/home/runner/work/workshop/workshop/src/common/toPolar.glsl\",\"/home/runner/work/workshop/workshop/src/common/polar.glsl\",\"/home/runner/work/workshop/workshop/src/common/remix.glsl\",\"/home/runner/work/workshop/workshop/src/common/transform.glsl\",\"/home/runner/work/workshop/workshop/src/common/visualize.glsl\",\"/home/runner/work/workshop/workshop/src/common/waves.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/add.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf2d/addChamfer.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf2d/addFillet.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/opElongate.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/opRepLim.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdBox.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdCone.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdCylinder.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdTorus.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdIcosahedron.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdOctahedron.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdPyramid.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdSphere.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sub.glsl\"],\"names\":[],\"mappings\":\"AAAA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AfOA;;AgBhBA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACVA;AACA;AACA;AACA;AACA;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;;A7ByBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA\"}\nexport { sourceMap };\n","\nexport default \"#version 300 es\\n\\nprecision highp float;\\n\\n// START ../common/visualize.glsl\\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\\n  float isLow = float(t < 0.0);\\n  float isHigh = float(t > 1.0);\\n  float isMid = 1.0 - isLow - isHigh;\\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\\n}\\n\\nvec4 visualize(float t) {\\n  const vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\\n  const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\\n  return visualize(BLUE, RED, t);\\n}\\n\\n// #pragma glslify: export(visualize)\\n\\n\\n// END ../common/visualize.glsl\\n// START ../common/banded.glsl\\nfloat banded(float bandCount, float t) {\\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\\n}\\nfloat banded(int bandCount, float t) {\\n  return banded(float(bandCount), t);\\n}\\n\\n// #pragma glslify: export(banded)\\n\\n\\n// END ../common/banded.glsl\\n\\nuniform vec4 color;\\n\\nout vec4 fragColor;\\n\\nvoid main() {\\n  fragColor = color;\\n}\\n\"\nconst sourceMap = {\"version\":3,\"sources\":[\"/home/runner/work/workshop/workshop/src/raymarch/singleColor.frag\",\"/home/runner/work/workshop/workshop/src/common/visualize.glsl\",\"/home/runner/work/workshop/workshop/src/common/banded.glsl\"],\"names\":[],\"mappings\":\"AAAA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AFHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA\"}\nexport { sourceMap };\n","\nexport default \"#version 300 es\\nprecision highp float;\\n\\nuniform mat4 ts_ModelViewProjectionMatrix;\\nuniform float normalOffset;\\nin vec3 ts_Normal;\\nin vec4 ts_Vertex;\\n\\nvoid main() {\\n  gl_Position =\\n    ts_ModelViewProjectionMatrix *\\n    (ts_Vertex + normalOffset * vec4(ts_Normal, 0.0));\\n}\\n\"\nconst sourceMap = {\"version\":3,\"sources\":[\"/home/runner/work/workshop/workshop/src/raymarch/singleColor.vert\"],\"names\":[],\"mappings\":\"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA\"}\nexport { sourceMap };\n"],"names":["BoundNumberField","state","prop","setStatePartial","props","variant","size","type","value","onChange","e","target","label","FPSController","__init","this","count","__init2","lastTime","performance","now","constructor","notify","window","prototype","call","tick","time","fps","Math","floor","parseHash","hash","substring","split","map","part","key","decodeURIComponent","reduce","obj","objectToHash","o","Object","entries","encodeURIComponent","join","defaultDeserialize","x","v","NaN","isNaN","console","error","defaultSerialize","useHashState","initialState","deserialize","serialize","wait","createInitialState","useCallback","mergedState","assign","document","location","history","pushState","undefined","title","setState","useState","updateHashRef","useRef","current","newState","useEffect","onHashChange","addEventListener","removeEventListener","PAPER_SIZES_A","PAPER_SIZES_C","PAPER_SIZES","PaperSizeFromString","str","byName","find","name","a","b","PaperSizeFromDimensions","sort","lhs","y","rhsFn","PaperSizeToString","PAPER_SIZE_A4","INCH","fmtdeg","radiusFromSideWidth","sides","sideWidth","sin","sideWithFromRadius","radius","centerToSideFromSideWidth","tan","radiusFromCenterToSide","centerToSide","cos","sideWidthFromCenterToSide","RegularPolygon","startAngle","sideLength","Error","V3","polar","d","dTpl","i","RotStep","id","children","stepDeg","xlinkHref","transform","strings","exps","format","Array","isArray","result","length","openInNewTab","url","newWindow","open","opener","_optionalChain","ops","lastAccessLHS","op","fn","args","FlyCameraController","lastPos","O","pressedKeys","__init3","pauseCam","lockUp","__init4","__init5","__init6","__init7","m","M4","copy","registerListeners","mouseMoveTarget","keyUpDownTarget","_3","unregister","_4","mousemove","keydown","keyup","unregisterListeners","_5","_6","speed","q","Control","w","s","likeO","translate","toLength","_7","_8","pagePos","V","pageX","pageY","delta","to","buttons","rot","rotateY","rotateX","times","_9","_10","preventDefault","getLookAt","static","inverse","transposed","scale","eye","transformVector","getTranslation","dir","Z","up","Y","negated","lookAt","posFactor","coordString","f","z","invertLookAt","unit","cam","coord","sp","posStr","lookDirStr","upStr","plus","ACTIONS","OrbitCameraController","zoomIn","zoomOut","left","right","down","udRot","dist","keys","__init8","__init9","__init10","__init11","__init12","log","toOrbitCameraState","atan","lengthXY","angleXY","wheel","blur","dDist","dRot","newUDRot","PI","ss","_11","_12","stopImmediatePropagation","newDist","deltaY","_13","_14","action","rotateZ","udRotStr","rotStr","distStr","X_RED","gl","Y_GREEN","Z_BLUE","HIGHLIGHT","L3X","anchor","dir1","X","L3Y","L3Z","EGizmoController","meshes","highlight","offsetGC","dragging","pos","onHover","onStartDragging","onStopDragging","vector","rotation","computeNormalsFromFlatTriangles","compile","rotateBaseVerticesTM","rotater","transformPoint","drawVector","shader","pushMatrix","vT","getPerpendicular","multMatrix","forSys","cross","draw","popMatrix","render","enable","CULL_FACE","cullFace","BACK","FRONT","uniforms","color","normalOffset","rotate","getCameraMatrix","mousedown","mouseup","offsetX","offsetY","boundingClientRect","getBoundingClientRect","width","mouseLineWC","canvas","projectionMatrix","ndc1","height","ndc2","inverseProjectionMatrix","inversed","minus","getMouseLine","info","infoClosestToLine","offsetWC","targetPos","lineClosest","gizmoInverse","lineGC","lp","measure","l","at","lineT","distanceTo","thClosest","lastHighlight","t","th","line","eq","abs","dot","isParallelToLine","distance","c","bd","bb","squared","dd","ca","divisor","thT","buildShaders","sdf","create","singleColor","raymarchSetup","makeCurrent","planeMesh","plane","startX","startY","coords","shaders","raymarchRender","modelView","colors","dynamicState","extra","llli","colorPrimary","primary","colorSecondary","secondary","colorBackground","background","highResTimeStamp","secs","gradients","lll","MatrixDisplay","onFocus","onBlur","OutlinedInput","inputComponent","toString","makeShader","desc","di","float","n","includes","vec3","input","output","makePart","gen","g","r0","r1","prevInput","by","prevOutput","subf","subinput","suboutput","what","SphereEditor","onRadiusChange","ev","TextField","inputProps","BoxEditor","newRadius","style","display","Vec3Editor","ExpandEditor","onByChange","gizmoControl","onElChange","newValue","slice","gizmoClick","take","Button","onClick","TranslateEditor","newBy","DonutEditor","OctahedronEditor","AddEditor","onTypeChange","onWhatChange","newWhat","Select","MenuItem","Ed","onItemChange","oldValue","PEd","sphere","expand","add","sub","box","donut","octahedron","canvasRef","renderProgress","setRenderProgress","gp","setGp","IDENTITY","resolution","setResolution","gpFocused","setGpFocused","setPart","setFps","dynamic","raymarchRef","model","setModel","theme","useTheme","useMemo","palette","default","main","async","URL","createObjectURL","setup","onProgress","_","createElement","step","SCISSOR_TEST","shared","donePixels","scissorWidth","min","scissorHeight","scissor","_2","Promise","resolve","reject","toBlob","blob","renderHighRes","product","perspective","fromShortString","tsgl","alpha","premultipliedAlpha","throwOnError","getParameter","MAX_SAMPLES","onFPSChange","triggerRender","onCamChange","setExtra","startShader","camController","camMatrix","eGizmoController","clearColor","clear","COLOR_BUFFER_BIT","pointSize","disable","DEPTH_TEST","BLEND","blendFunc","ONE","blendEquation","FUNC_ADD","contentEditable","focus","fpsController","updateShader","newShader","ed","teardown","animate","_diff","offsetWidth","offsetHeight","matrixMode","PROJECTION","loadMatrix","MODELVIEW","loadIdentity","setCam","raymarch","debounce","toShortString","replace","RenderButton","dim","disabled","aesthetically","padStart","Grid","container","item","xs","md","ref","cursor","tabIndex","sx","flexDirection","padding","alignItems","gap","Card","CardContent","setEditing"],"sourceRoot":""}