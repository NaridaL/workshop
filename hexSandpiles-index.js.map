{"version":3,"file":"hexSandpiles-index.js","mappings":"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","sources":["/dev/workshop/./src/hexSandpiles/directVS.vert?","/dev/workshop/./src/hexSandpiles/HexSandpiles.tsx?","/dev/workshop/./src/hexSandpiles/FS.frag?","/dev/workshop/./src/hexSandpiles/step.frag?","/dev/workshop/./src/hexSandpiles/index.tsx?"],"sourcesContent":["\nexport default \"#version 300 es\\nin vec4 ts_Vertex;\\nin vec2 ts_TexCoord;\\nout vec2 coord;\\nvoid main() {\\n  coord = ts_TexCoord.xy;\\n  gl_Position = ts_Vertex;\\n}\\n\"\nconst sourceMap = {\"version\":3,\"sources\":[\"/home/runner/work/workshop/workshop/src/hexSandpiles/directVS.vert\"],\"names\":[],\"mappings\":\"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA\"}\nexport { sourceMap };\n"," function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }import * as chroma from \"chroma.ts\"\nimport { load } from \"opentype.js\"\nimport * as React from \"react\"\nimport { useEffect, useMemo, useRef } from \"react\"\nimport sleep from \"sleep-promise\"\nimport { M4, V } from \"ts3dutils\"\nimport { Mesh, Shader, Texture, TSGLContext } from \"tsgl\"\nimport directVS from \"./directVS.vert\"\nimport FS from \"./FS.frag\"\nimport oleo from \"./OleoScript-Bold.ttf\"\nimport stepFS from \"./step.frag\"\n\nconst makePlane = (x0, y0, x1, y1) => {\n  const plane = Mesh.plane({\n    startX: -1,\n    width: 2,\n    startY: -1,\n    height: 2,\n  })\n  plane.coords[0] = [x0, y0]\n  plane.coords[1] = [x1, y0]\n  plane.coords[2] = [x0, y1]\n  plane.coords[3] = [x1, y1]\n  plane.compile()\n  return plane\n}\nconst forEachNeighbor = async (\n  x,\n  y,\n  f,\n) => {\n  await f(x + 1, y)\n  await f(x - 1, y)\n  await f(x, y + 1)\n  await f(x, y - 1)\n  // +- 1, depending on even/odd row\n  await f(x + 1 - (y & 1) * 2, y + 1)\n  await f(x + 1 - (y & 1) * 2, y - 1)\n}\nconst andNeighbors = async (\n  x,\n  y,\n  f,\n) => {\n  await f(x, y)\n  await forEachNeighbor(x, y, f)\n}\n\n// https://www.redblobgames.com/grids/hexagons/#coordinates\n\n//       ODDR (odd-right) Coords\n// Y\n// ^ 0:2   1:2   2:2\n// |    0:1   1:1   2:0\n// | 0:0   1:0   2:0\n// +------------------> X\n\n//      Cube Coords\n//\n//\n//  -1:2:-1   0:2:-2   1:2:-3\n//        0:1:-1   1:1:-2   2:1:-3\n//   0:0:0    1:0:-1   2:0:-2\n//  --------------------> X\n\nconst SQRT3_2 = Math.sqrt(3) / 2\n\nexport const oddr_to_px = (col, row) => {\n  const x = col + 0.5 * (row & 1)\n  const y = row * SQRT3_2\n  return V(x, y, 0)\n}\nconst SINK = 255\n\nconst cube_distance = (\n  [x1, y1, z1],\n  [x2, y2, z2],\n) => (Math.abs(x2 - x1) + Math.abs(y2 - y1) + Math.abs(z2 - z1)) / 2\n\nconst oddr_distance = (x1, y1, x2, y2) =>\n  cube_distance(oddr_to_cube(x1, y1), oddr_to_cube(x2, y2))\n\nconst cube_to_oddr = ([x, y, z]) => {\n  const col = x + (y - (y & 1)) / 2\n  const row = y\n  return [col, row]\n}\nexport const oddr_to_cube = (col, row) => {\n  const x = col - (row >> 1)\n  const y = row\n  const z = -x - y\n  return [x, y, z]\n}\n\nconst loadFont = (url) =>\n  new Promise((resolve, reject) => {\n    load(url, (error, font) => (error ? reject(error) : resolve(font)))\n  })\n\nclass HexSand {\n  \n\n   constructor(\n      w,\n      h,\n  ) {;this.w = w;this.h = h;\n    this.data = new Uint8Array(w * h)\n  }\n\n  clone() {\n    const hs = new HexSand(this.w, this.h)\n    hs.plusHS(this)\n    return hs\n  }\n\n  dualize() {\n    for (let i = 0; i < this.h * this.w; i++) {\n      if (SINK !== this.data[i]) this.data[i] = 5 - this.data[i]\n    }\n    console.log(\"dualized\")\n  }\n\n  plus(x) {\n    for (let i = 0; i < this.h * this.w; i++) {\n      if (SINK !== this.data[i]) this.data[i] += x\n    }\n    console.log(\"plus \" + x)\n  }\n\n  times(x) {\n    for (let i = 0; i < this.h * this.w; i++) {\n      if (SINK !== this.data[i]) this.data[i] *= x\n    }\n    console.log(\"times \" + x)\n  }\n\n  setHS(o) {\n    for (let i = 0; i < this.h * this.w; i++) {\n      this.data[i] = o.data[i]\n    }\n  }\n\n  plusHS(o) {\n    for (let i = 0; i < this.h * this.w; i++) {\n      if (SINK !== this.data[i]) this.data[i] += o.data[i]\n    }\n  }\n\n  fill(n) {\n    for (let i = 0; i < this.h * this.w; i++) {\n      if (SINK !== this.data[i]) this.data[i] = n\n    }\n  }\n\n  fillf(f) {\n    for (let i = 0; i < this.h * this.w; i++) {\n      const x = i % this.w\n      const y = (i / this.w) | 0\n      if (SINK !== this.data[i]) this.data[i] = f(x, y, i, this.data[i])\n    }\n  }\n\n  getOddr(x, y) {\n    return this.data[y * this.w + x]\n  }\n\n  setOddr(x, y, value) {\n    return (this.data[y * this.w + x] = value)\n  }\n\n  addOddr(x, y, value) {\n    return (this.data[y * this.w + x] += value)\n  }\n\n  isSink(x, y) {\n    return this.getOddr(x, y) === SINK\n  }\n\n  drawHex(inner, outer, value) {\n    const cx = (this.w / 2) | 0\n    const cy = (this.h / 2) | 0\n    for (let i = 0; i < this.h * this.w; i++) {\n      const x = i % this.w\n      const y = (i / this.w) | 0\n      if (\n        inner <= oddr_distance(cx, cy, x, y) &&\n        oddr_distance(cx, cy, x, y) <= outer\n      ) {\n        this.data[i] = value\n      }\n    }\n  }\n\n  async drawText(\n    oddr_cx,\n    oddr_cy,\n    text,\n    fontSize,\n    value,\n  ) {\n    const font = await loadFont(oleo)\n    const path = font.getPath(text, 0, 0, fontSize)\n    const pathBB = path.getBoundingBox()\n    const c = V(oddr_cx, oddr_cy)\n    const pathBBSize = V(pathBB.x1, pathBB.y1).to(V(pathBB.x2, pathBB.y2))\n\n    console.log(\"path\", path)\n\n    const canvas = document.createElement(\"canvas\")\n    canvas.width = (pathBB.x2 - pathBB.x1) * 2\n    canvas.height = (pathBB.y2 - pathBB.y1) * 2\n    const context = canvas.getContext(\"2d\")\n    context.scale(2, 2)\n    context.translate(-pathBB.x1, -pathBB.y1)\n    context.fillStyle = \"black\"\n    context.imageSmoothingEnabled = false\n    // document.body.appendChild(canvas)\n    path.draw(context)\n    // canvas.setAttribute(\"d\", path)\n\n    // const svg = document.createElementNS(\"http://www.w3.org/2000/svg\",\n    // \"svg\") svg.setAttribute(\"fill\", \"black\") svg.setAttribute(\"width\",\n    // \"400\") svg.setAttribute(\"height\", \"100\") svg.appendChild(canvas)\n    // document.body.appendChild(svg)\n    const offset = oddr_to_px(oddr_cx, oddr_cy).minus(pathBBSize.div(2))\n    const p = context.getImageData(0, 0, canvas.width, canvas.height).data\n    for (let i = 0; i < this.h * this.w; i++) {\n      const x = i % this.w\n      const y = (i / this.w) | 0\n      const px = oddr_to_px(x, y).minus(offset)\n      if (\n        0 < px.x &&\n        px.x < pathBB.x2 - pathBB.x1 &&\n        0 < px.y &&\n        px.y < pathBB.y2 - pathBB.y1\n      ) {\n        if (\n          p[(((px.y * 2) | 0) * canvas.width + ((px.x * 2) | 0)) * 4 + 3] > 127\n        ) {\n          this.data[i] = value\n        }\n      }\n    }\n  }\n\n  drawTriangle(inner, outer, value) {\n    const cx = (this.w / 2) | 0\n    const cy = (this.h / 2) | 0\n\n    for (let i = 0; i < this.h * this.w; i++) {\n      const x = i % this.w\n      const y = (i / this.w) | 0\n      const d = Math.max(...oddr_to_cube(x - cx, y - cy))\n      if (inner <= d && d <= outer) {\n        this.data[i] = value\n      }\n    }\n  }\n\n  drawCircle(inner, outer, value) {\n    const cx = (this.w / 2) | 0\n    const cy = (this.h / 2) | 0\n    const c = oddr_to_px(cx, cy)\n\n    for (let i = 0; i < this.h * this.w; i++) {\n      const x = i % this.w\n      const y = (i / this.w) | 0\n      const d = oddr_to_px(x, y).distanceTo(c)\n      if (inner <= d && d <= outer) {\n        this.data[i] = value\n      }\n    }\n  }\n\n  drawRect(w, h, value) {\n    for (let i = 0; i < this.h * this.w; i++) {\n      const x = (i % this.w) - ((this.w / 2) | 0)\n      const y = ((i / this.w) | 0) - ((this.h / 2) | 0)\n      const cc = V(...oddr_to_cube(x, y))\n      if (\n        Math.abs(cc.x + (cc.y >> 1)) < w / 2 &&\n        Math.abs(cc.y) < h / 2 &&\n        Math.abs(cc.x) < w / 2 + 12 &&\n        Math.abs(cc.z) < w / 2 + 12\n      ) {\n        this.data[i] = value\n      }\n    }\n  }\n\n  async asyncStabilizeNoShader() {\n    let changed\n    do {\n      changed = 0\n      for (let i = 0; i < this.h * this.w; i++) {\n        const x = i % this.w\n        const y = (i / this.w) | 0\n\n        if (!this.isSink(x, y) && this.getOddr(x, y) >= 6) {\n          await forEachNeighbor(\n            x,\n            y,\n            async (x, y) => !this.isSink(x, y) && this.addOddr(x, y, 1),\n          )\n          this.addOddr(x, y, -6)\n          changed++\n        }\n      }\n      await sleep(10)\n    } while (changed !== 0)\n    console.log(\"stabilized\")\n    await sleep(2000)\n  }\n\n  \n\n\n\n\n\n\n\n\n\n   createTextures(\n    gl,\n    stepShader,\n  ) {\n    _optionalChain([this, 'access', _2 => _2.glInfo, 'optionalAccess', _3 => _3.gl]) === gl && (this.glInfo = undefined)\n    if (!this.glInfo) {\n      this.glInfo = {\n        gl,\n        t0: new Texture(this.w, this.h, {\n          filter: gl.NEAREST,\n          internalFormat: gl.R8UI,\n          format: gl.RED_INTEGER,\n        }),\n        t1: new Texture(this.w, this.h, {\n          filter: gl.NEAREST,\n          internalFormat: gl.R8UI,\n          format: gl.RED_INTEGER,\n        }),\n        stepPlane: makePlane(0, 0, this.w, this.h),\n        stepShader,\n      }\n    }\n    return this.glInfo.t0\n  }\n\n  async asyncStabilize() {\n    const glInfo = this.glInfo\n\n    this.upload()\n\n    while (this.countUnstable() > 0) {\n      for (let i = 0; i < 1000; i++) {\n        for (let ss = 0; ss < 1; ss++) {\n          glInfo.t1.drawTo((_gl) => {\n            glInfo.t0.bind(0)\n            glInfo.stepShader.uniforms({ heights: 0 }).draw(glInfo.stepPlane)\n          })\n          glInfo.t0.swapWith(glInfo.t1)\n        }\n      }\n      glInfo.t0.downloadData(this.data)\n    }\n  }\n\n  *stabilizeInteractive(frameSteps = 1) {\n    const glInfo = this.glInfo\n\n    this.upload()\n\n    while (this.countUnstable() > 0) {\n      for (let i = 0; i < 1000; i++) {\n        for (let ss = 0; ss < frameSteps; ss++) {\n          glInfo.t1.drawTo((_gl) => {\n            glInfo.t0.bind(0)\n            glInfo.stepShader.uniforms({ heights: 0 }).draw(glInfo.stepPlane)\n          })\n          glInfo.t0.swapWith(glInfo.t1)\n        }\n        yield\n      }\n      glInfo.t0.downloadData(this.data)\n    }\n  }\n\n  async calcHash() {\n    return Array.from(\n      new Uint8Array(await crypto.subtle.digest(\"SHA-1\", this.data)),\n    )\n      .map((b) => b.toString(16).padStart(2, \"0\"))\n      .join(\"\")\n  }\n\n  countUnstable() {\n    let unstable = 0\n    for (let i = 0; i < this.w * this.h; i++)\n      unstable += +(SINK !== this.data[i] && this.data[i] >= 6)\n    return unstable\n  }\n\n  async calcRecurringInverse() {\n    this.plus(10)\n    await this.asyncStabilize()\n    this.dualize()\n    this.plus(5)\n    await this.asyncStabilize()\n  }\n\n  async calcRecurringIdentity() {\n    this.fill(10)\n    await this.asyncStabilize()\n    this.dualize()\n    this.plus(5)\n    await this.asyncStabilize()\n  }\n\n  upload() {\n    this.glInfo.t0.setData(this.data)\n  }\n\n  getOddrBB() {\n    const rowEmpty = (y) => {\n      for (let x = 0; x < this.w; x++)\n        if (this.data[y * this.w + x] !== SINK) return false\n      return true\n    }\n    let y0 = 0\n    let y1 = this.h\n    while (y0 < this.h && rowEmpty(y0)) y0++\n    while (y1 > 0 && rowEmpty(y1 - 1)) y1--\n    const colEmpty = (x) => {\n      for (let y = y0; y < y1; y++)\n        if (this.data[y * this.w + x] !== SINK) return false\n      return true\n    }\n    let x0 = 0\n    let x1 = this.w\n    while (x0 < this.h && colEmpty(x0)) x0++\n    while (x1 > 0 && colEmpty(x1 - 1)) x1--\n    return {\n      x0,\n      x1,\n      y0,\n      y1,\n    }\n  }\n\n  getBB() {\n    const { x0, x1, y0, y1 } = this.getOddrBB()\n    return {\n      min: oddr_to_px(x0, y0),\n      max: oddr_to_px(x1, y1),\n    }\n  }\n}\n\nasync function setup(\n  canvas,\n  colorsFg,\n  colorBackground,\n) {\n  const gl = TSGLContext.create({\n    canvas,\n    throwOnError: false,\n  }) \n\n  console.log(\"gl\", gl)\n\n  gl.addResizeListener()\n\n  // gl.enable(gl.SAMPLE_COVERAGE);\n  // gl.sampleCoverage(0.5, false);\n  console.log(gl.canvas.width, gl.canvas.height)\n\n  const shader = Shader.create(directVS, FS)\n  const stepShader = Shader.create(directVS, stepFS)\n\n  const field = new HexSand(256, 256)\n  const fieldTexture = field.createTextures(gl, stepShader)\n  const plane = makePlane(-1, -1, 1, 1)\n  const si = async (x) => {\n    for (const _ of field.stabilizeInteractive(x)) {\n      await sleep(16)\n    }\n  }\n\n  const aspect = gl.canvas.width / gl.canvas.height\n  gl.addResizeListener()\n  console.log(\"aspect\", aspect)\n\n  field.fill(SINK)\n  // field.data[1000] = 200\n  field.drawHex(0, 80, 0)\n  const fBB = field.getBB()\n  const fBBd = fBB.min.to(fBB.max)\n  const bbRatio = fBBd.x / fBBd.y\n  console.log(\"ratios\", aspect, bbRatio, \"\" + fBBd, fBB)\n  //   forSys(fBBd.schur(V3.X), fBBd.schur(V3.Y), V3.Z, fBB.min)\n  //     .inversed()\n  const mm = M4\n    // center AABB\n    .translate(fBB.min.plus(fBB.max).times(-1 / 2))\n    .scale(aspect < bbRatio ? 1 / fBBd.x : 1 / fBBd.y)\n    // add border\n    .scale(0.98)\n    .scale(2)\n    .scale(1, -1, 1)\n    .scale(1 / aspect, 1, 1)\n  //   field.drawRect(200, 100, 4)\n  // field.drawCircle(0, 50, 0)\n  // field.drawTriangle(50, 65, 0)\n  // field.drawTriangle(30, 45, 0)\n  // field.drawTriangle(10, 25, 0)\n  //   field.fill(10)\n\n  //   const base = field.clone()\n  const queryParam = (p) =>\n    new URL(\"\" + document.location).searchParams.get(p)\n\n  await field.calcRecurringIdentity()\n  //   field.upload()\n  //   return\n  field.fillf((_x, _y, _i, v) => (SINK === v ? SINK : 3 + (v % 3)))\n  //   field.drawRect(100, 50, 4)\n  const queryTextBase64 = queryParam(\"t\")\n  await field.drawText(\n    128,\n    128,\n    queryTextBase64 ? atob(queryTextBase64) : \"Hi!\",\n    25,\n    5,\n  )\n  //   field.upload()\n  //   return\n\n  //   field.fillf(() => (5 + Math.random() * 6) | 0)\n  //   await field.calcRecurringInverse()\n  //   await sleep(1000)\n  //   field.plusHS(base)\n  //   field.asyncStabilize()\n  //   console.log(\"random + (-random)\", await field.calcHash())\n  //   await sleep(1000)\n\n  //   create random field\n  const rf = field.clone()\n  rf.createTextures(gl, stepShader)\n  rf.fillf(() => (5 + Math.random() * 6) | 0)\n  await rf.asyncStabilize()\n  //   rf.upload()\n\n  // add it to field\n  field.plusHS(rf)\n  await field.asyncStabilize()\n\n  await rf.calcRecurringInverse()\n\n  field.plusHS(rf)\n  field.upload()\n\n  gl.animate(() => {\n    fieldTexture.bind(0)\n    shader\n      .uniforms({\n        iResolution: [800, 600],\n        tt: mm.inversed(),\n        colorBackground,\n        \"colorFg[0]\": colorsFg,\n        heights: 0,\n      })\n      .draw(plane)\n  })\n\n  await sleep(2000)\n  await si(+(queryParam(\"speed\") || \"2\"))\n  field.upload()\n\n  const colorHex = async (x, y, value) =>\n    andNeighbors(x, y, async (x, y) => {\n      field.setOddr(x, y, value)\n      field.upload()\n      await sleep(60)\n    })\n\n  // await colorHex(10, 10, 3)\n  // await colorHex(20, 10, 3)\n  // await colorHex(30, 11, 3)\n  // await colorHex(25, 12, 3)\n\n  console.log(\"aspect\", aspect)\n\n  const naive = async () => {\n    field.fill(10)\n    field.upload()\n    await sleep(2000)\n    await field.asyncStabilize()\n    field.dualize()\n    field.upload()\n    await sleep(3000)\n    field.plus(5)\n    field.upload()\n    await sleep(3000)\n    await field.asyncStabilize()\n    const zero = field.clone()\n    console.log(\"zero hash\", await zero.calcHash())\n    return\n  }\n}\n\nexport const HexSandpiles = ({\n  colorFg,\n  colorBg,\n}\n\n\n) => {\n  const canvasRef = useRef(null)\n\n  const colorsFg = useMemo(\n    () => chroma.scale(\"white\", colorFg).mode(\"rgb\").colors(10, \"gl\"),\n    [colorFg],\n  )\n  useEffect(() => {\n    setup(canvasRef.current, colorsFg, chroma.css(colorBg).gl())\n  }, [colorsFg, colorBg])\n\n  return React.createElement('canvas', { ref: canvasRef, style: { flexGrow: 1 },} )\n}\n","\nexport default \"#version 300 es\\nprecision mediump float;\\nprecision mediump usampler2D;\\n\\n// this shader defines a virtual texture, which renders\\n// a hex \\\"(height-)map\\\" saved as ODDR\\n\\n// texture coordinate to render\\nin vec2 coord;\\n\\nuniform vec4 colorBackground;\\nuniform vec4[10] colorFg;\\n\\nuniform mat4 tt;\\n\\nconst int MAX_MARCHING_STEPS = 255;\\nconst float MIN_DIST = 0.0;\\nconst float MAX_DIST = 100.0;\\n\\nconst uint SINK = 255u;\\n\\nout vec4 fragColor;\\n\\n// the \\\"map\\\" being rendered. also implicitely defines the\\n// size of the texture.\\n// width: x is in [-0.5, heights.width], (0, 0) is the center of the first hex\\n// height: sqrt(3) / 2 * heights.height\\nuniform usampler2D heights;\\n\\nvec3 raToHex(vec2 xy) {\\n  float hex_t = xy.y / 0.866;\\n  float hex_s = xy.x - hex_t / 2.0;\\n  return vec3(hex_s, hex_t, -(hex_s + hex_t));\\n}\\n\\nvec2 hexToRa(vec3 hex) {\\n  float y = hex.t * 0.866;\\n  float x = hex.s + hex.t / 2.0;\\n  return vec2(x, y);\\n}\\nivec2 cube_to_oddr(ivec3 cube) {\\n  int col = cube.x + (cube.y - (cube.y & 1)) / 2;\\n  int row = cube.y;\\n  return ivec2(col, row);\\n}\\nivec3 oddr_to_cube(ivec2 hex) {\\n  int x = hex.x - (hex.y - (hex.y & 1)) / 2;\\n  int y = hex.y;\\n  int z = -x - y;\\n  return ivec3(x, y, z);\\n}\\n\\nvec3 hexRound(vec3 hex) {\\n  vec3 r = floor(hex + 0.5);\\n  vec3 diff = abs(r - hex);\\n\\n  if (diff.x > diff.y && diff.x > diff.z) {\\n    r.x = -(r.y + r.z);\\n  } else if (diff.y > diff.z) {\\n    r.y = -(r.x + r.z);\\n  } else {\\n    r.z = -(r.x + r.y);\\n  }\\n\\n  return r;\\n}\\nfloat max3(vec3 v) {\\n  return max(max(v.x, v.y), v.z);\\n}\\nfloat min3(vec3 v) {\\n  return max(max(v.x, v.y), v.z);\\n}\\nfloat hex_sdf(vec3 h) {\\n  return max3(abs(h.yzx + h.zxy / 2.0));\\n  // return abs(h.x+(h.y/2.0) );\\n  // return max3(abs(vec3(h)));\\n}\\n\\nbool between(float min, float max, float x) {\\n  return min <= x && x <= max;\\n}\\n\\nuint heightAt(ivec2 p) {\\n  ivec2 tex_size = textureSize(heights, 0);\\n\\n  if (p.x < 0 || p.y < 0 || tex_size.x <= p.x || tex_size.y <= p.y) {\\n    // point is outside source texture, treat as sink\\n    return SINK;\\n  } else {\\n    return texelFetch(heights, p, 0).r;\\n  }\\n}\\n\\nvoid main() {\\n  // vec2 pos2 = vec4(coord, 0.0, 1.0).xy * 400.0;\\n  vec2 pos2 = (tt * vec4(coord, 0.0, 1.0)).xy;\\n\\n  // fragColor = length(pos2 - vec2(100.0, 100.0)) < 50.0\\n  // ? colorFg[0]\\n  // : colorBackground;\\n  // return;\\n  vec3 hex_pos = raToHex(pos2);\\n  // vec2 hex_center = floor(hex_pos + 0.5);\\n  vec3 hex_center = hexRound(hex_pos);\\n  vec2 center = hexToRa(hex_center);\\n  vec2 squarePos = floor(pos2 + 0.5);\\n  vec3 hex_d = hex_pos - hex_center;\\n  // vec2 d =hex_pos - hex_center;\\n  // vec3 zz = vec3(d.xy, (d.y - d.x)/1.41);\\n  vec2 local_ra_offset = pos2 - center;\\n  // if (abs(zz.x +zz.y+ zz.z) < 0.1) {\\n  // if (max(d.x, max(d.y, 0.0)) < 0.45) {\\n  // if (length(pos2 - squarePos) < 0.5) {\\n  float d = hex_sdf(hex_d);\\n  if (\\n    between(0.0, 0.425, d) // || length(pos2 - center) < 0.2\\n  ) {\\n    // if (length (pos2 - center) <0.53){\\n    // if (length (hex_pos - hex_center) <0.45){\\n    ivec2 center2 = cube_to_oddr(ivec3(hex_center));\\n    uint value = heightAt(center2);\\n    uint valueClamped = clamp(value, 0u, uint(colorFg.length()) - 1u);\\n    fragColor = value == 255u ? colorBackground : colorFg[valueClamped];\\n  } else {\\n    fragColor = colorBackground;\\n  }\\n}\\n\"\nconst sourceMap = {\"version\":3,\"sources\":[\"/home/runner/work/workshop/workshop/src/hexSandpiles/FS.frag\"],\"names\":[],\"mappings\":\"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA\"}\nexport { sourceMap };\n","\nexport default \"#version 300 es\\nprecision mediump float;\\nprecision mediump usampler2D;\\nin vec2 coord;\\n\\nuniform vec2 iResolution;\\nuniform vec4 colorBackground;\\nuniform vec4[10] colorFg;\\n\\nout uvec4 fragColor;\\n\\nconst uint SINK = 255u;\\n\\nuniform usampler2D heights;\\n\\nfloat EPSILON = 0.0001;\\n\\nvec3 raToHex(vec2 xy) {\\n  float hex_t = xy.y / 0.866;\\n  float hex_s = xy.x - hex_t / 2.0;\\n  return vec3(hex_s, hex_t, -(hex_s + hex_t));\\n}\\n\\nvec2 hexToRa(vec3 hex) {\\n  float y = hex.t * 0.866;\\n  float x = hex.s + hex.t / 2.0;\\n  return vec2(x, y);\\n}\\nivec2 cube_to_oddr(ivec3 cube) {\\n  int col = cube.x + (cube.y - (cube.y & 1)) / 2;\\n  int row = cube.y;\\n  return ivec2(col, row);\\n}\\nivec3 oddr_to_cube(ivec2 hex) {\\n  int x = hex.x - (hex.y - (hex.y & 1)) / 2;\\n  int y = hex.y;\\n  int z = -x - y;\\n  return ivec3(x, y, z);\\n}\\n\\nvec3 hexRound(vec3 hex) {\\n  vec3 r = floor(hex + 0.5);\\n  vec3 diff = abs(r - hex);\\n\\n  if (diff.x > diff.y && diff.x > diff.z) {\\n    r.x = -(r.y + r.z);\\n  } else if (diff.y > diff.z) {\\n    r.y = -(r.x + r.z);\\n  } else {\\n    r.z = -(r.x + r.y);\\n  }\\n\\n  return r;\\n}\\nfloat max3(vec3 v) {\\n  return max(max(v.x, v.y), v.z);\\n}\\nfloat min3(vec3 v) {\\n  return min(min(v.x, v.y), v.z);\\n}\\nfloat hex_sdf(vec3 h) {\\n  return max3(abs(h.yzx + h.zxy / 2.0));\\n  // return abs(h.x+(h.y/2.0) );\\n  // return max3(abs(vec3(h)));\\n}\\n\\nbool between(float min, float max, float x) {\\n  return min <= x && x <= max;\\n}\\n\\nuint heightAt(ivec2 p) {\\n  ivec2 tex_size = textureSize(heights, 0);\\n\\n  if (p.x < 0 || p.y < 0 || tex_size.x <= p.x || tex_size.y <= p.y) {\\n    // point is outside source texture, treat as sink\\n    return SINK;\\n  } else {\\n    return texelFetch(heights, p, 0).r;\\n  }\\n}\\n\\nuint at(ivec2 p) {\\n  uint value = heightAt(p);\\n  if (SINK == value) {\\n    return 0u;\\n  } else {\\n    return value / 6u;\\n  }\\n}\\n\\nuint calc(ivec2 oddr_pos) {\\n  uint value = texelFetch(heights, oddr_pos, 0).r;\\n\\n  if (SINK == value) {\\n    return SINK;\\n  }\\n\\n  // the current pos topples as many times as it can\\n  value = value % 6u;\\n  // all the neighbors topple as often as they can\\n  value += at(oddr_pos + ivec2(+1, 0));\\n  value += at(oddr_pos + ivec2(-1, 0));\\n\\n  value += at(oddr_pos + ivec2(0, +1));\\n  value += at(oddr_pos + ivec2(0, -1));\\n\\n  value += at(oddr_pos + ivec2(0 != (oddr_pos.y & 1) ? 1 : -1, +1));\\n  value += at(oddr_pos + ivec2(0 != (oddr_pos.y & 1) ? 1 : -1, -1));\\n\\n  return value;\\n}\\n\\nvoid main() {\\n  fragColor = uvec4(calc(ivec2(coord)), 0u, 0u, 0u);\\n  // fragColor = uvec4(2u, 0u, 0u, 0u);\\n}\\n\"\nconst sourceMap = {\"version\":3,\"sources\":[\"/home/runner/work/workshop/workshop/src/hexSandpiles/step.frag\"],\"names\":[],\"mappings\":\"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA\"}\nexport { sourceMap };\n","import { useTheme } from \"@mui/material/styles\"\nimport * as chroma from \"chroma.ts\"\n\nimport * as React from \"react\"\n\n\n\nimport { HexSandpiles } from \"./HexSandpiles\"\nexport default () => {\n  const theme = useTheme()\n\n  const width = 32\n  const SQRT3_2 = Math.sqrt(3) / 2\n\n  const c = {\n    boxSizing: \"border-box\",\n    position: \"relative\",\n    content: \"\",\n    width,\n    display: \"block\",\n    height: width / SQRT3_2 / 4,\n    borderWidth: `0 ${width / 2}px ${width / SQRT3_2 / 4}px ${width / 2}px`,\n    borderStyle: \"solid\",\n  }\n\n  return (\n    React.createElement('div', { style: { display: \"flex\", flexDirection: \"column\", height: \"100%\" },}\n      , React.createElement(HexSandpiles, {\n        colorFg: theme.palette.primary.main,\n        colorBg: theme.palette.background.default,}\n      )\n      , React.createElement('div', {\n        style: {\n          padding: 4,\n          display: \"flex\",\n          backgroundColor: theme.palette.background.default,\n        },}\n\n        , false &&\n          colorFg.map((value, index) => (\n            React.createElement('div', {\n              className: \"hex\",\n              style: {\n                display: \"flex\",\n                flexDirection: \"column\",\n                margin: 4,\n              },\n              key: index,}\n\n              , React.createElement('div', {\n                style: {\n                  ...c,\n                  borderColor: chroma.gl(value).css() + \" transparent\",\n                  borderWidth: `0 ${width / 2}px ${width / SQRT3_2 / 4}px ${\n                    width / 2\n                  }px`,\n                },}\n              )\n              , React.createElement('div', {\n                style: {\n                  textAlign: \"center\",\n                  backgroundColor: chroma.gl(value).css(),\n                  height: width / SQRT3_2 / 2,\n                  color: chroma.gl(value).textColor().css(),\n                  display: \"flex\",\n                  alignItems: \"center\",\n                  justifyContent: \"center\",\n                },}\n\n                , index === 9 ? \"9+\" : index\n              )\n              , React.createElement('div', {\n                style: {\n                  ...c,\n                  borderColor: chroma.gl(value).css() + \" transparent\",\n                  borderWidth: `${width / SQRT3_2 / 4}px ${width / 2}px 0 ${\n                    width / 2\n                  }px`,\n                },}\n              )\n            )\n          ))\n        /* <Tooltip title=\"Calculate Recuring Inverse\">\n          <Button>Calc Rec. Inv.</Button>\n\t\t</Tooltip>\n\t\t */\n        , React.createElement('div', { style: { textAlign: \"right\", padding: 10, flexGrow: 1 },}\n          , React.createElement('a', { href: \"http://people.reed.edu/~davidp/grant/\",}, \"Original (square)\" ), \" \"\n          , React.createElement('a', { href: \"https://www.youtube.com/watch?v=1MtEUErz7Gg\",}, \"Explanatory video\"\n\n          )\n        )\n      )\n    )\n  )\n}\n"],"names":["makePlane","x0","y0","x1","y1","plane","startX","width","startY","height","coords","compile","forEachNeighbor","async","x","y","f","SQRT3_2","Math","sqrt","oddr_to_px","col","row","V","SINK","oddr_distance","x2","y2","z1","z2","abs","cube_distance","oddr_to_cube","HexSand","constructor","w","h","this","data","Uint8Array","clone","hs","plusHS","dualize","i","console","log","plus","times","setHS","o","fill","n","fillf","getOddr","setOddr","value","addOddr","isSink","drawHex","inner","outer","cx","cy","oddr_cx","oddr_cy","text","fontSize","url","path","Promise","resolve","reject","error","font","getPath","pathBB","getBoundingBox","pathBBSize","to","canvas","document","createElement","context","getContext","scale","translate","fillStyle","imageSmoothingEnabled","draw","offset","minus","div","p","getImageData","px","drawTriangle","d","max","drawCircle","c","distanceTo","drawRect","cc","z","changed","createTextures","gl","stepShader","ops","lastAccessLHS","length","op","fn","args","call","undefined","_optionalChain","_2","glInfo","_3","t0","filter","NEAREST","internalFormat","R8UI","format","RED_INTEGER","t1","stepPlane","upload","countUnstable","ss","drawTo","_gl","bind","uniforms","heights","swapWith","downloadData","frameSteps","Array","from","crypto","subtle","digest","map","b","toString","padStart","join","unstable","asyncStabilize","setData","getOddrBB","rowEmpty","colEmpty","getBB","min","HexSandpiles","colorFg","colorBg","canvasRef","useRef","colorsFg","useMemo","mode","colors","useEffect","colorBackground","create","throwOnError","addResizeListener","shader","directVS","field","fieldTexture","aspect","fBB","fBBd","bbRatio","mm","M4","queryParam","URL","location","searchParams","get","calcRecurringIdentity","_x","_y","_i","v","queryTextBase64","drawText","atob","rf","random","calcRecurringInverse","animate","iResolution","tt","inversed","_","stabilizeInteractive","si","setup","current","ref","style","flexGrow","theme","useTheme","display","flexDirection","palette","primary","main","background","default","padding","backgroundColor","textAlign","href"],"sourceRoot":""}