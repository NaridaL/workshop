{"version":3,"file":"sdfs-index.js","mappings":"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","sources":["/dev/workshop/./src/common/BoundNumberField.tsx?","/dev/workshop/./src/common/FPSController.ts?","/dev/workshop/./src/common/useHashState.ts?","/dev/workshop/./src/paperBox1/PaperSize.tsx?","/dev/workshop/./src/paperBox1/common.tsx?","/dev/workshop/./src/raymarch/FlyCameraController.ts?","/dev/workshop/./src/raymarch/OrbitCameraController.ts?","/dev/workshop/./src/sdfs/SimpleCanvasRenderer.tsx?","/dev/workshop/./src/common/memoizeLast.ts?","/dev/workshop/./src/sdfs/index.tsx?","/dev/workshop/./node_modules/@mui/material/internal/switchBaseClasses.js?","/dev/workshop/./node_modules/@mui/material/internal/SwitchBase.js?","/dev/workshop/./node_modules/@mui/material/internal/svg-icons/CheckBoxOutlineBlank.js?","/dev/workshop/./node_modules/@mui/material/internal/svg-icons/CheckBox.js?","/dev/workshop/./node_modules/@mui/material/internal/svg-icons/IndeterminateCheckBox.js?","/dev/workshop/./node_modules/@mui/material/Checkbox/checkboxClasses.js?","/dev/workshop/./node_modules/@mui/material/Checkbox/Checkbox.js?","/dev/workshop/./src/common/raymarch.vert?","/dev/workshop/./src/sdfs/demoLego.frag?","/dev/workshop/./src/sdfs/demoTemple.frag?","/dev/workshop/./src/sdfs/fractals.frag?","/dev/workshop/./src/sdfs/mandelbrot.frag?","/dev/workshop/./src/sdfs/ sync ^\\.\\/.*\\.frag$?"],"sourcesContent":["import TextField, { } from \"@mui/material/TextField\"\nimport * as React from \"react\"\n\n\nexport function BoundNumberField({\n  state,\n  prop,\n  setStatePartial,\n  ...props\n}\n\n\n\n) {\n  return (\n    React.createElement(TextField, {\n      variant: \"outlined\",\n      size: \"small\",\n      type: \"number\",\n      value: state[prop],\n      onChange: (e) =>\n        setStatePartial({ [prop]: +e.target.value } )\n      ,\n      label: prop,\n      ...props,}\n    )\n  )\n}\n","/**\n * Helper class to count frames per second.\n */\nexport class FPSController {\n   __init() {this.count = 0}\n\n   __init2() {this.lastTime = performance.now()}\n  constructor(\n      notify,\n      window = 10,\n  ) {;this.notify = notify;this.window = window;FPSController.prototype.__init.call(this);FPSController.prototype.__init2.call(this);}\n\n  tick(time = performance.now()) {\n    const window = this.window\n    this.count = (this.count + 1) % window\n    if (this.count === 0) {\n      const fps = Math.floor((window * 1000) / (time - this.lastTime))\n      this.notify(fps)\n      this.lastTime = time\n    }\n  }\n}\n","import debounce from \"lodash/debounce\"\nimport mapValues from \"lodash/mapValues\"\nimport { useCallback, useEffect, useRef, useState } from \"react\"\nimport {\n  PAPER_SIZE_A4,\n\n  PaperSizeFromString,\n  PaperSizeToString,\n} from \"../paperBox1/PaperSize\"\n\nconst parseHash = (hash) => {\n  return !hash\n    ? {}\n    : hash\n        .substring(1)\n        .split(\"&\")\n        .map((part) => {\n          const [key, value] = part.split(\"=\")\n          return [decodeURIComponent(key), decodeURIComponent(value)]\n        })\n        .reduce((obj, [key, value]) => {\n          obj[key] = value\n          return obj\n        }, {} )\n}\nconst objectToHash = (o) => {\n  return (\n    \"#\" +\n    Object.entries(o)\n      .map(\n        ([key, value]) =>\n          encodeURIComponent(key) + \"=\" + encodeURIComponent(value),\n      )\n      .join(\"&\")\n  )\n}\n\nconst defaultDeserialize = (\n  x,\n) =>\n  mapValues(x, (v, key) => {\n    if (\"paperSize\" === key) {\n      try {\n        return PaperSizeFromString(v)\n      } catch (e) {\n        console.error(e)\n        return PAPER_SIZE_A4\n      }\n    } else if (\"true\" === v) {\n      return true\n    } else if (\"false\" === v) {\n      return false\n    } else if (\"NaN\" === v) {\n      return NaN\n    } else if (\"undefined\" === v) {\n      return undefined\n    } else if (\"null\" === v) {\n      return null\n    } else if (\"\" === v) {\n      return \"\"\n    } else if (!isNaN(+v)) {\n      return +v\n    } else {\n      return v\n    }\n  })\nconst defaultSerialize = (x) =>\n  mapValues(x, (v, key) =>\n    key === \"paperSize\" ? PaperSizeToString(v ) : \"\" + v,\n  )\n\nexport function useHashState(\n  initialState,\n  {\n    deserialize = defaultDeserialize,\n    serialize = defaultSerialize,\n    wait = 1000,\n  } = {},\n) {\n  const createInitialState = useCallback(() => {\n    const state =\n      \"function\" === typeof initialState\n        ? (initialState )()\n        : initialState\n    // hash overrides parameter\n    const mergedState = deserialize(\n      Object.assign(serialize(state), parseHash(document.location.hash)),\n    ) \n    history.pushState(\n      undefined,\n      document.title,\n      objectToHash(serialize(mergedState)),\n    )\n\n    return mergedState\n  }, [deserialize, initialState, serialize])\n  const [state, setState] = useState(createInitialState)\n  const updateHashRef = useRef()\n  if (!updateHashRef.current) {\n    updateHashRef.current = debounce(function (newState) {\n      history.pushState(\n        undefined,\n        document.title,\n        objectToHash(serialize(newState)),\n      )\n    }, wait)\n  }\n  useEffect(() => updateHashRef.current(state), [state])\n\n  useEffect(() => {\n    const onHashChange = () => {\n      setState(createInitialState())\n    }\n    window.addEventListener(\"hashchange\", onHashChange)\n    return () => {\n      window.removeEventListener(\"hashchange\", onHashChange)\n    }\n  }, [createInitialState])\n  return [state, setState]\n}\n"," function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } }import { MINUS } from \"ts3dutils\"\n\n \n// Always portrait orientation,\n\n// Always portrait orientation,\nexport const PAPER_SIZES_A = [\n  [841, 1189, \"A0\"],\n  [594, 841, \"A1\"],\n  [420, 594, \"A2\"],\n  [297, 420, \"A3\"],\n  [210, 297, \"A4\"],\n  [148, 210, \"A5\"],\n  [105, 148, \"A6\"],\n  [74, 105, \"A7\"],\n  [52, 74, \"A8\"],\n  [37, 52, \"A9\"],\n  [26, 37, \"A10\"],\n]\n\nexport function PaperSizeEquals([aw, ah], [bw, bh]) {\n  return aw === bw && bh === bw\n}\n\nexport const PAPER_SIZES_B = [\n  [1000, 1414, \"C0\"],\n  [707, 1000, \"C1\"],\n  [500, 707, \"C2\"],\n  [353, 500, \"C3\"],\n  [250, 353, \"C4\"],\n  [176, 250, \"C5\"],\n  [125, 176, \"C6\"],\n  [88, 125, \"C7\"],\n  [62, 88, \"C8\"],\n  [44, 62, \"C9\"],\n  [31, 44, \"C10\"],\n]\n\n// C size envelopes fit A size paper.\nexport const PAPER_SIZES_C = [\n  [917, 1297, \"C0\"],\n  [648, 917, \"C1\"],\n  [458, 648, \"C2\"],\n  [324, 458, \"C3\"],\n  [229, 324, \"C4\"],\n  [162, 229, \"C5\"],\n  [114, 162, \"C6\"],\n  [81, 114, \"C7\"],\n  [57, 81, \"C8\"],\n  [40, 57, \"C9\"],\n  [28, 40, \"C10\"],\n]\nexport const PAPER_SIZES = [\n  ...PAPER_SIZES_A,\n  [150, 150, \"Origami 15cm\"],\n  [100, 100, \"Origami 10cm\"],\n  [75, 75, \"Origami 7.5cm\"],\n  [215.9, 279.4, \"Letter\"],\n  [215.9, 355.6, \"Legal\"],\n]\n\nexport const ALL_PAPER_SIZES = [\n  ...PAPER_SIZES,\n  ...PAPER_SIZES_C,\n  ...PAPER_SIZES_B,\n]\n\nexport function PaperSizeFromString(str) {\n  const byName = PAPER_SIZES.find(([, , name]) => name === str)\n  if (byName) return byName\n  const [a, b] = str.split(\"x\")\n  return [+a, +b, \"Custom\"]\n}\nexport function PaperSizeFromDimensions(a, b) {\n  ;[a, b] = [a, b].sort(MINUS)\n  return _nullishCoalesce(PAPER_SIZES.find(([x, y]) => x === a && y === b), () => ( [a, b, \"Custom\"]))\n}\nexport function PaperSizeToString([a, b, name]) {\n  return name === \"Custom\" ? \"\" + a + \"x\" + b : name\n}\n\nexport const PAPER_SIZE_A4 = PAPER_SIZES_A[4]\n","import * as React from \"react\"\n\nimport { arrayRange, DEG, round10, TAU, V3 } from \"ts3dutils\"\n\nexport const INCH = 25.4\nexport const fmtdeg = (x) => \"\" + round10(x / DEG, -1) + \"°\"\n \n\nexport const radiusFromSideWidth = (sides, sideWidth) =>\n  sideWidth / 2 / Math.sin(TAU / sides / 2)\nexport const sideWithFromRadius = (sides, radius) =>\n  radius * 2 * Math.sin(TAU / sides / 2)\nexport const centerToSideFromSideWidth = (\n  sides,\n  sideWidth,\n) => sideWidth / 2 / Math.tan(TAU / sides / 2)\nexport const radiusFromCenterToSide = (\n  sides,\n  centerToSide,\n) => centerToSide / Math.cos(TAU / sides / 2)\nexport const sideWidthFromCenterToSide = (\n  sides,\n  centerToSide,\n) => centerToSide * 2 * Math.tan(TAU / sides / 2)\n\nexport function RegularPolygon({\n  sides,\n  radius,\n  startAngle = 0,\n  sideLength = undefined,\n  ...props\n}\n\n\n\n\n) {\n  if ((undefined !== sideLength) === (undefined !== radius)) {\n    throw new Error(\"must set either sideLength or radius\")\n  }\n  if (undefined === radius) {\n    radius = radiusFromSideWidth(sides, sideLength)\n  }\n  const { x, y } = V3.polar(radius, startAngle)\n  return (\n    React.createElement('path', {\n      d: dTpl`\n        M${x},${y}\n        ${arrayRange(0, sides).map(\n          (i) => dTpl`L${V3.polar(radius, startAngle + i * (TAU / sides))}`,\n        )}Z`,\n      ...props,}\n    )\n  )\n}\n\nexport function RotStep({\n  id,\n  children,\n  count,\n  stepDeg,\n}\n\n\n\n\n) {\n  return (\n    React.createElement(React.Fragment, null\n      , React.createElement('g', { id: id,}, children)\n      , arrayRange(0, count - 1).map((i) => (\n        React.createElement('use', {\n          key: i,\n          xlinkHref: \"#\" + id,\n          transform: `rotate(${(i + 1) * stepDeg} 0 0)`,}\n        )\n      ))\n    )\n  )\n}\n\nexport function dTpl(\n  strings,\n  ...exps\n) {\n  const format = (x) =>\n    \"number\" === typeof x\n      ? \"\" + x\n      : \"string\" === typeof x\n      ? x\n      : Array.isArray(x)\n      ? x.map(format).join(\" \")\n      : x.x + \",\" + x.y\n  let result = strings[0]\n  for (let i = 0; i < exps.length; i++) {\n    result += format(exps[i])\n    result += strings[i + 1]\n  }\n  return result\n}\n\nexport const openInNewTab = (url) => {\n  const newWindow = window.open(url, \"_blank\", \"noopener,noreferrer\")\n  if (newWindow) newWindow.opener = null\n}\n"," function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }import { DEG, M4, V, V3 } from \"ts3dutils\"\n\n/**\n * You can't use the keyboard events directly to move the camera, as they are\n * not fired often enough. Instead, we track which keys are down and tick()\n * should be called in the render loop.\n */\nexport class FlyCameraController {\n   __init() {this.lastPos = V3.O}\n  \n\n   __init2() {this.pressedKeys = {}}\n   __init3() {this.pauseCam = false}\n\n  constructor(\n     state,\n      onChange,\n      lockUp,\n  ) {;this.state = state;this.onChange = onChange;this.lockUp = lockUp;FlyCameraController.prototype.__init.call(this);FlyCameraController.prototype.__init2.call(this);FlyCameraController.prototype.__init3.call(this);FlyCameraController.prototype.__init4.call(this);FlyCameraController.prototype.__init5.call(this);FlyCameraController.prototype.__init6.call(this);FlyCameraController.prototype.__init7.call(this);}\n\n  __init4() {this.setState = (m) => {\n    m !== this.state && M4.copy(m, this.state)\n  }}\n\n  registerListeners(\n    mouseMoveTarget\n\n\n,\n    keyUpDownTarget = mouseMoveTarget,\n  ) {\n    _optionalChain([this, 'access', _3 => _3.unregister, 'optionalCall', _4 => _4()])\n    mouseMoveTarget.addEventListener(\"mousemove\", this.mousemove)\n    keyUpDownTarget.addEventListener(\"keydown\", this.keydown)\n    keyUpDownTarget.addEventListener(\"keyup\", this.keyup)\n\n    return (this.unregister = () => {\n      mouseMoveTarget.removeEventListener(\"mousemove\", this.mousemove)\n      keyUpDownTarget.removeEventListener(\"keydown\", this.keydown)\n      keyUpDownTarget.removeEventListener(\"keyup\", this.keyup)\n    })\n  }\n\n  unregisterListeners() {\n    _optionalChain([this, 'access', _5 => _5.unregister, 'optionalCall', _6 => _6()])\n  }\n\n  tick() {\n    const speed = new V3(\n      +!!this.pressedKeys.a - +!!this.pressedKeys.d,\n      +!!this.pressedKeys.q +\n        +!!this.pressedKeys.Control -\n        +!!this.pressedKeys.e -\n        +!!this.pressedKeys[\" \"],\n      +!!this.pressedKeys.w - +!!this.pressedKeys.s,\n    )\n    if (!speed.likeO()) {\n      this.state = this.state.translate(speed.toLength(0.05))\n      _optionalChain([this, 'access', _7 => _7.onChange, 'optionalCall', _8 => _8(this.state)])\n    }\n  }\n\n   __init5() {this.mousemove = (e) => {\n    const pagePos = V(e.pageX, e.pageY)\n    const delta = this.lastPos.to(pagePos)\n    if (e.buttons & 1 && !this.pauseCam) {\n      // zRot -= delta.x * 0.25 * DEG\n      const rot = M4.rotateY(delta.x * 0.25 * DEG)\n        //\n        .rotateX(delta.y * 0.25 * DEG)\n      this.state = rot.times(this.state)\n      // rot = rot.rotate(V3.O, rot.X, delta.y * 0.25 * DEG)\n      // yRot = clamp(yRot - delta.y * 0.25 * DEG, -85 * DEG, 85 * DEG)\n      _optionalChain([this, 'access', _9 => _9.onChange, 'optionalCall', _10 => _10(this.state)])\n    }\n    this.lastPos = pagePos\n  }}\n\n   __init6() {this.keydown = (e) => {\n    this.pressedKeys[e.key] = true\n    e.preventDefault()\n  }}\n   __init7() {this.keyup = (e) => {\n    this.pressedKeys[e.key] = undefined\n    e.preventDefault()\n  }}\n\n  getLookAt() {\n    return this.state\n  }\n\n  static invertLookAt(m) {\n    const inverse = m.transposed().scale(-1)\n    return {\n      eye: inverse.transformVector(m.getTranslation(), false),\n      dir: inverse.transformVector(V3.Z, false),\n      up: inverse.transformVector(V3.Y.negated(), false),\n    }\n  }\n\n  static toShortString(lookAt, posFactor = 100) {\n    const coordString = (v, f) =>\n      [v.x, v.y, v.z].map((e) => Math.floor(e * f)).join(\".\")\n    const { eye, dir, up } = FlyCameraController.invertLookAt(lookAt)\n    return (\n      coordString(eye, posFactor) +\n      \"~\" +\n      coordString(dir.unit(), 100) +\n      \"~\" +\n      coordString(up, 100)\n    )\n  }\n\n  static fromShortString(cam, posFactor = 100) {\n    const coord = (s, f) =>\n      V(s.split(\".\").map((sp) => +sp / f) )\n    const [posStr, lookDirStr, upStr] = cam.split(\"~\")\n    const eye = coord(posStr, posFactor)\n    return M4.lookAt(eye, eye.plus(coord(lookDirStr, 100)), coord(upStr, 100))\n  }\n}\n"," function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }import { clamp, M4, V, V3 } from \"ts3dutils\"\n\n \n\nconst ACTIONS = [\"zoomIn\", \"zoomOut\", \"left\", \"right\", \"up\", \"down\"] \n\n/**\n * You can't use the keyboard events directly to move the camera, as they are\n * not fired often enough. Instead, we track which keys are down and tick()\n * should be called in the render loop.\n */\nexport class OrbitCameraController {\n   __init() {this.lastPos = V3.O}\n  \n\n   __init2() {this.pressedKeys = {\n    zoomIn: false,\n    zoomOut: false,\n    left: false,\n    right: false,\n    up: false,\n    down: false,\n  }}\n   __init3() {this.pauseCam = false}\n   __init4() {this.udRot = 0.1}\n   __init5() {this.rot = 0}\n   __init6() {this.dist = 10}\n\n  constructor(\n      onChange,\n      keys = {\n      zoomIn: \"w\",\n      zoomOut: \"s\",\n      left: \"a\",\n      right: \"d\",\n      up: \" \",\n      down: \"Control\",\n    },\n  ) {;this.onChange = onChange;this.keys = keys;OrbitCameraController.prototype.__init.call(this);OrbitCameraController.prototype.__init2.call(this);OrbitCameraController.prototype.__init3.call(this);OrbitCameraController.prototype.__init4.call(this);OrbitCameraController.prototype.__init5.call(this);OrbitCameraController.prototype.__init6.call(this);OrbitCameraController.prototype.__init7.call(this);OrbitCameraController.prototype.__init8.call(this);OrbitCameraController.prototype.__init9.call(this);OrbitCameraController.prototype.__init10.call(this);OrbitCameraController.prototype.__init11.call(this);OrbitCameraController.prototype.__init12.call(this);}\n\n  __init7() {this.setState = (m) => {\n    console.log(\"setStaet\")\n    ;[this.udRot, this.rot, this.dist] =\n      OrbitCameraController.toOrbitCameraState(m)\n  }}\n\n  static toOrbitCameraState(m) {\n    if (m instanceof M4) {\n      const eye = m\n        .transposed()\n        .scale(-1)\n        .transformVector(m.getTranslation(), false)\n      return [Math.atan(eye.z / eye.lengthXY()), eye.angleXY(), eye.length()]\n    } else {\n      return m\n    }\n  }\n\n  registerListeners(\n    mouseMoveTarget\n\n\n,\n    keyUpDownTarget = mouseMoveTarget,\n  ) {\n    _optionalChain([this, 'access', _5 => _5.unregister, 'optionalCall', _6 => _6()])\n    mouseMoveTarget.addEventListener(\"mousemove\", this.mousemove)\n    mouseMoveTarget.addEventListener(\"wheel\", this.wheel)\n    keyUpDownTarget.addEventListener(\"keydown\", this.keydown)\n    keyUpDownTarget.addEventListener(\"keyup\", this.keyup)\n    keyUpDownTarget.addEventListener(\"blur\", this.keyup)\n\n    return (this.unregister = () => {\n      mouseMoveTarget.removeEventListener(\"mousemove\", this.mousemove)\n      mouseMoveTarget.removeEventListener(\"wheel\", this.wheel)\n      keyUpDownTarget.removeEventListener(\"keydown\", this.keydown)\n      keyUpDownTarget.removeEventListener(\"keyup\", this.keyup)\n      keyUpDownTarget.removeEventListener(\"keyup\", this.keyup)\n    })\n  }\n\n  __init8() {this.blur = () => {\n    // TODO\n  }}\n\n  unregisterListeners() {\n    _optionalChain([this, 'access', _7 => _7.unregister, 'optionalCall', _8 => _8()])\n  }\n\n  tick() {\n    const dDist = (+this.pressedKeys.zoomOut - +this.pressedKeys.zoomIn) * 0.1\n    const dRot = (-+this.pressedKeys.left + +this.pressedKeys.right) * 0.1\n    const newUDRot = clamp(\n      this.udRot + (+this.pressedKeys.up - +this.pressedKeys.down) * 0.1,\n      -Math.PI * 0.5,\n      Math.PI * 0.5,\n    )\n    if (dDist !== 0 || dRot !== 0 || newUDRot !== this.udRot) {\n      this.dist += dDist\n      this.rot += dRot\n      this.udRot = newUDRot\n      _optionalChain([this, 'access', _9 => _9.onChange, 'optionalCall', _10 => _10(this.ss)])\n    }\n  }\n\n   __init9() {this.mousemove = (e) => {\n    const pagePos = V(e.pageX, e.pageY)\n    const delta = this.lastPos.to(pagePos)\n    if (e.buttons & 1 && !this.pauseCam) {\n      // zRot -= delta.x * 0.25 * DEG\n      const dRot = delta.x / 100\n      const newUDRot = clamp(\n        this.udRot + delta.y / 100,\n        -Math.PI * 0.5,\n        Math.PI * 0.5,\n      )\n      if (newUDRot !== this.udRot || dRot !== 0) {\n        this.udRot = newUDRot\n        this.rot += dRot\n        _optionalChain([this, 'access', _11 => _11.onChange, 'optionalCall', _12 => _12(this.ss)])\n        e.stopImmediatePropagation()\n        e.preventDefault()\n      }\n    }\n    this.lastPos = pagePos\n  }}\n\n   __init10() {this.wheel = (e) => {\n    const newDist = clamp(this.dist + e.deltaY, 0.1, 1000)\n    if (newDist !== this.dist) {\n      this.dist = newDist\n      e.stopImmediatePropagation()\n      e.preventDefault()\n      _optionalChain([this, 'access', _13 => _13.onChange, 'optionalCall', _14 => _14(this.ss)])\n    }\n  }}\n\n  get ss() {\n    return [this.udRot, this.rot, this.dist]\n  }\n\n   __init11() {this.keydown = (e) => {\n    for (const action of ACTIONS) {\n      if (this.keys[action] === e.key) {\n        this.pressedKeys[action] = true\n        e.stopImmediatePropagation()\n        e.preventDefault()\n        return\n      }\n    }\n  }}\n\n   __init12() {this.keyup = (e) => {\n    for (const action of ACTIONS) {\n      if (this.keys[action] === e.key) {\n        this.pressedKeys[action] = false\n        e.stopImmediatePropagation()\n        e.preventDefault()\n        return\n      }\n    }\n  }}\n\n  getLookAt() {\n    return OrbitCameraController.getLookAt(this.ss)\n  }\n\n  static getLookAt([udRot, rot, dist]) {\n    return M4.rotateZ(rot)\n      .rotateY(udRot)\n      .transform(M4.lookAt(V(dist, 0, 0), V3.O, V3.Z))\n  }\n\n  static invertLookAt(m) {\n    const inverse = m.transposed().scale(-1)\n    return {\n      eye: inverse.transformVector(m.getTranslation(), false),\n      dir: inverse.transformVector(V3.Z, false),\n      up: inverse.transformVector(V3.Y.negated(), false),\n    }\n  }\n\n  static toShortString(m, posFactor = 100) {\n    const [udRot, rot, dist] = this.toOrbitCameraState(m)\n    const coordString = (v, f) => Math.floor(v * f)\n    return (\n      coordString(udRot, 100) +\n      \"~\" +\n      coordString(rot, 100) +\n      \"~\" +\n      coordString(dist, 100)\n    )\n  }\n\n  static fromShortString(cam, posFactor = 100) {\n    const coord = (s, f) => +s / f\n    const [udRotStr, rotStr, distStr] = cam.split(\"~\")\n    return [coord(udRotStr, 100), coord(rotStr, 100), coord(distStr, 100)]\n  }\n}\n"," function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }import MoreVertIcon from \"@mui/icons-material/MoreVert\"\nimport Box from \"@mui/material/Box\"\nimport Card from \"@mui/material/Card\"\nimport CardMedia from \"@mui/material/CardMedia\"\nimport CircularProgress from \"@mui/material/CircularProgress\"\nimport Fab from \"@mui/material/Fab\"\nimport ListItem from \"@mui/material/ListItem\"\nimport ListItemText from \"@mui/material/ListItemText\"\nimport Menu from \"@mui/material/Menu/Menu\"\nimport MenuItem from \"@mui/material/MenuItem\"\nimport Select from \"@mui/material/Select\"\nimport { useTheme } from \"@mui/material/styles\"\n\nimport * as chroma from \"chroma.ts\"\nimport * as React from \"react\"\nimport {\n\n\n  useCallback,\n  useEffect,\n  useRef,\n  useState,\n} from \"react\"\nimport sleep from \"sleep-promise\"\nimport { SourceMapConsumer } from \"source-map-js\"\nimport { Mesh, Shader, TSGLContext } from \"tsgl\"\n\nimport { FPSController } from \"../common/FPSController\"\nimport { memoizeLast } from \"../common/memoizeLast\"\nimport { openInNewTab } from \"../paperBox1/common\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nexport function GenericDemo({\n  sx,\n  animate,\n  state,\n  Renderer,\n  focusable,\n  rendererRef,\n}\n\n\n\n\n\n\n) {\n  const rendererRef2 = useRef()\n  const [fps, setFps] = useState(0)\n  const [anchorEl, setAnchorEl] = useState()\n\n  const [renderProgress, setRenderProgress] = useState()\n\n  const render = useCallback(\n    async (event) => {\n      const dim = event.currentTarget.dataset\n        .dim.split(\"x\")\n        .map((x) => +x) \n      setAnchorEl(undefined)\n      if (rendererRef2.current) {\n        try {\n          const url = URL.createObjectURL(\n            await rendererRef2.current.renderImage(dim, setRenderProgress),\n          )\n          setRenderProgress(undefined)\n          openInNewTab(url)\n        } catch (e) {\n          console.error(e)\n        }\n      }\n    },\n    [],\n  )\n  useEffect(() => {\n    if (rendererRef) {\n      rendererRef.current = rendererRef2.current\n    }\n  }, [rendererRef])\n\n  const openMenu = useCallback(\n    (event) => setAnchorEl(event.currentTarget),\n    [],\n  )\n  const [resolutionScale, setResolutionScale] = useState(1)\n  const resolutionScales = [\n    0.5,\n    1,\n    window.devicePixelRatio,\n    2,\n    4 * window.devicePixelRatio,\n  ]\n  const closeMenu = useCallback(() => setAnchorEl(undefined), [])\n  return (\n    React.createElement(Card, { sx: { ...sx, position: \"relative\" },}\n      , React.createElement(Menu, { open: !!anchorEl, anchorEl: anchorEl, onClose: closeMenu,}\n        , React.createElement(MenuItem, { 'data-dim': \"1920x1080\", onClick: render,}, \"Render HD\"\n\n        )\n        , React.createElement(MenuItem, { 'data-dim': \"3840x2160\", onClick: render,}, \"Render 4K\"\n\n        )\n        , React.createElement(ListItem, null\n          , React.createElement(ListItemText, null, \"Res Scale \"  ), \" \"\n          , React.createElement(Select, {\n            value: resolutionScale,\n            onChange: (e) => {\n              setAnchorEl(undefined)\n              setResolutionScale(+e.target.value)\n            },\n            size: \"small\",}\n\n            , resolutionScales.map((x) => (\n              React.createElement(MenuItem, { key: x, value: x,}\n                , x\n              )\n            ))\n          )\n        )\n      )\n      , React.createElement(Box, { sx: { position: \"absolute\", margin: 1, right: 0 },}\n        , renderProgress !== undefined ? (\n          React.createElement(CircularProgress, {\n            variant: \"determinate\",\n            value: renderProgress * 100,}\n          )\n        ) : (\n          React.createElement(Fab, { size: \"small\", onClick: openMenu,}\n            , React.createElement(MoreVertIcon, null )\n          )\n        )\n      )\n      , React.createElement(Box, { sx: { position: \"absolute\", margin: 1, left: 0 },}, fps)\n\n      , React.createElement(CardMedia, {\n        component: ReactGlCanvas,\n        Renderer: Renderer,\n        animate: animate,\n        state: state,\n        rendererRef: rendererRef2,\n        onFps: setFps,\n        resolutionScale: resolutionScale,\n        focusable: focusable,\n        sx: { width: \"100%\", height: \"100%\" },}\n      )\n    )\n  )\n}\n\nexport const ReactGlCanvas = ({\n  Renderer,\n  onFps,\n  animate,\n  state,\n  rendererRef,\n  focusable = false,\n  resolutionScale,\n}\n\n\n\n\n\n\n\n) => {\n  const canvasRef = useRef(null)\n  const rendererRef2 = useRef()\n\n  useEffect(() => {\n    if (canvasRef.current) {\n      const renderer1 = new Renderer(canvasRef.current, {\n        onFps,\n        resolutionScale,\n      })\n      rendererRef2.current = renderer1\n      renderer1.start()\n      if (rendererRef) {\n        rendererRef.current = renderer1\n      }\n      return () => renderer1.destroy()\n    }\n  }, [Renderer, onFps, resolutionScale, rendererRef])\n  const theme = useTheme()\n  useEffect(() => {\n    rendererRef2.current &&\n      Object.assign(rendererRef2.current.dyn, {\n        colorBackground: chroma.css(theme.palette.background.default).gl(),\n        colorPrimary: chroma.css(theme.palette.primary.main).gl(),\n        colorSecondary: chroma.css(theme.palette.secondary.main).gl(),\n      })\n  }, [rendererRef2.current, theme.palette])\n  useEffect(() => {\n    if (rendererRef2.current) rendererRef2.current.animate = animate\n  }, [rendererRef2.current, animate])\n  useEffect(() => {\n    if (rendererRef2.current) Object.assign(rendererRef2.current.dyn, state)\n  }, [rendererRef2.current, state])\n  return React.createElement('canvas', { ref: canvasRef, style: { width: \"100%\", height: \"100%\" },} )\n}\nexport class SimpleCanvasRenderer {\n  \n\n\n\n\n\n  \n\n   __init() {this.mousePos = [-1, -1] }\n\n  \n   __init2() {this.dyn = {}}\n   __init3() {this.animate = true}\n  \n   __init4() {this.stop = () => {}}\n  \n\n  constructor(\n      fragShader\n\n,\n      canvas,\n    {\n      onFps,\n      resolutionScale = window.devicePixelRatio,\n    },\n  ) {;this.fragShader = fragShader;this.canvas = canvas;SimpleCanvasRenderer.prototype.__init.call(this);SimpleCanvasRenderer.prototype.__init2.call(this);SimpleCanvasRenderer.prototype.__init3.call(this);SimpleCanvasRenderer.prototype.__init4.call(this);SimpleCanvasRenderer.prototype.__init5.call(this);\n    const mousemove = (e) => {\n      const canvas = e.currentTarget \n      const { width, height } = canvas.getBoundingClientRect()\n      this.mousePos = [\n        canvas.width * (e.offsetX / width),\n        canvas.height * (1 - e.offsetY / height),\n      ]\n    }\n    const mouseleave = (e) => {\n      this.mousePos = [-1, -1]\n    }\n    const gl = TSGLContext.create({\n      canvas: canvas,\n      alpha: true,\n      premultipliedAlpha: true,\n      // antialias: true,\n      // don't enable by default: bad for perf\n      // throwOnError: true,\n    }) \n    this.gl = gl\n    function fixCanvasRes() {\n      gl.canvas.width = gl.canvas.clientWidth * resolutionScale\n      gl.canvas.height = gl.canvas.clientHeight * resolutionScale\n      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height)\n    }\n    console.log(\"resolutionScale\", resolutionScale)\n    this.resolutionScale = resolutionScale\n    if (this.canvas.clientWidth !== 0) {\n      fixCanvasRes()\n      gl.canvas.addEventListener(\"resize\", fixCanvasRes)\n    }\n    gl.canvas.addEventListener(\"mouseleave\", mouseleave)\n    gl.canvas.addEventListener(\"mousemove\", mousemove)\n    this.planeMesh = Mesh.plane({ startX: -1, startY: -1, width: 2, height: 2 })\n    // Mesh.plane generates tex coords [0,1] and we want [-1, 1] for rendering.\n    // this.planeMesh.coords = [\n    //   [-1, -1],\n    //   [1, -1],\n    //   [-1, 1],\n    //   [1, 1],\n    // ]\n    this.planeMesh.compile(gl)\n    this.fpsController = onFps && new FPSController(onFps)\n    this.gl.makeCurrent()\n    this.updateShader()\n  }\n\n   updateShader() {\n    this.buildShader(\n      // eslint-disable-next-line @typescript-eslint/no-var-requires\n      require(\"../common/raymarch.vert\").default,\n      // eslint-disable-next-line @typescript-eslint/no-var-requires\n      this.fragShader(),\n    )\n  }\n\n   __init5() {this.buildShader = memoizeLast(\n    (vs, fs) => {\n      let sourceMap\n      try {\n        let fsSrc\n        if (typeof fs === \"string\") {\n          fsSrc = fs\n        } else {\n          fsSrc = fs.default\n          sourceMap = fs.sourceMap\n        }\n        // if (this.shader) {\n        //   this.gl.deleteProgram(this.shader.program)\n        // }\n        console.log(\"building shader\")\n\n        this.shader = Shader.create(vs, fsSrc, this.gl)\n      } catch (e) {\n        console.clear()\n        console.error(sourceMap)\n        if (sourceMap) {\n          const sourceMapConsumer = new SourceMapConsumer(sourceMap)\n          const newMessage = (e ).message.replace(\n            /ERROR: 0:(\\d+)/,\n            (match, line) => {\n              const originalPosition = sourceMapConsumer.originalPositionFor({\n                line: +line,\n                column: 0,\n              })\n              console.log(\"originalPosition\", originalPosition)\n              return (\n                \"ERROR \" +\n                originalPosition.source +\n                \":\" +\n                originalPosition.line +\n                \":\" +\n                originalPosition.column\n              )\n            },\n          )\n          ;(e ).message = newMessage\n        }\n\n        if (!this.shader) throw e\n      }\n    },\n  )}\n\n  start() {\n    this.stop = this.gl.animate(this.render.bind(this))\n  }\n\n  render(abs) {\n    console.log(\"render\", this.resolutionScale)\n    this.gl.makeCurrent()\n    this.updateShader()\n    _optionalChain([this, 'access', _ => _.fpsController, 'optionalAccess', _2 => _2.tick, 'call', _3 => _3(abs)])\n    // this.cam.tick(abs)\n    if (!this.shader) return\n    this.shader\n      .uniforms({\n        iResolution: [this.gl.canvas.width, this.gl.canvas.height],\n        iMouse: this.mousePos,\n        iTime: this.animate ? abs / 1000 : 0,\n      })\n      .uniforms(this.dyn)\n      .uniforms(this.uniforms())\n      .draw(this.planeMesh)\n  }\n\n  destroy() {\n    console.log(\"destroy\")\n    this.stop()\n    // this.planeMesh.destroy()\n    // this.shader.destroy()\n  }\n\n  async renderImage(\n    \n    [width, height],\n    onProgress,\n  ) {\n    _optionalChain([onProgress, 'optionalCall', _4 => _4(0)])\n    await sleep(10)\n    const canvas = document.createElement(\"canvas\")\n    canvas.width = width\n    canvas.height = height\n\n    console.log(this.constructor)\n    const renderer = new this.constructor(canvas, { resolutionScale: 4 })\n    Object.assign(renderer.dyn, this.dyn)\n    const step = 256\n    const gl = renderer.gl\n    gl.enable(gl.SCISSOR_TEST)\n    let donePixels = 0\n    for (let x = 0; x < width; x += step) {\n      for (let y = 0; y < height; y += step) {\n        const scissorWidth = Math.min(step, width - x)\n        const scissorHeight = Math.min(step, height - y)\n        gl.scissor(x, y, scissorWidth, scissorHeight)\n        // console.time(\"render block\")\n        renderer.render(0)\n        // console.timeEnd(\"render block\")\n        await sleep(0)\n        donePixels += scissorWidth * scissorHeight\n        _optionalChain([onProgress, 'optionalCall', _5 => _5(donePixels / (width * height))])\n      }\n    }\n    return new Promise((resolve, reject) =>\n      canvas.toBlob(\n        (blob) =>\n          blob ? resolve(blob) : reject(\"error creating png from canvas\"),\n        \"png\",\n      ),\n    )\n  }\n\n  /**\n   * Override this method to add additional uniforms to the simple renderer shader.\n   */\n   uniforms() {\n    return {}\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nexport function memoizeLast(f) {\n  let lastArgs = []\n  let lastResult\n  return function (...args) {\n    if (\n      lastArgs.length !== args.length ||\n      lastArgs.some((v, i) => v !== args[i])\n    ) {\n      lastArgs = args\n      lastResult = f(...args)\n    }\n    return lastResult\n  } \n}\n","import { Checkbox } from \"@mui/material\"\nimport Button from \"@mui/material/Button\"\nimport Card from \"@mui/material/Card\"\n\nimport CardMedia from \"@mui/material/CardMedia\"\nimport Grid from \"@mui/material/Grid\"\nimport MenuItem from \"@mui/material/MenuItem\"\nimport Select from \"@mui/material/Select\"\nimport { useTheme } from \"@mui/material/styles\"\nimport aesthetically from \"aesthetically\"\n\nimport * as React from \"react\"\nimport { useCallback, useEffect, useRef, useState } from \"react\"\n\n\nimport { BoundNumberField } from \"../common/BoundNumberField\"\n\n\nimport { useHashState } from \"../common/useHashState\"\nimport { FlyCameraController } from \"../raymarch/FlyCameraController\"\nimport { OrbitCameraController } from \"../raymarch/OrbitCameraController\"\n\nimport {\n  ReactGlCanvas,\n\n  SimpleCanvasRenderer,\n} from \"./SimpleCanvasRenderer\"\n\nfunction normfig(s) {\n  return aesthetically.format(s, \"monospace\")\n}\n\nconst initialState = {\n  a: 0.2,\n  b: 0.2,\n  c: 0.2,\n  d: 0.2,\n  animate: true,\n}\n\n\nfunction GenericDemo({\n  frag,\n  sx,\n  animate,\n  state,\n}\n\n\n\n\n\n) {\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  const Renderer = useCallback(\n    SimpleCanvasRenderer.bind(\n      undefined,\n      // eslint-disable-next-line @typescript-eslint/no-var-requires\n      () => require(\"./\" + frag + \".frag\"),\n    ),\n    [frag],\n  )\n\n  return (\n    React.createElement(Card, { sx: sx,}\n      , React.createElement(CardMedia, {\n        component: ReactGlCanvas,\n        Renderer: Renderer,\n        animate: animate,\n        state: state,\n        sx: { width: \"100%\", height: \"100%\" },}\n      )\n    )\n  )\n}\n\nexport default () => {\n  const [renderProgress, setRenderProgress] = useState(\n    undefined ,\n  )\n  const [resolution, setResolution] = useState(512)\n  const [state, setState] = useHashState(initialState)\n  const setStatePartial = useCallback(\n    (o) => setState((s) => ({ ...s, ...o })),\n    [setState],\n  )\n\n  const renderer = useRef(undefined )\n\n  // useEffect(() => {\n  //   tsgl.current = TSGLContext.create({\n  //     canvas: canvasRef.current!,\n  //     alpha: true,\n  //     premultipliedAlpha: true,\n  //     // antialias: true,\n  //     throwOnError: true,\n  //   })\n  //   tsgl.current.fixCanvasRes()\n  //   tsgl.current.addResizeListener()\n  //\n  //   renderer.current = new Renderer(tsgl.current)\n  //   renderer.current.start()\n  // }, [])\n  useEffect(() => {\n    // state.cam &&\n    //   raymarchRef.current?.setCam(\n    //     OrbitCameraController.fromShortString(state.cam),\n    //   )\n  }, [state.cam])\n  const theme = useTheme()\n\n  useEffect(() => {\n    renderer.current && Object.assign(renderer.current.dyn, state)\n  }, [state])\n  const render = () => {}\n\n  const RenderButton = useCallback(\n    ({ dim, children }) => (\n      React.createElement(Button, {\n        variant: \"contained\",\n        onClick: () => render(dim),\n        disabled: \"undefined\" !== typeof renderProgress,}\n\n        , \"undefined\" === typeof renderProgress\n          ? children\n          : \"Rendering... \" +\n            normfig(\"\" + Math.floor(renderProgress * 100)).padStart(\n              3,\n              \"\\u2007\",\n            ) +\n            \"%\"\n      )\n    ),\n    [render, renderProgress],\n  )\n\n  function setCam({ cam }) {\n    const m = FlyCameraController.fromShortString(cam)\n    setStatePartial({ cam: OrbitCameraController.toShortString(m) })\n  }\n\n  return (\n    React.createElement(Grid, { container: true, style: { height: \"99%\" }, spacing: 2, padding: 2,}\n      , React.createElement(Grid, { item: true, xs: 12,}\n        , React.createElement(GenericDemo, {\n          frag: \"demoTemple\",\n          sx: { height: 500 },\n          animate: state.animate,\n          state: state,}\n        )\n      )\n      , React.createElement(Grid, { item: true, xs: 12, md: 6, lg: 4,}\n        , React.createElement(Checkbox, {\n          checked: state.animate,\n          onChange: (_, animate) => setStatePartial({ animate }),}\n        )\n        , React.createElement(Select, {\n          onChange: (e) => setResolution(+(e.target.value )),\n          value: resolution,}\n\n          , React.createElement(MenuItem, { value: 256,}, \"256x256\")\n          , React.createElement(MenuItem, { value: 512,}, \"512x512\")\n        )\n        , React.createElement(BoundNumberField, {\n          ...{ state, setStatePartial },\n          prop: \"a\",\n          inputProps: { step: 0.05 },}\n        )\n        , React.createElement(BoundNumberField, {\n          ...{ state, setStatePartial },\n          prop: \"b\",\n          inputProps: { step: 0.05 },}\n        )\n        , React.createElement(BoundNumberField, {\n          ...{ state, setStatePartial },\n          prop: \"c\",\n          inputProps: { step: 0.05 },}\n        )\n        , React.createElement(BoundNumberField, {\n          ...{ state, setStatePartial },\n          prop: \"d\",\n          inputProps: { step: 0.05 },}\n        )\n      )\n      /*<Grid item xs={12} md={6} lg={4}>*/\n      /*  <GenericDemo*/\n      /*    frag=\"fractals\"*/\n      /*    sx={{ height: 300 }}*/\n      /*    animate={state.animate}*/\n      /*    state={state}*/\n      /*  />*/\n      /*</Grid>*/\n    )\n  )\n}\nif (module.hot) {\n  module.hot.accept(\"./fractals.frag\", () => {\n    console.log(\"updating\")\n  })\n}\n","import { unstable_generateUtilityClasses as generateUtilityClasses } from '@mui/utils';\nimport generateUtilityClass from '../generateUtilityClass';\nexport function getSwitchBaseUtilityClass(slot) {\n  return generateUtilityClass('PrivateSwitchBase', slot);\n}\nconst switchBaseClasses = generateUtilityClasses('PrivateSwitchBase', ['root', 'checked', 'disabled', 'input', 'edgeStart', 'edgeEnd']);\nexport default switchBaseClasses;","import _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nconst _excluded = [\"autoFocus\", \"checked\", \"checkedIcon\", \"className\", \"defaultChecked\", \"disabled\", \"disableFocusRipple\", \"edge\", \"icon\", \"id\", \"inputProps\", \"inputRef\", \"name\", \"onBlur\", \"onChange\", \"onFocus\", \"readOnly\", \"required\", \"tabIndex\", \"type\", \"value\"];\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport clsx from 'clsx';\nimport { refType } from '@mui/utils';\nimport { unstable_composeClasses as composeClasses } from '@mui/base';\nimport capitalize from '../utils/capitalize';\nimport styled from '../styles/styled';\nimport useControlled from '../utils/useControlled';\nimport useFormControl from '../FormControl/useFormControl';\nimport ButtonBase from '../ButtonBase';\nimport { getSwitchBaseUtilityClass } from './switchBaseClasses';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\nconst useUtilityClasses = ownerState => {\n  const {\n    classes,\n    checked,\n    disabled,\n    edge\n  } = ownerState;\n  const slots = {\n    root: ['root', checked && 'checked', disabled && 'disabled', edge && `edge${capitalize(edge)}`],\n    input: ['input']\n  };\n  return composeClasses(slots, getSwitchBaseUtilityClass, classes);\n};\nconst SwitchBaseRoot = styled(ButtonBase)(({\n  ownerState\n}) => _extends({\n  padding: 9,\n  borderRadius: '50%'\n}, ownerState.edge === 'start' && {\n  marginLeft: ownerState.size === 'small' ? -3 : -12\n}, ownerState.edge === 'end' && {\n  marginRight: ownerState.size === 'small' ? -3 : -12\n}));\nconst SwitchBaseInput = styled('input')({\n  cursor: 'inherit',\n  position: 'absolute',\n  opacity: 0,\n  width: '100%',\n  height: '100%',\n  top: 0,\n  left: 0,\n  margin: 0,\n  padding: 0,\n  zIndex: 1\n});\n\n/**\n * @ignore - internal component.\n */\nconst SwitchBase = /*#__PURE__*/React.forwardRef(function SwitchBase(props, ref) {\n  const {\n      autoFocus,\n      checked: checkedProp,\n      checkedIcon,\n      className,\n      defaultChecked,\n      disabled: disabledProp,\n      disableFocusRipple = false,\n      edge = false,\n      icon,\n      id,\n      inputProps,\n      inputRef,\n      name,\n      onBlur,\n      onChange,\n      onFocus,\n      readOnly,\n      required = false,\n      tabIndex,\n      type,\n      value\n    } = props,\n    other = _objectWithoutPropertiesLoose(props, _excluded);\n  const [checked, setCheckedState] = useControlled({\n    controlled: checkedProp,\n    default: Boolean(defaultChecked),\n    name: 'SwitchBase',\n    state: 'checked'\n  });\n  const muiFormControl = useFormControl();\n  const handleFocus = event => {\n    if (onFocus) {\n      onFocus(event);\n    }\n    if (muiFormControl && muiFormControl.onFocus) {\n      muiFormControl.onFocus(event);\n    }\n  };\n  const handleBlur = event => {\n    if (onBlur) {\n      onBlur(event);\n    }\n    if (muiFormControl && muiFormControl.onBlur) {\n      muiFormControl.onBlur(event);\n    }\n  };\n  const handleInputChange = event => {\n    // Workaround for https://github.com/facebook/react/issues/9023\n    if (event.nativeEvent.defaultPrevented) {\n      return;\n    }\n    const newChecked = event.target.checked;\n    setCheckedState(newChecked);\n    if (onChange) {\n      // TODO v6: remove the second argument.\n      onChange(event, newChecked);\n    }\n  };\n  let disabled = disabledProp;\n  if (muiFormControl) {\n    if (typeof disabled === 'undefined') {\n      disabled = muiFormControl.disabled;\n    }\n  }\n  const hasLabelFor = type === 'checkbox' || type === 'radio';\n  const ownerState = _extends({}, props, {\n    checked,\n    disabled,\n    disableFocusRipple,\n    edge\n  });\n  const classes = useUtilityClasses(ownerState);\n  return /*#__PURE__*/_jsxs(SwitchBaseRoot, _extends({\n    component: \"span\",\n    className: clsx(classes.root, className),\n    centerRipple: true,\n    focusRipple: !disableFocusRipple,\n    disabled: disabled,\n    tabIndex: null,\n    role: undefined,\n    onFocus: handleFocus,\n    onBlur: handleBlur,\n    ownerState: ownerState,\n    ref: ref\n  }, other, {\n    children: [/*#__PURE__*/_jsx(SwitchBaseInput, _extends({\n      autoFocus: autoFocus,\n      checked: checkedProp,\n      defaultChecked: defaultChecked,\n      className: classes.input,\n      disabled: disabled,\n      id: hasLabelFor ? id : undefined,\n      name: name,\n      onChange: handleInputChange,\n      readOnly: readOnly,\n      ref: inputRef,\n      required: required,\n      ownerState: ownerState,\n      tabIndex: tabIndex,\n      type: type\n    }, type === 'checkbox' && value === undefined ? {} : {\n      value\n    }, inputProps)), checked ? checkedIcon : icon]\n  }));\n});\n\n// NB: If changed, please update Checkbox, Switch and Radio\n// so that the API documentation is updated.\nprocess.env.NODE_ENV !== \"production\" ? SwitchBase.propTypes = {\n  /**\n   * If `true`, the `input` element is focused during the first mount.\n   */\n  autoFocus: PropTypes.bool,\n  /**\n   * If `true`, the component is checked.\n   */\n  checked: PropTypes.bool,\n  /**\n   * The icon to display when the component is checked.\n   */\n  checkedIcon: PropTypes.node.isRequired,\n  /**\n   * Override or extend the styles applied to the component.\n   * See [CSS API](#css) below for more details.\n   */\n  classes: PropTypes.object,\n  /**\n   * @ignore\n   */\n  className: PropTypes.string,\n  /**\n   * @ignore\n   */\n  defaultChecked: PropTypes.bool,\n  /**\n   * If `true`, the component is disabled.\n   */\n  disabled: PropTypes.bool,\n  /**\n   * If `true`, the  keyboard focus ripple is disabled.\n   * @default false\n   */\n  disableFocusRipple: PropTypes.bool,\n  /**\n   * If given, uses a negative margin to counteract the padding on one\n   * side (this is often helpful for aligning the left or right\n   * side of the icon with content above or below, without ruining the border\n   * size and shape).\n   * @default false\n   */\n  edge: PropTypes.oneOf(['end', 'start', false]),\n  /**\n   * The icon to display when the component is unchecked.\n   */\n  icon: PropTypes.node.isRequired,\n  /**\n   * The id of the `input` element.\n   */\n  id: PropTypes.string,\n  /**\n   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.\n   */\n  inputProps: PropTypes.object,\n  /**\n   * Pass a ref to the `input` element.\n   */\n  inputRef: refType,\n  /*\n   * @ignore\n   */\n  name: PropTypes.string,\n  /**\n   * @ignore\n   */\n  onBlur: PropTypes.func,\n  /**\n   * Callback fired when the state is changed.\n   *\n   * @param {object} event The event source of the callback.\n   * You can pull out the new checked state by accessing `event.target.checked` (boolean).\n   */\n  onChange: PropTypes.func,\n  /**\n   * @ignore\n   */\n  onFocus: PropTypes.func,\n  /**\n   * It prevents the user from changing the value of the field\n   * (not from interacting with the field).\n   */\n  readOnly: PropTypes.bool,\n  /**\n   * If `true`, the `input` element is required.\n   */\n  required: PropTypes.bool,\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: PropTypes.object,\n  /**\n   * @ignore\n   */\n  tabIndex: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n  /**\n   * The input component prop `type`.\n   */\n  type: PropTypes.string.isRequired,\n  /**\n   * The value of the component.\n   */\n  value: PropTypes.any\n} : void 0;\nexport default SwitchBase;","import * as React from 'react';\nimport createSvgIcon from '../../utils/createSvgIcon';\n\n/**\n * @ignore - internal component.\n */\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon( /*#__PURE__*/_jsx(\"path\", {\n  d: \"M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z\"\n}), 'CheckBoxOutlineBlank');","import * as React from 'react';\nimport createSvgIcon from '../../utils/createSvgIcon';\n\n/**\n * @ignore - internal component.\n */\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon( /*#__PURE__*/_jsx(\"path\", {\n  d: \"M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-9 14l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z\"\n}), 'CheckBox');","import * as React from 'react';\nimport createSvgIcon from '../../utils/createSvgIcon';\n\n/**\n * @ignore - internal component.\n */\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon( /*#__PURE__*/_jsx(\"path\", {\n  d: \"M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10H7v-2h10v2z\"\n}), 'IndeterminateCheckBox');","import { unstable_generateUtilityClasses as generateUtilityClasses } from '@mui/utils';\nimport generateUtilityClass from '../generateUtilityClass';\nexport function getCheckboxUtilityClass(slot) {\n  return generateUtilityClass('MuiCheckbox', slot);\n}\nconst checkboxClasses = generateUtilityClasses('MuiCheckbox', ['root', 'checked', 'disabled', 'indeterminate', 'colorPrimary', 'colorSecondary']);\nexport default checkboxClasses;","import _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nconst _excluded = [\"checkedIcon\", \"color\", \"icon\", \"indeterminate\", \"indeterminateIcon\", \"inputProps\", \"size\", \"className\"];\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport clsx from 'clsx';\nimport { refType } from '@mui/utils';\nimport { unstable_composeClasses as composeClasses } from '@mui/base';\nimport { alpha } from '@mui/system';\nimport SwitchBase from '../internal/SwitchBase';\nimport CheckBoxOutlineBlankIcon from '../internal/svg-icons/CheckBoxOutlineBlank';\nimport CheckBoxIcon from '../internal/svg-icons/CheckBox';\nimport IndeterminateCheckBoxIcon from '../internal/svg-icons/IndeterminateCheckBox';\nimport capitalize from '../utils/capitalize';\nimport useThemeProps from '../styles/useThemeProps';\nimport styled, { rootShouldForwardProp } from '../styles/styled';\nimport checkboxClasses, { getCheckboxUtilityClass } from './checkboxClasses';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst useUtilityClasses = ownerState => {\n  const {\n    classes,\n    indeterminate,\n    color\n  } = ownerState;\n  const slots = {\n    root: ['root', indeterminate && 'indeterminate', `color${capitalize(color)}`]\n  };\n  const composedClasses = composeClasses(slots, getCheckboxUtilityClass, classes);\n  return _extends({}, classes, composedClasses);\n};\nconst CheckboxRoot = styled(SwitchBase, {\n  shouldForwardProp: prop => rootShouldForwardProp(prop) || prop === 'classes',\n  name: 'MuiCheckbox',\n  slot: 'Root',\n  overridesResolver: (props, styles) => {\n    const {\n      ownerState\n    } = props;\n    return [styles.root, ownerState.indeterminate && styles.indeterminate, ownerState.color !== 'default' && styles[`color${capitalize(ownerState.color)}`]];\n  }\n})(({\n  theme,\n  ownerState\n}) => _extends({\n  color: (theme.vars || theme).palette.text.secondary\n}, !ownerState.disableRipple && {\n  '&:hover': {\n    backgroundColor: theme.vars ? `rgba(${ownerState.color === 'default' ? theme.vars.palette.action.activeChannel : theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(ownerState.color === 'default' ? theme.palette.action.active : theme.palette[ownerState.color].main, theme.palette.action.hoverOpacity),\n    // Reset on touch devices, it doesn't add specificity\n    '@media (hover: none)': {\n      backgroundColor: 'transparent'\n    }\n  }\n}, ownerState.color !== 'default' && {\n  [`&.${checkboxClasses.checked}, &.${checkboxClasses.indeterminate}`]: {\n    color: (theme.vars || theme).palette[ownerState.color].main\n  },\n  [`&.${checkboxClasses.disabled}`]: {\n    color: (theme.vars || theme).palette.action.disabled\n  }\n}));\nconst defaultCheckedIcon = /*#__PURE__*/_jsx(CheckBoxIcon, {});\nconst defaultIcon = /*#__PURE__*/_jsx(CheckBoxOutlineBlankIcon, {});\nconst defaultIndeterminateIcon = /*#__PURE__*/_jsx(IndeterminateCheckBoxIcon, {});\nconst Checkbox = /*#__PURE__*/React.forwardRef(function Checkbox(inProps, ref) {\n  var _icon$props$fontSize, _indeterminateIcon$pr;\n  const props = useThemeProps({\n    props: inProps,\n    name: 'MuiCheckbox'\n  });\n  const {\n      checkedIcon = defaultCheckedIcon,\n      color = 'primary',\n      icon: iconProp = defaultIcon,\n      indeterminate = false,\n      indeterminateIcon: indeterminateIconProp = defaultIndeterminateIcon,\n      inputProps,\n      size = 'medium',\n      className\n    } = props,\n    other = _objectWithoutPropertiesLoose(props, _excluded);\n  const icon = indeterminate ? indeterminateIconProp : iconProp;\n  const indeterminateIcon = indeterminate ? indeterminateIconProp : checkedIcon;\n  const ownerState = _extends({}, props, {\n    color,\n    indeterminate,\n    size\n  });\n  const classes = useUtilityClasses(ownerState);\n  return /*#__PURE__*/_jsx(CheckboxRoot, _extends({\n    type: \"checkbox\",\n    inputProps: _extends({\n      'data-indeterminate': indeterminate\n    }, inputProps),\n    icon: /*#__PURE__*/React.cloneElement(icon, {\n      fontSize: (_icon$props$fontSize = icon.props.fontSize) != null ? _icon$props$fontSize : size\n    }),\n    checkedIcon: /*#__PURE__*/React.cloneElement(indeterminateIcon, {\n      fontSize: (_indeterminateIcon$pr = indeterminateIcon.props.fontSize) != null ? _indeterminateIcon$pr : size\n    }),\n    ownerState: ownerState,\n    ref: ref,\n    className: clsx(classes.root, className)\n  }, other, {\n    classes: classes\n  }));\n});\nprocess.env.NODE_ENV !== \"production\" ? Checkbox.propTypes /* remove-proptypes */ = {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // |     To update them edit the d.ts file and run \"yarn proptypes\"     |\n  // ----------------------------------------------------------------------\n  /**\n   * If `true`, the component is checked.\n   */\n  checked: PropTypes.bool,\n  /**\n   * The icon to display when the component is checked.\n   * @default <CheckBoxIcon />\n   */\n  checkedIcon: PropTypes.node,\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: PropTypes.object,\n  /**\n   * @ignore\n   */\n  className: PropTypes.string,\n  /**\n   * The color of the component.\n   * It supports both default and custom theme colors, which can be added as shown in the\n   * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).\n   * @default 'primary'\n   */\n  color: PropTypes /* @typescript-to-proptypes-ignore */.oneOfType([PropTypes.oneOf(['default', 'primary', 'secondary', 'error', 'info', 'success', 'warning']), PropTypes.string]),\n  /**\n   * The default checked state. Use when the component is not controlled.\n   */\n  defaultChecked: PropTypes.bool,\n  /**\n   * If `true`, the component is disabled.\n   * @default false\n   */\n  disabled: PropTypes.bool,\n  /**\n   * If `true`, the ripple effect is disabled.\n   * @default false\n   */\n  disableRipple: PropTypes.bool,\n  /**\n   * The icon to display when the component is unchecked.\n   * @default <CheckBoxOutlineBlankIcon />\n   */\n  icon: PropTypes.node,\n  /**\n   * The id of the `input` element.\n   */\n  id: PropTypes.string,\n  /**\n   * If `true`, the component appears indeterminate.\n   * This does not set the native input element to indeterminate due\n   * to inconsistent behavior across browsers.\n   * However, we set a `data-indeterminate` attribute on the `input`.\n   * @default false\n   */\n  indeterminate: PropTypes.bool,\n  /**\n   * The icon to display when the component is indeterminate.\n   * @default <IndeterminateCheckBoxIcon />\n   */\n  indeterminateIcon: PropTypes.node,\n  /**\n   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.\n   */\n  inputProps: PropTypes.object,\n  /**\n   * Pass a ref to the `input` element.\n   */\n  inputRef: refType,\n  /**\n   * Callback fired when the state is changed.\n   *\n   * @param {React.ChangeEvent<HTMLInputElement>} event The event source of the callback.\n   * You can pull out the new checked state by accessing `event.target.checked` (boolean).\n   */\n  onChange: PropTypes.func,\n  /**\n   * If `true`, the `input` element is required.\n   * @default false\n   */\n  required: PropTypes.bool,\n  /**\n   * The size of the component.\n   * `small` is equivalent to the dense checkbox styling.\n   * @default 'medium'\n   */\n  size: PropTypes /* @typescript-to-proptypes-ignore */.oneOfType([PropTypes.oneOf(['medium', 'small']), PropTypes.string]),\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),\n  /**\n   * The value of the component. The DOM API casts this to a string.\n   * The browser uses \"on\" as the default value.\n   */\n  value: PropTypes.any\n} : void 0;\nexport default Checkbox;","\nexport default \"#version 300 es\\nprecision highp float;\\n\\nin vec4 ts_Vertex;\\nin vec2 ts_TexCoord;\\nout vec2 coord;\\nvoid main() {\\n  gl_Position = ts_Vertex;\\n  coord = ts_TexCoord;\\n}\\n\"\nconst sourceMap = {\"version\":3,\"sources\":[\"/home/runner/work/workshop/workshop/src/common/raymarch.vert\"],\"names\":[],\"mappings\":\"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA\"}\nexport { sourceMap };\n","\nexport default \"#version 300 es\\n\\nprecision highp float;\\n\\n// START ../common/colors.glsl\\nconst vec3 INDIAN_RED = vec3(0.804, 0.361, 0.361);\\nconst vec3 LIGHT_CORAL = vec3(0.941, 0.502, 0.502);\\nconst vec3 SALMON = vec3(0.98, 0.502, 0.447);\\nconst vec3 DARK_SALMON = vec3(0.914, 0.588, 0.478);\\nconst vec3 LIGHT_SALMON = vec3(1.0, 0.627, 0.478);\\nconst vec3 CRIMSON = vec3(0.863, 0.078, 0.235);\\nconst vec3 RED = vec3(1.0, 0.0, 0.0);\\nconst vec3 FIRE_BRICK = vec3(0.698, 0.133, 0.133);\\nconst vec3 DARK_RED = vec3(0.545, 0.0, 0.0);\\nconst vec3 PINK = vec3(1.0, 0.753, 0.796);\\nconst vec3 LIGHT_PINK = vec3(1.0, 0.714, 0.757);\\nconst vec3 HOT_PINK = vec3(1.0, 0.412, 0.706);\\nconst vec3 DEEP_PINK = vec3(1.0, 0.078, 0.576);\\nconst vec3 MEDIUM_VIOLET_RED = vec3(0.78, 0.082, 0.522);\\nconst vec3 PALE_VIOLET_RED = vec3(0.859, 0.439, 0.576);\\nconst vec3 CORAL = vec3(1.0, 0.498, 0.314);\\nconst vec3 TOMATO = vec3(1.0, 0.388, 0.278);\\nconst vec3 ORANGE_RED = vec3(1.0, 0.271, 0.0);\\nconst vec3 DARK_ORANGE = vec3(1.0, 0.549, 0.0);\\nconst vec3 ORANGE = vec3(1.0, 0.647, 0.0);\\nconst vec3 GOLD = vec3(1.0, 0.843, 0.0);\\nconst vec3 YELLOW = vec3(1.0, 1.0, 0.0);\\nconst vec3 LIGHT_YELLOW = vec3(1.0, 1.0, 0.878);\\nconst vec3 LEMON_CHION = vec3(1.0, 0.98, 0.804);\\nconst vec3 LIGHT_GOLDENROD_YELLOW = vec3(0.98, 0.98, 0.824);\\nconst vec3 PAPAYA_WHIP = vec3(1.0, 0.937, 0.835);\\nconst vec3 MOCCASIN = vec3(1.0, 0.894, 0.71);\\nconst vec3 PEACH_PU = vec3(1.0, 0.855, 0.725);\\nconst vec3 PALE_GOLDENROD = vec3(0.933, 0.91, 0.667);\\nconst vec3 KHAKI = vec3(0.941, 0.902, 0.549);\\nconst vec3 DARK_KHAKI = vec3(0.741, 0.718, 0.42);\\nconst vec3 LAVENDER = vec3(0.902, 0.902, 0.98);\\nconst vec3 THISTLE = vec3(0.847, 0.749, 0.847);\\nconst vec3 PLUM = vec3(0.867, 0.627, 0.867);\\nconst vec3 VIOLET = vec3(0.933, 0.51, 0.933);\\nconst vec3 ORCHID = vec3(0.855, 0.439, 0.839);\\nconst vec3 FUCHSIA = vec3(1.0, 0.0, 1.0);\\nconst vec3 MAGENTA = vec3(1.0, 0.0, 1.0);\\nconst vec3 MEDIUM_ORCHID = vec3(0.729, 0.333, 0.827);\\nconst vec3 MEDIUM_PURPLE = vec3(0.576, 0.439, 0.859);\\nconst vec3 BLUE_VIOLET = vec3(0.541, 0.169, 0.886);\\nconst vec3 DARK_VIOLET = vec3(0.58, 0.0, 0.827);\\nconst vec3 DARK_ORCHID = vec3(0.6, 0.196, 0.8);\\nconst vec3 DARK_MAGENTA = vec3(0.545, 0.0, 0.545);\\nconst vec3 PURPLE = vec3(0.502, 0.0, 0.502);\\nconst vec3 INDIGO = vec3(0.294, 0.0, 0.51);\\nconst vec3 SLATE_BLUE = vec3(0.416, 0.353, 0.804);\\nconst vec3 DARK_SLATE_BLUE = vec3(0.282, 0.239, 0.545);\\nconst vec3 GREEN_YELLOW = vec3(0.678, 1.0, 0.184);\\nconst vec3 CHARTREUSE = vec3(0.498, 1.0, 0.0);\\nconst vec3 LAWN_GREEN = vec3(0.486, 0.988, 0.0);\\nconst vec3 LIME = vec3(0.0, 1.0, 0.0);\\nconst vec3 LIME_GREEN = vec3(0.196, 0.804, 0.196);\\nconst vec3 PALE_GREEN = vec3(0.596, 0.984, 0.596);\\nconst vec3 LIGHT_GREEN = vec3(0.565, 0.933, 0.565);\\nconst vec3 MEDIUM_SPRING_GREEN = vec3(0.0, 0.98, 0.604);\\nconst vec3 SPRING_GREEN = vec3(0.0, 1.0, 0.498);\\nconst vec3 MEDIUM_SEA_GREEN = vec3(0.235, 0.702, 0.443);\\nconst vec3 SEA_GREEN = vec3(0.18, 0.545, 0.341);\\nconst vec3 FOREST_GREEN = vec3(0.133, 0.545, 0.133);\\nconst vec3 GREEN = vec3(0.0, 0.502, 0.0);\\nconst vec3 DARK_GREEN = vec3(0.0, 0.392, 0.0);\\nconst vec3 YELLOW_GREEN = vec3(0.604, 0.804, 0.196);\\nconst vec3 OLIVE_DRAB = vec3(0.42, 0.557, 0.137);\\nconst vec3 OLIVE = vec3(0.502, 0.502, 0.0);\\nconst vec3 DARK_OLIVE_GREEN = vec3(0.333, 0.42, 0.184);\\nconst vec3 MEDIUM_AQUAMARINE = vec3(0.4, 0.804, 0.667);\\nconst vec3 DARK_SEA_GREEN = vec3(0.561, 0.737, 0.561);\\nconst vec3 LIGHT_SEA_GREEN = vec3(0.125, 0.698, 0.667);\\nconst vec3 DARK_CYAN = vec3(0.0, 0.545, 0.545);\\nconst vec3 TEAL = vec3(0.0, 0.502, 0.502);\\nconst vec3 AQUA = vec3(0.0, 1.0, 1.0);\\nconst vec3 CYAN = vec3(0.0, 1.0, 1.0);\\nconst vec3 LIGHT_CYAN = vec3(0.878, 1.0, 1.0);\\nconst vec3 PALE_TURQUOISE = vec3(0.686, 0.933, 0.933);\\nconst vec3 AQUAMARINE = vec3(0.498, 1.0, 0.831);\\nconst vec3 TURQUOISE = vec3(0.251, 0.878, 0.816);\\nconst vec3 MEDIUM_TURQUOISE = vec3(0.282, 0.82, 0.8);\\nconst vec3 DARK_TURQUOISE = vec3(0.0, 0.808, 0.82);\\nconst vec3 CADET_BLUE = vec3(0.373, 0.62, 0.627);\\nconst vec3 STEEL_BLUE = vec3(0.275, 0.51, 0.706);\\nconst vec3 LIGHT_STEEL_BLUE = vec3(0.69, 0.769, 0.871);\\nconst vec3 POWDER_BLUE = vec3(0.69, 0.878, 0.902);\\nconst vec3 LIGHT_BLUE = vec3(0.678, 0.847, 0.902);\\nconst vec3 SKY_BLUE = vec3(0.529, 0.808, 0.922);\\nconst vec3 LIGHT_SKY_BLUE = vec3(0.529, 0.808, 0.98);\\nconst vec3 DEEP_SKY_BLUE = vec3(0.0, 0.749, 1.0);\\nconst vec3 DODGER_BLUE = vec3(0.118, 0.565, 1.0);\\nconst vec3 CORNLOWER_BLUE = vec3(0.392, 0.584, 0.929);\\nconst vec3 MEDIUM_SLATE_BLUE = vec3(0.482, 0.408, 0.933);\\nconst vec3 ROYAL_BLUE = vec3(0.255, 0.412, 0.882);\\nconst vec3 BLUE = vec3(0.0, 0.0, 1.0);\\nconst vec3 MEDIUM_BLUE = vec3(0.0, 0.0, 0.804);\\nconst vec3 DARK_BLUE = vec3(0.0, 0.0, 0.545);\\nconst vec3 NAVY = vec3(0.0, 0.0, 0.502);\\nconst vec3 MIDNIGHT_BLUE = vec3(0.098, 0.098, 0.439);\\nconst vec3 CORNSILK = vec3(1.0, 0.973, 0.863);\\nconst vec3 BLANCHED_ALMOND = vec3(1.0, 0.922, 0.804);\\nconst vec3 BISQUE = vec3(1.0, 0.894, 0.769);\\nconst vec3 NAVAJO_WHITE = vec3(1.0, 0.871, 0.678);\\nconst vec3 WHEAT = vec3(0.961, 0.871, 0.702);\\nconst vec3 BURLY_WOOD = vec3(0.871, 0.722, 0.529);\\nconst vec3 TAN = vec3(0.824, 0.706, 0.549);\\nconst vec3 ROSY_BROWN = vec3(0.737, 0.561, 0.561);\\nconst vec3 SANDY_BROWN = vec3(0.957, 0.643, 0.376);\\nconst vec3 GOLDENROD = vec3(0.855, 0.647, 0.125);\\nconst vec3 DARK_GOLDENROD = vec3(0.722, 0.525, 0.043);\\nconst vec3 PERU = vec3(0.804, 0.522, 0.247);\\nconst vec3 CHOCOLATE = vec3(0.824, 0.412, 0.118);\\nconst vec3 SADDLE_BROWN = vec3(0.545, 0.271, 0.075);\\nconst vec3 SIENNA = vec3(0.627, 0.322, 0.176);\\nconst vec3 BROWN = vec3(0.647, 0.165, 0.165);\\nconst vec3 MAROON = vec3(0.502, 0.0, 0.0);\\nconst vec3 WHITE = vec3(1.0, 1.0, 1.0);\\nconst vec3 SNOW = vec3(1.0, 0.98, 0.98);\\nconst vec3 HONEYDEW = vec3(0.941, 1.0, 0.941);\\nconst vec3 MINT_CREAM = vec3(0.961, 1.0, 0.98);\\nconst vec3 AZURE = vec3(0.941, 1.0, 1.0);\\nconst vec3 ALICE_BLUE = vec3(0.941, 0.973, 1.0);\\nconst vec3 GHOST_WHITE = vec3(0.973, 0.973, 1.0);\\nconst vec3 WHITE_SMOKE = vec3(0.961, 0.961, 0.961);\\nconst vec3 SEASHELL = vec3(1.0, 0.961, 0.933);\\nconst vec3 BEIGE = vec3(0.961, 0.961, 0.863);\\nconst vec3 OLD_LACE = vec3(0.992, 0.961, 0.902);\\nconst vec3 FLORAL_WHITE = vec3(1.0, 0.98, 0.941);\\nconst vec3 IVORY = vec3(1.0, 1.0, 0.941);\\nconst vec3 ANTIQUE_WHITE = vec3(0.98, 0.922, 0.843);\\nconst vec3 LINEN = vec3(0.98, 0.941, 0.902);\\nconst vec3 LAVENDER_BLUSH = vec3(1.0, 0.941, 0.961);\\nconst vec3 MISTY_ROSE = vec3(1.0, 0.894, 0.882);\\nconst vec3 GAINSBORO = vec3(0.863, 0.863, 0.863);\\nconst vec3 LIGHT_GREY = vec3(0.827, 0.827, 0.827);\\nconst vec3 SILVER = vec3(0.753, 0.753, 0.753);\\nconst vec3 DARK_GRAY = vec3(0.663, 0.663, 0.663);\\nconst vec3 GRAY = vec3(0.502, 0.502, 0.502);\\nconst vec3 DIM_GRAY = vec3(0.412, 0.412, 0.412);\\nconst vec3 LIGHT_SLATE_GRAY = vec3(0.467, 0.533, 0.6);\\nconst vec3 SLATE_GRAY = vec3(0.439, 0.502, 0.565);\\nconst vec3 DARK_SLATE_GRAY = vec3(0.184, 0.31, 0.31);\\nconst vec3 BLACK = vec3(0.0, 0.0, 0.0);\\n\\n// END ../common/colors.glsl\\n// START ../common/matrices.glsl\\n// START ./constants.glsl\\nconst float SQRT1_2 = 0.7071067811865476;\\nconst float SQRT1_3 = 0.57735026919;\\nconst float SQRT2 = 1.4142135623730951;\\nconst float SQRT3 = 1.732050807568877;\\n// sqrt(3)/2 = sin(60*)\\nconst float SQRT3_2 = 0.86602540378;\\nconst float GOLDEN_RATIO = 1.61803398875;\\nconst float PI = 3.141592653589793;\\nconst float TAU = 6.28318530718;\\n/**\\n * One degree in radians. Use like `sin(30 * DEG)`.\\n */\\nconst float DEGREE = 0.017453292519943295;\\n\\n// END ./constants.glsl\\n\\nmat2 rot2(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat2(c, s, -s, c);\\n}\\nmat3 rotX(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\\n}\\nmat3 rotY(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\\n}\\nmat3 rotZ(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\\n}\\n/**\\n * Returns a matrix that puts the camera at the eye point `ex, ey, ez` looking\\n * toward the center point `cx, cy, cz` with an up direction of `ux, uy, uz`.\\n * This emulates the OpenGL function `gluLookAt()`.\\n */\\nmat4 lookAt(vec3 eye, vec3 focus, vec3 up) {\\n  vec3 f = normalize(eye - focus);\\n  vec3 s = normalize(cross(up, f));\\n  vec3 t = normalize(cross(f, s));\\n\\n  return mat4(\\n    vec4(s.x, t.x, f.x, 0.0),\\n    vec4(s.y, t.y, f.y, 0.0),\\n    vec4(s.z, t.z, f.z, 0.0),\\n    vec4(-dot(s, eye), -dot(t, eye), -dot(f, eye), 1)\\n  );\\n}\\n\\n// the OpenGL function `glFrustum()`.\\nmat4 frustum(\\n  float left,\\n  float right,\\n  float bottom,\\n  float top,\\n  float near,\\n  float far\\n) {\\n  return mat4(\\n    vec4(2.0 * near / (right - left), 0.0, 0.0, 0.0),\\n    vec4(0, 2.0 * near / (top - bottom), 0.0, 0.0),\\n    vec4(\\n      (right + left) / (right - left),\\n      (top + bottom) / (top - bottom),\\n      -(far + near) / (far - near),\\n      -1\\n    ),\\n    vec4(0.0, 0.0, -2.0 * far * near / (far - near), 0.0)\\n  );\\n}\\n\\nmat4 perspective(float fovDegrees, float aspect, float near, float far) {\\n  float y = tan(fovDegrees * DEGREE / 2.0) * near;\\n  float x = y * aspect;\\n  return frustum(-x, x, -y, y, near, far);\\n}\\nmat4 ortho(\\n  float left,\\n  float right,\\n  float bottom,\\n  float top,\\n  float near,\\n  float far\\n) {\\n  return mat4(\\n    vec4(2.0 / (right - left), 0.0, 0.0, 0.0),\\n    vec4(0.0, 2.0 / (top - bottom), 0.0, 0.0),\\n    vec4(0.0, 0.0, -2.0 / (far - near), 0.0),\\n    vec4(\\n      -(right + left) / (right - left),\\n      -(top + bottom) / (top - bottom),\\n      -(far + near) / (far - near),\\n      1.0\\n    )\\n  );\\n}\\n\\n// END ../common/matrices.glsl\\n// START ../common/max3.glsl\\nfloat max3(float a, float b, float c) {\\n  return max(a, max(b, c));\\n}\\nfloat max3(vec3 v) {\\n  return max(v.x, max(v.y, v.z));\\n}\\n\\n// #pragma glslify: export(max3)\\n\\n\\n// END ../common/max3.glsl\\n// START ../common/polar.glsl\\n// START ../common/fromPolar.glsl\\n// START ./unmix.glsl\\nfloat unmix(float a, float b, float value) {\\n  return (value - a) / (b - a);\\n}\\n\\n// #pragma glslify: export(unmix)\\n\\n\\n// END ./unmix.glsl\\n\\nvec3 fromPolar(float radius, float phi, float z) {\\n  return vec3(radius * cos(phi), radius * sin(phi), z);\\n}\\n\\nvec2 fromPolar(float radius, float phi) {\\n  return vec2(radius * cos(phi), radius * sin(phi));\\n}\\n\\nvec2 fromPolar(vec2 polar) {\\n  return fromPolar(polar.x, polar.y);\\n}\\n\\n// #pragma glslify: export(fromPolar)\\n\\n\\n// END ../common/fromPolar.glsl\\n// START ../common/toPolar.glsl\\n\\nvec2 toPolar(vec2 xy) {\\n  return vec2(length(xy), atan(xy.y, xy.x));\\n}\\n\\nmat2 toPolarDerivate(vec2 xy) {\\n  return mat2(xy.x * xy.x, xy.y * xy.y, -xy.y, xy.x) / dot(xy, xy);\\n}\\n\\n// #pragma glslify: export(toPolar)\\n\\n\\n// END ../common/toPolar.glsl\\n\\n// END ../common/polar.glsl\\n// START ../common/sdf3d/sdArrow.glsl\\n// START ./sdCylinder.glsl\\nfloat sdCylinder(float radius, float z, vec3 p) {\\n  vec2 d = vec2(length(p.xy), abs(p.z)) - vec2(radius, z);\\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\\n}\\n\\n// #pragma glslify: export(sdCylinder)\\n\\n\\n// END ./sdCylinder.glsl\\n// START ./sdCone.glsl\\n\\n/**\\n * Signed distance function (SDF) of a cone. The tip of the cone is at the\\n * origin and points towards +Z. q is a point on the rim of the cone.\\n */\\nfloat sdCone(vec2 c, float h, vec3 p) {\\n  vec2 q = h * vec2(c.x / c.y, -1.0);\\n  vec2 w = vec2(length(p.xz), p.y);\\n  vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);\\n  vec2 b = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0);\\n  float k = sign(q.y);\\n  float d = min(dot(a, a), dot(b, b));\\n  float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));\\n  return sqrt(d) * sign(s);\\n}\\n// #pragma glslify: export(sdBox)\\n\\nfloat sdConeB(vec2 c, float h, vec3 p) {\\n  float q = length(p.xz);\\n  return max(dot(c.xy, vec2(q, p.y)), -h - p.y);\\n}\\n\\n// END ./sdCone.glsl\\nvec3 perpendicularVector(vec3 a) {\\n  return cross(a, abs(a.z) > abs(a.x) ? vec3(0, 0, 1) : vec3(0, 1, 0));\\n}\\n/**\\n * Signed distance function (SDF) of an arrow. The arrow goes along the X axis.\\n * The shaft of the arrow has thickness TODO. The tip of the arrow has 30°\\n * angle, length of TODO, with the widest point being.\\n */\\nfloat sdArrow(float length, vec3 p) {\\n  float r = 0.01;\\n  return min(\\n    sdCylinder(\\n      0.02 - r,\\n      0.5 * (length - 0.1) - r,\\n      p.yzx - vec3(0, 0, 0.5 * (length - 0.1))\\n    ) -\\n      r,\\n    sdCone(\\n      vec2(sin(15.0 * DEGREE), cos(15.0 * DEGREE)),\\n      0.15 - r,\\n      p.zxy - vec3(0, length - r, 0)\\n    ) -\\n      r\\n  );\\n}\\nfloat sdArrow(vec3 a, vec3 b, vec3 p) {\\n  vec3 x = normalize(b - a);\\n  vec3 y = normalize(perpendicularVector(x));\\n  vec3 z = cross(x, y);\\n  return sdArrow(length(b - a), inverse(mat3(x, y, z)) * (p - a));\\n}\\n\\n// END ../common/sdf3d/sdArrow.glsl\\n// START ../common/sdf3d/sdBox.glsl\\n\\nfloat sdBox(vec3 r, vec3 p) {\\n  vec3 q = abs(p) - r;\\n  return length(max(q, 0.0)) + min(max3(q), 0.0);\\n}\\n\\nfloat sdBox(vec3 r, float r2, vec3 p) {\\n  return sdBox(r - r2, p) - r2;\\n}\\n\\n// #pragma glslify: export(sdBox)\\n\\n\\n// END ../common/sdf3d/sdBox.glsl\\n// START ../common/sdf3d/sdIcosahedron.glsl\\n\\n// signed distance function for icosahedron\\n// cf. https://en.wikipedia.org/wiki/Regular_icosahedron\\n// s: edge length\\n// p: point to evaluate function for\\nfloat sdIcosahedron(float s, vec3 p) {\\n  // NN = 1/GOLDEN_RATIO = GOLDEN_RATIO - 1\\n  const float K = GOLDEN_RATIO * 0.5;\\n  // the three vertices of the icosahedron triangle which\\n  // is fully inside the +++ octant. (edge length = 1)\\n  const vec3 a = vec3(0.5, K, 0.0);\\n  const vec3 b = vec3(0.0, 0.5, K);\\n  const vec3 c = vec3(K, 0.0, 0.5);\\n  const vec3 ab1 = b - a; // values chosen so edge length is 1\\n  const vec3 n1 = normalize(cross(a, b));\\n  const vec3 n2 = normalize(cross(b, c));\\n  const vec3 n3 = normalize(cross(c, a));\\n  const vec3 xyz1 = normalize(vec3(1.0));\\n  // for edge-length 1\\n  const float INSCRIBED_SPHERE_RADIUS = 0.7557613141;\\n\\n  // we use a rotation where the icosahedron is symmetric\\n  // in all three coordinate planes, and reduce the problem\\n  // to the +++ octant\\n  p = abs(p);\\n\\n  // there is one complete triangle in the +++ octant\\n  // mirror on planes which go through origin and the\\n  // complete triangles sides.\\n  if (dot(p, n1) < 0.0) {\\n    p += -2.0 * dot(p, n1) * n1;\\n  }\\n  if (dot(p, n2) < 0.0) {\\n    p += -2.0 * dot(p, n2) * n2;\\n  }\\n  if (dot(p, n3) < 0.0) {\\n    p += -2.0 * dot(p, n3) * n3;\\n  }\\n\\n  // rotate space around (1,1,1) vector so that all sides of the triangle\\n  // end up mapped on the ab side.\\n  vec3 dirs = vec3(-dot(n1, p), -dot(n2, p), -dot(n3, p));\\n  if (dirs.y > dirs.x && dirs.y > dirs.z) {\\n    p = p.yzx;\\n  } else if (dirs.z > dirs.x && dirs.z > dirs.y) {\\n    p = p.zxy;\\n  }\\n\\n  // check if the point is directly (perpendicular) above the triangle.\\n  // as we have rotated the space, we only need to check if it is\\n  // inside one edge.\\n  vec3 midAB = (a + b) / 2.0;\\n  vec3 pn = normalize(c - midAB);\\n  float w = dot(midAB, pn);\\n  if (dot(p, pn) > w * s) {\\n    // if not, return the distance to the plane the triangle is in\\n    return dot(xyz1, p) - INSCRIBED_SPHERE_RADIUS * s;\\n  }\\n\\n  // project the point onto segment ab, and return the distance to it\\n  float d3 = dot(ab1, p);\\n  d3 = clamp(d3, -0.5 * s, 0.5 * s);\\n  vec3 closestp = midAB * s + d3 * ab1;\\n  return distance(closestp, p);\\n}\\n// #pragma glslify: export(sdIcosahedron)\\n\\n// END ../common/sdf3d/sdIcosahedron.glsl\\n// START ../common/sdf3d/sdOctahedron.glsl\\nfloat sdOctahedron(float s, vec3 p) {\\n  p = abs(p);\\n  float m = p.x + p.y + p.z - s;\\n  vec3 q;\\n  if (3.0 * p.x < m) q = p.xyz;\\n  else if (3.0 * p.y < m) q = p.yzx;\\n  else if (3.0 * p.z < m) q = p.zxy;\\n  else return m * 0.57735027;\\n\\n  float k = clamp(0.5 * (q.z - q.y + s), 0.0, s);\\n  return length(vec3(q.x, q.y - s + k, q.z - k));\\n}\\n// #pragma glslify: export(sdOctahedron)\\n\\nfloat sdOctahedron(vec3 p, float s) {\\n  p = abs(p);\\n\\n  float m = p.x + p.y + p.z - s;\\n  //find point on octohedron surf nearest to p\\n  vec3 projPoint = p - vec3(0.333333 * m); //project onto surface plane\\n  //now push projected point, if outside triangle edge, perpendicular to edge, to edge\\n  vec3 toMove = min(projPoint, 0.0); //if projpoint.x<0 move along (1.0,-0.5,-0.5) , etc\\n  float toMoveSum = dot(toMove, vec3(1.0)); //which is basically along (1.5,0,0) then vec3(-0.5)\\n\\n  vec3 movedPoint = projPoint + toMove * vec3(-1.5) + toMoveSum * vec3(0.5); //better to multiply toMove by a matrix (1s diagonal, 0.5 other)?\\n\\n  movedPoint = max(movedPoint, 0.0); //cap x,y,z to 0 then\\n  movedPoint *= s / dot(movedPoint, vec3(1.0)); //scale about 0,0,0\\n\\n  return length(p - movedPoint);\\n}\\n\\n// END ../common/sdf3d/sdOctahedron.glsl\\n// START ../common/sdf3d/sdDodecahedron.glsl\\n\\nfloat sdDodecahedron(float s, vec3 p, out vec3 color) {\\n  const float PHI = GOLDEN_RATIO;\\n  color = vec3(0.2);\\n  if (p != abs(p)) {\\n    p = abs(p);\\n    if (color == vec3(0.2)) color = RED;\\n  }\\n  p = abs(p);\\n  const vec3 fv =\\n    vec3(1.0 / PHI, 0, PHI) + 2.0 * vec3(1, 0, 1) + 2.0 * vec3(PHI, 0, 0);\\n  const vec3 fv2 =\\n    vec3(PHI, 1.0 / PHI, 0) + 2.0 * vec3(1, 1, 0) + 2.0 * vec3(0, PHI, 0);\\n  const vec3 fv3 =\\n    vec3(0, PHI, 1.0 / PHI) + 2.0 * vec3(0, 1, 1) + 2.0 * vec3(0, 0, PHI);\\n  return max3(\\n    dot(normalize(fv), p),\\n    dot(normalize(fv2), p),\\n    dot(normalize(fv3), p)\\n  ) -\\n  s;\\n  //  float m = p.x + p.y + p.z - s;\\n  //  vec3 q;\\n  //  if (3.0 * p.x < m) q = p.xyz;\\n  //  else if (3.0 * p.y < m) q = p.yzx;\\n  //  else if (3.0 * p.z < m) q = p.zxy;\\n  //  else return m * 0.57735027;\\n  //\\n  //  float k = clamp(0.5 * (q.z - q.y + s), 0.0, s);\\n  //  return length(vec3(q.x, q.y - s + k, q.z - k));\\n}\\nfloat sdDodecahedron(float s, vec3 p) {\\n  vec3 c;\\n  return sdDodecahedron(s, p, c);\\n}\\n\\n// END ../common/sdf3d/sdDodecahedron.glsl\\n// START ../common/sdf3d/sdTetrahedron.glsl\\n// START ./sdCapsule.glsl\\nfloat sdCapsule(vec3 a, vec3 b, float r, vec3 p) {\\n  vec3 pa = p - a;\\n  vec3 ba = b - a;\\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\\n  return length(pa - ba * h) - r;\\n}\\n// #pragma glslify: export(sdCapsule)\\n\\n// END ./sdCapsule.glsl\\n\\n/**\\n * Signed distance function (SDF) of a tetrahedron centered at the origin with\\n * side length `2s`.\\n *\\n * The corners are at `a/b = (+-1,0,sqrt(1/2))` and `c/d = (0,+-1,-sqrt(1/2))`.\\n *\\n * The side length is `||`\\n *\\n * The outscribed sphere has a radius of `sqrt(3/2)`.\\n *\\n * The inscribed sphere has a radius of `sqrt(1/6)`. This is calculated using\\n * the fact that the triangle defined by `mid(a,b) = (0,0,sqrt(1/2))`, `c` and\\n * `mid(c,d) = (0,0,-sqrt(1/2))` is similar to the triangle `mid(a,b)`, `q`, and\\n * `O`.\\n *\\n * For rounded edges, use TODO.\\n *\\n * ```\\n *           ^ Z\\n *           |(+-1, sqrt(1/2))\\n *          /\\\\_\\n *        /    \\\\.q = closest point to center on face\\n *      /    .   \\\\__> Y\\n *    /            \\\\_\\n *  /________________\\\\_(0,-1,sqrt(1/2))\\n * (0,-1,-sqrt(1/2))\\n * ```\\n */\\nfloat sdTetrahedron(float s, vec3 p) {\\n  const vec3 a = vec3(1, 0, SQRT1_2);\\n  const vec3 b = vec3(-1, 0, SQRT1_2);\\n  const vec3 c = vec3(0, 1, -SQRT1_2);\\n  const vec3 d = vec3(0, -1, -SQRT1_2);\\n  const vec3 midBC = 0.5 * (b + c);\\n  const vec3 mirror = normalize(cross(midBC - d, midBC - a));\\n\\n  // Tetra is symmetric in X and Y axes. RED surface in image.\\n  p.xy = abs(p.xy);\\n  // The part z < 0 is symmetric if we rotate it by 90°. BLUE surface in image.\\n  if (p.z < 0.0) {\\n    p = vec3(p.y, p.x, -p.z);\\n  }\\n  // Points below the plane through a, d and mid(b,c) are mirrored through it.\\n  // GREEN surface in image.\\n  p -= 2.0 * mirror * min(dot(p, mirror), 0.0);\\n  // After mirror some points are negative, abs again:\\n  p.xy = abs(p.xy);\\n\\n  // Points are now either above the white surface, or above the positive ab segment.\\n  // We shift the coordinate system so that a is now at the origin.\\n  p -= vec3(1, 0, SQRT1_2) * s;\\n  // Finally, we move points which are directely above the face parallel along\\n  // it to a/origin. We can then calculate the sdf as length(p).\\n  p.x = max(p.x, 0.0);\\n  vec3 midABToC1 = normalize(vec3(0, 1, -SQRT2));\\n\\n  p -= max(dot(midABToC1, p), 0.0) * midABToC1;\\n  return sign(p.z) * length(p);\\n}\\n\\n// Same function but also outputs color for explanation image:\\n//float sdTetrahedron(float s, vec3 p, out vec3 color) {\\n//  //  return distance(vec3(1), p) - 0.2;\\n//  const vec3 a = vec3(0, -1, -SQRT1_2);\\n//  const vec3 b = vec3(0, 1, -SQRT1_2);\\n//  const vec3 c = vec3(1, 0, SQRT1_2);\\n//  const vec3 d = vec3(-1, 0, SQRT1_2);\\n//  const vec3 x = 0.5 * (b + d);\\n//  const vec3 mirror = normalize(cross(x - a, x - c));\\n//\\n//  color = WHITE;\\n//  if (p.xy != abs(p.xy)) {\\n//    p.xy = abs(p.xy);\\n//    if (color == WHITE) color = RED;\\n//  }\\n//  if (p.z < 0.0) {\\n//    p = vec3(p.y, p.x, -p.z);\\n//    if (color == WHITE) color = BLUE;\\n//  }\\n//  if (dot(p, mirror) < 0.0) {\\n//    if (color == WHITE) color = GREEN;\\n//    p -= 2.0 * mirror * min(dot(p, mirror), 0.0);\\n//  }\\n//  p.xy = abs(p.xy);\\n//  p -= vec3(1, 0, SQRT1_2);\\n//  p.x = max(p.x, 0.0);\\n//  vec3 fgh = normalize(vec3(0, 1, -SQRT2));\\n//\\n//  p -= max(dot(fgh, p), 0.0) * fgh;\\n//  return sign(p.z) * length(p);\\n//}\\n\\n\\n// END ../common/sdf3d/sdTetrahedron.glsl\\n// START ../common/ungamma.glsl\\nvec3 ungamma(vec4 col) {\\n  return pow(col.rgb, vec3(2.2));\\n}\\nvec3 ungamma(vec3 col) {\\n  return pow(col, vec3(2.2));\\n}\\n\\n// END ../common/ungamma.glsl\\n\\nuniform sampler2D texture;\\nuniform float iTime;\\nuniform vec4 colorPrimary;\\nuniform vec4 colorSecondary;\\nuniform vec4 colorBackground;\\nuniform float a;\\nuniform float b;\\nuniform float c;\\nuniform float d;\\nuniform int bandCount;\\nuniform vec2 iResolution;\\nuniform vec2 iMouse;\\nin float n;\\nin vec2 coord;\\nout vec4 fragColor;\\n\\n\\nstruct Hit {\\n  float distance;\\n  vec4 color;\\n};\\nHit mixa(Hit a, Hit b, float t) {\\n  return Hit(mix(a.distance, b.distance, t), mix(a.color, b.color, t));\\n}\\nfloat skybox(vec3 p) {\\n  return 32.0 - max3(abs(p));\\n}\\n\\nHit add(Hit a, Hit b) {\\n  //    return a.distance < b.distance\\n  //        ? Hit(a.distance, a.color)\\n  //        : Hit(b.distance, b.color);\\n  return mixa(a, b, float(b.distance < a.distance));\\n}\\n\\nHit addFillet(float r, Hit a, Hit b) {\\n  if (a.distance < r && b.distance < r) {\\n    return Hit(\\n      r - distance(vec2(a.distance, b.distance), vec2(r)),\\n      mix(a.color, b.color, (a.distance - b.distance) / r * 0.5 + 0.5)\\n    );\\n  } else {\\n    return add(a, b);\\n  }\\n}\\n\\nHit addFillet(float r, Hit a, Hit b, vec4 tilletColor) {\\n  if (a.distance < r && b.distance < r) {\\n    return Hit(\\n      r - distance(vec2(a.distance, b.distance), vec2(r)),\\n      tilletColor\\n    );\\n  } else {\\n    return add(a, b);\\n  }\\n}\\nHit addFillet2(float r, Hit a, Hit b) {\\n  float h = smoothstep(-r, r, a.distance - b.distance);\\n  return Hit(\\n    mix(a.distance, b.distance, h) - r * h * (1.0 - h),\\n    mix(a.color, b.color, h)\\n  );\\n}\\n\\nHit neg(Hit a) {\\n  return Hit(-a.distance, a.color);\\n}\\nHit sub(Hit from, Hit what) {\\n  Hit whatNeg = neg(what);\\n  return mixa(from, whatNeg, float(whatNeg.distance > from.distance));\\n}\\n\\nvec3 modv(vec3 v, vec3 dir1, float y) {\\n  float t = dot(v, dir1);\\n  return v - floor(t / y) * y * dir1;\\n}\\nvec3 modRotZ(vec3 p, float count) {\\n  vec2 polarXY = toPolar(p.xy);\\n  return fromPolar(polarXY.x, mod(polarXY.y, TAU / count), p.z);\\n}\\n\\nfloat sin01(float x) {\\n  return 0.5 + 0.5 * sin(x);\\n}\\nfloat cos01(float x) {\\n  return 0.5 + 0.5 * cos(x);\\n}\\n\\nfloat smoothmin(float r, float a, float b) {\\n  float h = smoothstep(-r, r, a - b);\\n  return mix(a, b, h) - r * h * (1.0 - h);\\n}\\n\\nvec2 project(vec2 a, vec2 onto1) {\\n  return onto1 * (dot(a, onto1) / dot(onto1, onto1));\\n}\\n\\nconst float r = 0.0;\\nvec3 reject(vec3 a, vec3 b1) {\\n  return a - b1 * dot(a, b1);\\n}\\nfloat demoIcosahedron(vec3 p) {\\n  float d1 = sdIcosahedron(1.0 - r, p - vec3(0, 0, 1)) - r;\\n  float d2 = p.z;\\n  return min(d1, d2);\\n}\\nfloat demoOctahedron(vec3 p) {\\n  float d1 = sdOctahedron(1.0 - r, p - vec3(0, 0, 1)) - r;\\n  float d2 = p.z;\\n  return min(d1, d2);\\n}\\nfloat demoCube(vec3 p) {\\n  float d1 = sdBox(vec3(1.0 - r), p - vec3(0, 0, 1)) - r;\\n  float d2 = p.z;\\n  return min(d1, d2);\\n}\\nHit gizmo(vec3 p) {\\n  vec3 absp = abs(p);\\n\\n  Hit res = Hit(sdArrow(1.0, p), vec4(RED, 1));\\n  res = add(res, Hit(sdArrow(1.0, p.yzx), vec4(GREEN, 1)));\\n  res = add(res, Hit(sdArrow(1.0, p.zxy), vec4(BLUE, 1)));\\n  res = add(res, Hit(length(p) - 0.05, vec4(BLACK, 1)));\\n  return res;\\n}\\n// START ../common/squareWave.glsl\\nfloat squareWave(float x) {\\n  return floor(2.0 * fract(0.5 * x));\\n}\\n\\n// END ../common/squareWave.glsl\\n\\nHit sdtetra(vec3 p) {\\n  float r = d * 0.1;\\n  vec3 cc;\\n  return Hit(sdDodecahedron(b - r / sqrt(1.0 / 6.0), p, cc) - r, vec4(cc, 1));\\n}\\nfloat demoTetrahedron(vec3 p, out vec3 color) {\\n  const vec3 ta = vec3(0, -1, -SQRT1_2);\\n  const vec3 tb = vec3(0, 1, -SQRT1_2);\\n  const vec3 tc = vec3(1, 0, SQRT1_2);\\n  const vec3 td = vec3(-1, 0, SQRT1_2);\\n  const vec3 x = 0.5 * (ta + td);\\n  const vec3 x2 = 0.5 * (tb + td);\\n  const vec3 mirror = normalize(-cross(x - tb, x - tc));\\n  const vec3 mirror2 = normalize(cross(x2 - ta, x2 - tc));\\n  float dbox = sdBox(vec3(3.0), p);\\n  if (dbox > 0.0) {\\n    color = SALMON;\\n    return dbox + 1.0;\\n  }\\n  Hit d1 = gizmo(p - vec3(0, 0, 1));\\n  vec3 fgh = normalize(vec3(0, 1, -SQRT2));\\n  vec3 cc;\\n  float d2 = p.z;\\n  p = p - vec3(0, 0, 1);\\n  vec3 pa = abs(p);\\n  const float PHI = GOLDEN_RATIO;\\n  d1 = add(d1, Hit(distance(vec3(1), pa) - 0.05, vec4(ORANGE, 1)));\\n  d1 = add(\\n    d1,\\n    Hit(distance(vec3(0, PHI, 1.0 / PHI), pa) - 0.05, vec4(GREEN, 1))\\n  );\\n  d1 = add(\\n    d1,\\n    Hit(distance(vec3(1.0 / PHI, 0, PHI), pa) - 0.05, vec4(BLUE, 1))\\n  );\\n  d1 = add(\\n    d1,\\n    Hit(distance(vec3(PHI, 1.0 / PHI, 0), pa) - 0.05, vec4(PINK, 1))\\n  );\\n  const vec3 fv =\\n    0.2 *\\n    (vec3(1.0 / PHI, 0, PHI) + 2.0 * vec3(1, 0, 1) + 2.0 * vec3(PHI, 0, 0));\\n  const vec3 fv2 =\\n    0.2 *\\n    (2.0 * vec3(0, PHI, 0) + 2.0 * vec3(1, 1, 0) + vec3(PHI, 1.0 / PHI, 0));\\n  d1 = add(d1, Hit(distance(fv, p) - 0.05, vec4(RED, 1)));\\n  d1 = add(d1, Hit(distance(fv2, p) - 0.05, vec4(RED, 1)));\\n  d1 = add(d1, sdtetra(p));\\n  //  d1 = add(d1, Hit(distance(ta, p) - 0.1, vec4(OLIVE_DRAB, 1)));\\n  //  d1 = add(d1, Hit(distance(tb, p) - 0.1, vec4(OLIVE_DRAB, 1)));\\n  //  d1 = add(d1, Hit(distance(tc, p) - 0.1, vec4(OLIVE_DRAB, 1)));\\n  //  d1 = add(d1, Hit(distance(td, p) - 0.1, vec4(OLIVE_DRAB, 1)));\\n  //  d1 = add(d1, Hit(sdArrow(vec3(0), mirror2, p), vec4(OLIVE_DRAB, 1)));\\n  //  d1 = add(d1, Hit(length(p) - sqrt(1.0 / 6.0) - 0.002, vec4(CHARTREUSE, 1)));\\n  //  d1 = add(\\n  //    d1,\\n  //    Hit(sdArrow(0.5 * (tc + td), 0.5 * (tc + td) + fgh, p), vec4(OLIVE_DRAB, 1))\\n  //  );\\n  //  float cd = sdBox(vec3(2.0, 2.0, 0.005), p - vec3(0, 0, a));\\n  //  d1 = add(\\n  //    d1,\\n  //    Hit(cd, vec4(mix(BLUE, CYAN, squareWave(sdtetra(p) * 10.0)), 1))\\n  //  );\\n  //  d1 = sub(d1, Hit(sdBox(vec3(10), p - vec3(0, 0, c)), vec4(HOT_PINK, 1)));\\n  //  float d1 = sdTetrahedron(1.0 - r, p - vec3(0, 0, 1), color) - r;\\n  if (d2 < d1.distance) {\\n    color = WHITE;\\n    return d2;\\n  } else {\\n    color = d1.color.xyz;\\n    return d1.distance;\\n  }\\n}\\n// START ../common/sdf3d/sdLego.glsl\\n// START ./sdTube.glsl\\nfloat sdTube(float radius, float r2, float z, vec3 p) {\\n  vec2 d = vec2(length(p.xy), abs(p.z)) - vec2(radius, z);\\n  d.x = abs(d.x) - r2;\\n  vec2 closest = vec2(abs(d.x - radius) - r2, clamp(d.y, 0.0, z));\\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\\n}\\n\\n// END ./sdTube.glsl\\n\\nfloat sdLego(vec3 p) {\\n  const float IWALLT = 0.04;\\n  p.xy = abs(p.xy);\\n  vec2 c = vec2(4.0, 2.0);\\n  //    p.xy = mod(p.xy + c * 0.5, c) - c * 0.5;\\n  p -= vec3(0.0, 0.0, 0.6);\\n  float d;\\n  const float cr = 0.02;\\n  d = sdBox(vec3(2.0, 1.0, 0.6), cr, p);\\n  if (d > 0.5) {\\n    return d;\\n  }\\n  //    top studs\\n  vec3 p8 = vec3(abs(p.xy - vec2(1.0, 0.0)), p.z) - vec3(0.5, 0.5, 0.6);\\n  float dStuds = sdCylinder(0.35 - 0.04, 0.2, p8) - 0.04;\\n  d = min(d, dStuds);\\n  // little holes in bottom of studs\\n  float dStudHoles = sdCylinder(0.2 - 0.04, 0.3, p8 - vec3(0, 0, -0.4)) - 0.04;\\n  d = max(d, -dStudHoles);\\n  // TODO use sdf texture to add LEGO or custom logo to studs\\n\\n  // hole in the bottom\\n  const float WALLT = 4.0 * IWALLT;\\n  float dBottom = sdBox(\\n    vec3(2.0 - WALLT, 1.0 - WALLT, 0.6),\\n    p - vec3(0, 0, -WALLT)\\n  );\\n  d = max(d, -dBottom);\\n\\n  // 12 indentations on inside.\\n  vec3 pa = p;\\n  // 3. move by 1 in X dir\\n  pa.x -= 1.0;\\n  // 2. mirror across XY axis\\n  if (pa.x > pa.y) pa.xy = pa.yx;\\n  // 1. mirror across Y axis\\n  pa.x = abs(pa.x);\\n  float k = sdBox(vec3(0.5 * IWALLT, 0.05, 0.6), pa - vec3(0.5, 0.8, 0));\\n  d = min(d, k);\\n\\n  // center bar\\n  p = vec3(abs(p.xy), p.z);\\n  d = min(d, sdBox(vec3(0.5 * IWALLT, 0.3, 0.5), p - vec3(0, 0.65, 0.1)));\\n\\n  // 3 tubes\\n  vec3 pTube = p;\\n  if (pTube.x > 0.5) pTube.x -= 1.0;\\n  pTube.x = abs(pTube.x);\\n  d = min(d, sdTube(0.35 + 0.5 * IWALLT, 0.5 * IWALLT, 0.6, pTube));\\n  return d;\\n}\\n\\n// END ../common/sdf3d/sdLego.glsl\\nconst mat4[] positions = mat4[](\\n  inverse(\\n    transpose(\\n      mat4(\\n        vec4(0.9146, 0.4043, -0.0, -4.4334),\\n        vec4(-0.4043, 0.9146, -0.0, 5.642),\\n        vec4(0.0, 0.0, 1.0, 1.0401),\\n        vec4(0.0, 0.0, 0.0, 1.0)\\n      )\\n    )\\n  ),\\n  inverse(\\n    transpose(\\n      mat4(\\n        vec4(0.9993, 0.0378, -0.0, -0.406),\\n        vec4(-0.0378, 0.9993, 0.0, 2.944),\\n        vec4(0.0, -0.0, 1.0, 1.0401),\\n        vec4(0.0, 0.0, 0.0, 1.0)\\n      )\\n    )\\n  ),\\n  inverse(\\n    transpose(\\n      mat4(\\n        vec4(0.9795, 0.2015, 0.0, -0.3315),\\n        vec4(-0.2015, 0.9795, 0.0, 3.0562),\\n        vec4(0.0, -0.0, 1.0, 2.2402),\\n        vec4(0.0, 0.0, 0.0, 1.0)\\n      )\\n    )\\n  ),\\n  inverse(\\n    transpose(\\n      mat4(\\n        vec4(-0.9376, -0.3477, -0.0, -4.5541),\\n        vec4(0.3477, -0.9376, 0.0, 1.1356),\\n        vec4(-0.0, 0.0, 1.0, 1.0401),\\n        vec4(0.0, 0.0, 0.0, 1.0)\\n      )\\n    )\\n  ),\\n  inverse(\\n    transpose(\\n      mat4(\\n        vec4(-0.9709, 0.2393, 0.0001, 3.8652),\\n        vec4(0.2393, 0.9709, -0.0001, 3.4039),\\n        vec4(-0.0001, -0.0, -1.0, 7.0405),\\n        vec4(0.0, 0.0, 0.0, 1.0)\\n      )\\n    )\\n  ),\\n  inverse(\\n    transpose(\\n      mat4(\\n        vec4(0.999, 0.0456, -0.0, -0.1656),\\n        vec4(-0.0456, 0.999, -0.0, 0.6654),\\n        vec4(0.0, 0.0, 1.0, 1.0401),\\n        vec4(0.0, 0.0, 0.0, 1.0)\\n      )\\n    )\\n  ),\\n  inverse(\\n    transpose(\\n      mat4(\\n        vec4(0.9995, 0.0303, 0.0, -0.3213),\\n        vec4(-0.0303, 0.9995, 0.0, 3.4494),\\n        vec4(-0.0, -0.0, 1.0, 3.4403),\\n        vec4(0.0, 0.0, 0.0, 1.0)\\n      )\\n    )\\n  ),\\n  inverse(\\n    transpose(\\n      mat4(\\n        vec4(0.5829, -0.8126, -0.0, -8.6931),\\n        vec4(0.8126, 0.5829, 0.0, 0.5259),\\n        vec4(-0.0, -0.0, 1.0, 1.0401),\\n        vec4(0.0, 0.0, 0.0, 1.0)\\n      )\\n    )\\n  ),\\n  inverse(\\n    transpose(\\n      mat4(\\n        vec4(0.7582, 0.652, 0.0, 5.89),\\n        vec4(-0.652, 0.7582, -0.0, 2.8033),\\n        vec4(-0.0, 0.0, 1.0, 3.4401),\\n        vec4(0.0, 0.0, 0.0, 1.0)\\n      )\\n    )\\n  ),\\n  inverse(\\n    transpose(\\n      mat4(\\n        vec4(0.294, 0.9558, -0.0, 9.1408),\\n        vec4(-0.9558, 0.294, -0.0, -0.129),\\n        vec4(-0.0, 0.0, 1.0, 1.0401),\\n        vec4(0.0, 0.0, 0.0, 1.0)\\n      )\\n    )\\n  ),\\n  inverse(\\n    transpose(\\n      mat4(\\n        vec4(-0.7059, 0.7083, -0.0, 0.899),\\n        vec4(-0.7083, -0.7059, 0.0, -3.7542),\\n        vec4(0.0, 0.0, 1.0, 1.0401),\\n        vec4(0.0, 0.0, 0.0, 1.0)\\n      )\\n    )\\n  ),\\n  inverse(\\n    transpose(\\n      mat4(\\n        vec4(0.6319, 0.775, 0.0, 4.8559),\\n        vec4(-0.775, 0.6319, -0.0001, 2.6001),\\n        vec4(-0.0, 0.0, 1.0, 4.6402),\\n        vec4(0.0, 0.0, 0.0, 1.0)\\n      )\\n    )\\n  ),\\n  inverse(\\n    transpose(\\n      mat4(\\n        vec4(0.9808, 0.1952, 0.0, 4.0276),\\n        vec4(-0.1952, 0.9808, -0.0, 3.1987),\\n        vec4(-0.0, 0.0, 1.0, 2.2401),\\n        vec4(0.0, 0.0, 0.0, 1.0)\\n      )\\n    )\\n  ),\\n  inverse(\\n    transpose(\\n      mat4(\\n        vec4(0.4857, -0.2902, -0.8246, 9.5624),\\n        vec4(0.1916, 0.9557, -0.2235, 2.9451),\\n        vec4(0.8529, -0.0494, 0.5198, 5.9481),\\n        vec4(0.0, 0.0, 0.0, 1.0)\\n      )\\n    )\\n  ),\\n  inverse(\\n    transpose(\\n      mat4(\\n        vec4(0.0341, -0.3016, -0.9528, 10.418),\\n        vec4(0.0108, 0.9534, -0.3014, 3.3781),\\n        vec4(0.9994, 0.0, 0.0358, 3.0374),\\n        vec4(0.0, 0.0, 0.0, 1.0)\\n      )\\n    )\\n  ),\\n  inverse(\\n    transpose(\\n      mat4(\\n        vec4(0.9781, -0.2081, -0.0, 5.9647),\\n        vec4(0.2081, 0.9781, 0.0, 2.9215),\\n        vec4(0.0, -0.0, 1.0, 1.0401),\\n        vec4(0.0, 0.0, 0.0, 1.0)\\n      )\\n    )\\n  ),\\n  inverse(\\n    transpose(\\n      mat4(\\n        vec4(-0.0242, 0.9997, 0.0, -6.5609),\\n        vec4(-0.9997, -0.0242, -0.0, -1.5591),\\n        vec4(-0.0, -0.0, 1.0, 1.0401),\\n        vec4(0.0, 0.0, 0.0, 1.0)\\n      )\\n    )\\n  )\\n);\\n\\n// START ../common/transform.glsl\\nvec3 transform(mat4 pm, vec3 p) {\\n  vec4 pStar = pm * vec4(p, 1);\\n  return pStar.xyz / pStar.w;\\n}\\n\\nvec2 transform(mat4 pm, vec2 p) {\\n  vec4 pStar = pm * vec4(p, 0, 1);\\n  return pStar.xy / pStar.w;\\n}\\n\\n// END ../common/transform.glsl\\n// START ../common/checkerboardGrad.glsl\\n//https://iquilezles.org/articles/checkerfiltering/\\nfloat tri(float x) {\\n  float h = fract(x * 0.5) - 0.5;\\n  return 1.0 - 2.0 * abs(h);\\n}\\nvec2 tri(vec2 x) {\\n  vec2 h = fract(x * 0.5) - 0.5;\\n  return 1.0 - 2.0 * abs(h);\\n}\\n\\nfloat checkerboardGrad(vec2 uv) {\\n  vec2 w = max(abs(dFdx(uv)), abs(dFdy(uv))) + 0.01; // filter kernel\\n  vec2 i = (tri(uv + 0.5 * w) - tri(uv - 0.5 * w)) / w; // analytical integral (box filter)\\n  return 0.5 - 0.5 * i.x * i.y; // xor pattern\\n}\\n\\n// END ../common/checkerboardGrad.glsl\\n\\n#define NON_CONST_ZERO (min(int(iTime), 0))\\n\\nHit demoLego(float r, vec3 p) {\\n  float scale = 1.0;\\n  float d1 = sdLego(p * scale - vec3(0, 1, 0)) / scale;\\n  for (int i = 0; i < 5; i++) {\\n    vec3 pp = transform(positions[i], p);\\n    d1 = min(d1, sdLego(pp * scale) / scale);\\n  }\\n  d1 = min(\\n    d1,\\n    sdLego(rotX(200.0 * DEGREE) * (p * scale - vec3(0, -2, 2))) / scale\\n  );\\n  d1 = min(\\n    d1,\\n    sdLego(rotY(240.0 * DEGREE) * (p * scale - vec3(6, 4, 5))) / scale\\n  );\\n  float d2 = p.z;\\n  if (d2 < d1) {\\n    return Hit(\\n      d2,\\n      vec4(mix(WHITE, ungamma(colorSecondary), checkerboardGrad(p.xy)), 1)\\n    );\\n  } else {\\n    return Hit(d1, vec4(ungamma(colorPrimary), 1));\\n  }\\n}\\n\\nfloat sdf(vec3 p, out vec3 color) {\\n  Hit h = demoLego(1.0, p);\\n  color = h.color.xyz;\\n  return h.distance;\\n}\\nfloat sdf(vec3 p) {\\n  vec3 v;\\n  return sdf(p, v);\\n}\\nfloat ambientOcclusion(vec3 pWC, vec3 n1WC) {\\n  float k = 1.0;\\n  float distance = sdf(pWC + n1WC * k);\\n  return clamp(distance / k, 0.0, 1.0);\\n}\\n\\nstruct RMResult {\\n  float distance;\\n  vec3 pos;\\n  vec4 color;\\n};\\nRMResult raymarching2(vec3 start, vec3 dir1) {\\n  vec3 pos = start;\\n  float hit;\\n  vec3 color;\\n  for (int i = 0; i < 100; i++) {\\n    vec3 newColor;\\n    hit = sdf(pos, newColor);\\n    if (hit < 0.0001 * hit) break;\\n    pos = pos + dir1 * hit;\\n    color = newColor;\\n  }\\n  if (color == WHITE) {\\n    vec2 ff = round(fract(pos.xy * 0.5));\\n\\n    color = mix(\\n      ungamma(colorBackground),\\n      ungamma(colorSecondary),\\n      mod(ff.x + ff.y, 2.0)\\n    );\\n  }\\n  return RMResult(hit, pos, vec4(color, 1.0));\\n}\\nvec3 transform(mat4 pm, vec3 p) {\\n  vec4 pStar = pm * vec4(p, 1.0);\\n  return pStar.xyz / pStar.w;\\n}\\n\\nfloat softshadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {\\n  float res = 1.0;\\n  float t = 0.1;\\n  for (int i = 0; i < 1000 && t < maxt; i++) {\\n    float h = sdf(ro + rd * t);\\n    if (h < 0.001) return 0.0;\\n    res = min(res, k * h / t);\\n    t += h;\\n  }\\n  return res;\\n}\\n\\nconst float eps = 1e-4;\\nvec3 sdfNormal1(vec3 p, float d) {\\n  return normalize(\\n    vec3(\\n      sdf(p + vec3(eps, 0.0, 0.0)),\\n      sdf(p + vec3(0.0, eps, 0.0)),\\n      sdf(p + vec3(0.0, 0.0, eps))\\n    ) -\\n      vec3(sdf(p))\\n  );\\n}\\n\\n//layout (depth_greater) out float gl_FragDepth;\\nvoid main() {\\n  vec3 camPos =\\n    vec3(20, 0, 10) +\\n    (-1.0 == iMouse.x\\n      ? vec3(0)\\n      : vec3(0, (iMouse / iResolution * 2.0 - 1.0) * 10.0));\\n  mat4 modelView =\\n    perspective(40.0, iResolution.x / iResolution.y, 0.1, 20.0) *\\n    lookAt(camPos, vec3(0, 0, 1), vec3(0, 0, 1));\\n  mat4 modelViewInverse = inverse(modelView);\\n\\n  vec3 light = normalize(vec3(-1.0, -2.0, -2));\\n\\n  vec3 a = vec3(coord * 2.0 - 1.0, -1.0);\\n  vec3 b = vec3(coord * 2.0 - 1.0, 1.0);\\n  vec3 aWC = transform(modelViewInverse, a);\\n  vec3 bWC = transform(modelViewInverse, b);\\n  vec3 lookDir1 = normalize(bWC - aWC);\\n\\n  RMResult hitWC = raymarching2(aWC, lookDir1);\\n  vec3 hitn1 = sdfNormal1(hitWC.pos, hitWC.distance);\\n  float dWC = distance(aWC, hitWC.pos);\\n  vec3 hitNDC = transform(modelView, hitWC.pos);\\n  vec3 p = hitWC.pos;\\n  float inSun = softshadow(\\n    hitWC.pos + hitn1 * 0.05,\\n    -light,\\n    0.0001,\\n    300.0,\\n    8.0\\n  );\\n  //    float inSun=1.;\\n\\n  vec3 material = hitWC.color.xyz;\\n  if (dWC > 100.0) {\\n    material = vec3(0.0, 0.0, 0.0);\\n    //    } else if (p.z >= 0.001) {\\n    //        material = vec3(0.2, 0.0, 0.0);\\n    //    } else {\\n    //        vec2 c = vec2(4.0, 2.0);\\n    //        vec2 id = floor(((p.xy - c * 0.5) / c) );\\n    //        material += .15 * cos(vec3(id.x, id.y + 2., id.x + id.y + 4.));\\n  }\\n\\n  const vec3 sunlightColor = vec3(3.0);\\n\\n  float aOcc = ambientOcclusion(hitWC.pos, hitn1);\\n\\n  vec3 reflectionDirection = reflect(light, hitn1);\\n\\n  vec3 color = vec3(0.0);\\n  color += material * aOcc;\\n  color += inSun * sunlightColor * material * max(0.0, dot(-light, hitn1));\\n  //    color = (hitn1);\\n\\n  vec3 eyeDirection = -lookDir1;\\n  float uMaterialShininess = 256.0;\\n  float specularLightWeighting = pow(\\n    max(dot(reflectionDirection, eyeDirection), 0.0),\\n    uMaterialShininess\\n  );\\n  color += specularLightWeighting;\\n  //    float lightIntensity = 0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.);\\n  //    float lightIntensity =\\n  //        0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.) + 0.3*specularLightWeighting;\\n  //    fragColor = visualize(blue, red, mix(0.5, 1.0, inSun) * lightIntensity);\\n  //    fragColor = mix(hitWC.color, colorBackground, mix(0.5, 1.0, inSun) * clamp(lightIntensity, 0., 1.));\\n  color = pow(color, vec3(1.0 / 2.2)); // gamma correction\\n  fragColor = vec4(color, 1.0);\\n}\\n\"\nconst sourceMap = {\"version\":3,\"sources\":[\"/home/runner/work/workshop/workshop/src/sdfs/demoLego.frag\",\"/home/runner/work/workshop/workshop/src/common/colors.glsl\",\"/home/runner/work/workshop/workshop/src/common/constants.glsl\",\"/home/runner/work/workshop/workshop/src/common/matrices.glsl\",\"/home/runner/work/workshop/workshop/src/common/max3.glsl\",\"/home/runner/work/workshop/workshop/src/common/unmix.glsl\",\"/home/runner/work/workshop/workshop/src/common/fromPolar.glsl\",\"/home/runner/work/workshop/workshop/src/common/toPolar.glsl\",\"/home/runner/work/workshop/workshop/src/common/polar.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdCylinder.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdCone.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdArrow.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdBox.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdIcosahedron.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdOctahedron.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdDodecahedron.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdCapsule.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdTetrahedron.glsl\",\"/home/runner/work/workshop/workshop/src/common/ungamma.glsl\",\"/home/runner/work/workshop/workshop/src/common/squareWave.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdTube.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdLego.glsl\",\"/home/runner/work/workshop/workshop/src/common/transform.glsl\",\"/home/runner/work/workshop/workshop/src/common/checkerboardGrad.glsl\"],\"names\":[],\"mappings\":\"AAAA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC5IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;;AlBSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AmB7IA;AACA;AACA;AACA;;AnB4IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AoBxNA;AACA;AACA;AACA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ArBmKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AsBtYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AvB0XA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA\"}\nexport { sourceMap };\n","\nexport default \"#version 300 es\\n\\nprecision highp float;\\n\\n// START ../common/banded.glsl\\nfloat banded(float bandCount, float t) {\\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\\n}\\nfloat banded(int bandCount, float t) {\\n  return banded(float(bandCount), t);\\n}\\n\\n// #pragma glslify: export(banded)\\n\\n\\n// END ../common/banded.glsl\\n// START ../common/between.glsl\\nbool between(float min, float max, float value) {\\n  return min <= value && value <= max;\\n}\\n\\n// #pragma glslify: export(between)\\n\\n\\n// END ../common/between.glsl\\n// START ../common/hexFns.glsl\\n// START ./max3.glsl\\nfloat max3(float a, float b, float c) {\\n  return max(a, max(b, c));\\n}\\nfloat max3(vec3 v) {\\n  return max(v.x, max(v.y, v.z));\\n}\\n\\n// #pragma glslify: export(max3)\\n\\n\\n// END ./max3.glsl\\n// START ./constants.glsl\\nconst float SQRT1_2 = 0.7071067811865476;\\nconst float SQRT1_3 = 0.57735026919;\\nconst float SQRT2 = 1.4142135623730951;\\nconst float SQRT3 = 1.732050807568877;\\n// sqrt(3)/2 = sin(60*)\\nconst float SQRT3_2 = 0.86602540378;\\nconst float GOLDEN_RATIO = 1.61803398875;\\nconst float PI = 3.141592653589793;\\nconst float TAU = 6.28318530718;\\n/**\\n * One degree in radians. Use like `sin(30 * DEG)`.\\n */\\nconst float DEGREE = 0.017453292519943295;\\n\\n// END ./constants.glsl\\n\\nvec3 hexRound(vec3 hex) {\\n  vec3 r = floor(hex + 0.5);\\n  vec3 diff = abs(r - hex);\\n\\n  if (diff.x > diff.y && diff.x > diff.z) {\\n    r.x = -(r.y + r.z);\\n  } else if (diff.y > diff.z) {\\n    r.y = -(r.x + r.z);\\n  } else {\\n    r.z = -(r.x + r.y);\\n  }\\n\\n  return r;\\n}\\nvec2 hex2Ra(vec3 hex) {\\n  float y = hex.t * SQRT3_2;\\n  float x = hex.s + hex.t / 2.0;\\n  return vec2(x, y);\\n}\\n\\nfloat hexSdf(vec3 hex) {\\n  return max3(abs(hex.yzx + hex.zxy / 2.0));\\n}\\nvec3 ra2Hex(vec2 xy) {\\n  float hex_t = xy.y / SQRT3_2;\\n  float hex_s = xy.x - hex_t / 2.0;\\n  return vec3(hex_s, hex_t, -(hex_s + hex_t));\\n}\\n\\n// END ../common/hexFns.glsl\\n// START ../common/transform.glsl\\nvec3 transform(mat4 pm, vec3 p) {\\n  vec4 pStar = pm * vec4(p, 1);\\n  return pStar.xyz / pStar.w;\\n}\\n\\nvec2 transform(mat4 pm, vec2 p) {\\n  vec4 pStar = pm * vec4(p, 0, 1);\\n  return pStar.xy / pStar.w;\\n}\\n\\n// END ../common/transform.glsl\\n// START ../common/perlin2DTexture.glsl\\nuniform sampler2D gradients;\\n/* Create random direction vector\\n */\\nvec2 randomGradient(vec2 i) {\\n  // Random float. No precomputed gradients mean this works for any number of grid coordinates\\n  float random =\\n    2920.0 *\\n    sin(float(i.x) * 2.1942 + float(i.y) * 1.71324 + 8.912) *\\n    cos(float(i.x) * 2.3157 * float(i.y) * 2.17832 + 9.758);\\n  //    random = (i.x + 1667.) * (i.x + 2083.) * (i.y + 2659.) * (i.y * 50.77 + .3769);\\n  //    random = sin(SQRT2 * i.x) + cos(GOLDEN_RATIO * i.y) + tan((i.x + i.y) * SQRT3);\\n  return vec2(cos(random), sin(random));\\n}\\nfloat dotGridGradient(vec2 cell, vec2 pos) {\\n  vec2 d = cell - pos;\\n\\n  //  vec2 gradient = texelFetch(gradients, ivec2(cell), 0).xy;\\n  vec2 gradient = randomGradient(vec2(cell));\\n\\n  return dot(gradient, d);\\n}\\n\\nfloat mixx(float a, float b, float t) {\\n  return mix(a, b, smoothstep(0.0, 1.0, t));\\n  //    return mix(a, b, t);\\n}\\n\\n// resulting range is [-0.68, 0.68]. Use unmix to normalize if necessary.\\nfloat perlin2D(vec2 xy) {\\n  float x0 = floor(xy.x);\\n  float x1 = x0 + 1.0;\\n  float y0 = floor(xy.y);\\n  float y1 = y0 + 1.0;\\n\\n  // Interpolate between grid point gradients\\n  float n00 = dotGridGradient(vec2(x0, y0), xy);\\n  float n10 = dotGridGradient(vec2(x1, y0), xy);\\n  float ny0 = mixx(n00, n10, xy.x - x0);\\n\\n  float n01 = dotGridGradient(vec2(x0, y1), xy);\\n  float n11 = dotGridGradient(vec2(x1, y1), xy);\\n  float ny1 = mixx(n01, n11, xy.x - x0);\\n\\n  return mixx(ny0, ny1, xy.y - y0);\\n}\\n\\n// #pragma glslify: export(perlin2D)\\n\\n\\n// END ../common/perlin2DTexture.glsl\\n// START ../common/hsl2rgb.glsl\\n/**\\n * The MIT License (MIT) Copyright (c) 2015 Jam3\\n *\\n * Permission is hereby granted, free of charge, to any person obtaining a copy\\n * of this software and associated documentation files (the \\\"Software\\\"), to deal\\n * in the Software without restriction, including without limitation the rights\\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n * copies of the Software, and to permit persons to whom the Software is\\n * furnished to do so, subject to the following conditions:\\n *\\n * The above copyright notice and this permission notice shall be included in\\n * all copies or substantial portions of the Software.\\n *\\n * THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n * SOFTWARE.\\n */\\nfloat hue2rgb(float f1, float f2, float hue) {\\n  if (hue < 0.0) hue += 1.0;\\n  else if (hue > 1.0) hue -= 1.0;\\n  float res;\\n  if (6.0 * hue < 1.0) res = f1 + (f2 - f1) * 6.0 * hue;\\n  else if (2.0 * hue < 1.0) res = f2;\\n  else if (3.0 * hue < 2.0) res = f1 + (f2 - f1) * (2.0 / 3.0 - hue) * 6.0;\\n  else res = f1;\\n  return res;\\n}\\n\\nvec3 hsl2rgb(vec3 hsl) {\\n  vec3 rgb;\\n\\n  if (hsl.y == 0.0) {\\n    rgb = vec3(hsl.z); // Luminance\\n  } else {\\n    float f2;\\n\\n    if (hsl.z < 0.5) f2 = hsl.z * (1.0 + hsl.y);\\n    else f2 = hsl.z + hsl.y - hsl.y * hsl.z;\\n\\n    float f1 = 2.0 * hsl.z - f2;\\n\\n    rgb.r = hue2rgb(f1, f2, hsl.x + 1.0 / 3.0);\\n    rgb.g = hue2rgb(f1, f2, hsl.x);\\n    rgb.b = hue2rgb(f1, f2, hsl.x - 1.0 / 3.0);\\n  }\\n  return rgb;\\n}\\n\\nvec3 hsl2rgb(float h, float s, float l) {\\n  return hsl2rgb(vec3(h, s, l));\\n}\\n\\n// END ../common/hsl2rgb.glsl\\n// START ../common/polar.glsl\\n// START ../common/fromPolar.glsl\\n// START ./unmix.glsl\\nfloat unmix(float a, float b, float value) {\\n  return (value - a) / (b - a);\\n}\\n\\n// #pragma glslify: export(unmix)\\n\\n\\n// END ./unmix.glsl\\n\\nvec3 fromPolar(float radius, float phi, float z) {\\n  return vec3(radius * cos(phi), radius * sin(phi), z);\\n}\\n\\nvec2 fromPolar(float radius, float phi) {\\n  return vec2(radius * cos(phi), radius * sin(phi));\\n}\\n\\nvec2 fromPolar(vec2 polar) {\\n  return fromPolar(polar.x, polar.y);\\n}\\n\\n// #pragma glslify: export(fromPolar)\\n\\n\\n// END ../common/fromPolar.glsl\\n// START ../common/toPolar.glsl\\n\\nvec2 toPolar(vec2 xy) {\\n  return vec2(length(xy), atan(xy.y, xy.x));\\n}\\n\\nmat2 toPolarDerivate(vec2 xy) {\\n  return mat2(xy.x * xy.x, xy.y * xy.y, -xy.y, xy.x) / dot(xy, xy);\\n}\\n\\n// #pragma glslify: export(toPolar)\\n\\n\\n// END ../common/toPolar.glsl\\n\\n// END ../common/polar.glsl\\n// START ../common/remix.glsl\\n\\nfloat remix(float fromA, float fromB, float toA, float toB, float value) {\\n  return mix(toA, toB, unmix(fromA, fromB, value));\\n}\\n\\nvec4 remix(float fromA, float fromB, vec4 toA, vec4 toB, float value) {\\n  return mix(toA, toB, unmix(fromA, fromB, value));\\n}\\n\\n// #pragma glslify: export(remix)\\n\\n\\n// END ../common/remix.glsl\\n// START ../common/visualize.glsl\\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\\n  float isLow = float(t < 0.0);\\n  float isHigh = float(t > 1.0);\\n  float isMid = 1.0 - isLow - isHigh;\\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\\n}\\n\\nvec4 visualize(float t) {\\n  const vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\\n  const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\\n  return visualize(BLUE, RED, t);\\n}\\n\\n// #pragma glslify: export(visualize)\\n\\n\\n// END ../common/visualize.glsl\\n// START ../common/waves.glsl\\nfloat waves(vec4 color, vec2 position, vec2 direction, float highResTimeStamp) {\\n  return sin(\\n    dot(position, direction / pow(length(direction), 2.0)) +\\n      float(highResTimeStamp) / 200.0\\n  );\\n}\\n\\n// #pragma glslify: export(waves)\\n\\n\\n// END ../common/waves.glsl\\n// START ../common/matrices.glsl\\n\\nmat2 rot2(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat2(c, s, -s, c);\\n}\\nmat3 rotX(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\\n}\\nmat3 rotY(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\\n}\\nmat3 rotZ(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\\n}\\n/**\\n * Returns a matrix that puts the camera at the eye point `ex, ey, ez` looking\\n * toward the center point `cx, cy, cz` with an up direction of `ux, uy, uz`.\\n * This emulates the OpenGL function `gluLookAt()`.\\n */\\nmat4 lookAt(vec3 eye, vec3 focus, vec3 up) {\\n  vec3 f = normalize(eye - focus);\\n  vec3 s = normalize(cross(up, f));\\n  vec3 t = normalize(cross(f, s));\\n\\n  return mat4(\\n    vec4(s.x, t.x, f.x, 0.0),\\n    vec4(s.y, t.y, f.y, 0.0),\\n    vec4(s.z, t.z, f.z, 0.0),\\n    vec4(-dot(s, eye), -dot(t, eye), -dot(f, eye), 1)\\n  );\\n}\\n\\n// the OpenGL function `glFrustum()`.\\nmat4 frustum(\\n  float left,\\n  float right,\\n  float bottom,\\n  float top,\\n  float near,\\n  float far\\n) {\\n  return mat4(\\n    vec4(2.0 * near / (right - left), 0.0, 0.0, 0.0),\\n    vec4(0, 2.0 * near / (top - bottom), 0.0, 0.0),\\n    vec4(\\n      (right + left) / (right - left),\\n      (top + bottom) / (top - bottom),\\n      -(far + near) / (far - near),\\n      -1\\n    ),\\n    vec4(0.0, 0.0, -2.0 * far * near / (far - near), 0.0)\\n  );\\n}\\n\\nmat4 perspective(float fovDegrees, float aspect, float near, float far) {\\n  float y = tan(fovDegrees * DEGREE / 2.0) * near;\\n  float x = y * aspect;\\n  return frustum(-x, x, -y, y, near, far);\\n}\\nmat4 ortho(\\n  float left,\\n  float right,\\n  float bottom,\\n  float top,\\n  float near,\\n  float far\\n) {\\n  return mat4(\\n    vec4(2.0 / (right - left), 0.0, 0.0, 0.0),\\n    vec4(0.0, 2.0 / (top - bottom), 0.0, 0.0),\\n    vec4(0.0, 0.0, -2.0 / (far - near), 0.0),\\n    vec4(\\n      -(right + left) / (right - left),\\n      -(top + bottom) / (top - bottom),\\n      -(far + near) / (far - near),\\n      1.0\\n    )\\n  );\\n}\\n\\n// END ../common/matrices.glsl\\n\\n// START ../common/sdf3d/sdTorus.glsl\\nfloat sdTorus(float r0, float r1, vec3 p) {\\n  vec3 closestCenter = vec3(normalize(p.xy) * r0, 0.0);\\n  return distance(closestCenter, p) - r1;\\n}\\n\\n// #pragma glslify: export(sdTorus)\\n\\n\\n// END ../common/sdf3d/sdTorus.glsl\\n// START ../common/sdf3d/sdSphere.glsl\\nfloat sdSphere(float radius, vec3 p) {\\n  return length(p) - radius;\\n}\\n\\n// #pragma glslify: export(sdSphere)\\n\\n\\n// END ../common/sdf3d/sdSphere.glsl\\n// START ../common/sdf3d/sdCylinder.glsl\\nfloat sdCylinder(float radius, float z, vec3 p) {\\n  vec2 d = vec2(length(p.xy), abs(p.z)) - vec2(radius, z);\\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\\n}\\n\\n// #pragma glslify: export(sdCylinder)\\n\\n\\n// END ../common/sdf3d/sdCylinder.glsl\\n// START ../common/sdf2d/addChamfer.glsl\\n\\nfloat addChamfer(float d, float a, float b) {\\n  // exact variant, but abs is larger when a and b aren't perpendicular\\n  // which is worse than underestimating, which is what the simple version does.\\n  //  vec2 p = vec2(a, b);\\n  //  if (p.x < d && p.y < d) {\\n  //    p = rot2(0.25 * PI) * p;\\n  //    p.y = abs(p.y);\\n  //    p.y -= min(p.y, d * SQRT1_2);\\n  //    p.x -= d * SQRT1_2;\\n  //    //    p -= vec2(SQRT1_2) * clamp(dot(p, vec2(SQRT1_2)), 0.0, d);\\n  //    float fillet = -length(p);\\n  //    return -sign(p.x) * fillet;\\n  //  } else {\\n  //  }\\n  float tillet = (a + b - d) * SQRT1_2;\\n  return min(tillet, min(a, b));\\n}\\n\\n// #pragma glslify: export(addChamfer)\\n\\n\\n// END ../common/sdf2d/addChamfer.glsl\\n// START ../common/sdf2d/addFillet.glsl\\nfloat addFillet(float r, float a, float b) {\\n  if (a < r && b < r) {\\n    return r - distance(vec2(a, b), vec2(r));\\n  } else {\\n    return min(a, b);\\n  }\\n}\\n\\n// #pragma glslify: export(addFillet)\\n\\n\\n// END ../common/sdf2d/addFillet.glsl\\n// START ../common/sdf3d/sdBox.glsl\\n\\nfloat sdBox(vec3 r, vec3 p) {\\n  vec3 q = abs(p) - r;\\n  return length(max(q, 0.0)) + min(max3(q), 0.0);\\n}\\n\\nfloat sdBox(vec3 r, float r2, vec3 p) {\\n  return sdBox(r - r2, p) - r2;\\n}\\n\\n// #pragma glslify: export(sdBox)\\n\\n\\n// END ../common/sdf3d/sdBox.glsl\\n// START ../common/sdf3d/add.glsl\\nfloat add(float a, float b) {\\n  return min(a, b);\\n}\\n\\n// #pragma glslify: export(add)\\n\\n\\n// END ../common/sdf3d/add.glsl\\n// START ../common/sdf3d/sub.glsl\\nfloat sub(float from, float what) {\\n  return max(from, -what);\\n}\\n\\n// #pragma glslify: export(sub)\\n\\n\\n// END ../common/sdf3d/sub.glsl\\n\\nuniform sampler2D texture;\\nuniform float iTime;\\nuniform vec2 iMouse;\\nuniform vec2 iResolution;\\nuniform vec4 colorPrimary;\\nuniform vec4 colorSecondary;\\nuniform vec4 colorBackground;\\nuniform float a;\\nuniform float b;\\nuniform float c;\\nuniform float d;\\nuniform int bandCount;\\nuniform vec3 campos;\\nin float n;\\nin vec2 coord;\\nout vec4 fragColor;\\n\\n\\nconst vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\\nconst vec4 yellow = vec4(1.0, 1.0, 0.0, 1.0);\\nconst vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\\nconst vec4 blue = vec4(0.0, 0.0, 1.0, 1.0);\\nconst vec4 purple = vec4(0.5, 0.0, 0.5, 1.0);\\nconst vec4 red = vec4(1.0, 0.0, 0.0, 1.0);\\n\\nstruct RMHit {\\n  float distance;\\n  vec4 color;\\n};\\nRMHit mixa(RMHit a, RMHit b, float t) {\\n  return RMHit(mix(a.distance, b.distance, t), mix(a.color, b.color, t));\\n}\\nfloat skybox(vec3 p) {\\n  return 32.0 - max3(abs(p));\\n}\\n\\nfloat perlinSphere(float radius, vec3 p) {\\n  vec3 cp = normalize(p);\\n  float alpha = atan(cp.y, cp.x);\\n  float beta = asin(cp.z);\\n  return length(p) -\\n  radius +\\n  0.1 *\\n    perlin2D(vec2(0.0 / 100.0, 0.0) + (vec2(5.0) + vec2(alpha, beta)) * 8.0);\\n}\\n\\nfloat cylCircle(vec3 p) {\\n  float d = 10e9;\\n  for (int i = 0; i < 10; i++) {\\n    d = min(\\n      d,\\n      sdCylinder(0.2, 2.0, p + fromPolar(3.0, TAU * float(i) / 10.0, 1.0))\\n    );\\n  }\\n\\n  return d;\\n}\\n\\nfloat rblock(float r, vec3 p) {\\n  return sdBox(vec3(r), p);\\n}\\n\\nRMHit add(RMHit a, RMHit b) {\\n  //    return a.distance < b.distance\\n  //        ? RMHit(a.distance, a.color)\\n  //        : RMHit(b.distance, b.color);\\n  return mixa(a, b, float(b.distance < a.distance));\\n}\\n\\nfloat wtf(vec3 p) {\\n  vec3 center = p - mod(p, 3.0) + vec3(1.5);\\n  return rblock(0.4 + 0.3 * sin(iTime + center.x), p - center);\\n}\\n\\nRMHit addFillet(float r, RMHit a, RMHit b) {\\n  if (a.distance < r && b.distance < r) {\\n    return RMHit(\\n      r - distance(vec2(a.distance, b.distance), vec2(r)),\\n      mix(a.color, b.color, (a.distance - b.distance) / r * 0.5 + 0.5)\\n    );\\n  } else {\\n    return add(a, b);\\n  }\\n}\\n\\nRMHit addFillet(float r, RMHit a, RMHit b, vec4 tilletColor) {\\n  if (a.distance < r && b.distance < r) {\\n    return RMHit(\\n      r - distance(vec2(a.distance, b.distance), vec2(r)),\\n      tilletColor\\n    );\\n  } else {\\n    return add(a, b);\\n  }\\n}\\nRMHit addFillet2(float r, RMHit a, RMHit b) {\\n  float h = smoothstep(-r, r, a.distance - b.distance);\\n  return RMHit(\\n    mix(a.distance, b.distance, h) - r * h * (1.0 - h),\\n    mix(a.color, b.color, h)\\n  );\\n}\\n\\nRMHit neg(RMHit a) {\\n  return RMHit(-a.distance, a.color);\\n}\\nRMHit sub(RMHit from, RMHit what) {\\n  RMHit whatNeg = neg(what);\\n  return mixa(from, whatNeg, float(whatNeg.distance > from.distance));\\n}\\n\\nvec3 modv(vec3 v, vec3 dir1, float y) {\\n  float t = dot(v, dir1);\\n  return v - floor(t / y) * y * dir1;\\n}\\nvec3 modRotZ(vec3 p, float count) {\\n  vec2 polarXY = toPolar(p.xy);\\n  return fromPolar(polarXY.x, mod(polarXY.y, TAU / count), p.z);\\n}\\n\\nRMHit sdf(vec3 p) {\\n  RMHit r = RMHit(skybox(p), colorBackground);\\n  r = add(r, RMHit(sdBox(vec3(6.0, 6.0, 1.0), p), colorSecondary));\\n  vec3 rotp = rotZ(0.1) * p;\\n  vec3 floorTiles = vec3(mod(rotp.xy, 0.1), rotp.z);\\n  float ftd = sdBox(\\n    vec3(0.045),\\n    rotY(d) * floorTiles - vec3(0.05, 0.05, -0.04)\\n  );\\n  float ftdl = max(ftd, sdBox(vec3(6), p));\\n  //    r = addFillet2(.01, r, RMHit(ftdl, colorSecondary));\\n  float dSphere = sdSphere(7.0, p);\\n  if (dSphere < 0.0) {\\n    RMHit m = RMHit(100000.0, black);\\n    for (int i = 0; i < 50; i++) {\\n      //            m = (addFillet(a, (m),\\n      m = addFillet2(\\n        a,\\n        m,\\n        //            m = (add((m),\\n        RMHit(\\n          sdTorus(\\n            0.5 + float(i) * 0.1,\\n            0.05,\\n            rotX(2.0 + sin(iTime * 0.01) * 0.2) * rotZ(float(i) * 0.2) * p\\n          ),\\n          vec4(hsl2rgb(float(i) / 50.0, 0.99, 0.25), 1.0)\\n        )\\n      );\\n    }\\n    //        float b = sdBox(vec3(-5.,-5.,0.),vec3(5., 5., .2), p);\\n    //        m = neg(add(neg(m),neg(RMHit(b, black))));\\n    //    r = sub(r, RMHit(m.distance - 0.2, colorSecondary));\\n    r = addFillet(0.3, r, m);\\n  } else {\\n    r = add(r, RMHit(dSphere + 1.0, black));\\n  }\\n  r = neg(addFillet(0.3, neg(r), RMHit(sdSphere(c, p - extra), black)));\\n  //    vec3 rotSyma = modRotZ(p, 7.);\\n  //    vec3 rotSym = rotZ(b) *rotY(c) * (vec3(1., sin(rotSyma.x)*d, 1.) + rotSyma);\\n  //    vec3 tiled = vec3(mod(rotSym.x, 10. *a), rotSym.yz);\\n  //    float q = sdSphere(1., tiled - vec3(5.*a, 0., 0.));\\n  //    r = add(r, RMHit(q, blue));\\n  //    for (int i = 0; i < 300; i++) {\\n  //        float f = unmix(0., 300., float(i));\\n  //        vec3 spherepos = fromPolar(mix(-6., 6., f), abs(mix(-10., 10., f)) + PI / 2., 0.);\\n  r = add(r, RMHit(sdSphere(0.1, p - campos), black));\\n  //    }\\n  //    r = (addFillet(0.1, (r), RMHit(sdTorus(1.5, 0.5, rotX(iTime*6.) * p), colorSecondary)));\\n  //    r = (addFillet(0.1, (r), RMHit(sdTorus(3.9, 0.5, rotY(iTime*3.) * p), blue)));\\n  //    r = neg(addFillet(.2, neg(r), RMHit(sdBox(vec3(-1., -1., -2.), vec3(1., 1., 2.), p), red)));\\n  //    r = add(r, wtf(p));\\n  //    r = add(r, RMHit(perlinSphere(1., p - vec3(-2.0, 0.0, 3.0)), purple));\\n  //    r = add(r, cylCircle(p));\\n\\n  //    r = add(r, sdSphere(p - vec3(3., 3., 0.)));\\n  //    r = sub(r, RMHit(\\n  //        cylinder(1.3, 4.5, rotX(iTime/30. * TAU) * p- vec3(2.0, 0.0, 0.0) - vec3(0., 0., -2.25)),\\n  //        blue));\\n  //    r = add(r, cylinder(0.8, 4., rotX(iTime/30. * TAU) * p- vec3(2.0, 0.0, 0.0) - vec3(0., 0., -2.)));\\n  //    r = sub(r, cylCircle(p));\\n  return r;\\n}\\nfloat sdff(vec3 p) {\\n  return sdf(p).distance;\\n}\\n\\nstruct RMResult {\\n  float distance;\\n  vec3 pos;\\n  vec4 color;\\n};\\nRMResult raymarching2(vec3 start, vec3 dir1) {\\n  vec3 pos = start;\\n  RMHit hit;\\n  for (int i = 0; i < 200; i++) {\\n    hit = sdf(pos);\\n    if (hit.distance < 0.0) break;\\n    pos = pos + dir1 * hit.distance;\\n  }\\n  return RMResult(hit.distance, pos, hit.color);\\n}\\n\\nfloat softshadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {\\n  float res = 1.0;\\n  float t = 0.1;\\n  for (int i = 0; i < 1000 && t < maxt; i++) {\\n    float h = sdff(ro + rd * t);\\n    if (h < 0.001) return 0.0;\\n    res = min(res, k * h / t);\\n    t += h;\\n  }\\n  return res;\\n}\\n\\nconst float eps = 1e-5;\\nvec3 sdfNormal1(vec3 p, float d) {\\n  return normalize(\\n    vec3(\\n      sdff(p + vec3(eps, 0.0, 0.0)),\\n      sdff(p + vec3(0.0, eps, 0.0)),\\n      sdff(p + vec3(0.0, 0.0, eps))\\n    ) -\\n      vec3(d)\\n  );\\n}\\n//layout (depth_greater) out float gl_FragDepth;\\nvoid main() {\\n  vec3 camPos =\\n    vec3(20, 0, 10) +\\n    (-1.0 == iMouse.x\\n      ? vec3(0)\\n      : vec3(0, (iMouse / iResolution * 2.0 - 1.0) * 10.0));\\n  mat4 modelView =\\n    perspective(40.0, iResolution.x / iResolution.y, 0.1, 20.0) *\\n    lookAt(camPos, vec3(0, 0, 1), vec3(0, 0, 1));\\n  mat4 modelViewInverse = inverse(modelView);\\n\\n  vec3 light = normalize(vec3(-1.0, -2.0, -2));\\n\\n  vec3 a = vec3(coord * 2.0 - 1.0, -1.0);\\n  vec3 b = vec3(coord * 2.0 - 1.0, 1.0);\\n  vec3 aWC = transform(modelViewInverse, a);\\n  vec3 bWC = transform(modelViewInverse, b);\\n  vec3 lookDir1 = normalize(bWC - aWC);\\n  //  vec3 light = normalize(vec3(-1.0, -2.0, -2));\\n  //\\n  //  vec3 a = vec3(coord, -1.0);\\n  //  vec3 b = vec3(coord, 1.0);\\n  //  vec3 aWC = transform(llli, a);\\n  //  vec3 bWC = transform(llli, b);\\n  //  vec3 lookDir1 = normalize(bWC - aWC);\\n\\n  RMResult hitWC = raymarching2(aWC, lookDir1);\\n  vec3 hitn1 = sdfNormal1(hitWC.pos, hitWC.distance);\\n  float dWC = distance(aWC, hitWC.pos);\\n  //  vec3 hitNDC = transform(lll, hitWC.pos);\\n\\n  //    vec3 sunPoint = raymarching2(hitWC.pos +hitn1 *.1, -light).pos;\\n  //    float inSun = float(distance(hitWC.pos, sunPoint) > 30.);\\n  float inSun = softshadow(hitWC.pos + hitn1 * 0.1, -light, 0.1, 30.0, 64.0);\\n  //    float inSun=1.;\\n\\n  vec3 reflectionDirection = reflect(light, hitn1);\\n  vec3 eyeDirection = -lookDir1;\\n  float uMaterialShininess = 256.0;\\n  float specularLightWeighting = pow(\\n    max(dot(reflectionDirection, eyeDirection), 0.0),\\n    uMaterialShininess\\n  );\\n  //    float lightIntensity = 0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.);\\n  float lightIntensity =\\n    0.2 +\\n    0.5 * clamp(-dot(light, hitn1), 0.0, 1.0) +\\n    0.3 * specularLightWeighting;\\n  //    fragColor = visualize(blue, red, mix(0.5, 1.0, inSun) * lightIntensity);\\n  fragColor = mix(\\n    hitWC.color,\\n    colorBackground,\\n    mix(0.5, 1.0, inSun) * clamp(lightIntensity, 0.0, 1.0)\\n  );\\n  fragColor /= 4.0;\\n  fragColor.a = 1.0;\\n  //    fragColor = visualize(hitWC.pos.x/10.);\\n  //    fragColor = hitWC.color;\\n  //    fragColor = visualize(blue, red, distance(hitWC, sunPoint)/20.);\\n  //    fragColor = vec4(coord,0.,1.);\\n  //    fragColor = vec4(aWC, 1.0);\\n  // remap [-1, 1] to [0, 1]\\n  // gl_FragDepth = hitNDC.z * 0.5 + 0.5;\\n  //    gl_FragDepth = .9999999;\\n}\\n\"\nconst sourceMap = {\"version\":3,\"sources\":[\"/home/runner/work/workshop/workshop/src/sdfs/demoTemple.frag\",\"/home/runner/work/workshop/workshop/src/common/banded.glsl\",\"/home/runner/work/workshop/workshop/src/common/between.glsl\",\"/home/runner/work/workshop/workshop/src/common/max3.glsl\",\"/home/runner/work/workshop/workshop/src/common/constants.glsl\",\"/home/runner/work/workshop/workshop/src/common/hexFns.glsl\",\"/home/runner/work/workshop/workshop/src/common/transform.glsl\",\"/home/runner/work/workshop/workshop/src/common/perlin2DTexture.glsl\",\"/home/runner/work/workshop/workshop/src/common/hsl2rgb.glsl\",\"/home/runner/work/workshop/workshop/src/common/unmix.glsl\",\"/home/runner/work/workshop/workshop/src/common/fromPolar.glsl\",\"/home/runner/work/workshop/workshop/src/common/toPolar.glsl\",\"/home/runner/work/workshop/workshop/src/common/polar.glsl\",\"/home/runner/work/workshop/workshop/src/common/remix.glsl\",\"/home/runner/work/workshop/workshop/src/common/visualize.glsl\",\"/home/runner/work/workshop/workshop/src/common/waves.glsl\",\"/home/runner/work/workshop/workshop/src/common/matrices.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdTorus.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdSphere.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdCylinder.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf2d/addChamfer.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf2d/addFillet.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdBox.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/add.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sub.glsl\"],\"names\":[],\"mappings\":\"AAAA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AhBtEA;;AiBjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;;AxBoBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA\"}\nexport { sourceMap };\n","\nexport default \"#version 300 es\\n\\nprecision highp float;\\n\\n// START ../common/sdf2d/sdSegment.glsl\\nfloat sdSegment(vec2 a, vec2 b, vec2 p) {\\n  vec2 ab = b - a;\\n  float t = dot(ab, p - a) / dot(ab, ab);\\n  t = clamp(t, 0.0, 1.0);\\n  vec2 closest = a + ab * t;\\n\\n  return distance(closest, p);\\n}\\n\\n// #pragma glslify: export(sdSegment)\\n\\n\\n// END ../common/sdf2d/sdSegment.glsl\\n// START ../common/unmix.glsl\\nfloat unmix(float a, float b, float value) {\\n  return (value - a) / (b - a);\\n}\\n\\n// #pragma glslify: export(unmix)\\n\\n\\n// END ../common/unmix.glsl\\n// START ../common/banded.glsl\\nfloat banded(float bandCount, float t) {\\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\\n}\\nfloat banded(int bandCount, float t) {\\n  return banded(float(bandCount), t);\\n}\\n\\n// #pragma glslify: export(banded)\\n\\n\\n// END ../common/banded.glsl\\n// START ../common/between.glsl\\nbool between(float min, float max, float value) {\\n  return min <= value && value <= max;\\n}\\n\\n// #pragma glslify: export(between)\\n\\n\\n// END ../common/between.glsl\\n// START ../common/hexFns.glsl\\n// START ./max3.glsl\\nfloat max3(float a, float b, float c) {\\n  return max(a, max(b, c));\\n}\\nfloat max3(vec3 v) {\\n  return max(v.x, max(v.y, v.z));\\n}\\n\\n// #pragma glslify: export(max3)\\n\\n\\n// END ./max3.glsl\\n// START ./constants.glsl\\nconst float SQRT1_2 = 0.7071067811865476;\\nconst float SQRT1_3 = 0.57735026919;\\nconst float SQRT2 = 1.4142135623730951;\\nconst float SQRT3 = 1.732050807568877;\\n// sqrt(3)/2 = sin(60*)\\nconst float SQRT3_2 = 0.86602540378;\\nconst float GOLDEN_RATIO = 1.61803398875;\\nconst float PI = 3.141592653589793;\\nconst float TAU = 6.28318530718;\\n/**\\n * One degree in radians. Use like `sin(30 * DEG)`.\\n */\\nconst float DEGREE = 0.017453292519943295;\\n\\n// END ./constants.glsl\\n\\nvec3 hexRound(vec3 hex) {\\n  vec3 r = floor(hex + 0.5);\\n  vec3 diff = abs(r - hex);\\n\\n  if (diff.x > diff.y && diff.x > diff.z) {\\n    r.x = -(r.y + r.z);\\n  } else if (diff.y > diff.z) {\\n    r.y = -(r.x + r.z);\\n  } else {\\n    r.z = -(r.x + r.y);\\n  }\\n\\n  return r;\\n}\\nvec2 hex2Ra(vec3 hex) {\\n  float y = hex.t * SQRT3_2;\\n  float x = hex.s + hex.t / 2.0;\\n  return vec2(x, y);\\n}\\n\\nfloat hexSdf(vec3 hex) {\\n  return max3(abs(hex.yzx + hex.zxy / 2.0));\\n}\\nvec3 ra2Hex(vec2 xy) {\\n  float hex_t = xy.y / SQRT3_2;\\n  float hex_s = xy.x - hex_t / 2.0;\\n  return vec3(hex_s, hex_t, -(hex_s + hex_t));\\n}\\n\\n// END ../common/hexFns.glsl\\n// START ../common/perlin2DTexture.glsl\\nuniform sampler2D gradients;\\n/* Create random direction vector\\n */\\nvec2 randomGradient(vec2 i) {\\n  // Random float. No precomputed gradients mean this works for any number of grid coordinates\\n  float random =\\n    2920.0 *\\n    sin(float(i.x) * 2.1942 + float(i.y) * 1.71324 + 8.912) *\\n    cos(float(i.x) * 2.3157 * float(i.y) * 2.17832 + 9.758);\\n  //    random = (i.x + 1667.) * (i.x + 2083.) * (i.y + 2659.) * (i.y * 50.77 + .3769);\\n  //    random = sin(SQRT2 * i.x) + cos(GOLDEN_RATIO * i.y) + tan((i.x + i.y) * SQRT3);\\n  return vec2(cos(random), sin(random));\\n}\\nfloat dotGridGradient(vec2 cell, vec2 pos) {\\n  vec2 d = cell - pos;\\n\\n  //  vec2 gradient = texelFetch(gradients, ivec2(cell), 0).xy;\\n  vec2 gradient = randomGradient(vec2(cell));\\n\\n  return dot(gradient, d);\\n}\\n\\nfloat mixx(float a, float b, float t) {\\n  return mix(a, b, smoothstep(0.0, 1.0, t));\\n  //    return mix(a, b, t);\\n}\\n\\n// resulting range is [-0.68, 0.68]. Use unmix to normalize if necessary.\\nfloat perlin2D(vec2 xy) {\\n  float x0 = floor(xy.x);\\n  float x1 = x0 + 1.0;\\n  float y0 = floor(xy.y);\\n  float y1 = y0 + 1.0;\\n\\n  // Interpolate between grid point gradients\\n  float n00 = dotGridGradient(vec2(x0, y0), xy);\\n  float n10 = dotGridGradient(vec2(x1, y0), xy);\\n  float ny0 = mixx(n00, n10, xy.x - x0);\\n\\n  float n01 = dotGridGradient(vec2(x0, y1), xy);\\n  float n11 = dotGridGradient(vec2(x1, y1), xy);\\n  float ny1 = mixx(n01, n11, xy.x - x0);\\n\\n  return mixx(ny0, ny1, xy.y - y0);\\n}\\n\\n// #pragma glslify: export(perlin2D)\\n\\n\\n// END ../common/perlin2DTexture.glsl\\n// START ../common/polar.glsl\\n// START ../common/fromPolar.glsl\\n\\nvec3 fromPolar(float radius, float phi, float z) {\\n  return vec3(radius * cos(phi), radius * sin(phi), z);\\n}\\n\\nvec2 fromPolar(float radius, float phi) {\\n  return vec2(radius * cos(phi), radius * sin(phi));\\n}\\n\\nvec2 fromPolar(vec2 polar) {\\n  return fromPolar(polar.x, polar.y);\\n}\\n\\n// #pragma glslify: export(fromPolar)\\n\\n\\n// END ../common/fromPolar.glsl\\n// START ../common/toPolar.glsl\\n\\nvec2 toPolar(vec2 xy) {\\n  return vec2(length(xy), atan(xy.y, xy.x));\\n}\\n\\nmat2 toPolarDerivate(vec2 xy) {\\n  return mat2(xy.x * xy.x, xy.y * xy.y, -xy.y, xy.x) / dot(xy, xy);\\n}\\n\\n// #pragma glslify: export(toPolar)\\n\\n\\n// END ../common/toPolar.glsl\\n\\n// END ../common/polar.glsl\\n// START ../common/remix.glsl\\n\\nfloat remix(float fromA, float fromB, float toA, float toB, float value) {\\n  return mix(toA, toB, unmix(fromA, fromB, value));\\n}\\n\\nvec4 remix(float fromA, float fromB, vec4 toA, vec4 toB, float value) {\\n  return mix(toA, toB, unmix(fromA, fromB, value));\\n}\\n\\n// #pragma glslify: export(remix)\\n\\n\\n// END ../common/remix.glsl\\n// START ../common/visualize.glsl\\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\\n  float isLow = float(t < 0.0);\\n  float isHigh = float(t > 1.0);\\n  float isMid = 1.0 - isLow - isHigh;\\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\\n}\\n\\nvec4 visualize(float t) {\\n  const vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\\n  const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\\n  return visualize(BLUE, RED, t);\\n}\\n\\n// #pragma glslify: export(visualize)\\n\\n\\n// END ../common/visualize.glsl\\n// START ../common/waves.glsl\\nfloat waves(vec4 color, vec2 position, vec2 direction, float highResTimeStamp) {\\n  return sin(\\n    dot(position, direction / pow(length(direction), 2.0)) +\\n      float(highResTimeStamp) / 200.0\\n  );\\n}\\n\\n// #pragma glslify: export(waves)\\n\\n\\n// END ../common/waves.glsl\\n// START ../common/matrices.glsl\\n\\nmat2 rot2(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat2(c, s, -s, c);\\n}\\nmat3 rotX(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\\n}\\nmat3 rotY(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\\n}\\nmat3 rotZ(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\\n}\\n/**\\n * Returns a matrix that puts the camera at the eye point `ex, ey, ez` looking\\n * toward the center point `cx, cy, cz` with an up direction of `ux, uy, uz`.\\n * This emulates the OpenGL function `gluLookAt()`.\\n */\\nmat4 lookAt(vec3 eye, vec3 focus, vec3 up) {\\n  vec3 f = normalize(eye - focus);\\n  vec3 s = normalize(cross(up, f));\\n  vec3 t = normalize(cross(f, s));\\n\\n  return mat4(\\n    vec4(s.x, t.x, f.x, 0.0),\\n    vec4(s.y, t.y, f.y, 0.0),\\n    vec4(s.z, t.z, f.z, 0.0),\\n    vec4(-dot(s, eye), -dot(t, eye), -dot(f, eye), 1)\\n  );\\n}\\n\\n// the OpenGL function `glFrustum()`.\\nmat4 frustum(\\n  float left,\\n  float right,\\n  float bottom,\\n  float top,\\n  float near,\\n  float far\\n) {\\n  return mat4(\\n    vec4(2.0 * near / (right - left), 0.0, 0.0, 0.0),\\n    vec4(0, 2.0 * near / (top - bottom), 0.0, 0.0),\\n    vec4(\\n      (right + left) / (right - left),\\n      (top + bottom) / (top - bottom),\\n      -(far + near) / (far - near),\\n      -1\\n    ),\\n    vec4(0.0, 0.0, -2.0 * far * near / (far - near), 0.0)\\n  );\\n}\\n\\nmat4 perspective(float fovDegrees, float aspect, float near, float far) {\\n  float y = tan(fovDegrees * DEGREE / 2.0) * near;\\n  float x = y * aspect;\\n  return frustum(-x, x, -y, y, near, far);\\n}\\nmat4 ortho(\\n  float left,\\n  float right,\\n  float bottom,\\n  float top,\\n  float near,\\n  float far\\n) {\\n  return mat4(\\n    vec4(2.0 / (right - left), 0.0, 0.0, 0.0),\\n    vec4(0.0, 2.0 / (top - bottom), 0.0, 0.0),\\n    vec4(0.0, 0.0, -2.0 / (far - near), 0.0),\\n    vec4(\\n      -(right + left) / (right - left),\\n      -(top + bottom) / (top - bottom),\\n      -(far + near) / (far - near),\\n      1.0\\n    )\\n  );\\n}\\n\\n// END ../common/matrices.glsl\\n\\n// START ../common/sdf3d/sdTorus.glsl\\nfloat sdTorus(float r0, float r1, vec3 p) {\\n  vec3 closestCenter = vec3(normalize(p.xy) * r0, 0.0);\\n  return distance(closestCenter, p) - r1;\\n}\\n\\n// #pragma glslify: export(sdTorus)\\n\\n\\n// END ../common/sdf3d/sdTorus.glsl\\n// START ../common/sdf3d/sdCapsule.glsl\\nfloat sdCapsule(vec3 a, vec3 b, float r, vec3 p) {\\n  vec3 pa = p - a;\\n  vec3 ba = b - a;\\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\\n  return length(pa - ba * h) - r;\\n}\\n// #pragma glslify: export(sdCapsule)\\n\\n// END ../common/sdf3d/sdCapsule.glsl\\n// START ../common/sdf3d/opElongate.glsl\\nvec3 opElongate(vec3 h, vec3 p) {\\n  return p - clamp(p, -h, h);\\n}\\n// #pragma glslify: export(opElongate)\\n\\n// END ../common/sdf3d/opElongate.glsl\\n// START ../common/sdf3d/sdSphere.glsl\\nfloat sdSphere(float radius, vec3 p) {\\n  return length(p) - radius;\\n}\\n\\n// #pragma glslify: export(sdSphere)\\n\\n\\n// END ../common/sdf3d/sdSphere.glsl\\n// START ../common/sdf3d/sdCylinder.glsl\\nfloat sdCylinder(float radius, float z, vec3 p) {\\n  vec2 d = vec2(length(p.xy), abs(p.z)) - vec2(radius, z);\\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\\n}\\n\\n// #pragma glslify: export(sdCylinder)\\n\\n\\n// END ../common/sdf3d/sdCylinder.glsl\\n// START ../common/sdf2d/addChamfer.glsl\\n\\nfloat addChamfer(float d, float a, float b) {\\n  // exact variant, but abs is larger when a and b aren't perpendicular\\n  // which is worse than underestimating, which is what the simple version does.\\n  //  vec2 p = vec2(a, b);\\n  //  if (p.x < d && p.y < d) {\\n  //    p = rot2(0.25 * PI) * p;\\n  //    p.y = abs(p.y);\\n  //    p.y -= min(p.y, d * SQRT1_2);\\n  //    p.x -= d * SQRT1_2;\\n  //    //    p -= vec2(SQRT1_2) * clamp(dot(p, vec2(SQRT1_2)), 0.0, d);\\n  //    float fillet = -length(p);\\n  //    return -sign(p.x) * fillet;\\n  //  } else {\\n  //  }\\n  float tillet = (a + b - d) * SQRT1_2;\\n  return min(tillet, min(a, b));\\n}\\n\\n// #pragma glslify: export(addChamfer)\\n\\n\\n// END ../common/sdf2d/addChamfer.glsl\\n// START ../common/sdf2d/addFillet.glsl\\nfloat addFillet(float r, float a, float b) {\\n  if (a < r && b < r) {\\n    return r - distance(vec2(a, b), vec2(r));\\n  } else {\\n    return min(a, b);\\n  }\\n}\\n\\n// #pragma glslify: export(addFillet)\\n\\n\\n// END ../common/sdf2d/addFillet.glsl\\n// START ../common/sdf3d/sdBox.glsl\\n\\nfloat sdBox(vec3 r, vec3 p) {\\n  vec3 q = abs(p) - r;\\n  return length(max(q, 0.0)) + min(max3(q), 0.0);\\n}\\n\\nfloat sdBox(vec3 r, float r2, vec3 p) {\\n  return sdBox(r - r2, p) - r2;\\n}\\n\\n// #pragma glslify: export(sdBox)\\n\\n\\n// END ../common/sdf3d/sdBox.glsl\\n// START ../common/sdf3d/sdOctahedron.glsl\\nfloat sdOctahedron(float s, vec3 p) {\\n  p = abs(p);\\n  float m = p.x + p.y + p.z - s;\\n  vec3 q;\\n  if (3.0 * p.x < m) q = p.xyz;\\n  else if (3.0 * p.y < m) q = p.yzx;\\n  else if (3.0 * p.z < m) q = p.zxy;\\n  else return m * 0.57735027;\\n\\n  float k = clamp(0.5 * (q.z - q.y + s), 0.0, s);\\n  return length(vec3(q.x, q.y - s + k, q.z - k));\\n}\\n// #pragma glslify: export(sdOctahedron)\\n\\nfloat sdOctahedron(vec3 p, float s) {\\n  p = abs(p);\\n\\n  float m = p.x + p.y + p.z - s;\\n  //find point on octohedron surf nearest to p\\n  vec3 projPoint = p - vec3(0.333333 * m); //project onto surface plane\\n  //now push projected point, if outside triangle edge, perpendicular to edge, to edge\\n  vec3 toMove = min(projPoint, 0.0); //if projpoint.x<0 move along (1.0,-0.5,-0.5) , etc\\n  float toMoveSum = dot(toMove, vec3(1.0)); //which is basically along (1.5,0,0) then vec3(-0.5)\\n\\n  vec3 movedPoint = projPoint + toMove * vec3(-1.5) + toMoveSum * vec3(0.5); //better to multiply toMove by a matrix (1s diagonal, 0.5 other)?\\n\\n  movedPoint = max(movedPoint, 0.0); //cap x,y,z to 0 then\\n  movedPoint *= s / dot(movedPoint, vec3(1.0)); //scale about 0,0,0\\n\\n  return length(p - movedPoint);\\n}\\n\\n// END ../common/sdf3d/sdOctahedron.glsl\\n// START ../common/sdf3d/add.glsl\\nfloat add(float a, float b) {\\n  return min(a, b);\\n}\\n\\n// #pragma glslify: export(add)\\n\\n\\n// END ../common/sdf3d/add.glsl\\n// START ../common/sdf3d/sub.glsl\\nfloat sub(float from, float what) {\\n  return max(from, -what);\\n}\\n\\n// #pragma glslify: export(sub)\\n\\n\\n// END ../common/sdf3d/sub.glsl\\n\\n// START ../common/complex.glsl\\n\\nvec2 complexConj(vec2 z) {\\n  return vec2(z.x, -z.y);\\n}\\n\\nvec2 complexMul(vec2 a, vec2 b) {\\n  return vec2(a.x * b.x - a.y * b.y, a.y * b.x + a.x * b.y);\\n}\\n\\nvec2 complexDiv(vec2 a, vec2 b) {\\n  vec2 bConj = vec2(b.x, -b.y);\\n  float divisor = complexMul(b, bConj).x;\\n  return complexMul(a, bConj) / divisor;\\n}\\n\\n// return e^z\\nvec2 complexPow(vec2 z) {\\n  // e^(re + i * im)\\n  // = e^re * e^(i * im)\\n  return fromPolar(exp(z.x), z.y);\\n}\\n\\n// return w^z\\nvec2 complexPow(vec2 w, float z) {\\n  // w = r * e ^ (i * phi)\\n  // ln(w) = ln(r) + i * phi\\n  // w^z = e^(z * log(w)) = e^(z * (ln(r) + i * (phi))\\n  vec2 wPolar = toPolar(w);\\n  vec2 eExp = z * vec2(log(wPolar.x), wPolar.y);\\n  return complexPow(eExp);\\n}\\n\\n// END ../common/complex.glsl\\n// START ../common/quaternion.glsl\\nvec4 quatMult(vec4 a, vec4 b) {\\n  return vec4(\\n    a[0] * b[0] - a[1] * b[1] - a[2] * b[2] - a[3] * b[3],\\n    a[0] * b[1] + a[1] * b[0] + a[2] * b[3] - a[3] * b[2],\\n    a[0] * b[2] - a[1] * b[3] + a[2] * b[0] + a[3] * b[1],\\n    a[0] * b[3] + a[1] * b[2] - a[2] * b[1] + a[3] * b[0]\\n  );\\n}\\n\\nvec4 quatMult2(vec4 a, vec4 b) {\\n  return vec4(\\n    a.x * b.x - dot(a.yzw, b.yzw),\\n    a.x * b.yzw + b.x * a.yzw + cross(a.yzw, b.yzw)\\n  );\\n}\\n\\nvec4 quatMult(vec4 a, vec4 b, vec4 c) {\\n  return quatMult(quatMult(a, b), c);\\n}\\n\\nvec4 quatConjugate(vec4 a) {\\n  return vec4(a[0], -a[1], -a[2], -a[3]);\\n}\\nvec4 quatConjugate2(vec4 a) {\\n  return vec4(a.x, -a.yzw);\\n}\\n\\nfloat quatNorm(vec4 a) {\\n  return length(a);\\n}\\n\\nvec4 quatInverse(vec4 a) {\\n  return quatConjugate(a) / dot(a, a);\\n}\\n\\nvec4 quatRotation(vec3 axis1, float angleRad) {\\n  return vec4(cos(0.5 * angleRad), axis1 * sin(0.5 * angleRad));\\n}\\n\\nvec4 quatPower(vec4 q, float x) {\\n  float a = q.x;\\n  vec3 vv = q.yzw;\\n  vec3 n1 = normalize(vv);\\n  float phi = atan(length(vv), a);\\n  return pow(quatNorm(q), x) * vec4(cos(x * phi), n1 * sin(x * phi));\\n}\\nvec4 quatExp(vec4 q) {\\n  float a = q.x;\\n  vec3 vv = q.yzw;\\n  return exp(a) * vec4(cos(length(vv)), normalize(vv) * sin(length(vv)));\\n}\\n\\nvec4 rotatePoint(vec4 quat, vec3 p) {\\n  return quatMult(quat, vec4(0, p), quatInverse(quat));\\n}\\n\\n// END ../common/quaternion.glsl\\n\\nuniform sampler2D texture;\\nuniform float secs;\\nuniform mat4 lll;\\nuniform mat4 llli;\\nuniform vec4 colorPrimary;\\nuniform vec4 colorSecondary;\\nuniform vec4 colorBackground;\\nuniform float a;\\nuniform float b;\\nuniform float c;\\nuniform float d;\\nuniform float highResTimeStamp;\\nuniform int bandCount;\\nuniform vec3 campos;\\nin float n;\\nin vec2 coord;\\nout vec4 fragColor;\\n\\nstruct FxDFx {\\n  float fx;\\n  vec2 dfx;\\n};\\n\\n// f(r,a) = r - 1 + sin(3a+2r2)/2\\n//float f(vec2 polar) {\\n//  float r = length()polar.x;\\n//  float a = polar.y;\\n//  return r - 1.0 + sin(25.0 * a + 20.0 * r * r) / 2.0;\\n//}\\n//vec2 df(vec2 x) {\\n//  float r = length(x);\\n//  float a = atan(x.y, x.x);\\n//  vec2 da = vec2(x.y, -x.x) / (r * r);\\n//  return x / r + (1.5 * da + 2.0 * x) * cos(3.0 * a + 2.0 * r * r);\\n//}\\n\\nFxDFx ff(vec2 p) {\\n  float r = length(p);\\n  float a = atan(p.x, p.y);\\n  float fx = r - 1.0 + 0.5 * sin(3.0 * a + 2.0 * r * r);\\n  vec2 da = vec2(p.y, -p.x) / (r * r);\\n  vec2 dfx = p / r + (1.5 * da + 2.0 * p) * cos(3.0 * a + 2.0 * r * r);\\n  return FxDFx(fx, dfx);\\n}\\n\\n#define CHAIN(NAME, F, G)                                                      \\\\\\n  FxDFx NAME(vec2 p) {                                                         \\\\\\n    FxDFx gResult = G(x);                                                      \\\\\\n    return FxDFx();                                                            \\\\\\n  }\\n\\nfloat f(vec2 x) {\\n  float r = length(x);\\n  float a = atan(x.y, x.x);\\n  return r - 1.0 + 0.5 * sin(5.0 * a + 2.0 * r * r);\\n}\\nvec2 grad(vec2 x) {\\n  vec2 h = vec2(0.01, 0.0);\\n  return vec2(f(x + h.xy) - f(x - h.xy), f(x + h.yx) - f(x - h.yx)) /\\n  (2.0 * h.x);\\n}\\nuniform vec2 iMouse;\\nuniform vec2 iResolution;\\n\\nfloat pointGrid(float scale, vec2 p) {\\n  p -= 0.5;\\n  p /= scale;\\n  vec2 pCenter = round(p);\\n  return smoothstep(-0.5, -0.4, -distance(pCenter, p) * scale);\\n}\\n\\nfloat lineGrid(float scale, vec2 p) {\\n  p -= 0.5;\\n  p /= scale;\\n  vec2 pCenter = round(p);\\n  vec2 d = abs(p - pCenter);\\n  return smoothstep(-0.5, -0.4, -min(d.x, d.y) * scale);\\n}\\nfloat lineGrid(float scale, vec2 p, vec2 dp) {\\n  p -= 0.5;\\n  p /= scale;\\n  vec2 pCenter = round(p);\\n  vec2 d = abs((p - pCenter) / dp);\\n  return smoothstep(-0.5, -0.4, -min(d.x, d.y) * scale);\\n}\\n/**\\n * Renders a transform of a coordinate system as a line grid.\\n *\\n * E.g.\\n *\\n * `p` should be p(fragCoord)\\n *\\n * and\\n *\\n * `scale` should be dp/dx(fragCoord)\\n *\\n * For a linear transformation (mat2 mi), you pass\\n * `lineGrid(mi * fragCoord, mi)`\\n */\\nfloat lineGrid(vec2 p, mat2 scale) {\\n  //  p -= 0.5;\\n  vec2 pCenter = round(p);\\n  vec2 gradX = vec2(1, 0) * scale;\\n  vec2 gradY = vec2(0, 1) * scale;\\n  vec2 d = abs(p - pCenter);\\n  float m = min(d.x / length(gradX), d.y / length(gradY));\\n  //  return float(m < 3.0);\\n  return smoothstep(-1.5, -0.0, -m);\\n}\\nfloat lineCross(float scale, vec2 p, mat2 dp) {\\n  p -= 0.5;\\n  p /= scale;\\n  dp /= scale;\\n  //  vec2 d = abs(p * inverse(dp));\\n  //  vec2 d = abs(inverse(dp) * p);\\n  //  vec2 d = abs(dp * p);\\n  vec2 d = abs(p);\\n  //  vec2 d = abs(p * dp);\\n  return smoothstep(-0.5, -0.4, -min(d.x, d.y));\\n}\\nconst vec3 white = vec3(1);\\nconst vec3 red = vec3(1, 0, 0);\\n\\nvec2 fff2(vec2 x) {\\n  vec2 p = toPolar(x);\\n  return fromPolar(p.x, p.x);\\n}\\nvec2 fff(vec2 x) {\\n  vec2 p = toPolar(x);\\n  vec2 pp = vec2(p.x, p.y + 0.01 * p.x);\\n  return fromPolar(pp);\\n}\\n\\nvec2 ff3(vec2 x) {\\n  return 1.0 + cos(x / 50.0) * 30.0 / 50.0;\\n  return 1.0 + cos(x / 50.0) * 30.0 * a / 50.0;\\n}\\nvec2 cPow(vec2 fragCoord, float it) {\\n  vec2 w = fragCoord / a / 50.0;\\n  float z = 1.0 / c;\\n  // w = r * e ^ (i * phi)\\n  // ln(w) = ln(r) + i * phi\\n  // w^z = e^(z * log(w)) = e^(z * (ln(r) + i * (phi))\\n  vec2 wPolar = toPolar(w);\\n  wPolar.y += it * TAU;\\n  vec2 eExp = z * vec2(log(wPolar.x), wPolar.y);\\n  if (!between(-PI, PI, eExp.y)) {\\n    return vec2(0);\\n  }\\n  return complexPow(eExp);\\n}\\n\\n#define DERIVATIVE_2_2(NAME, F, EPS)                                           \\\\\\n  mat2 NAME(vec2 x) {                                                          \\\\\\n    vec2 fx = F(x);                                                            \\\\\\n    vec2 fx1 = F(x + vec2(EPS, 0));                                            \\\\\\n    vec2 fx2 = F(x + vec2(0, EPS));                                            \\\\\\n    return mat2(fx1 - fx, fx2 - fx) / (EPS);                                   \\\\\\n  }\\n\\nDERIVATIVE_2_2(dfff, fff, 1e-4)\\nDERIVATIVE_2_2(dff3, ff3, 1e-4)\\nmat2 dCPow(vec2 x, float it) {\\n  const float EPS = 1e-3;\\n  vec2 fx = cPow(x, it);\\n  vec2 fx1 = cPow(x + vec2(EPS, 0), it);\\n  vec2 fx2 = cPow(x + vec2(0, EPS), it);\\n  return mat2(fx1 - fx, fx2 - fx) / EPS;\\n}\\n\\n#define MIX_MAT(genMType)                                                      \\\\\\n  genMType mixMat(genMType a, genMType b, float t) {                           \\\\\\n    return (1.0 - t) * a + t * b;                                              \\\\\\n  }\\n\\nMIX_MAT(mat2)\\n\\n#define MIN3(G)                                                                \\\\\\n  G min3(G a, G b, G c) {                                                      \\\\\\n    return min(min(a, b), c);                                                  \\\\\\n  }\\n\\nMIN3(vec2)\\n\\nuniform float iTime;\\nvec3 ungamma(vec4 col) {\\n  return pow(col.rgb, vec3(2.2));\\n}\\n\\nvoid main() {\\n  vec2 fragCoord = coord * iResolution;\\n  //  //  vec2 p = toPolar(coord * 2.0);\\n  vec2 crd = coord;\\n  crd *= 2.0;\\n  //  FxDFx r = ff(crd);\\n  //  float fx = r.fx;\\n  //  vec2 dfx = r.dfx;\\n  //  float de = abs(fx) / length(dfx);\\n  //  //  fx = abs(fx);\\n  //  //  de = smoothstep(0.01, 0.02, de);\\n  //  //  vec3 color = vec3(fx);\\n  //  fragColor = visualize(de);\\n  //  //  fragColor = vec4(color, 1.0);\\n\\n  vec4 z = vec4(coord, 0.0, 0.0);\\n  const vec4 c = vec4(-0.4, 0.6, 0.0, 0.0);\\n  int i = 0;\\n  for (; i < 30; i++) {\\n    z = quatMult(z, z) + c;\\n    const vec4 c2 = vec4(-0.4, 0.6, 0.0, 0.0);\\n    int i = 0;\\n    for (; i < 30; i++) {\\n      z = quatMult(z, z) + c2;\\n      if (length(z) > 1.2) {\\n        break;\\n      }\\n    }\\n\\n    //  vec3 color=mix(bl)\\n\\n    vec2 x = crd;\\n    float v = f(x);\\n    vec2 g = grad(x);\\n    float de = abs(v) / length(g);\\n    vec3 color;\\n    //  fragColor = visualize(pow(de, 0.5));\\n    color = mix(vec3(1.0), vec3(0.0, 0.0, 1.0), float(i) / 30.0);\\n\\n    {\\n      int i = 0;\\n      vec4 z = vec4(iMouse, 0, 0);\\n      for (; i < 30; i++) {\\n        vec4 prevZ = z;\\n        z = quatMult(z, z) + c;\\n        if (sdSegment(prevZ.xy, z.xy, coord) < 0.002) {\\n          color = mix(vec3(0, 0, 0), vec3(0.1, 1.0, 0), float(i) / 30.0);\\n          break;\\n        }\\n        if (length(z) > 1.2) {\\n          break;\\n        }\\n      }\\n    }\\n    if (distance(vec2(0), coord) < 0.05) {\\n      color = vec3(1, 0, 0);\\n    }\\n    if (distance(c.xy, coord) < 0.05) {\\n      color = vec3(0, 1, 0);\\n    }\\n    //  fragColor = visualize(sdSegment(vec2(0), iMouse, coord));\\n    //  color = mix(white, vec3(1, 0, 1), pointGrid(20.0, fragCoord));\\n    //  fragCoord += sin(fragCoord / 50.0) * 30.0;\\n    //    fragCoord -= 800.0;\\n    //  fragCoord *= 2.0;\\n    //  fragCoord = ff3(fragCoord);\\n    //  vec2 dFragCoord = 1.0 + cos(fragCoord / 50.0) * 30.0 / 50.0;\\n    mat2 dFragCoord = dfff(fragCoord);\\n    color = mix(white, vec3(1, 0, 1), lineGrid(20.0, fragCoord, vec2(1.0)));\\n    fragColor = vec4(color, 1.0);\\n    fragColor = visualize(determinant(dFragCoord));\\n    if (distance(c2.xy, coord) < 0.05) {\\n      color = vec3(0, 1, 0);\\n    }\\n\\n    color = pow(color, vec3(1.0 / 2.2)); // gamma correction\\n    //  color = mix(white, vec3(1, 0, 1), pointGrid(20.0, fragCoord));\\n    //  fragCoord += sin(fragCoord / 50.0) * 30.0;\\n    vec2 p = fragCoord;\\n    p -= 0.5 * iResolution;\\n    //  p.y *= -1.0;\\n    //  p *= 2.0;\\n    //  p = ff3(p);\\n    //  vec2 dFragCoord = 1.0 + cos(p / 50.0) * 30.0 / 50.0;\\n    mat2 mi = inverse(\\n      mat2(\\n        1.0, 0.0,\\n        0.0, 1.0\\n      ) *\\n        a *\\n        20.0\\n    );\\n    mat2 id = mat2(\\n      1.0, 0.0,\\n      0.0, 1.0\\n    );\\n    float t = 0.0;\\n    color = white;\\n    //  color = mix(\\n    //    color,\\n    //    vec3(cPow(p) / 4.0, 0),\\n    //    lineGrid(cPow(p), dCPow(p))\\n    //  );\\n\\n    //  for (int i = -100; i < 100; i++) {\\n    //    vec2 p = vec2(i, 2.0);\\n    //    p = cPow(p, 0.0);\\n    //    p *= 10.0;\\n    //    float xxx = float(distance(p, p) < 5.0);\\n    //    color = mix(color, vec3(float(i + 100) / 100.0, 0, 0), xxx);\\n    //  }\\n    // TODO: save this line grid/complex mult demo\\n    //    for (float it = -2.0; it <= 2.0; it++) {\\n    //      //    p += it * vec2(1.0) * d;\\n    //      color = mix(\\n    //        color,\\n    //        vec3(0.5),\\n    //        //      vec3(cPow(p, it) / 4.0, 0),\\n    //        lineGrid(cPow(p, it), dCPow(p, it))\\n    //      );\\n    //    }\\n    vec3 color0 = colorBackground.rgb;\\n    vec3 color1 = colorPrimary.rgb;\\n    vec3 color2 = colorSecondary.rgb;\\n    float val = 1000.0;\\n    //    const vec3 orange = vec3(1.0, 0.843, 0);\\n    //    color = mix(color, color1, float(distance(a, fragCoord) < 10.0));\\n    //    color = mix(color, color1, float(distance(b, fragCoord) < 10.0));\\n    //    color = mix(color, color1, float(distance(c, fragCoord) < 10.0));\\n    //    color = mix(color, color2, float(sdSegment(a, b, fragCoord) < 3.0));\\n    //    color = vec3(fragCoord, 0.0);\\n    color = pow(color, vec3(1.0 / 2.2)); // gamma correction\\n    fragColor = vec4(color, 1.0);\\n    //  fragColor = visualize(determinant(dFragCoord));\\n  }\\n}\\n\\n\"\nconst sourceMap = {\"version\":3,\"sources\":[\"/home/runner/work/workshop/workshop/src/sdfs/fractals.frag\",\"/home/runner/work/workshop/workshop/src/common/sdf2d/sdSegment.glsl\",\"/home/runner/work/workshop/workshop/src/common/unmix.glsl\",\"/home/runner/work/workshop/workshop/src/common/banded.glsl\",\"/home/runner/work/workshop/workshop/src/common/between.glsl\",\"/home/runner/work/workshop/workshop/src/common/max3.glsl\",\"/home/runner/work/workshop/workshop/src/common/constants.glsl\",\"/home/runner/work/workshop/workshop/src/common/hexFns.glsl\",\"/home/runner/work/workshop/workshop/src/common/perlin2DTexture.glsl\",\"/home/runner/work/workshop/workshop/src/common/fromPolar.glsl\",\"/home/runner/work/workshop/workshop/src/common/toPolar.glsl\",\"/home/runner/work/workshop/workshop/src/common/polar.glsl\",\"/home/runner/work/workshop/workshop/src/common/remix.glsl\",\"/home/runner/work/workshop/workshop/src/common/visualize.glsl\",\"/home/runner/work/workshop/workshop/src/common/waves.glsl\",\"/home/runner/work/workshop/workshop/src/common/matrices.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdTorus.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdCapsule.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/opElongate.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdSphere.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdCylinder.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf2d/addChamfer.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf2d/addFillet.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdBox.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdOctahedron.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/add.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sub.glsl\",\"/home/runner/work/workshop/workshop/src/common/complex.glsl\",\"/home/runner/work/workshop/workshop/src/common/quaternion.glsl\"],\"names\":[],\"mappings\":\"AAAA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AftEA;;AgBjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACPA;AACA;AACA;AACA;AACA;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;;A1BwBA;;A2B7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A5BrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA\"}\nexport { sourceMap };\n","\nexport default \"#version 300 es\\nprecision highp float;\\n\\n// START ../common/banded.glsl\\nfloat banded(float bandCount, float t) {\\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\\n}\\nfloat banded(int bandCount, float t) {\\n  return banded(float(bandCount), t);\\n}\\n\\n// #pragma glslify: export(banded)\\n\\n\\n// END ../common/banded.glsl\\n// START ../common/between.glsl\\nbool between(float min, float max, float value) {\\n  return min <= value && value <= max;\\n}\\n\\n// #pragma glslify: export(between)\\n\\n\\n// END ../common/between.glsl\\n// START ../common/perlin2DTexture.glsl\\nuniform sampler2D gradients;\\n/* Create random direction vector\\n */\\nvec2 randomGradient(vec2 i) {\\n  // Random float. No precomputed gradients mean this works for any number of grid coordinates\\n  float random =\\n    2920.0 *\\n    sin(float(i.x) * 2.1942 + float(i.y) * 1.71324 + 8.912) *\\n    cos(float(i.x) * 2.3157 * float(i.y) * 2.17832 + 9.758);\\n  //    random = (i.x + 1667.) * (i.x + 2083.) * (i.y + 2659.) * (i.y * 50.77 + .3769);\\n  //    random = sin(SQRT2 * i.x) + cos(GOLDEN_RATIO * i.y) + tan((i.x + i.y) * SQRT3);\\n  return vec2(cos(random), sin(random));\\n}\\nfloat dotGridGradient(vec2 cell, vec2 pos) {\\n  vec2 d = cell - pos;\\n\\n  //  vec2 gradient = texelFetch(gradients, ivec2(cell), 0).xy;\\n  vec2 gradient = randomGradient(vec2(cell));\\n\\n  return dot(gradient, d);\\n}\\n\\nfloat mixx(float a, float b, float t) {\\n  return mix(a, b, smoothstep(0.0, 1.0, t));\\n  //    return mix(a, b, t);\\n}\\n\\n// resulting range is [-0.68, 0.68]. Use unmix to normalize if necessary.\\nfloat perlin2D(vec2 xy) {\\n  float x0 = floor(xy.x);\\n  float x1 = x0 + 1.0;\\n  float y0 = floor(xy.y);\\n  float y1 = y0 + 1.0;\\n\\n  // Interpolate between grid point gradients\\n  float n00 = dotGridGradient(vec2(x0, y0), xy);\\n  float n10 = dotGridGradient(vec2(x1, y0), xy);\\n  float ny0 = mixx(n00, n10, xy.x - x0);\\n\\n  float n01 = dotGridGradient(vec2(x0, y1), xy);\\n  float n11 = dotGridGradient(vec2(x1, y1), xy);\\n  float ny1 = mixx(n01, n11, xy.x - x0);\\n\\n  return mixx(ny0, ny1, xy.y - y0);\\n}\\n\\n// #pragma glslify: export(perlin2D)\\n\\n\\n// END ../common/perlin2DTexture.glsl\\n// START ../common/remix.glsl\\n// START ./unmix.glsl\\nfloat unmix(float a, float b, float value) {\\n  return (value - a) / (b - a);\\n}\\n\\n// #pragma glslify: export(unmix)\\n\\n\\n// END ./unmix.glsl\\n\\nfloat remix(float fromA, float fromB, float toA, float toB, float value) {\\n  return mix(toA, toB, unmix(fromA, fromB, value));\\n}\\n\\nvec4 remix(float fromA, float fromB, vec4 toA, vec4 toB, float value) {\\n  return mix(toA, toB, unmix(fromA, fromB, value));\\n}\\n\\n// #pragma glslify: export(remix)\\n\\n\\n// END ../common/remix.glsl\\n// START ../common/waves.glsl\\nfloat waves(vec4 color, vec2 position, vec2 direction, float highResTimeStamp) {\\n  return sin(\\n    dot(position, direction / pow(length(direction), 2.0)) +\\n      float(highResTimeStamp) / 200.0\\n  );\\n}\\n\\n// #pragma glslify: export(waves)\\n\\n\\n// END ../common/waves.glsl\\n// START ../common/visualize.glsl\\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\\n  float isLow = float(t < 0.0);\\n  float isHigh = float(t > 1.0);\\n  float isMid = 1.0 - isLow - isHigh;\\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\\n}\\n\\nvec4 visualize(float t) {\\n  const vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\\n  const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\\n  return visualize(BLUE, RED, t);\\n}\\n\\n// #pragma glslify: export(visualize)\\n\\n\\n// END ../common/visualize.glsl\\n// START ../common/hexFns.glsl\\n// START ./max3.glsl\\nfloat max3(float a, float b, float c) {\\n  return max(a, max(b, c));\\n}\\nfloat max3(vec3 v) {\\n  return max(v.x, max(v.y, v.z));\\n}\\n\\n// #pragma glslify: export(max3)\\n\\n\\n// END ./max3.glsl\\n// START ./constants.glsl\\nconst float SQRT1_2 = 0.7071067811865476;\\nconst float SQRT1_3 = 0.57735026919;\\nconst float SQRT2 = 1.4142135623730951;\\nconst float SQRT3 = 1.732050807568877;\\n// sqrt(3)/2 = sin(60*)\\nconst float SQRT3_2 = 0.86602540378;\\nconst float GOLDEN_RATIO = 1.61803398875;\\nconst float PI = 3.141592653589793;\\nconst float TAU = 6.28318530718;\\n/**\\n * One degree in radians. Use like `sin(30 * DEG)`.\\n */\\nconst float DEGREE = 0.017453292519943295;\\n\\n// END ./constants.glsl\\n\\nvec3 hexRound(vec3 hex) {\\n  vec3 r = floor(hex + 0.5);\\n  vec3 diff = abs(r - hex);\\n\\n  if (diff.x > diff.y && diff.x > diff.z) {\\n    r.x = -(r.y + r.z);\\n  } else if (diff.y > diff.z) {\\n    r.y = -(r.x + r.z);\\n  } else {\\n    r.z = -(r.x + r.y);\\n  }\\n\\n  return r;\\n}\\nvec2 hex2Ra(vec3 hex) {\\n  float y = hex.t * SQRT3_2;\\n  float x = hex.s + hex.t / 2.0;\\n  return vec2(x, y);\\n}\\n\\nfloat hexSdf(vec3 hex) {\\n  return max3(abs(hex.yzx + hex.zxy / 2.0));\\n}\\nvec3 ra2Hex(vec2 xy) {\\n  float hex_t = xy.y / SQRT3_2;\\n  float hex_s = xy.x - hex_t / 2.0;\\n  return vec3(hex_s, hex_t, -(hex_s + hex_t));\\n}\\n\\n// END ../common/hexFns.glsl\\n// START ../common/triFns.glsl\\n\\n// (x, y) -> (u, v, R)\\n// where u is horizontal, v is south-west to north-east\\n// and R is wether the it is in the right triangle\\nvec3 xy2tri(vec2 xy) {\\n  float v = xy.y / SQRT3_2;\\n  float u = xy.x - v / 2.0;\\n  float R = float(\\n    mod(u + v, 2.0) > 1.0 != (mod(floor(u) + floor(v), 2.0) == 1.0)\\n  );\\n  return vec3(u, v, R);\\n}\\nvec3 triCenter(vec3 uvR) {\\n  vec3 base = floor(uvR);\\n  vec2 centerOffset = mix(vec2(1.0 / 3.0), vec2(2.0 / 3.0), uvR.z);\\n  return base + vec3(centerOffset, 0.0);\\n}\\nvec2 tri2xy(vec3 uvR) {\\n  float y = uvR.t * SQRT3_2;\\n  float x = uvR.s + uvR.t / 2.0;\\n  return vec2(x, y);\\n}\\nvec2 tri2xy(vec2 uv) {\\n  float y = uv.t * SQRT3_2;\\n  float x = uv.s + uv.t / 2.0;\\n  return vec2(x, y);\\n}\\nfloat triSdf(vec2 uv) {\\n  vec3 hex = vec3(uv.x, uv.y, -uv.x - uv.y);\\n  return max3(hex);\\n}\\n\\n// END ../common/triFns.glsl\\n\\nuniform sampler2D texture;\\nuniform vec4 colorPrimary;\\nuniform float highResTimeStamp;\\nuniform vec4 colorSecondary;\\nuniform vec4 colorBackground;\\nuniform float a;\\nuniform int bandCount;\\nin float n;\\nin vec2 coord;\\nout vec4 fragColor;\\n\\nmat2 rot2(float angle) {\\n  float c = cos(angle),\\n    s = sin(angle);\\n  return mat2(c, -s, s, c);\\n}\\n\\nfloat perlin01(vec2 pos) {\\n  return unmix(-0.68, 0.68, perlin2D(pos));\\n}\\n\\nvec2 fc(vec2 z, vec2 c) {\\n  return complexMul(z, z) + c;\\n}\\n\\nfloat mandelbrot(vec2 c) {\\n  vec2 z = vec2(0);\\n  for (int i = 0; i < bandCount * 2; i++) {\\n    z = fc(z, c);\\n  }\\n  return length(z);\\n}\\nvec2 mandelbrotz(vec2 c) {\\n  vec2 z = vec2(0);\\n  for (int i = 0; i < bandCount * 2; i++) {\\n    z = fc(z, c);\\n  }\\n  return z;\\n}\\n\\nint mandelbrotcount(vec2 c) {\\n  vec2 z = vec2(0);\\n  int i;\\n  for (i = 0; i < bandCount * 2; i++) {\\n    z = fc(z, c);\\n    if (length(z) > 1024.0) {\\n      break;\\n    }\\n  }\\n  return i;\\n}\\n\\nvoid main() {\\n  vec2 cc = coord / pow(10.0, a * 10.0) - vec2(0.5301, 0.5);\\n  vec2 f = mandelbrotz(cc);\\n  float inside = float(length(f) < 1024.0);\\n  int c = mandelbrotcount(cc);\\n\\n  //    fragColor =\\n  //        visualize(blue, red, f / 1000.0);\\n\\n  //    fragColor = vec4(f.xy, 0.0, 1.0);\\n  float val = pow(float(c) / float(bandCount), 1.0 / 2.0);\\n  fragColor = mix(colorBackground, colorPrimary, val);\\n  //    fragColor = visualize(blue, red, val);\\n}\\n\"\nconst sourceMap = {\"version\":3,\"sources\":[\"/home/runner/work/workshop/workshop/src/sdfs/mandelbrot.frag\",\"/home/runner/work/workshop/workshop/src/common/banded.glsl\",\"/home/runner/work/workshop/workshop/src/common/between.glsl\",\"/home/runner/work/workshop/workshop/src/common/perlin2DTexture.glsl\",\"/home/runner/work/workshop/workshop/src/common/unmix.glsl\",\"/home/runner/work/workshop/workshop/src/common/remix.glsl\",\"/home/runner/work/workshop/workshop/src/common/waves.glsl\",\"/home/runner/work/workshop/workshop/src/common/visualize.glsl\",\"/home/runner/work/workshop/workshop/src/common/max3.glsl\",\"/home/runner/work/workshop/workshop/src/common/constants.glsl\",\"/home/runner/work/workshop/workshop/src/common/hexFns.glsl\",\"/home/runner/work/workshop/workshop/src/common/triFns.glsl\"],\"names\":[],\"mappings\":\"AAAA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AXnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA\"}\nexport { sourceMap };\n","var map = {\n\t\"./demoLego.frag\": 2965,\n\t\"./demoTemple.frag\": 6026,\n\t\"./fractals.frag\": 383,\n\t\"./mandelbrot.frag\": 4818\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 8261;"],"names":["BoundNumberField","state","prop","setStatePartial","props","variant","size","type","value","onChange","e","target","label","FPSController","__init","this","count","__init2","lastTime","performance","now","constructor","notify","window","prototype","call","tick","time","fps","Math","floor","parseHash","hash","substring","split","map","part","key","decodeURIComponent","reduce","obj","objectToHash","o","Object","entries","encodeURIComponent","join","defaultDeserialize","x","v","NaN","isNaN","console","error","defaultSerialize","useHashState","initialState","deserialize","serialize","wait","createInitialState","useCallback","mergedState","assign","document","location","history","pushState","undefined","title","setState","useState","updateHashRef","useRef","current","newState","useEffect","onHashChange","addEventListener","removeEventListener","PAPER_SIZES_A","PAPER_SIZES_C","PAPER_SIZES","PaperSizeFromString","str","byName","find","name","a","b","PaperSizeFromDimensions","sort","lhs","y","rhsFn","PaperSizeToString","PAPER_SIZE_A4","INCH","fmtdeg","radiusFromSideWidth","sides","sideWidth","sin","sideWithFromRadius","radius","centerToSideFromSideWidth","tan","radiusFromCenterToSide","centerToSide","cos","sideWidthFromCenterToSide","RegularPolygon","startAngle","sideLength","Error","V3","polar","d","dTpl","i","RotStep","id","children","stepDeg","xlinkHref","transform","strings","exps","format","Array","isArray","result","length","openInNewTab","url","newWindow","open","opener","_optionalChain","ops","lastAccessLHS","op","fn","args","FlyCameraController","lastPos","O","pressedKeys","__init3","pauseCam","lockUp","__init4","__init5","__init6","__init7","m","M4","copy","registerListeners","mouseMoveTarget","keyUpDownTarget","_3","unregister","_4","mousemove","keydown","keyup","unregisterListeners","_5","_6","speed","q","Control","w","s","likeO","translate","toLength","_7","_8","pagePos","V","pageX","pageY","delta","to","buttons","rot","rotateY","rotateX","times","_9","_10","preventDefault","getLookAt","static","inverse","transposed","scale","eye","transformVector","getTranslation","dir","Z","up","Y","negated","lookAt","posFactor","coordString","f","z","invertLookAt","unit","cam","coord","sp","posStr","lookDirStr","upStr","plus","ACTIONS","OrbitCameraController","zoomIn","zoomOut","left","right","down","udRot","dist","keys","__init8","__init9","__init10","__init11","__init12","log","toOrbitCameraState","atan","lengthXY","angleXY","wheel","blur","dDist","dRot","newUDRot","PI","ss","_11","_12","stopImmediatePropagation","newDist","deltaY","_13","_14","action","rotateZ","udRotStr","rotStr","distStr","GenericDemo","sx","animate","Renderer","focusable","rendererRef","rendererRef2","setFps","anchorEl","setAnchorEl","renderProgress","setRenderProgress","render","async","event","dim","currentTarget","dataset","URL","createObjectURL","renderImage","openMenu","resolutionScale","setResolutionScale","resolutionScales","devicePixelRatio","closeMenu","Card","position","Menu","onClose","MenuItem","onClick","ListItem","ListItemText","Select","Box","margin","CircularProgress","Fab","MoreVert","CardMedia","component","ReactGlCanvas","onFps","width","height","canvasRef","renderer1","start","destroy","theme","useTheme","dyn","colorBackground","palette","background","default","gl","colorPrimary","primary","main","colorSecondary","secondary","ref","style","SimpleCanvasRenderer","mousePos","stop","fragShader","canvas","create","alpha","premultipliedAlpha","fixCanvasRes","clientWidth","clientHeight","viewport","getBoundingClientRect","offsetX","offsetY","planeMesh","plane","startX","startY","compile","fpsController","makeCurrent","updateShader","buildShader","lastResult","lastArgs","some","memoizeLast","vs","fs","sourceMap","fsSrc","shader","clear","sourceMapConsumer","SourceMapConsumer","newMessage","message","replace","match","line","originalPosition","originalPositionFor","column","source","bind","abs","_","_2","uniforms","iResolution","iMouse","iTime","draw","onProgress","createElement","renderer","step","enable","SCISSOR_TEST","donePixels","scissorWidth","min","scissorHeight","scissor","Promise","resolve","reject","toBlob","blob","c","frag","resolution","setResolution","disabled","padStart","container","spacing","padding","item","xs","md","lg","checked","inputProps","getSwitchBaseUtilityClass","slot","generateUtilityClass","generateUtilityClasses","_excluded","SwitchBaseRoot","styled","ButtonBase","ownerState","borderRadius","edge","marginLeft","marginRight","SwitchBaseInput","cursor","opacity","top","zIndex","autoFocus","checkedProp","checkedIcon","className","defaultChecked","disabledProp","disableFocusRipple","icon","inputRef","onBlur","onFocus","readOnly","required","tabIndex","other","setCheckedState","useControlled","controlled","Boolean","muiFormControl","useFormControl","hasLabelFor","classes","slots","root","capitalize","input","composeClasses","useUtilityClasses","centerRipple","focusRipple","role","nativeEvent","defaultPrevented","newChecked","createSvgIcon","getCheckboxUtilityClass","CheckboxRoot","shouldForwardProp","overridesResolver","styles","indeterminate","color","vars","text","disableRipple","backgroundColor","activeChannel","mainChannel","hoverOpacity","active","defaultCheckedIcon","CheckBox","defaultIcon","CheckBoxOutlineBlank","defaultIndeterminateIcon","IndeterminateCheckBox","inProps","_icon$props$fontSize","_indeterminateIcon$pr","useThemeProps","iconProp","indeterminateIcon","indeterminateIconProp","composedClasses","fontSize","webpackContext","req","webpackContextResolve","__webpack_require__","code","module","exports"],"sourceRoot":""}