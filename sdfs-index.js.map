{"version":3,"file":"sdfs-index.js","mappings":"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","sources":["/dev/workshop/./src/sdfs/SimpleCanvasRenderer.tsx?","/dev/workshop/./src/common/memoizeLast.ts?","/dev/workshop/./src/sdfs/index.tsx?","/dev/workshop/./node_modules/@mui/material/internal/switchBaseClasses.js?","/dev/workshop/./node_modules/@mui/material/internal/SwitchBase.js?","/dev/workshop/./node_modules/@mui/material/internal/svg-icons/CheckBoxOutlineBlank.js?","/dev/workshop/./node_modules/@mui/material/internal/svg-icons/CheckBox.js?","/dev/workshop/./node_modules/@mui/material/internal/svg-icons/IndeterminateCheckBox.js?","/dev/workshop/./node_modules/@mui/material/Checkbox/checkboxClasses.js?","/dev/workshop/./node_modules/@mui/material/Checkbox/Checkbox.js?","/dev/workshop/./src/sdfs/demoLego.frag?","/dev/workshop/./src/sdfs/demoTemple.frag?","/dev/workshop/./src/sdfs/fractals.frag?","/dev/workshop/./src/sdfs/mandelbrot.frag?","/dev/workshop/./src/sdfs/ sync ^\\.\\/.*\\.frag$?"],"sourcesContent":[" function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }import MoreVertIcon from \"@mui/icons-material/MoreVert\"\nimport Box from \"@mui/material/Box\"\nimport Card from \"@mui/material/Card\"\nimport CardMedia from \"@mui/material/CardMedia\"\nimport CircularProgress from \"@mui/material/CircularProgress\"\nimport Fab from \"@mui/material/Fab\"\nimport ListItem from \"@mui/material/ListItem\"\nimport ListItemText from \"@mui/material/ListItemText\"\nimport Menu from \"@mui/material/Menu/Menu\"\nimport MenuItem from \"@mui/material/MenuItem\"\nimport Select from \"@mui/material/Select\"\nimport { useTheme } from \"@mui/material/styles\"\n\nimport * as chroma from \"chroma.ts\"\nimport * as React from \"react\"\nimport {\n\n\n  useCallback,\n  useEffect,\n  useRef,\n  useState,\n} from \"react\"\nimport sleep from \"sleep-promise\"\nimport { SourceMapConsumer } from \"source-map-js\"\nimport { Mesh, Shader, TSGLContext } from \"tsgl\"\n\nimport { FPSController } from \"../common/FPSController\"\nimport { memoizeLast } from \"../common/memoizeLast\"\nimport { openInNewTab } from \"../paperBox1/common\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nexport function GenericDemo({\n  sx,\n  animate,\n  state,\n  Renderer,\n  focusable,\n  rendererRef,\n}\n\n\n\n\n\n\n) {\n  const rendererRef2 = useRef()\n  const [fps, setFps] = useState(0)\n  const [anchorEl, setAnchorEl] = useState()\n\n  const [renderProgress, setRenderProgress] = useState()\n\n  const render = useCallback(\n    async (event) => {\n      const dim = event.currentTarget.dataset\n        .dim.split(\"x\")\n        .map((x) => +x) \n      setAnchorEl(undefined)\n      if (rendererRef2.current) {\n        try {\n          const url = URL.createObjectURL(\n            await rendererRef2.current.renderImage(dim, setRenderProgress),\n          )\n          setRenderProgress(undefined)\n          openInNewTab(url)\n        } catch (e) {\n          console.error(e)\n        }\n      }\n    },\n    [],\n  )\n  useEffect(() => {\n    if (rendererRef) {\n      rendererRef.current = rendererRef2.current\n    }\n  }, [rendererRef])\n\n  const openMenu = useCallback(\n    (event) => setAnchorEl(event.currentTarget),\n    [],\n  )\n  const [resolutionScale, setResolutionScale] = useState(1)\n  const resolutionScales = [\n    0.5,\n    1,\n    window.devicePixelRatio,\n    2,\n    4 * window.devicePixelRatio,\n  ]\n  const closeMenu = useCallback(() => setAnchorEl(undefined), [])\n  return (\n    React.createElement(Card, { sx: { ...sx, position: \"relative\" },}\n      , React.createElement(Menu, { open: !!anchorEl, anchorEl: anchorEl, onClose: closeMenu,}\n        , React.createElement(MenuItem, { 'data-dim': \"1920x1080\", onClick: render,}, \"Render HD\"\n\n        )\n        , React.createElement(MenuItem, { 'data-dim': \"3840x2160\", onClick: render,}, \"Render 4K\"\n\n        )\n        , React.createElement(ListItem, null\n          , React.createElement(ListItemText, null, \"Res Scale \"  ), \" \"\n          , React.createElement(Select, {\n            value: resolutionScale,\n            onChange: (e) => {\n              setAnchorEl(undefined)\n              setResolutionScale(+e.target.value)\n            },\n            size: \"small\",}\n\n            , resolutionScales.map((x) => (\n              React.createElement(MenuItem, { key: x, value: x,}\n                , x\n              )\n            ))\n          )\n        )\n      )\n      , React.createElement(Box, { sx: { position: \"absolute\", margin: 1, right: 0 },}\n        , renderProgress !== undefined ? (\n          React.createElement(CircularProgress, {\n            variant: \"determinate\",\n            value: renderProgress * 100,}\n          )\n        ) : (\n          React.createElement(Fab, { size: \"small\", onClick: openMenu,}\n            , React.createElement(MoreVertIcon, null )\n          )\n        )\n      )\n      , React.createElement(Box, { sx: { position: \"absolute\", margin: 1, left: 0 },}, fps)\n\n      , React.createElement(CardMedia, {\n        component: ReactGlCanvas,\n        Renderer: Renderer,\n        animate: animate,\n        state: state,\n        rendererRef: rendererRef2,\n        onFps: setFps,\n        resolutionScale: resolutionScale,\n        focusable: focusable,\n        sx: { width: \"100%\", height: \"100%\" },}\n      )\n    )\n  )\n}\n\nexport const ReactGlCanvas = ({\n  Renderer,\n  onFps,\n  animate,\n  state,\n  rendererRef,\n  focusable = false,\n  resolutionScale,\n}\n\n\n\n\n\n\n\n) => {\n  const canvasRef = useRef(null)\n  const rendererRef2 = useRef()\n\n  useEffect(() => {\n    if (canvasRef.current) {\n      const renderer1 = new Renderer(canvasRef.current, {\n        onFps,\n        resolutionScale,\n      })\n      rendererRef2.current = renderer1\n      renderer1.start()\n      if (rendererRef) {\n        rendererRef.current = renderer1\n      }\n      return () => renderer1.destroy()\n    }\n  }, [Renderer, onFps, resolutionScale, rendererRef])\n  const theme = useTheme()\n  useEffect(() => {\n    rendererRef2.current &&\n      Object.assign(rendererRef2.current.dyn, {\n        colorBackground: chroma.css(theme.palette.background.default).gl(),\n        colorPrimary: chroma.css(theme.palette.primary.main).gl(),\n        colorSecondary: chroma.css(theme.palette.secondary.main).gl(),\n      })\n  }, [rendererRef2.current, theme.palette])\n  useEffect(() => {\n    if (rendererRef2.current) rendererRef2.current.animate = animate\n  }, [rendererRef2.current, animate])\n  useEffect(() => {\n    if (rendererRef2.current) Object.assign(rendererRef2.current.dyn, state)\n  }, [rendererRef2.current, state])\n  return React.createElement('canvas', { ref: canvasRef, style: { width: \"100%\", height: \"100%\" },} )\n}\nexport class SimpleCanvasRenderer {\n  \n\n\n\n\n\n  \n\n   __init() {this.mousePos = [-1, -1] }\n\n  \n   __init2() {this.dyn = {}}\n   __init3() {this.animate = true}\n  \n   __init4() {this.stop = () => {}}\n  \n\n  constructor(\n      fragShader\n\n,\n      canvas,\n    {\n      onFps,\n      resolutionScale = window.devicePixelRatio,\n    },\n  ) {;this.fragShader = fragShader;this.canvas = canvas;SimpleCanvasRenderer.prototype.__init.call(this);SimpleCanvasRenderer.prototype.__init2.call(this);SimpleCanvasRenderer.prototype.__init3.call(this);SimpleCanvasRenderer.prototype.__init4.call(this);SimpleCanvasRenderer.prototype.__init5.call(this);\n    const mousemove = (e) => {\n      const canvas = e.currentTarget \n      const { width, height } = canvas.getBoundingClientRect()\n      this.mousePos = [\n        canvas.width * (e.offsetX / width),\n        canvas.height * (1 - e.offsetY / height),\n      ]\n    }\n    const mouseleave = (e) => {\n      this.mousePos = [-1, -1]\n    }\n    const gl = TSGLContext.create({\n      canvas: canvas,\n      alpha: true,\n      premultipliedAlpha: true,\n      // antialias: true,\n      // don't enable by default: bad for perf\n      // throwOnError: true,\n    }) \n    this.gl = gl\n    function fixCanvasRes() {\n      gl.canvas.width = gl.canvas.clientWidth * resolutionScale\n      gl.canvas.height = gl.canvas.clientHeight * resolutionScale\n      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height)\n    }\n    console.log(\"resolutionScale\", resolutionScale)\n    this.resolutionScale = resolutionScale\n    if (this.canvas.clientWidth !== 0) {\n      fixCanvasRes()\n      gl.canvas.addEventListener(\"resize\", fixCanvasRes)\n    }\n    gl.canvas.addEventListener(\"mouseleave\", mouseleave)\n    gl.canvas.addEventListener(\"mousemove\", mousemove)\n    this.planeMesh = Mesh.plane({ startX: -1, startY: -1, width: 2, height: 2 })\n    // Mesh.plane generates tex coords [0,1] and we want [-1, 1] for rendering.\n    // this.planeMesh.coords = [\n    //   [-1, -1],\n    //   [1, -1],\n    //   [-1, 1],\n    //   [1, 1],\n    // ]\n    this.planeMesh.compile(gl)\n    this.fpsController = onFps && new FPSController(onFps)\n    this.gl.makeCurrent()\n    this.updateShader()\n  }\n\n   updateShader() {\n    this.buildShader(\n      // eslint-disable-next-line @typescript-eslint/no-var-requires\n      require(\"../common/raymarch.vert\").default,\n      // eslint-disable-next-line @typescript-eslint/no-var-requires\n      this.fragShader(),\n    )\n  }\n\n   __init5() {this.buildShader = memoizeLast(\n    (vs, fs) => {\n      let sourceMap\n      try {\n        let fsSrc\n        if (typeof fs === \"string\") {\n          fsSrc = fs\n        } else {\n          fsSrc = fs.default\n          sourceMap = fs.sourceMap\n        }\n        // if (this.shader) {\n        //   this.gl.deleteProgram(this.shader.program)\n        // }\n        console.log(\"building shader\")\n\n        this.shader = Shader.create(vs, fsSrc, this.gl)\n      } catch (e) {\n        console.clear()\n        console.error(sourceMap)\n        if (sourceMap) {\n          const sourceMapConsumer = new SourceMapConsumer(sourceMap)\n          const newMessage = (e ).message.replace(\n            /ERROR: 0:(\\d+)/,\n            (match, line) => {\n              const originalPosition = sourceMapConsumer.originalPositionFor({\n                line: +line,\n                column: 0,\n              })\n              console.log(\"originalPosition\", originalPosition)\n              return (\n                \"ERROR \" +\n                originalPosition.source +\n                \":\" +\n                originalPosition.line +\n                \":\" +\n                originalPosition.column\n              )\n            },\n          )\n          ;(e ).message = newMessage\n        }\n\n        if (!this.shader) throw e\n      }\n    },\n  )}\n\n  start() {\n    this.stop = this.gl.animate(this.render.bind(this))\n  }\n\n  render(abs) {\n    console.log(\"render\", this.resolutionScale)\n    this.gl.makeCurrent()\n    this.updateShader()\n    _optionalChain([this, 'access', _ => _.fpsController, 'optionalAccess', _2 => _2.tick, 'call', _3 => _3(abs)])\n    // this.cam.tick(abs)\n    if (!this.shader) return\n    this.shader\n      .uniforms({\n        iResolution: [this.gl.canvas.width, this.gl.canvas.height],\n        iMouse: this.mousePos,\n        iTime: this.animate ? abs / 1000 : 0,\n      })\n      .uniforms(this.dyn)\n      .uniforms(this.uniforms())\n      .draw(this.planeMesh)\n  }\n\n  destroy() {\n    console.log(\"destroy\")\n    this.stop()\n    // this.planeMesh.destroy()\n    // this.shader.destroy()\n  }\n\n  async renderImage(\n    \n    [width, height],\n    onProgress,\n  ) {\n    _optionalChain([onProgress, 'optionalCall', _4 => _4(0)])\n    await sleep(10)\n    const canvas = document.createElement(\"canvas\")\n    canvas.width = width\n    canvas.height = height\n\n    console.log(this.constructor)\n    const renderer = new this.constructor(canvas, { resolutionScale: 4 })\n    Object.assign(renderer.dyn, this.dyn)\n    const step = 256\n    const gl = renderer.gl\n    gl.enable(gl.SCISSOR_TEST)\n    let donePixels = 0\n    for (let x = 0; x < width; x += step) {\n      for (let y = 0; y < height; y += step) {\n        const scissorWidth = Math.min(step, width - x)\n        const scissorHeight = Math.min(step, height - y)\n        gl.scissor(x, y, scissorWidth, scissorHeight)\n        // console.time(\"render block\")\n        renderer.render(0)\n        // console.timeEnd(\"render block\")\n        await sleep(0)\n        donePixels += scissorWidth * scissorHeight\n        _optionalChain([onProgress, 'optionalCall', _5 => _5(donePixels / (width * height))])\n      }\n    }\n    return new Promise((resolve, reject) =>\n      canvas.toBlob(\n        (blob) =>\n          blob ? resolve(blob) : reject(\"error creating png from canvas\"),\n        \"png\",\n      ),\n    )\n  }\n\n  /**\n   * Override this method to add additional uniforms to the simple renderer shader.\n   */\n   uniforms() {\n    return {}\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nexport function memoizeLast(f) {\n  let lastArgs = []\n  let lastResult\n  return function (...args) {\n    if (\n      lastArgs.length !== args.length ||\n      lastArgs.some((v, i) => v !== args[i])\n    ) {\n      lastArgs = args\n      lastResult = f(...args)\n    }\n    return lastResult\n  } \n}\n","import { Checkbox } from \"@mui/material\"\nimport Button from \"@mui/material/Button\"\nimport Card from \"@mui/material/Card\"\n\nimport CardMedia from \"@mui/material/CardMedia\"\nimport Grid from \"@mui/material/Grid\"\nimport MenuItem from \"@mui/material/MenuItem\"\nimport Select from \"@mui/material/Select\"\nimport { useTheme } from \"@mui/material/styles\"\nimport aesthetically from \"aesthetically\"\n\nimport * as React from \"react\"\nimport { useCallback, useEffect, useRef, useState } from \"react\"\n\n\nimport { BoundNumberField } from \"../common/BoundNumberField\"\n\n\nimport { useHashState } from \"../common/useHashState\"\nimport { FlyCameraController } from \"../raymarch/FlyCameraController\"\nimport { OrbitCameraController } from \"../raymarch/OrbitCameraController\"\n\nimport {\n  ReactGlCanvas,\n\n  SimpleCanvasRenderer,\n} from \"./SimpleCanvasRenderer\"\n\nfunction normfig(s) {\n  return aesthetically.format(s, \"monospace\")\n}\n\nconst initialState = {\n  a: 0.2,\n  b: 0.2,\n  c: 0.2,\n  d: 0.2,\n  animate: true,\n}\n\n\nfunction GenericDemo({\n  frag,\n  sx,\n  animate,\n  state,\n}\n\n\n\n\n\n) {\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  const Renderer = useCallback(\n    SimpleCanvasRenderer.bind(\n      undefined,\n      // eslint-disable-next-line @typescript-eslint/no-var-requires\n      () => require(\"./\" + frag + \".frag\"),\n    ),\n    [frag],\n  )\n\n  return (\n    React.createElement(Card, { sx: sx,}\n      , React.createElement(CardMedia, {\n        component: ReactGlCanvas,\n        Renderer: Renderer,\n        animate: animate,\n        state: state,\n        sx: { width: \"100%\", height: \"100%\" },}\n      )\n    )\n  )\n}\n\nexport default () => {\n  const [renderProgress, setRenderProgress] = useState(\n    undefined ,\n  )\n  const [resolution, setResolution] = useState(512)\n  const [state, setState] = useHashState(initialState)\n  const setStatePartial = useCallback(\n    (o) => setState((s) => ({ ...s, ...o })),\n    [setState],\n  )\n\n  const renderer = useRef(undefined )\n\n  // useEffect(() => {\n  //   tsgl.current = TSGLContext.create({\n  //     canvas: canvasRef.current!,\n  //     alpha: true,\n  //     premultipliedAlpha: true,\n  //     // antialias: true,\n  //     throwOnError: true,\n  //   })\n  //   tsgl.current.fixCanvasRes()\n  //   tsgl.current.addResizeListener()\n  //\n  //   renderer.current = new Renderer(tsgl.current)\n  //   renderer.current.start()\n  // }, [])\n  useEffect(() => {\n    // state.cam &&\n    //   raymarchRef.current?.setCam(\n    //     OrbitCameraController.fromShortString(state.cam),\n    //   )\n  }, [state.cam])\n  const theme = useTheme()\n\n  useEffect(() => {\n    renderer.current && Object.assign(renderer.current.dyn, state)\n  }, [state])\n  const render = () => {}\n\n  const RenderButton = useCallback(\n    ({ dim, children }) => (\n      React.createElement(Button, {\n        variant: \"contained\",\n        onClick: () => render(dim),\n        disabled: \"undefined\" !== typeof renderProgress,}\n\n        , \"undefined\" === typeof renderProgress\n          ? children\n          : \"Rendering... \" +\n            normfig(\"\" + Math.floor(renderProgress * 100)).padStart(\n              3,\n              \"\\u2007\",\n            ) +\n            \"%\"\n      )\n    ),\n    [render, renderProgress],\n  )\n\n  function setCam({ cam }) {\n    const m = FlyCameraController.fromShortString(cam)\n    setStatePartial({ cam: OrbitCameraController.toShortString(m) })\n  }\n\n  return (\n    React.createElement(Grid, { container: true, style: { height: \"99%\" }, spacing: 2, padding: 2,}\n      , React.createElement(Grid, { item: true, xs: 12,}\n        , React.createElement(GenericDemo, {\n          frag: \"demoTemple\",\n          sx: { height: 500 },\n          animate: state.animate,\n          state: state,}\n        )\n      )\n      , React.createElement(Grid, { item: true, xs: 12, md: 6, lg: 4,}\n        , React.createElement(Checkbox, {\n          checked: state.animate,\n          onChange: (_, animate) => setStatePartial({ animate }),}\n        )\n        , React.createElement(Select, {\n          onChange: (e) => setResolution(+(e.target.value )),\n          value: resolution,}\n\n          , React.createElement(MenuItem, { value: 256,}, \"256x256\")\n          , React.createElement(MenuItem, { value: 512,}, \"512x512\")\n        )\n        , React.createElement(BoundNumberField, {\n          ...{ state, setStatePartial },\n          prop: \"a\",\n          inputProps: { step: 0.05 },}\n        )\n        , React.createElement(BoundNumberField, {\n          ...{ state, setStatePartial },\n          prop: \"b\",\n          inputProps: { step: 0.05 },}\n        )\n        , React.createElement(BoundNumberField, {\n          ...{ state, setStatePartial },\n          prop: \"c\",\n          inputProps: { step: 0.05 },}\n        )\n        , React.createElement(BoundNumberField, {\n          ...{ state, setStatePartial },\n          prop: \"d\",\n          inputProps: { step: 0.05 },}\n        )\n      )\n      /*<Grid item xs={12} md={6} lg={4}>*/\n      /*  <GenericDemo*/\n      /*    frag=\"fractals\"*/\n      /*    sx={{ height: 300 }}*/\n      /*    animate={state.animate}*/\n      /*    state={state}*/\n      /*  />*/\n      /*</Grid>*/\n    )\n  )\n}\nif (module.hot) {\n  module.hot.accept(\"./fractals.frag\", () => {\n    console.log(\"updating\")\n  })\n}\n","import { unstable_generateUtilityClasses as generateUtilityClasses } from '@mui/utils';\nimport generateUtilityClass from '../generateUtilityClass';\nexport function getSwitchBaseUtilityClass(slot) {\n  return generateUtilityClass('PrivateSwitchBase', slot);\n}\nconst switchBaseClasses = generateUtilityClasses('PrivateSwitchBase', ['root', 'checked', 'disabled', 'input', 'edgeStart', 'edgeEnd']);\nexport default switchBaseClasses;","'use client';\n\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nconst _excluded = [\"autoFocus\", \"checked\", \"checkedIcon\", \"className\", \"defaultChecked\", \"disabled\", \"disableFocusRipple\", \"edge\", \"icon\", \"id\", \"inputProps\", \"inputRef\", \"name\", \"onBlur\", \"onChange\", \"onFocus\", \"readOnly\", \"required\", \"tabIndex\", \"type\", \"value\"];\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport clsx from 'clsx';\nimport { refType } from '@mui/utils';\nimport { unstable_composeClasses as composeClasses } from '@mui/base';\nimport capitalize from '../utils/capitalize';\nimport styled from '../styles/styled';\nimport useControlled from '../utils/useControlled';\nimport useFormControl from '../FormControl/useFormControl';\nimport ButtonBase from '../ButtonBase';\nimport { getSwitchBaseUtilityClass } from './switchBaseClasses';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\nconst useUtilityClasses = ownerState => {\n  const {\n    classes,\n    checked,\n    disabled,\n    edge\n  } = ownerState;\n  const slots = {\n    root: ['root', checked && 'checked', disabled && 'disabled', edge && `edge${capitalize(edge)}`],\n    input: ['input']\n  };\n  return composeClasses(slots, getSwitchBaseUtilityClass, classes);\n};\nconst SwitchBaseRoot = styled(ButtonBase)(({\n  ownerState\n}) => _extends({\n  padding: 9,\n  borderRadius: '50%'\n}, ownerState.edge === 'start' && {\n  marginLeft: ownerState.size === 'small' ? -3 : -12\n}, ownerState.edge === 'end' && {\n  marginRight: ownerState.size === 'small' ? -3 : -12\n}));\nconst SwitchBaseInput = styled('input')({\n  cursor: 'inherit',\n  position: 'absolute',\n  opacity: 0,\n  width: '100%',\n  height: '100%',\n  top: 0,\n  left: 0,\n  margin: 0,\n  padding: 0,\n  zIndex: 1\n});\n\n/**\n * @ignore - internal component.\n */\nconst SwitchBase = /*#__PURE__*/React.forwardRef(function SwitchBase(props, ref) {\n  const {\n      autoFocus,\n      checked: checkedProp,\n      checkedIcon,\n      className,\n      defaultChecked,\n      disabled: disabledProp,\n      disableFocusRipple = false,\n      edge = false,\n      icon,\n      id,\n      inputProps,\n      inputRef,\n      name,\n      onBlur,\n      onChange,\n      onFocus,\n      readOnly,\n      required = false,\n      tabIndex,\n      type,\n      value\n    } = props,\n    other = _objectWithoutPropertiesLoose(props, _excluded);\n  const [checked, setCheckedState] = useControlled({\n    controlled: checkedProp,\n    default: Boolean(defaultChecked),\n    name: 'SwitchBase',\n    state: 'checked'\n  });\n  const muiFormControl = useFormControl();\n  const handleFocus = event => {\n    if (onFocus) {\n      onFocus(event);\n    }\n    if (muiFormControl && muiFormControl.onFocus) {\n      muiFormControl.onFocus(event);\n    }\n  };\n  const handleBlur = event => {\n    if (onBlur) {\n      onBlur(event);\n    }\n    if (muiFormControl && muiFormControl.onBlur) {\n      muiFormControl.onBlur(event);\n    }\n  };\n  const handleInputChange = event => {\n    // Workaround for https://github.com/facebook/react/issues/9023\n    if (event.nativeEvent.defaultPrevented) {\n      return;\n    }\n    const newChecked = event.target.checked;\n    setCheckedState(newChecked);\n    if (onChange) {\n      // TODO v6: remove the second argument.\n      onChange(event, newChecked);\n    }\n  };\n  let disabled = disabledProp;\n  if (muiFormControl) {\n    if (typeof disabled === 'undefined') {\n      disabled = muiFormControl.disabled;\n    }\n  }\n  const hasLabelFor = type === 'checkbox' || type === 'radio';\n  const ownerState = _extends({}, props, {\n    checked,\n    disabled,\n    disableFocusRipple,\n    edge\n  });\n  const classes = useUtilityClasses(ownerState);\n  return /*#__PURE__*/_jsxs(SwitchBaseRoot, _extends({\n    component: \"span\",\n    className: clsx(classes.root, className),\n    centerRipple: true,\n    focusRipple: !disableFocusRipple,\n    disabled: disabled,\n    tabIndex: null,\n    role: undefined,\n    onFocus: handleFocus,\n    onBlur: handleBlur,\n    ownerState: ownerState,\n    ref: ref\n  }, other, {\n    children: [/*#__PURE__*/_jsx(SwitchBaseInput, _extends({\n      autoFocus: autoFocus,\n      checked: checkedProp,\n      defaultChecked: defaultChecked,\n      className: classes.input,\n      disabled: disabled,\n      id: hasLabelFor ? id : undefined,\n      name: name,\n      onChange: handleInputChange,\n      readOnly: readOnly,\n      ref: inputRef,\n      required: required,\n      ownerState: ownerState,\n      tabIndex: tabIndex,\n      type: type\n    }, type === 'checkbox' && value === undefined ? {} : {\n      value\n    }, inputProps)), checked ? checkedIcon : icon]\n  }));\n});\n\n// NB: If changed, please update Checkbox, Switch and Radio\n// so that the API documentation is updated.\nprocess.env.NODE_ENV !== \"production\" ? SwitchBase.propTypes = {\n  /**\n   * If `true`, the `input` element is focused during the first mount.\n   */\n  autoFocus: PropTypes.bool,\n  /**\n   * If `true`, the component is checked.\n   */\n  checked: PropTypes.bool,\n  /**\n   * The icon to display when the component is checked.\n   */\n  checkedIcon: PropTypes.node.isRequired,\n  /**\n   * Override or extend the styles applied to the component.\n   * See [CSS API](#css) below for more details.\n   */\n  classes: PropTypes.object,\n  /**\n   * @ignore\n   */\n  className: PropTypes.string,\n  /**\n   * @ignore\n   */\n  defaultChecked: PropTypes.bool,\n  /**\n   * If `true`, the component is disabled.\n   */\n  disabled: PropTypes.bool,\n  /**\n   * If `true`, the  keyboard focus ripple is disabled.\n   * @default false\n   */\n  disableFocusRipple: PropTypes.bool,\n  /**\n   * If given, uses a negative margin to counteract the padding on one\n   * side (this is often helpful for aligning the left or right\n   * side of the icon with content above or below, without ruining the border\n   * size and shape).\n   * @default false\n   */\n  edge: PropTypes.oneOf(['end', 'start', false]),\n  /**\n   * The icon to display when the component is unchecked.\n   */\n  icon: PropTypes.node.isRequired,\n  /**\n   * The id of the `input` element.\n   */\n  id: PropTypes.string,\n  /**\n   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.\n   */\n  inputProps: PropTypes.object,\n  /**\n   * Pass a ref to the `input` element.\n   */\n  inputRef: refType,\n  /*\n   * @ignore\n   */\n  name: PropTypes.string,\n  /**\n   * @ignore\n   */\n  onBlur: PropTypes.func,\n  /**\n   * Callback fired when the state is changed.\n   *\n   * @param {object} event The event source of the callback.\n   * You can pull out the new checked state by accessing `event.target.checked` (boolean).\n   */\n  onChange: PropTypes.func,\n  /**\n   * @ignore\n   */\n  onFocus: PropTypes.func,\n  /**\n   * It prevents the user from changing the value of the field\n   * (not from interacting with the field).\n   */\n  readOnly: PropTypes.bool,\n  /**\n   * If `true`, the `input` element is required.\n   */\n  required: PropTypes.bool,\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: PropTypes.object,\n  /**\n   * @ignore\n   */\n  tabIndex: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n  /**\n   * The input component prop `type`.\n   */\n  type: PropTypes.string.isRequired,\n  /**\n   * The value of the component.\n   */\n  value: PropTypes.any\n} : void 0;\nexport default SwitchBase;","'use client';\n\nimport * as React from 'react';\nimport createSvgIcon from '../../utils/createSvgIcon';\n\n/**\n * @ignore - internal component.\n */\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon( /*#__PURE__*/_jsx(\"path\", {\n  d: \"M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z\"\n}), 'CheckBoxOutlineBlank');","'use client';\n\nimport * as React from 'react';\nimport createSvgIcon from '../../utils/createSvgIcon';\n\n/**\n * @ignore - internal component.\n */\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon( /*#__PURE__*/_jsx(\"path\", {\n  d: \"M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-9 14l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z\"\n}), 'CheckBox');","'use client';\n\nimport * as React from 'react';\nimport createSvgIcon from '../../utils/createSvgIcon';\n\n/**\n * @ignore - internal component.\n */\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon( /*#__PURE__*/_jsx(\"path\", {\n  d: \"M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10H7v-2h10v2z\"\n}), 'IndeterminateCheckBox');","import { unstable_generateUtilityClasses as generateUtilityClasses } from '@mui/utils';\nimport generateUtilityClass from '../generateUtilityClass';\nexport function getCheckboxUtilityClass(slot) {\n  return generateUtilityClass('MuiCheckbox', slot);\n}\nconst checkboxClasses = generateUtilityClasses('MuiCheckbox', ['root', 'checked', 'disabled', 'indeterminate', 'colorPrimary', 'colorSecondary']);\nexport default checkboxClasses;","'use client';\n\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nconst _excluded = [\"checkedIcon\", \"color\", \"icon\", \"indeterminate\", \"indeterminateIcon\", \"inputProps\", \"size\", \"className\"];\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport clsx from 'clsx';\nimport { refType } from '@mui/utils';\nimport { unstable_composeClasses as composeClasses } from '@mui/base';\nimport { alpha } from '@mui/system';\nimport SwitchBase from '../internal/SwitchBase';\nimport CheckBoxOutlineBlankIcon from '../internal/svg-icons/CheckBoxOutlineBlank';\nimport CheckBoxIcon from '../internal/svg-icons/CheckBox';\nimport IndeterminateCheckBoxIcon from '../internal/svg-icons/IndeterminateCheckBox';\nimport capitalize from '../utils/capitalize';\nimport useThemeProps from '../styles/useThemeProps';\nimport styled, { rootShouldForwardProp } from '../styles/styled';\nimport checkboxClasses, { getCheckboxUtilityClass } from './checkboxClasses';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst useUtilityClasses = ownerState => {\n  const {\n    classes,\n    indeterminate,\n    color\n  } = ownerState;\n  const slots = {\n    root: ['root', indeterminate && 'indeterminate', `color${capitalize(color)}`]\n  };\n  const composedClasses = composeClasses(slots, getCheckboxUtilityClass, classes);\n  return _extends({}, classes, composedClasses);\n};\nconst CheckboxRoot = styled(SwitchBase, {\n  shouldForwardProp: prop => rootShouldForwardProp(prop) || prop === 'classes',\n  name: 'MuiCheckbox',\n  slot: 'Root',\n  overridesResolver: (props, styles) => {\n    const {\n      ownerState\n    } = props;\n    return [styles.root, ownerState.indeterminate && styles.indeterminate, ownerState.color !== 'default' && styles[`color${capitalize(ownerState.color)}`]];\n  }\n})(({\n  theme,\n  ownerState\n}) => _extends({\n  color: (theme.vars || theme).palette.text.secondary\n}, !ownerState.disableRipple && {\n  '&:hover': {\n    backgroundColor: theme.vars ? `rgba(${ownerState.color === 'default' ? theme.vars.palette.action.activeChannel : theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(ownerState.color === 'default' ? theme.palette.action.active : theme.palette[ownerState.color].main, theme.palette.action.hoverOpacity),\n    // Reset on touch devices, it doesn't add specificity\n    '@media (hover: none)': {\n      backgroundColor: 'transparent'\n    }\n  }\n}, ownerState.color !== 'default' && {\n  [`&.${checkboxClasses.checked}, &.${checkboxClasses.indeterminate}`]: {\n    color: (theme.vars || theme).palette[ownerState.color].main\n  },\n  [`&.${checkboxClasses.disabled}`]: {\n    color: (theme.vars || theme).palette.action.disabled\n  }\n}));\nconst defaultCheckedIcon = /*#__PURE__*/_jsx(CheckBoxIcon, {});\nconst defaultIcon = /*#__PURE__*/_jsx(CheckBoxOutlineBlankIcon, {});\nconst defaultIndeterminateIcon = /*#__PURE__*/_jsx(IndeterminateCheckBoxIcon, {});\nconst Checkbox = /*#__PURE__*/React.forwardRef(function Checkbox(inProps, ref) {\n  var _icon$props$fontSize, _indeterminateIcon$pr;\n  const props = useThemeProps({\n    props: inProps,\n    name: 'MuiCheckbox'\n  });\n  const {\n      checkedIcon = defaultCheckedIcon,\n      color = 'primary',\n      icon: iconProp = defaultIcon,\n      indeterminate = false,\n      indeterminateIcon: indeterminateIconProp = defaultIndeterminateIcon,\n      inputProps,\n      size = 'medium',\n      className\n    } = props,\n    other = _objectWithoutPropertiesLoose(props, _excluded);\n  const icon = indeterminate ? indeterminateIconProp : iconProp;\n  const indeterminateIcon = indeterminate ? indeterminateIconProp : checkedIcon;\n  const ownerState = _extends({}, props, {\n    color,\n    indeterminate,\n    size\n  });\n  const classes = useUtilityClasses(ownerState);\n  return /*#__PURE__*/_jsx(CheckboxRoot, _extends({\n    type: \"checkbox\",\n    inputProps: _extends({\n      'data-indeterminate': indeterminate\n    }, inputProps),\n    icon: /*#__PURE__*/React.cloneElement(icon, {\n      fontSize: (_icon$props$fontSize = icon.props.fontSize) != null ? _icon$props$fontSize : size\n    }),\n    checkedIcon: /*#__PURE__*/React.cloneElement(indeterminateIcon, {\n      fontSize: (_indeterminateIcon$pr = indeterminateIcon.props.fontSize) != null ? _indeterminateIcon$pr : size\n    }),\n    ownerState: ownerState,\n    ref: ref,\n    className: clsx(classes.root, className)\n  }, other, {\n    classes: classes\n  }));\n});\nprocess.env.NODE_ENV !== \"production\" ? Checkbox.propTypes /* remove-proptypes */ = {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // |     To update them edit the d.ts file and run \"yarn proptypes\"     |\n  // ----------------------------------------------------------------------\n  /**\n   * If `true`, the component is checked.\n   */\n  checked: PropTypes.bool,\n  /**\n   * The icon to display when the component is checked.\n   * @default <CheckBoxIcon />\n   */\n  checkedIcon: PropTypes.node,\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: PropTypes.object,\n  /**\n   * @ignore\n   */\n  className: PropTypes.string,\n  /**\n   * The color of the component.\n   * It supports both default and custom theme colors, which can be added as shown in the\n   * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).\n   * @default 'primary'\n   */\n  color: PropTypes /* @typescript-to-proptypes-ignore */.oneOfType([PropTypes.oneOf(['default', 'primary', 'secondary', 'error', 'info', 'success', 'warning']), PropTypes.string]),\n  /**\n   * The default checked state. Use when the component is not controlled.\n   */\n  defaultChecked: PropTypes.bool,\n  /**\n   * If `true`, the component is disabled.\n   * @default false\n   */\n  disabled: PropTypes.bool,\n  /**\n   * If `true`, the ripple effect is disabled.\n   * @default false\n   */\n  disableRipple: PropTypes.bool,\n  /**\n   * The icon to display when the component is unchecked.\n   * @default <CheckBoxOutlineBlankIcon />\n   */\n  icon: PropTypes.node,\n  /**\n   * The id of the `input` element.\n   */\n  id: PropTypes.string,\n  /**\n   * If `true`, the component appears indeterminate.\n   * This does not set the native input element to indeterminate due\n   * to inconsistent behavior across browsers.\n   * However, we set a `data-indeterminate` attribute on the `input`.\n   * @default false\n   */\n  indeterminate: PropTypes.bool,\n  /**\n   * The icon to display when the component is indeterminate.\n   * @default <IndeterminateCheckBoxIcon />\n   */\n  indeterminateIcon: PropTypes.node,\n  /**\n   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.\n   */\n  inputProps: PropTypes.object,\n  /**\n   * Pass a ref to the `input` element.\n   */\n  inputRef: refType,\n  /**\n   * Callback fired when the state is changed.\n   *\n   * @param {React.ChangeEvent<HTMLInputElement>} event The event source of the callback.\n   * You can pull out the new checked state by accessing `event.target.checked` (boolean).\n   */\n  onChange: PropTypes.func,\n  /**\n   * If `true`, the `input` element is required.\n   * @default false\n   */\n  required: PropTypes.bool,\n  /**\n   * The size of the component.\n   * `small` is equivalent to the dense checkbox styling.\n   * @default 'medium'\n   */\n  size: PropTypes /* @typescript-to-proptypes-ignore */.oneOfType([PropTypes.oneOf(['medium', 'small']), PropTypes.string]),\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),\n  /**\n   * The value of the component. The DOM API casts this to a string.\n   * The browser uses \"on\" as the default value.\n   */\n  value: PropTypes.any\n} : void 0;\nexport default Checkbox;","\nexport default \"#version 300 es\\n\\nprecision highp float;\\n\\n// START ../common/colors.glsl\\nconst vec3 INDIAN_RED = vec3(0.804, 0.361, 0.361);\\nconst vec3 LIGHT_CORAL = vec3(0.941, 0.502, 0.502);\\nconst vec3 SALMON = vec3(0.98, 0.502, 0.447);\\nconst vec3 DARK_SALMON = vec3(0.914, 0.588, 0.478);\\nconst vec3 LIGHT_SALMON = vec3(1.0, 0.627, 0.478);\\nconst vec3 CRIMSON = vec3(0.863, 0.078, 0.235);\\nconst vec3 RED = vec3(1.0, 0.0, 0.0);\\nconst vec3 FIRE_BRICK = vec3(0.698, 0.133, 0.133);\\nconst vec3 DARK_RED = vec3(0.545, 0.0, 0.0);\\nconst vec3 PINK = vec3(1.0, 0.753, 0.796);\\nconst vec3 LIGHT_PINK = vec3(1.0, 0.714, 0.757);\\nconst vec3 HOT_PINK = vec3(1.0, 0.412, 0.706);\\nconst vec3 DEEP_PINK = vec3(1.0, 0.078, 0.576);\\nconst vec3 MEDIUM_VIOLET_RED = vec3(0.78, 0.082, 0.522);\\nconst vec3 PALE_VIOLET_RED = vec3(0.859, 0.439, 0.576);\\nconst vec3 CORAL = vec3(1.0, 0.498, 0.314);\\nconst vec3 TOMATO = vec3(1.0, 0.388, 0.278);\\nconst vec3 ORANGE_RED = vec3(1.0, 0.271, 0.0);\\nconst vec3 DARK_ORANGE = vec3(1.0, 0.549, 0.0);\\nconst vec3 ORANGE = vec3(1.0, 0.647, 0.0);\\nconst vec3 GOLD = vec3(1.0, 0.843, 0.0);\\nconst vec3 YELLOW = vec3(1.0, 1.0, 0.0);\\nconst vec3 LIGHT_YELLOW = vec3(1.0, 1.0, 0.878);\\nconst vec3 LEMON_CHION = vec3(1.0, 0.98, 0.804);\\nconst vec3 LIGHT_GOLDENROD_YELLOW = vec3(0.98, 0.98, 0.824);\\nconst vec3 PAPAYA_WHIP = vec3(1.0, 0.937, 0.835);\\nconst vec3 MOCCASIN = vec3(1.0, 0.894, 0.71);\\nconst vec3 PEACH_PU = vec3(1.0, 0.855, 0.725);\\nconst vec3 PALE_GOLDENROD = vec3(0.933, 0.91, 0.667);\\nconst vec3 KHAKI = vec3(0.941, 0.902, 0.549);\\nconst vec3 DARK_KHAKI = vec3(0.741, 0.718, 0.42);\\nconst vec3 LAVENDER = vec3(0.902, 0.902, 0.98);\\nconst vec3 THISTLE = vec3(0.847, 0.749, 0.847);\\nconst vec3 PLUM = vec3(0.867, 0.627, 0.867);\\nconst vec3 VIOLET = vec3(0.933, 0.51, 0.933);\\nconst vec3 ORCHID = vec3(0.855, 0.439, 0.839);\\nconst vec3 FUCHSIA = vec3(1.0, 0.0, 1.0);\\nconst vec3 MAGENTA = vec3(1.0, 0.0, 1.0);\\nconst vec3 MEDIUM_ORCHID = vec3(0.729, 0.333, 0.827);\\nconst vec3 MEDIUM_PURPLE = vec3(0.576, 0.439, 0.859);\\nconst vec3 BLUE_VIOLET = vec3(0.541, 0.169, 0.886);\\nconst vec3 DARK_VIOLET = vec3(0.58, 0.0, 0.827);\\nconst vec3 DARK_ORCHID = vec3(0.6, 0.196, 0.8);\\nconst vec3 DARK_MAGENTA = vec3(0.545, 0.0, 0.545);\\nconst vec3 PURPLE = vec3(0.502, 0.0, 0.502);\\nconst vec3 INDIGO = vec3(0.294, 0.0, 0.51);\\nconst vec3 SLATE_BLUE = vec3(0.416, 0.353, 0.804);\\nconst vec3 DARK_SLATE_BLUE = vec3(0.282, 0.239, 0.545);\\nconst vec3 GREEN_YELLOW = vec3(0.678, 1.0, 0.184);\\nconst vec3 CHARTREUSE = vec3(0.498, 1.0, 0.0);\\nconst vec3 LAWN_GREEN = vec3(0.486, 0.988, 0.0);\\nconst vec3 LIME = vec3(0.0, 1.0, 0.0);\\nconst vec3 LIME_GREEN = vec3(0.196, 0.804, 0.196);\\nconst vec3 PALE_GREEN = vec3(0.596, 0.984, 0.596);\\nconst vec3 LIGHT_GREEN = vec3(0.565, 0.933, 0.565);\\nconst vec3 MEDIUM_SPRING_GREEN = vec3(0.0, 0.98, 0.604);\\nconst vec3 SPRING_GREEN = vec3(0.0, 1.0, 0.498);\\nconst vec3 MEDIUM_SEA_GREEN = vec3(0.235, 0.702, 0.443);\\nconst vec3 SEA_GREEN = vec3(0.18, 0.545, 0.341);\\nconst vec3 FOREST_GREEN = vec3(0.133, 0.545, 0.133);\\nconst vec3 GREEN = vec3(0.0, 0.502, 0.0);\\nconst vec3 DARK_GREEN = vec3(0.0, 0.392, 0.0);\\nconst vec3 YELLOW_GREEN = vec3(0.604, 0.804, 0.196);\\nconst vec3 OLIVE_DRAB = vec3(0.42, 0.557, 0.137);\\nconst vec3 OLIVE = vec3(0.502, 0.502, 0.0);\\nconst vec3 DARK_OLIVE_GREEN = vec3(0.333, 0.42, 0.184);\\nconst vec3 MEDIUM_AQUAMARINE = vec3(0.4, 0.804, 0.667);\\nconst vec3 DARK_SEA_GREEN = vec3(0.561, 0.737, 0.561);\\nconst vec3 LIGHT_SEA_GREEN = vec3(0.125, 0.698, 0.667);\\nconst vec3 DARK_CYAN = vec3(0.0, 0.545, 0.545);\\nconst vec3 TEAL = vec3(0.0, 0.502, 0.502);\\nconst vec3 AQUA = vec3(0.0, 1.0, 1.0);\\nconst vec3 CYAN = vec3(0.0, 1.0, 1.0);\\nconst vec3 LIGHT_CYAN = vec3(0.878, 1.0, 1.0);\\nconst vec3 PALE_TURQUOISE = vec3(0.686, 0.933, 0.933);\\nconst vec3 AQUAMARINE = vec3(0.498, 1.0, 0.831);\\nconst vec3 TURQUOISE = vec3(0.251, 0.878, 0.816);\\nconst vec3 MEDIUM_TURQUOISE = vec3(0.282, 0.82, 0.8);\\nconst vec3 DARK_TURQUOISE = vec3(0.0, 0.808, 0.82);\\nconst vec3 CADET_BLUE = vec3(0.373, 0.62, 0.627);\\nconst vec3 STEEL_BLUE = vec3(0.275, 0.51, 0.706);\\nconst vec3 LIGHT_STEEL_BLUE = vec3(0.69, 0.769, 0.871);\\nconst vec3 POWDER_BLUE = vec3(0.69, 0.878, 0.902);\\nconst vec3 LIGHT_BLUE = vec3(0.678, 0.847, 0.902);\\nconst vec3 SKY_BLUE = vec3(0.529, 0.808, 0.922);\\nconst vec3 LIGHT_SKY_BLUE = vec3(0.529, 0.808, 0.98);\\nconst vec3 DEEP_SKY_BLUE = vec3(0.0, 0.749, 1.0);\\nconst vec3 DODGER_BLUE = vec3(0.118, 0.565, 1.0);\\nconst vec3 CORNLOWER_BLUE = vec3(0.392, 0.584, 0.929);\\nconst vec3 MEDIUM_SLATE_BLUE = vec3(0.482, 0.408, 0.933);\\nconst vec3 ROYAL_BLUE = vec3(0.255, 0.412, 0.882);\\nconst vec3 BLUE = vec3(0.0, 0.0, 1.0);\\nconst vec3 MEDIUM_BLUE = vec3(0.0, 0.0, 0.804);\\nconst vec3 DARK_BLUE = vec3(0.0, 0.0, 0.545);\\nconst vec3 NAVY = vec3(0.0, 0.0, 0.502);\\nconst vec3 MIDNIGHT_BLUE = vec3(0.098, 0.098, 0.439);\\nconst vec3 CORNSILK = vec3(1.0, 0.973, 0.863);\\nconst vec3 BLANCHED_ALMOND = vec3(1.0, 0.922, 0.804);\\nconst vec3 BISQUE = vec3(1.0, 0.894, 0.769);\\nconst vec3 NAVAJO_WHITE = vec3(1.0, 0.871, 0.678);\\nconst vec3 WHEAT = vec3(0.961, 0.871, 0.702);\\nconst vec3 BURLY_WOOD = vec3(0.871, 0.722, 0.529);\\nconst vec3 TAN = vec3(0.824, 0.706, 0.549);\\nconst vec3 ROSY_BROWN = vec3(0.737, 0.561, 0.561);\\nconst vec3 SANDY_BROWN = vec3(0.957, 0.643, 0.376);\\nconst vec3 GOLDENROD = vec3(0.855, 0.647, 0.125);\\nconst vec3 DARK_GOLDENROD = vec3(0.722, 0.525, 0.043);\\nconst vec3 PERU = vec3(0.804, 0.522, 0.247);\\nconst vec3 CHOCOLATE = vec3(0.824, 0.412, 0.118);\\nconst vec3 SADDLE_BROWN = vec3(0.545, 0.271, 0.075);\\nconst vec3 SIENNA = vec3(0.627, 0.322, 0.176);\\nconst vec3 BROWN = vec3(0.647, 0.165, 0.165);\\nconst vec3 MAROON = vec3(0.502, 0.0, 0.0);\\nconst vec3 WHITE = vec3(1.0, 1.0, 1.0);\\nconst vec3 SNOW = vec3(1.0, 0.98, 0.98);\\nconst vec3 HONEYDEW = vec3(0.941, 1.0, 0.941);\\nconst vec3 MINT_CREAM = vec3(0.961, 1.0, 0.98);\\nconst vec3 AZURE = vec3(0.941, 1.0, 1.0);\\nconst vec3 ALICE_BLUE = vec3(0.941, 0.973, 1.0);\\nconst vec3 GHOST_WHITE = vec3(0.973, 0.973, 1.0);\\nconst vec3 WHITE_SMOKE = vec3(0.961, 0.961, 0.961);\\nconst vec3 SEASHELL = vec3(1.0, 0.961, 0.933);\\nconst vec3 BEIGE = vec3(0.961, 0.961, 0.863);\\nconst vec3 OLD_LACE = vec3(0.992, 0.961, 0.902);\\nconst vec3 FLORAL_WHITE = vec3(1.0, 0.98, 0.941);\\nconst vec3 IVORY = vec3(1.0, 1.0, 0.941);\\nconst vec3 ANTIQUE_WHITE = vec3(0.98, 0.922, 0.843);\\nconst vec3 LINEN = vec3(0.98, 0.941, 0.902);\\nconst vec3 LAVENDER_BLUSH = vec3(1.0, 0.941, 0.961);\\nconst vec3 MISTY_ROSE = vec3(1.0, 0.894, 0.882);\\nconst vec3 GAINSBORO = vec3(0.863, 0.863, 0.863);\\nconst vec3 LIGHT_GREY = vec3(0.827, 0.827, 0.827);\\nconst vec3 SILVER = vec3(0.753, 0.753, 0.753);\\nconst vec3 DARK_GRAY = vec3(0.663, 0.663, 0.663);\\nconst vec3 GRAY = vec3(0.502, 0.502, 0.502);\\nconst vec3 DIM_GRAY = vec3(0.412, 0.412, 0.412);\\nconst vec3 LIGHT_SLATE_GRAY = vec3(0.467, 0.533, 0.6);\\nconst vec3 SLATE_GRAY = vec3(0.439, 0.502, 0.565);\\nconst vec3 DARK_SLATE_GRAY = vec3(0.184, 0.31, 0.31);\\nconst vec3 BLACK = vec3(0.0, 0.0, 0.0);\\n\\n// END ../common/colors.glsl\\n// START ../common/matrices.glsl\\n// START ./constants.glsl\\nconst float SQRT1_2 = 0.7071067811865476;\\nconst float SQRT1_3 = 0.57735026919;\\nconst float SQRT2 = 1.4142135623730951;\\nconst float SQRT3 = 1.732050807568877;\\n// sqrt(3)/2 = sin(60*)\\nconst float SQRT3_2 = 0.86602540378;\\nconst float GOLDEN_RATIO = 1.61803398875;\\nconst float PI = 3.141592653589793;\\nconst float TAU = 6.28318530718;\\n/**\\n * One degree in radians. Use like `sin(30 * DEG)`.\\n */\\nconst float DEGREE = 0.017453292519943295;\\n\\n// END ./constants.glsl\\n\\nmat2 rot2(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat2(c, s, -s, c);\\n}\\nmat3 rotX(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\\n}\\nmat3 rotY(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\\n}\\nmat3 rotZ(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\\n}\\n/**\\n * Returns a matrix that puts the camera at the eye point `ex, ey, ez` looking\\n * toward the center point `cx, cy, cz` with an up direction of `ux, uy, uz`.\\n * This emulates the OpenGL function `gluLookAt()`.\\n */\\nmat4 lookAt(vec3 eye, vec3 focus, vec3 up) {\\n  vec3 f = normalize(eye - focus);\\n  vec3 s = normalize(cross(up, f));\\n  vec3 t = normalize(cross(f, s));\\n\\n  return mat4(\\n    vec4(s.x, t.x, f.x, 0.0),\\n    vec4(s.y, t.y, f.y, 0.0),\\n    vec4(s.z, t.z, f.z, 0.0),\\n    vec4(-dot(s, eye), -dot(t, eye), -dot(f, eye), 1)\\n  );\\n}\\n\\n// the OpenGL function `glFrustum()`.\\nmat4 frustum(\\n  float left,\\n  float right,\\n  float bottom,\\n  float top,\\n  float near,\\n  float far\\n) {\\n  return mat4(\\n    vec4(2.0 * near / (right - left), 0.0, 0.0, 0.0),\\n    vec4(0, 2.0 * near / (top - bottom), 0.0, 0.0),\\n    vec4(\\n      (right + left) / (right - left),\\n      (top + bottom) / (top - bottom),\\n      -(far + near) / (far - near),\\n      -1\\n    ),\\n    vec4(0.0, 0.0, -2.0 * far * near / (far - near), 0.0)\\n  );\\n}\\n\\nmat4 perspective(float fovDegrees, float aspect, float near, float far) {\\n  float y = tan(fovDegrees * DEGREE / 2.0) * near;\\n  float x = y * aspect;\\n  return frustum(-x, x, -y, y, near, far);\\n}\\nmat4 ortho(\\n  float left,\\n  float right,\\n  float bottom,\\n  float top,\\n  float near,\\n  float far\\n) {\\n  return mat4(\\n    vec4(2.0 / (right - left), 0.0, 0.0, 0.0),\\n    vec4(0.0, 2.0 / (top - bottom), 0.0, 0.0),\\n    vec4(0.0, 0.0, -2.0 / (far - near), 0.0),\\n    vec4(\\n      -(right + left) / (right - left),\\n      -(top + bottom) / (top - bottom),\\n      -(far + near) / (far - near),\\n      1.0\\n    )\\n  );\\n}\\n\\n// END ../common/matrices.glsl\\n// START ../common/max3.glsl\\nfloat max3(float a, float b, float c) {\\n  return max(a, max(b, c));\\n}\\nfloat max3(vec3 v) {\\n  return max(v.x, max(v.y, v.z));\\n}\\n\\n// #pragma glslify: export(max3)\\n\\n\\n// END ../common/max3.glsl\\n// START ../common/polar.glsl\\n// START ../common/fromPolar.glsl\\n// START ./unmix.glsl\\nfloat unmix(float a, float b, float value) {\\n  return (value - a) / (b - a);\\n}\\n\\n// #pragma glslify: export(unmix)\\n\\n\\n// END ./unmix.glsl\\n\\nvec3 fromPolar(float radius, float phi, float z) {\\n  return vec3(radius * cos(phi), radius * sin(phi), z);\\n}\\n\\nvec2 fromPolar(float radius, float phi) {\\n  return vec2(radius * cos(phi), radius * sin(phi));\\n}\\n\\nvec2 fromPolar(vec2 polar) {\\n  return fromPolar(polar.x, polar.y);\\n}\\n\\n// #pragma glslify: export(fromPolar)\\n\\n\\n// END ../common/fromPolar.glsl\\n// START ../common/toPolar.glsl\\n\\nvec2 toPolar(vec2 xy) {\\n  return vec2(length(xy), atan(xy.y, xy.x));\\n}\\n\\nmat2 toPolarDerivate(vec2 xy) {\\n  return mat2(xy.x * xy.x, xy.y * xy.y, -xy.y, xy.x) / dot(xy, xy);\\n}\\n\\n// #pragma glslify: export(toPolar)\\n\\n\\n// END ../common/toPolar.glsl\\n\\n// END ../common/polar.glsl\\n// START ../common/sdf3d/sdArrow.glsl\\n// START ./sdCylinder.glsl\\nfloat sdCylinder(float radius, float z, vec3 p) {\\n  vec2 d = vec2(length(p.xy), abs(p.z)) - vec2(radius, z);\\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\\n}\\n\\n// #pragma glslify: export(sdCylinder)\\n\\n\\n// END ./sdCylinder.glsl\\n// START ./sdCone.glsl\\n\\n/**\\n * Signed distance function (SDF) of a cone. The tip of the cone is at the\\n * origin and points towards +Z. q is a point on the rim of the cone.\\n */\\nfloat sdCone(vec2 c, float h, vec3 p) {\\n  vec2 q = h * vec2(c.x / c.y, -1.0);\\n  vec2 w = vec2(length(p.xz), p.y);\\n  vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);\\n  vec2 b = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0);\\n  float k = sign(q.y);\\n  float d = min(dot(a, a), dot(b, b));\\n  float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));\\n  return sqrt(d) * sign(s);\\n}\\n// #pragma glslify: export(sdBox)\\n\\nfloat sdConeB(vec2 c, float h, vec3 p) {\\n  float q = length(p.xz);\\n  return max(dot(c.xy, vec2(q, p.y)), -h - p.y);\\n}\\n\\n// END ./sdCone.glsl\\nvec3 perpendicularVector(vec3 a) {\\n  return cross(a, abs(a.z) > abs(a.x) ? vec3(0, 0, 1) : vec3(0, 1, 0));\\n}\\n/**\\n * Signed distance function (SDF) of an arrow. The arrow goes along the X axis.\\n * The shaft of the arrow has thickness TODO. The tip of the arrow has 30°\\n * angle, length of TODO, with the widest point being.\\n */\\nfloat sdArrow(float length, vec3 p) {\\n  float r = 0.01;\\n  return min(\\n    sdCylinder(\\n      0.02 - r,\\n      0.5 * (length - 0.1) - r,\\n      p.yzx - vec3(0, 0, 0.5 * (length - 0.1))\\n    ) -\\n      r,\\n    sdCone(\\n      vec2(sin(15.0 * DEGREE), cos(15.0 * DEGREE)),\\n      0.15 - r,\\n      p.zxy - vec3(0, length - r, 0)\\n    ) -\\n      r\\n  );\\n}\\nfloat sdArrow(vec3 a, vec3 b, vec3 p) {\\n  vec3 x = normalize(b - a);\\n  vec3 y = normalize(perpendicularVector(x));\\n  vec3 z = cross(x, y);\\n  return sdArrow(length(b - a), inverse(mat3(x, y, z)) * (p - a));\\n}\\n\\n// END ../common/sdf3d/sdArrow.glsl\\n// START ../common/sdf3d/sdBox.glsl\\n\\nfloat sdBox(vec3 r, vec3 p) {\\n  vec3 q = abs(p) - r;\\n  return length(max(q, 0.0)) + min(max3(q), 0.0);\\n}\\n\\nfloat sdBox(vec3 r, float r2, vec3 p) {\\n  return sdBox(r - r2, p) - r2;\\n}\\n\\n// #pragma glslify: export(sdBox)\\n\\n\\n// END ../common/sdf3d/sdBox.glsl\\n// START ../common/sdf3d/sdIcosahedron.glsl\\n\\n// signed distance function for icosahedron\\n// cf. https://en.wikipedia.org/wiki/Regular_icosahedron\\n// s: edge length\\n// p: point to evaluate function for\\nfloat sdIcosahedron(float s, vec3 p) {\\n  // NN = 1/GOLDEN_RATIO = GOLDEN_RATIO - 1\\n  const float K = GOLDEN_RATIO * 0.5;\\n  // the three vertices of the icosahedron triangle which\\n  // is fully inside the +++ octant. (edge length = 1)\\n  const vec3 a = vec3(0.5, K, 0.0);\\n  const vec3 b = vec3(0.0, 0.5, K);\\n  const vec3 c = vec3(K, 0.0, 0.5);\\n  const vec3 ab1 = b - a; // values chosen so edge length is 1\\n  const vec3 n1 = normalize(cross(a, b));\\n  const vec3 n2 = normalize(cross(b, c));\\n  const vec3 n3 = normalize(cross(c, a));\\n  const vec3 xyz1 = normalize(vec3(1.0));\\n  // for edge-length 1\\n  const float INSCRIBED_SPHERE_RADIUS = 0.7557613141;\\n\\n  // we use a rotation where the icosahedron is symmetric\\n  // in all three coordinate planes, and reduce the problem\\n  // to the +++ octant\\n  p = abs(p);\\n\\n  // there is one complete triangle in the +++ octant\\n  // mirror on planes which go through origin and the\\n  // complete triangles sides.\\n  if (dot(p, n1) < 0.0) {\\n    p += -2.0 * dot(p, n1) * n1;\\n  }\\n  if (dot(p, n2) < 0.0) {\\n    p += -2.0 * dot(p, n2) * n2;\\n  }\\n  if (dot(p, n3) < 0.0) {\\n    p += -2.0 * dot(p, n3) * n3;\\n  }\\n\\n  // rotate space around (1,1,1) vector so that all sides of the triangle\\n  // end up mapped on the ab side.\\n  vec3 dirs = vec3(-dot(n1, p), -dot(n2, p), -dot(n3, p));\\n  if (dirs.y > dirs.x && dirs.y > dirs.z) {\\n    p = p.yzx;\\n  } else if (dirs.z > dirs.x && dirs.z > dirs.y) {\\n    p = p.zxy;\\n  }\\n\\n  // check if the point is directly (perpendicular) above the triangle.\\n  // as we have rotated the space, we only need to check if it is\\n  // inside one edge.\\n  vec3 midAB = (a + b) / 2.0;\\n  vec3 pn = normalize(c - midAB);\\n  float w = dot(midAB, pn);\\n  if (dot(p, pn) > w * s) {\\n    // if not, return the distance to the plane the triangle is in\\n    return dot(xyz1, p) - INSCRIBED_SPHERE_RADIUS * s;\\n  }\\n\\n  // project the point onto segment ab, and return the distance to it\\n  float d3 = dot(ab1, p);\\n  d3 = clamp(d3, -0.5 * s, 0.5 * s);\\n  vec3 closestp = midAB * s + d3 * ab1;\\n  return distance(closestp, p);\\n}\\n// #pragma glslify: export(sdIcosahedron)\\n\\n// END ../common/sdf3d/sdIcosahedron.glsl\\n// START ../common/sdf3d/sdOctahedron.glsl\\nfloat sdOctahedron(float s, vec3 p) {\\n  p = abs(p);\\n  float m = p.x + p.y + p.z - s;\\n  vec3 q;\\n  if (3.0 * p.x < m) q = p.xyz;\\n  else if (3.0 * p.y < m) q = p.yzx;\\n  else if (3.0 * p.z < m) q = p.zxy;\\n  else return m * 0.57735027;\\n\\n  float k = clamp(0.5 * (q.z - q.y + s), 0.0, s);\\n  return length(vec3(q.x, q.y - s + k, q.z - k));\\n}\\n// #pragma glslify: export(sdOctahedron)\\n\\nfloat sdOctahedron(vec3 p, float s) {\\n  p = abs(p);\\n\\n  float m = p.x + p.y + p.z - s;\\n  //find point on octohedron surf nearest to p\\n  vec3 projPoint = p - vec3(0.333333 * m); //project onto surface plane\\n  //now push projected point, if outside triangle edge, perpendicular to edge, to edge\\n  vec3 toMove = min(projPoint, 0.0); //if projpoint.x<0 move along (1.0,-0.5,-0.5) , etc\\n  float toMoveSum = dot(toMove, vec3(1.0)); //which is basically along (1.5,0,0) then vec3(-0.5)\\n\\n  vec3 movedPoint = projPoint + toMove * vec3(-1.5) + toMoveSum * vec3(0.5); //better to multiply toMove by a matrix (1s diagonal, 0.5 other)?\\n\\n  movedPoint = max(movedPoint, 0.0); //cap x,y,z to 0 then\\n  movedPoint *= s / dot(movedPoint, vec3(1.0)); //scale about 0,0,0\\n\\n  return length(p - movedPoint);\\n}\\n\\n// END ../common/sdf3d/sdOctahedron.glsl\\n// START ../common/sdf3d/sdDodecahedron.glsl\\n\\nfloat sdDodecahedron(float s, vec3 p, out vec3 color) {\\n  const float PHI = GOLDEN_RATIO;\\n  color = vec3(0.2);\\n  if (p != abs(p)) {\\n    p = abs(p);\\n    if (color == vec3(0.2)) color = RED;\\n  }\\n  p = abs(p);\\n  const vec3 fv =\\n    vec3(1.0 / PHI, 0, PHI) + 2.0 * vec3(1, 0, 1) + 2.0 * vec3(PHI, 0, 0);\\n  const vec3 fv2 =\\n    vec3(PHI, 1.0 / PHI, 0) + 2.0 * vec3(1, 1, 0) + 2.0 * vec3(0, PHI, 0);\\n  const vec3 fv3 =\\n    vec3(0, PHI, 1.0 / PHI) + 2.0 * vec3(0, 1, 1) + 2.0 * vec3(0, 0, PHI);\\n  return max3(\\n    dot(normalize(fv), p),\\n    dot(normalize(fv2), p),\\n    dot(normalize(fv3), p)\\n  ) -\\n  s;\\n  //  float m = p.x + p.y + p.z - s;\\n  //  vec3 q;\\n  //  if (3.0 * p.x < m) q = p.xyz;\\n  //  else if (3.0 * p.y < m) q = p.yzx;\\n  //  else if (3.0 * p.z < m) q = p.zxy;\\n  //  else return m * 0.57735027;\\n  //\\n  //  float k = clamp(0.5 * (q.z - q.y + s), 0.0, s);\\n  //  return length(vec3(q.x, q.y - s + k, q.z - k));\\n}\\nfloat sdDodecahedron(float s, vec3 p) {\\n  vec3 c;\\n  return sdDodecahedron(s, p, c);\\n}\\n\\n// END ../common/sdf3d/sdDodecahedron.glsl\\n// START ../common/sdf3d/sdTetrahedron.glsl\\n// START ./sdCapsule.glsl\\nfloat sdCapsule(vec3 a, vec3 b, float r, vec3 p) {\\n  vec3 pa = p - a;\\n  vec3 ba = b - a;\\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\\n  return length(pa - ba * h) - r;\\n}\\n// #pragma glslify: export(sdCapsule)\\n\\n// END ./sdCapsule.glsl\\n\\n/**\\n * Signed distance function (SDF) of a tetrahedron centered at the origin with\\n * side length `2s`.\\n *\\n * The corners are at `a/b = (+-1,0,sqrt(1/2))` and `c/d = (0,+-1,-sqrt(1/2))`.\\n *\\n * The side length is `||`\\n *\\n * The outscribed sphere has a radius of `sqrt(3/2)`.\\n *\\n * The inscribed sphere has a radius of `sqrt(1/6)`. This is calculated using\\n * the fact that the triangle defined by `mid(a,b) = (0,0,sqrt(1/2))`, `c` and\\n * `mid(c,d) = (0,0,-sqrt(1/2))` is similar to the triangle `mid(a,b)`, `q`, and\\n * `O`.\\n *\\n * For rounded edges, use TODO.\\n *\\n * ```\\n *           ^ Z\\n *           |(+-1, sqrt(1/2))\\n *          /\\\\_\\n *        /    \\\\.q = closest point to center on face\\n *      /    .   \\\\__> Y\\n *    /            \\\\_\\n *  /________________\\\\_(0,-1,sqrt(1/2))\\n * (0,-1,-sqrt(1/2))\\n * ```\\n */\\nfloat sdTetrahedron(float s, vec3 p) {\\n  const vec3 a = vec3(1, 0, SQRT1_2);\\n  const vec3 b = vec3(-1, 0, SQRT1_2);\\n  const vec3 c = vec3(0, 1, -SQRT1_2);\\n  const vec3 d = vec3(0, -1, -SQRT1_2);\\n  const vec3 midBC = 0.5 * (b + c);\\n  const vec3 mirror = normalize(cross(midBC - d, midBC - a));\\n\\n  // Tetra is symmetric in X and Y axes. RED surface in image.\\n  p.xy = abs(p.xy);\\n  // The part z < 0 is symmetric if we rotate it by 90°. BLUE surface in image.\\n  if (p.z < 0.0) {\\n    p = vec3(p.y, p.x, -p.z);\\n  }\\n  // Points below the plane through a, d and mid(b,c) are mirrored through it.\\n  // GREEN surface in image.\\n  p -= 2.0 * mirror * min(dot(p, mirror), 0.0);\\n  // After mirror some points are negative, abs again:\\n  p.xy = abs(p.xy);\\n\\n  // Points are now either above the white surface, or above the positive ab segment.\\n  // We shift the coordinate system so that a is now at the origin.\\n  p -= vec3(1, 0, SQRT1_2) * s;\\n  // Finally, we move points which are directely above the face parallel along\\n  // it to a/origin. We can then calculate the sdf as length(p).\\n  p.x = max(p.x, 0.0);\\n  vec3 midABToC1 = normalize(vec3(0, 1, -SQRT2));\\n\\n  p -= max(dot(midABToC1, p), 0.0) * midABToC1;\\n  return sign(p.z) * length(p);\\n}\\n\\n// Same function but also outputs color for explanation image:\\n//float sdTetrahedron(float s, vec3 p, out vec3 color) {\\n//  //  return distance(vec3(1), p) - 0.2;\\n//  const vec3 a = vec3(0, -1, -SQRT1_2);\\n//  const vec3 b = vec3(0, 1, -SQRT1_2);\\n//  const vec3 c = vec3(1, 0, SQRT1_2);\\n//  const vec3 d = vec3(-1, 0, SQRT1_2);\\n//  const vec3 x = 0.5 * (b + d);\\n//  const vec3 mirror = normalize(cross(x - a, x - c));\\n//\\n//  color = WHITE;\\n//  if (p.xy != abs(p.xy)) {\\n//    p.xy = abs(p.xy);\\n//    if (color == WHITE) color = RED;\\n//  }\\n//  if (p.z < 0.0) {\\n//    p = vec3(p.y, p.x, -p.z);\\n//    if (color == WHITE) color = BLUE;\\n//  }\\n//  if (dot(p, mirror) < 0.0) {\\n//    if (color == WHITE) color = GREEN;\\n//    p -= 2.0 * mirror * min(dot(p, mirror), 0.0);\\n//  }\\n//  p.xy = abs(p.xy);\\n//  p -= vec3(1, 0, SQRT1_2);\\n//  p.x = max(p.x, 0.0);\\n//  vec3 fgh = normalize(vec3(0, 1, -SQRT2));\\n//\\n//  p -= max(dot(fgh, p), 0.0) * fgh;\\n//  return sign(p.z) * length(p);\\n//}\\n\\n\\n// END ../common/sdf3d/sdTetrahedron.glsl\\n// START ../common/ungamma.glsl\\nvec3 ungamma(vec4 col) {\\n  return pow(col.rgb, vec3(2.2));\\n}\\nvec3 ungamma(vec3 col) {\\n  return pow(col, vec3(2.2));\\n}\\n\\n// END ../common/ungamma.glsl\\n\\nuniform sampler2D texture;\\nuniform float iTime;\\nuniform vec4 colorPrimary;\\nuniform vec4 colorSecondary;\\nuniform vec4 colorBackground;\\nuniform float a;\\nuniform float b;\\nuniform float c;\\nuniform float d;\\nuniform int bandCount;\\nuniform vec2 iResolution;\\nuniform vec2 iMouse;\\nin float n;\\nin vec2 coord;\\nout vec4 fragColor;\\n\\n\\nstruct Hit {\\n  float distance;\\n  vec4 color;\\n};\\nHit mixa(Hit a, Hit b, float t) {\\n  return Hit(mix(a.distance, b.distance, t), mix(a.color, b.color, t));\\n}\\nfloat skybox(vec3 p) {\\n  return 32.0 - max3(abs(p));\\n}\\n\\nHit add(Hit a, Hit b) {\\n  //    return a.distance < b.distance\\n  //        ? Hit(a.distance, a.color)\\n  //        : Hit(b.distance, b.color);\\n  return mixa(a, b, float(b.distance < a.distance));\\n}\\n\\nHit addFillet(float r, Hit a, Hit b) {\\n  if (a.distance < r && b.distance < r) {\\n    return Hit(\\n      r - distance(vec2(a.distance, b.distance), vec2(r)),\\n      mix(a.color, b.color, (a.distance - b.distance) / r * 0.5 + 0.5)\\n    );\\n  } else {\\n    return add(a, b);\\n  }\\n}\\n\\nHit addFillet(float r, Hit a, Hit b, vec4 tilletColor) {\\n  if (a.distance < r && b.distance < r) {\\n    return Hit(\\n      r - distance(vec2(a.distance, b.distance), vec2(r)),\\n      tilletColor\\n    );\\n  } else {\\n    return add(a, b);\\n  }\\n}\\nHit addFillet2(float r, Hit a, Hit b) {\\n  float h = smoothstep(-r, r, a.distance - b.distance);\\n  return Hit(\\n    mix(a.distance, b.distance, h) - r * h * (1.0 - h),\\n    mix(a.color, b.color, h)\\n  );\\n}\\n\\nHit neg(Hit a) {\\n  return Hit(-a.distance, a.color);\\n}\\nHit sub(Hit from, Hit what) {\\n  Hit whatNeg = neg(what);\\n  return mixa(from, whatNeg, float(whatNeg.distance > from.distance));\\n}\\n\\nvec3 modv(vec3 v, vec3 dir1, float y) {\\n  float t = dot(v, dir1);\\n  return v - floor(t / y) * y * dir1;\\n}\\nvec3 modRotZ(vec3 p, float count) {\\n  vec2 polarXY = toPolar(p.xy);\\n  return fromPolar(polarXY.x, mod(polarXY.y, TAU / count), p.z);\\n}\\n\\nfloat sin01(float x) {\\n  return 0.5 + 0.5 * sin(x);\\n}\\nfloat cos01(float x) {\\n  return 0.5 + 0.5 * cos(x);\\n}\\n\\nfloat smoothmin(float r, float a, float b) {\\n  float h = smoothstep(-r, r, a - b);\\n  return mix(a, b, h) - r * h * (1.0 - h);\\n}\\n\\nvec2 project(vec2 a, vec2 onto1) {\\n  return onto1 * (dot(a, onto1) / dot(onto1, onto1));\\n}\\n\\nconst float r = 0.0;\\nvec3 reject(vec3 a, vec3 b1) {\\n  return a - b1 * dot(a, b1);\\n}\\nfloat demoIcosahedron(vec3 p) {\\n  float d1 = sdIcosahedron(1.0 - r, p - vec3(0, 0, 1)) - r;\\n  float d2 = p.z;\\n  return min(d1, d2);\\n}\\nfloat demoOctahedron(vec3 p) {\\n  float d1 = sdOctahedron(1.0 - r, p - vec3(0, 0, 1)) - r;\\n  float d2 = p.z;\\n  return min(d1, d2);\\n}\\nfloat demoCube(vec3 p) {\\n  float d1 = sdBox(vec3(1.0 - r), p - vec3(0, 0, 1)) - r;\\n  float d2 = p.z;\\n  return min(d1, d2);\\n}\\nHit gizmo(vec3 p) {\\n  vec3 absp = abs(p);\\n\\n  Hit res = Hit(sdArrow(1.0, p), vec4(RED, 1));\\n  res = add(res, Hit(sdArrow(1.0, p.yzx), vec4(GREEN, 1)));\\n  res = add(res, Hit(sdArrow(1.0, p.zxy), vec4(BLUE, 1)));\\n  res = add(res, Hit(length(p) - 0.05, vec4(BLACK, 1)));\\n  return res;\\n}\\n// START ../common/squareWave.glsl\\nfloat squareWave(float x) {\\n  return floor(2.0 * fract(0.5 * x));\\n}\\n\\n// END ../common/squareWave.glsl\\n\\nHit sdtetra(vec3 p) {\\n  float r = d * 0.1;\\n  vec3 cc;\\n  return Hit(sdDodecahedron(b - r / sqrt(1.0 / 6.0), p, cc) - r, vec4(cc, 1));\\n}\\nfloat demoTetrahedron(vec3 p, out vec3 color) {\\n  const vec3 ta = vec3(0, -1, -SQRT1_2);\\n  const vec3 tb = vec3(0, 1, -SQRT1_2);\\n  const vec3 tc = vec3(1, 0, SQRT1_2);\\n  const vec3 td = vec3(-1, 0, SQRT1_2);\\n  const vec3 x = 0.5 * (ta + td);\\n  const vec3 x2 = 0.5 * (tb + td);\\n  const vec3 mirror = normalize(-cross(x - tb, x - tc));\\n  const vec3 mirror2 = normalize(cross(x2 - ta, x2 - tc));\\n  float dbox = sdBox(vec3(3.0), p);\\n  if (dbox > 0.0) {\\n    color = SALMON;\\n    return dbox + 1.0;\\n  }\\n  Hit d1 = gizmo(p - vec3(0, 0, 1));\\n  vec3 fgh = normalize(vec3(0, 1, -SQRT2));\\n  vec3 cc;\\n  float d2 = p.z;\\n  p = p - vec3(0, 0, 1);\\n  vec3 pa = abs(p);\\n  const float PHI = GOLDEN_RATIO;\\n  d1 = add(d1, Hit(distance(vec3(1), pa) - 0.05, vec4(ORANGE, 1)));\\n  d1 = add(\\n    d1,\\n    Hit(distance(vec3(0, PHI, 1.0 / PHI), pa) - 0.05, vec4(GREEN, 1))\\n  );\\n  d1 = add(\\n    d1,\\n    Hit(distance(vec3(1.0 / PHI, 0, PHI), pa) - 0.05, vec4(BLUE, 1))\\n  );\\n  d1 = add(\\n    d1,\\n    Hit(distance(vec3(PHI, 1.0 / PHI, 0), pa) - 0.05, vec4(PINK, 1))\\n  );\\n  const vec3 fv =\\n    0.2 *\\n    (vec3(1.0 / PHI, 0, PHI) + 2.0 * vec3(1, 0, 1) + 2.0 * vec3(PHI, 0, 0));\\n  const vec3 fv2 =\\n    0.2 *\\n    (2.0 * vec3(0, PHI, 0) + 2.0 * vec3(1, 1, 0) + vec3(PHI, 1.0 / PHI, 0));\\n  d1 = add(d1, Hit(distance(fv, p) - 0.05, vec4(RED, 1)));\\n  d1 = add(d1, Hit(distance(fv2, p) - 0.05, vec4(RED, 1)));\\n  d1 = add(d1, sdtetra(p));\\n  //  d1 = add(d1, Hit(distance(ta, p) - 0.1, vec4(OLIVE_DRAB, 1)));\\n  //  d1 = add(d1, Hit(distance(tb, p) - 0.1, vec4(OLIVE_DRAB, 1)));\\n  //  d1 = add(d1, Hit(distance(tc, p) - 0.1, vec4(OLIVE_DRAB, 1)));\\n  //  d1 = add(d1, Hit(distance(td, p) - 0.1, vec4(OLIVE_DRAB, 1)));\\n  //  d1 = add(d1, Hit(sdArrow(vec3(0), mirror2, p), vec4(OLIVE_DRAB, 1)));\\n  //  d1 = add(d1, Hit(length(p) - sqrt(1.0 / 6.0) - 0.002, vec4(CHARTREUSE, 1)));\\n  //  d1 = add(\\n  //    d1,\\n  //    Hit(sdArrow(0.5 * (tc + td), 0.5 * (tc + td) + fgh, p), vec4(OLIVE_DRAB, 1))\\n  //  );\\n  //  float cd = sdBox(vec3(2.0, 2.0, 0.005), p - vec3(0, 0, a));\\n  //  d1 = add(\\n  //    d1,\\n  //    Hit(cd, vec4(mix(BLUE, CYAN, squareWave(sdtetra(p) * 10.0)), 1))\\n  //  );\\n  //  d1 = sub(d1, Hit(sdBox(vec3(10), p - vec3(0, 0, c)), vec4(HOT_PINK, 1)));\\n  //  float d1 = sdTetrahedron(1.0 - r, p - vec3(0, 0, 1), color) - r;\\n  if (d2 < d1.distance) {\\n    color = WHITE;\\n    return d2;\\n  } else {\\n    color = d1.color.xyz;\\n    return d1.distance;\\n  }\\n}\\n// START ../common/sdf3d/sdLego.glsl\\n// START ./sdTube.glsl\\nfloat sdTube(float radius, float r2, float z, vec3 p) {\\n  vec2 d = vec2(length(p.xy), abs(p.z)) - vec2(radius, z);\\n  d.x = abs(d.x) - r2;\\n  vec2 closest = vec2(abs(d.x - radius) - r2, clamp(d.y, 0.0, z));\\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\\n}\\n\\n// END ./sdTube.glsl\\n\\nfloat sdLego(vec3 p) {\\n  const float IWALLT = 0.04;\\n  p.xy = abs(p.xy);\\n  vec2 c = vec2(4.0, 2.0);\\n  //    p.xy = mod(p.xy + c * 0.5, c) - c * 0.5;\\n  p -= vec3(0.0, 0.0, 0.6);\\n  float d;\\n  const float cr = 0.02;\\n  d = sdBox(vec3(2.0, 1.0, 0.6), cr, p);\\n  if (d > 0.5) {\\n    return d;\\n  }\\n  //    top studs\\n  vec3 p8 = vec3(abs(p.xy - vec2(1.0, 0.0)), p.z) - vec3(0.5, 0.5, 0.6);\\n  float dStuds = sdCylinder(0.35 - 0.04, 0.2, p8) - 0.04;\\n  d = min(d, dStuds);\\n  // little holes in bottom of studs\\n  float dStudHoles = sdCylinder(0.2 - 0.04, 0.3, p8 - vec3(0, 0, -0.4)) - 0.04;\\n  d = max(d, -dStudHoles);\\n  // TODO use sdf texture to add LEGO or custom logo to studs\\n\\n  // hole in the bottom\\n  const float WALLT = 4.0 * IWALLT;\\n  float dBottom = sdBox(\\n    vec3(2.0 - WALLT, 1.0 - WALLT, 0.6),\\n    p - vec3(0, 0, -WALLT)\\n  );\\n  d = max(d, -dBottom);\\n\\n  // 12 indentations on inside.\\n  vec3 pa = p;\\n  // 3. move by 1 in X dir\\n  pa.x -= 1.0;\\n  // 2. mirror across XY axis\\n  if (pa.x > pa.y) pa.xy = pa.yx;\\n  // 1. mirror across Y axis\\n  pa.x = abs(pa.x);\\n  float k = sdBox(vec3(0.5 * IWALLT, 0.05, 0.6), pa - vec3(0.5, 0.8, 0));\\n  d = min(d, k);\\n\\n  // center bar\\n  p = vec3(abs(p.xy), p.z);\\n  d = min(d, sdBox(vec3(0.5 * IWALLT, 0.3, 0.5), p - vec3(0, 0.65, 0.1)));\\n\\n  // 3 tubes\\n  vec3 pTube = p;\\n  if (pTube.x > 0.5) pTube.x -= 1.0;\\n  pTube.x = abs(pTube.x);\\n  d = min(d, sdTube(0.35 + 0.5 * IWALLT, 0.5 * IWALLT, 0.6, pTube));\\n  return d;\\n}\\n\\n// END ../common/sdf3d/sdLego.glsl\\nconst mat4[] positions = mat4[](\\n  inverse(\\n    transpose(\\n      mat4(\\n        vec4(0.9146, 0.4043, -0.0, -4.4334),\\n        vec4(-0.4043, 0.9146, -0.0, 5.642),\\n        vec4(0.0, 0.0, 1.0, 1.0401),\\n        vec4(0.0, 0.0, 0.0, 1.0)\\n      )\\n    )\\n  ),\\n  inverse(\\n    transpose(\\n      mat4(\\n        vec4(0.9993, 0.0378, -0.0, -0.406),\\n        vec4(-0.0378, 0.9993, 0.0, 2.944),\\n        vec4(0.0, -0.0, 1.0, 1.0401),\\n        vec4(0.0, 0.0, 0.0, 1.0)\\n      )\\n    )\\n  ),\\n  inverse(\\n    transpose(\\n      mat4(\\n        vec4(0.9795, 0.2015, 0.0, -0.3315),\\n        vec4(-0.2015, 0.9795, 0.0, 3.0562),\\n        vec4(0.0, -0.0, 1.0, 2.2402),\\n        vec4(0.0, 0.0, 0.0, 1.0)\\n      )\\n    )\\n  ),\\n  inverse(\\n    transpose(\\n      mat4(\\n        vec4(-0.9376, -0.3477, -0.0, -4.5541),\\n        vec4(0.3477, -0.9376, 0.0, 1.1356),\\n        vec4(-0.0, 0.0, 1.0, 1.0401),\\n        vec4(0.0, 0.0, 0.0, 1.0)\\n      )\\n    )\\n  ),\\n  inverse(\\n    transpose(\\n      mat4(\\n        vec4(-0.9709, 0.2393, 0.0001, 3.8652),\\n        vec4(0.2393, 0.9709, -0.0001, 3.4039),\\n        vec4(-0.0001, -0.0, -1.0, 7.0405),\\n        vec4(0.0, 0.0, 0.0, 1.0)\\n      )\\n    )\\n  ),\\n  inverse(\\n    transpose(\\n      mat4(\\n        vec4(0.999, 0.0456, -0.0, -0.1656),\\n        vec4(-0.0456, 0.999, -0.0, 0.6654),\\n        vec4(0.0, 0.0, 1.0, 1.0401),\\n        vec4(0.0, 0.0, 0.0, 1.0)\\n      )\\n    )\\n  ),\\n  inverse(\\n    transpose(\\n      mat4(\\n        vec4(0.9995, 0.0303, 0.0, -0.3213),\\n        vec4(-0.0303, 0.9995, 0.0, 3.4494),\\n        vec4(-0.0, -0.0, 1.0, 3.4403),\\n        vec4(0.0, 0.0, 0.0, 1.0)\\n      )\\n    )\\n  ),\\n  inverse(\\n    transpose(\\n      mat4(\\n        vec4(0.5829, -0.8126, -0.0, -8.6931),\\n        vec4(0.8126, 0.5829, 0.0, 0.5259),\\n        vec4(-0.0, -0.0, 1.0, 1.0401),\\n        vec4(0.0, 0.0, 0.0, 1.0)\\n      )\\n    )\\n  ),\\n  inverse(\\n    transpose(\\n      mat4(\\n        vec4(0.7582, 0.652, 0.0, 5.89),\\n        vec4(-0.652, 0.7582, -0.0, 2.8033),\\n        vec4(-0.0, 0.0, 1.0, 3.4401),\\n        vec4(0.0, 0.0, 0.0, 1.0)\\n      )\\n    )\\n  ),\\n  inverse(\\n    transpose(\\n      mat4(\\n        vec4(0.294, 0.9558, -0.0, 9.1408),\\n        vec4(-0.9558, 0.294, -0.0, -0.129),\\n        vec4(-0.0, 0.0, 1.0, 1.0401),\\n        vec4(0.0, 0.0, 0.0, 1.0)\\n      )\\n    )\\n  ),\\n  inverse(\\n    transpose(\\n      mat4(\\n        vec4(-0.7059, 0.7083, -0.0, 0.899),\\n        vec4(-0.7083, -0.7059, 0.0, -3.7542),\\n        vec4(0.0, 0.0, 1.0, 1.0401),\\n        vec4(0.0, 0.0, 0.0, 1.0)\\n      )\\n    )\\n  ),\\n  inverse(\\n    transpose(\\n      mat4(\\n        vec4(0.6319, 0.775, 0.0, 4.8559),\\n        vec4(-0.775, 0.6319, -0.0001, 2.6001),\\n        vec4(-0.0, 0.0, 1.0, 4.6402),\\n        vec4(0.0, 0.0, 0.0, 1.0)\\n      )\\n    )\\n  ),\\n  inverse(\\n    transpose(\\n      mat4(\\n        vec4(0.9808, 0.1952, 0.0, 4.0276),\\n        vec4(-0.1952, 0.9808, -0.0, 3.1987),\\n        vec4(-0.0, 0.0, 1.0, 2.2401),\\n        vec4(0.0, 0.0, 0.0, 1.0)\\n      )\\n    )\\n  ),\\n  inverse(\\n    transpose(\\n      mat4(\\n        vec4(0.4857, -0.2902, -0.8246, 9.5624),\\n        vec4(0.1916, 0.9557, -0.2235, 2.9451),\\n        vec4(0.8529, -0.0494, 0.5198, 5.9481),\\n        vec4(0.0, 0.0, 0.0, 1.0)\\n      )\\n    )\\n  ),\\n  inverse(\\n    transpose(\\n      mat4(\\n        vec4(0.0341, -0.3016, -0.9528, 10.418),\\n        vec4(0.0108, 0.9534, -0.3014, 3.3781),\\n        vec4(0.9994, 0.0, 0.0358, 3.0374),\\n        vec4(0.0, 0.0, 0.0, 1.0)\\n      )\\n    )\\n  ),\\n  inverse(\\n    transpose(\\n      mat4(\\n        vec4(0.9781, -0.2081, -0.0, 5.9647),\\n        vec4(0.2081, 0.9781, 0.0, 2.9215),\\n        vec4(0.0, -0.0, 1.0, 1.0401),\\n        vec4(0.0, 0.0, 0.0, 1.0)\\n      )\\n    )\\n  ),\\n  inverse(\\n    transpose(\\n      mat4(\\n        vec4(-0.0242, 0.9997, 0.0, -6.5609),\\n        vec4(-0.9997, -0.0242, -0.0, -1.5591),\\n        vec4(-0.0, -0.0, 1.0, 1.0401),\\n        vec4(0.0, 0.0, 0.0, 1.0)\\n      )\\n    )\\n  )\\n);\\n\\n// START ../common/transform.glsl\\nvec3 transform(mat4 pm, vec3 p) {\\n  vec4 pStar = pm * vec4(p, 1);\\n  return pStar.xyz / pStar.w;\\n}\\n\\nvec2 transform(mat4 pm, vec2 p) {\\n  vec4 pStar = pm * vec4(p, 0, 1);\\n  return pStar.xy / pStar.w;\\n}\\n\\n// END ../common/transform.glsl\\n// START ../common/checkerboardGrad.glsl\\n//https://iquilezles.org/articles/checkerfiltering/\\nfloat tri(float x) {\\n  float h = fract(x * 0.5) - 0.5;\\n  return 1.0 - 2.0 * abs(h);\\n}\\nvec2 tri(vec2 x) {\\n  vec2 h = fract(x * 0.5) - 0.5;\\n  return 1.0 - 2.0 * abs(h);\\n}\\n\\nfloat checkerboardGrad(vec2 uv) {\\n  vec2 w = max(abs(dFdx(uv)), abs(dFdy(uv))) + 0.01; // filter kernel\\n  vec2 i = (tri(uv + 0.5 * w) - tri(uv - 0.5 * w)) / w; // analytical integral (box filter)\\n  return 0.5 - 0.5 * i.x * i.y; // xor pattern\\n}\\n\\n// END ../common/checkerboardGrad.glsl\\n\\n#define NON_CONST_ZERO (min(int(iTime), 0))\\n\\nHit demoLego(float r, vec3 p) {\\n  float scale = 1.0;\\n  float d1 = sdLego(p * scale - vec3(0, 1, 0)) / scale;\\n  for (int i = 0; i < 5; i++) {\\n    vec3 pp = transform(positions[i], p);\\n    d1 = min(d1, sdLego(pp * scale) / scale);\\n  }\\n  d1 = min(\\n    d1,\\n    sdLego(rotX(200.0 * DEGREE) * (p * scale - vec3(0, -2, 2))) / scale\\n  );\\n  d1 = min(\\n    d1,\\n    sdLego(rotY(240.0 * DEGREE) * (p * scale - vec3(6, 4, 5))) / scale\\n  );\\n  float d2 = p.z;\\n  if (d2 < d1) {\\n    return Hit(\\n      d2,\\n      vec4(mix(WHITE, ungamma(colorSecondary), checkerboardGrad(p.xy)), 1)\\n    );\\n  } else {\\n    return Hit(d1, vec4(ungamma(colorPrimary), 1));\\n  }\\n}\\n\\nfloat sdf(vec3 p, out vec3 color) {\\n  Hit h = demoLego(1.0, p);\\n  color = h.color.xyz;\\n  return h.distance;\\n}\\nfloat sdf(vec3 p) {\\n  vec3 v;\\n  return sdf(p, v);\\n}\\nfloat ambientOcclusion(vec3 pWC, vec3 n1WC) {\\n  float k = 1.0;\\n  float distance = sdf(pWC + n1WC * k);\\n  return clamp(distance / k, 0.0, 1.0);\\n}\\n\\nstruct RMResult {\\n  float distance;\\n  vec3 pos;\\n  vec4 color;\\n};\\nRMResult raymarching2(vec3 start, vec3 dir1) {\\n  vec3 pos = start;\\n  float hit;\\n  vec3 color;\\n  for (int i = 0; i < 100; i++) {\\n    vec3 newColor;\\n    hit = sdf(pos, newColor);\\n    if (hit < 0.0001 * hit) break;\\n    pos = pos + dir1 * hit;\\n    color = newColor;\\n  }\\n  if (color == WHITE) {\\n    vec2 ff = round(fract(pos.xy * 0.5));\\n\\n    color = mix(\\n      ungamma(colorBackground),\\n      ungamma(colorSecondary),\\n      mod(ff.x + ff.y, 2.0)\\n    );\\n  }\\n  return RMResult(hit, pos, vec4(color, 1.0));\\n}\\nvec3 transform(mat4 pm, vec3 p) {\\n  vec4 pStar = pm * vec4(p, 1.0);\\n  return pStar.xyz / pStar.w;\\n}\\n\\nfloat softshadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {\\n  float res = 1.0;\\n  float t = 0.1;\\n  for (int i = 0; i < 1000 && t < maxt; i++) {\\n    float h = sdf(ro + rd * t);\\n    if (h < 0.001) return 0.0;\\n    res = min(res, k * h / t);\\n    t += h;\\n  }\\n  return res;\\n}\\n\\nconst float eps = 1e-4;\\nvec3 sdfNormal1(vec3 p, float d) {\\n  return normalize(\\n    vec3(\\n      sdf(p + vec3(eps, 0.0, 0.0)),\\n      sdf(p + vec3(0.0, eps, 0.0)),\\n      sdf(p + vec3(0.0, 0.0, eps))\\n    ) -\\n      vec3(sdf(p))\\n  );\\n}\\n\\n//layout (depth_greater) out float gl_FragDepth;\\nvoid main() {\\n  vec3 camPos =\\n    vec3(20, 0, 10) +\\n    (-1.0 == iMouse.x\\n      ? vec3(0)\\n      : vec3(0, (iMouse / iResolution * 2.0 - 1.0) * 10.0));\\n  mat4 modelView =\\n    perspective(40.0, iResolution.x / iResolution.y, 0.1, 20.0) *\\n    lookAt(camPos, vec3(0, 0, 1), vec3(0, 0, 1));\\n  mat4 modelViewInverse = inverse(modelView);\\n\\n  vec3 light = normalize(vec3(-1.0, -2.0, -2));\\n\\n  vec3 a = vec3(coord * 2.0 - 1.0, -1.0);\\n  vec3 b = vec3(coord * 2.0 - 1.0, 1.0);\\n  vec3 aWC = transform(modelViewInverse, a);\\n  vec3 bWC = transform(modelViewInverse, b);\\n  vec3 lookDir1 = normalize(bWC - aWC);\\n\\n  RMResult hitWC = raymarching2(aWC, lookDir1);\\n  vec3 hitn1 = sdfNormal1(hitWC.pos, hitWC.distance);\\n  float dWC = distance(aWC, hitWC.pos);\\n  vec3 hitNDC = transform(modelView, hitWC.pos);\\n  vec3 p = hitWC.pos;\\n  float inSun = softshadow(\\n    hitWC.pos + hitn1 * 0.05,\\n    -light,\\n    0.0001,\\n    300.0,\\n    8.0\\n  );\\n  //    float inSun=1.;\\n\\n  vec3 material = hitWC.color.xyz;\\n  if (dWC > 100.0) {\\n    material = vec3(0.0, 0.0, 0.0);\\n    //    } else if (p.z >= 0.001) {\\n    //        material = vec3(0.2, 0.0, 0.0);\\n    //    } else {\\n    //        vec2 c = vec2(4.0, 2.0);\\n    //        vec2 id = floor(((p.xy - c * 0.5) / c) );\\n    //        material += .15 * cos(vec3(id.x, id.y + 2., id.x + id.y + 4.));\\n  }\\n\\n  const vec3 sunlightColor = vec3(3.0);\\n\\n  float aOcc = ambientOcclusion(hitWC.pos, hitn1);\\n\\n  vec3 reflectionDirection = reflect(light, hitn1);\\n\\n  vec3 color = vec3(0.0);\\n  color += material * aOcc;\\n  color += inSun * sunlightColor * material * max(0.0, dot(-light, hitn1));\\n  //    color = (hitn1);\\n\\n  vec3 eyeDirection = -lookDir1;\\n  float uMaterialShininess = 256.0;\\n  float specularLightWeighting = pow(\\n    max(dot(reflectionDirection, eyeDirection), 0.0),\\n    uMaterialShininess\\n  );\\n  color += specularLightWeighting;\\n  //    float lightIntensity = 0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.);\\n  //    float lightIntensity =\\n  //        0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.) + 0.3*specularLightWeighting;\\n  //    fragColor = visualize(blue, red, mix(0.5, 1.0, inSun) * lightIntensity);\\n  //    fragColor = mix(hitWC.color, colorBackground, mix(0.5, 1.0, inSun) * clamp(lightIntensity, 0., 1.));\\n  color = pow(color, vec3(1.0 / 2.2)); // gamma correction\\n  fragColor = vec4(color, 1.0);\\n}\\n\"\nconst sourceMap = {\"version\":3,\"sources\":[\"/home/runner/work/workshop/workshop/src/sdfs/demoLego.frag\",\"/home/runner/work/workshop/workshop/src/common/colors.glsl\",\"/home/runner/work/workshop/workshop/src/common/constants.glsl\",\"/home/runner/work/workshop/workshop/src/common/matrices.glsl\",\"/home/runner/work/workshop/workshop/src/common/max3.glsl\",\"/home/runner/work/workshop/workshop/src/common/unmix.glsl\",\"/home/runner/work/workshop/workshop/src/common/fromPolar.glsl\",\"/home/runner/work/workshop/workshop/src/common/toPolar.glsl\",\"/home/runner/work/workshop/workshop/src/common/polar.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdCylinder.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdCone.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdArrow.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdBox.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdIcosahedron.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdOctahedron.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdDodecahedron.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdCapsule.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdTetrahedron.glsl\",\"/home/runner/work/workshop/workshop/src/common/ungamma.glsl\",\"/home/runner/work/workshop/workshop/src/common/squareWave.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdTube.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdLego.glsl\",\"/home/runner/work/workshop/workshop/src/common/transform.glsl\",\"/home/runner/work/workshop/workshop/src/common/checkerboardGrad.glsl\"],\"names\":[],\"mappings\":\"AAAA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC5IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;;AlBSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AmB7IA;AACA;AACA;AACA;;AnB4IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AoBxNA;AACA;AACA;AACA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ArBmKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AsBtYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AvB0XA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA\"}\nexport { sourceMap };\n","\nexport default \"#version 300 es\\n\\nprecision highp float;\\n\\n// START ../common/banded.glsl\\nfloat banded(float bandCount, float t) {\\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\\n}\\nfloat banded(int bandCount, float t) {\\n  return banded(float(bandCount), t);\\n}\\n\\n// #pragma glslify: export(banded)\\n\\n\\n// END ../common/banded.glsl\\n// START ../common/between.glsl\\nbool between(float min, float max, float value) {\\n  return min <= value && value <= max;\\n}\\n\\n// #pragma glslify: export(between)\\n\\n\\n// END ../common/between.glsl\\n// START ../common/hexFns.glsl\\n// START ./max3.glsl\\nfloat max3(float a, float b, float c) {\\n  return max(a, max(b, c));\\n}\\nfloat max3(vec3 v) {\\n  return max(v.x, max(v.y, v.z));\\n}\\n\\n// #pragma glslify: export(max3)\\n\\n\\n// END ./max3.glsl\\n// START ./constants.glsl\\nconst float SQRT1_2 = 0.7071067811865476;\\nconst float SQRT1_3 = 0.57735026919;\\nconst float SQRT2 = 1.4142135623730951;\\nconst float SQRT3 = 1.732050807568877;\\n// sqrt(3)/2 = sin(60*)\\nconst float SQRT3_2 = 0.86602540378;\\nconst float GOLDEN_RATIO = 1.61803398875;\\nconst float PI = 3.141592653589793;\\nconst float TAU = 6.28318530718;\\n/**\\n * One degree in radians. Use like `sin(30 * DEG)`.\\n */\\nconst float DEGREE = 0.017453292519943295;\\n\\n// END ./constants.glsl\\n\\nvec3 hexRound(vec3 hex) {\\n  vec3 r = floor(hex + 0.5);\\n  vec3 diff = abs(r - hex);\\n\\n  if (diff.x > diff.y && diff.x > diff.z) {\\n    r.x = -(r.y + r.z);\\n  } else if (diff.y > diff.z) {\\n    r.y = -(r.x + r.z);\\n  } else {\\n    r.z = -(r.x + r.y);\\n  }\\n\\n  return r;\\n}\\nvec2 hex2Ra(vec3 hex) {\\n  float y = hex.t * SQRT3_2;\\n  float x = hex.s + hex.t / 2.0;\\n  return vec2(x, y);\\n}\\n\\nfloat hexSdf(vec3 hex) {\\n  return max3(abs(hex.yzx + hex.zxy / 2.0));\\n}\\nvec3 ra2Hex(vec2 xy) {\\n  float hex_t = xy.y / SQRT3_2;\\n  float hex_s = xy.x - hex_t / 2.0;\\n  return vec3(hex_s, hex_t, -(hex_s + hex_t));\\n}\\n\\n// END ../common/hexFns.glsl\\n// START ../common/transform.glsl\\nvec3 transform(mat4 pm, vec3 p) {\\n  vec4 pStar = pm * vec4(p, 1);\\n  return pStar.xyz / pStar.w;\\n}\\n\\nvec2 transform(mat4 pm, vec2 p) {\\n  vec4 pStar = pm * vec4(p, 0, 1);\\n  return pStar.xy / pStar.w;\\n}\\n\\n// END ../common/transform.glsl\\n// START ../common/perlin2DTexture.glsl\\nuniform sampler2D gradients;\\n/* Create random direction vector\\n */\\nvec2 randomGradient(vec2 i) {\\n  // Random float. No precomputed gradients mean this works for any number of grid coordinates\\n  float random =\\n    2920.0 *\\n    sin(float(i.x) * 2.1942 + float(i.y) * 1.71324 + 8.912) *\\n    cos(float(i.x) * 2.3157 * float(i.y) * 2.17832 + 9.758);\\n  //    random = (i.x + 1667.) * (i.x + 2083.) * (i.y + 2659.) * (i.y * 50.77 + .3769);\\n  //    random = sin(SQRT2 * i.x) + cos(GOLDEN_RATIO * i.y) + tan((i.x + i.y) * SQRT3);\\n  return vec2(cos(random), sin(random));\\n}\\nfloat dotGridGradient(vec2 cell, vec2 pos) {\\n  vec2 d = cell - pos;\\n\\n  //  vec2 gradient = texelFetch(gradients, ivec2(cell), 0).xy;\\n  vec2 gradient = randomGradient(vec2(cell));\\n\\n  return dot(gradient, d);\\n}\\n\\nfloat mixx(float a, float b, float t) {\\n  return mix(a, b, smoothstep(0.0, 1.0, t));\\n  //    return mix(a, b, t);\\n}\\n\\n// resulting range is [-0.68, 0.68]. Use unmix to normalize if necessary.\\nfloat perlin2D(vec2 xy) {\\n  float x0 = floor(xy.x);\\n  float x1 = x0 + 1.0;\\n  float y0 = floor(xy.y);\\n  float y1 = y0 + 1.0;\\n\\n  // Interpolate between grid point gradients\\n  float n00 = dotGridGradient(vec2(x0, y0), xy);\\n  float n10 = dotGridGradient(vec2(x1, y0), xy);\\n  float ny0 = mixx(n00, n10, xy.x - x0);\\n\\n  float n01 = dotGridGradient(vec2(x0, y1), xy);\\n  float n11 = dotGridGradient(vec2(x1, y1), xy);\\n  float ny1 = mixx(n01, n11, xy.x - x0);\\n\\n  return mixx(ny0, ny1, xy.y - y0);\\n}\\n\\n// #pragma glslify: export(perlin2D)\\n\\n\\n// END ../common/perlin2DTexture.glsl\\n// START ../common/hsl2rgb.glsl\\n/**\\n * The MIT License (MIT) Copyright (c) 2015 Jam3\\n *\\n * Permission is hereby granted, free of charge, to any person obtaining a copy\\n * of this software and associated documentation files (the \\\"Software\\\"), to deal\\n * in the Software without restriction, including without limitation the rights\\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n * copies of the Software, and to permit persons to whom the Software is\\n * furnished to do so, subject to the following conditions:\\n *\\n * The above copyright notice and this permission notice shall be included in\\n * all copies or substantial portions of the Software.\\n *\\n * THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n * SOFTWARE.\\n */\\nfloat hue2rgb(float f1, float f2, float hue) {\\n  if (hue < 0.0) hue += 1.0;\\n  else if (hue > 1.0) hue -= 1.0;\\n  float res;\\n  if (6.0 * hue < 1.0) res = f1 + (f2 - f1) * 6.0 * hue;\\n  else if (2.0 * hue < 1.0) res = f2;\\n  else if (3.0 * hue < 2.0) res = f1 + (f2 - f1) * (2.0 / 3.0 - hue) * 6.0;\\n  else res = f1;\\n  return res;\\n}\\n\\nvec3 hsl2rgb(vec3 hsl) {\\n  vec3 rgb;\\n\\n  if (hsl.y == 0.0) {\\n    rgb = vec3(hsl.z); // Luminance\\n  } else {\\n    float f2;\\n\\n    if (hsl.z < 0.5) f2 = hsl.z * (1.0 + hsl.y);\\n    else f2 = hsl.z + hsl.y - hsl.y * hsl.z;\\n\\n    float f1 = 2.0 * hsl.z - f2;\\n\\n    rgb.r = hue2rgb(f1, f2, hsl.x + 1.0 / 3.0);\\n    rgb.g = hue2rgb(f1, f2, hsl.x);\\n    rgb.b = hue2rgb(f1, f2, hsl.x - 1.0 / 3.0);\\n  }\\n  return rgb;\\n}\\n\\nvec3 hsl2rgb(float h, float s, float l) {\\n  return hsl2rgb(vec3(h, s, l));\\n}\\n\\n// END ../common/hsl2rgb.glsl\\n// START ../common/polar.glsl\\n// START ../common/fromPolar.glsl\\n// START ./unmix.glsl\\nfloat unmix(float a, float b, float value) {\\n  return (value - a) / (b - a);\\n}\\n\\n// #pragma glslify: export(unmix)\\n\\n\\n// END ./unmix.glsl\\n\\nvec3 fromPolar(float radius, float phi, float z) {\\n  return vec3(radius * cos(phi), radius * sin(phi), z);\\n}\\n\\nvec2 fromPolar(float radius, float phi) {\\n  return vec2(radius * cos(phi), radius * sin(phi));\\n}\\n\\nvec2 fromPolar(vec2 polar) {\\n  return fromPolar(polar.x, polar.y);\\n}\\n\\n// #pragma glslify: export(fromPolar)\\n\\n\\n// END ../common/fromPolar.glsl\\n// START ../common/toPolar.glsl\\n\\nvec2 toPolar(vec2 xy) {\\n  return vec2(length(xy), atan(xy.y, xy.x));\\n}\\n\\nmat2 toPolarDerivate(vec2 xy) {\\n  return mat2(xy.x * xy.x, xy.y * xy.y, -xy.y, xy.x) / dot(xy, xy);\\n}\\n\\n// #pragma glslify: export(toPolar)\\n\\n\\n// END ../common/toPolar.glsl\\n\\n// END ../common/polar.glsl\\n// START ../common/remix.glsl\\n\\nfloat remix(float fromA, float fromB, float toA, float toB, float value) {\\n  return mix(toA, toB, unmix(fromA, fromB, value));\\n}\\n\\nvec4 remix(float fromA, float fromB, vec4 toA, vec4 toB, float value) {\\n  return mix(toA, toB, unmix(fromA, fromB, value));\\n}\\n\\n// #pragma glslify: export(remix)\\n\\n\\n// END ../common/remix.glsl\\n// START ../common/visualize.glsl\\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\\n  float isLow = float(t < 0.0);\\n  float isHigh = float(t > 1.0);\\n  float isMid = 1.0 - isLow - isHigh;\\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\\n}\\n\\nvec4 visualize(float t) {\\n  const vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\\n  const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\\n  return visualize(BLUE, RED, t);\\n}\\n\\n// #pragma glslify: export(visualize)\\n\\n\\n// END ../common/visualize.glsl\\n// START ../common/waves.glsl\\nfloat waves(vec4 color, vec2 position, vec2 direction, float highResTimeStamp) {\\n  return sin(\\n    dot(position, direction / pow(length(direction), 2.0)) +\\n      float(highResTimeStamp) / 200.0\\n  );\\n}\\n\\n// #pragma glslify: export(waves)\\n\\n\\n// END ../common/waves.glsl\\n// START ../common/matrices.glsl\\n\\nmat2 rot2(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat2(c, s, -s, c);\\n}\\nmat3 rotX(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\\n}\\nmat3 rotY(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\\n}\\nmat3 rotZ(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\\n}\\n/**\\n * Returns a matrix that puts the camera at the eye point `ex, ey, ez` looking\\n * toward the center point `cx, cy, cz` with an up direction of `ux, uy, uz`.\\n * This emulates the OpenGL function `gluLookAt()`.\\n */\\nmat4 lookAt(vec3 eye, vec3 focus, vec3 up) {\\n  vec3 f = normalize(eye - focus);\\n  vec3 s = normalize(cross(up, f));\\n  vec3 t = normalize(cross(f, s));\\n\\n  return mat4(\\n    vec4(s.x, t.x, f.x, 0.0),\\n    vec4(s.y, t.y, f.y, 0.0),\\n    vec4(s.z, t.z, f.z, 0.0),\\n    vec4(-dot(s, eye), -dot(t, eye), -dot(f, eye), 1)\\n  );\\n}\\n\\n// the OpenGL function `glFrustum()`.\\nmat4 frustum(\\n  float left,\\n  float right,\\n  float bottom,\\n  float top,\\n  float near,\\n  float far\\n) {\\n  return mat4(\\n    vec4(2.0 * near / (right - left), 0.0, 0.0, 0.0),\\n    vec4(0, 2.0 * near / (top - bottom), 0.0, 0.0),\\n    vec4(\\n      (right + left) / (right - left),\\n      (top + bottom) / (top - bottom),\\n      -(far + near) / (far - near),\\n      -1\\n    ),\\n    vec4(0.0, 0.0, -2.0 * far * near / (far - near), 0.0)\\n  );\\n}\\n\\nmat4 perspective(float fovDegrees, float aspect, float near, float far) {\\n  float y = tan(fovDegrees * DEGREE / 2.0) * near;\\n  float x = y * aspect;\\n  return frustum(-x, x, -y, y, near, far);\\n}\\nmat4 ortho(\\n  float left,\\n  float right,\\n  float bottom,\\n  float top,\\n  float near,\\n  float far\\n) {\\n  return mat4(\\n    vec4(2.0 / (right - left), 0.0, 0.0, 0.0),\\n    vec4(0.0, 2.0 / (top - bottom), 0.0, 0.0),\\n    vec4(0.0, 0.0, -2.0 / (far - near), 0.0),\\n    vec4(\\n      -(right + left) / (right - left),\\n      -(top + bottom) / (top - bottom),\\n      -(far + near) / (far - near),\\n      1.0\\n    )\\n  );\\n}\\n\\n// END ../common/matrices.glsl\\n\\n// START ../common/sdf3d/sdTorus.glsl\\nfloat sdTorus(float r0, float r1, vec3 p) {\\n  vec3 closestCenter = vec3(normalize(p.xy) * r0, 0.0);\\n  return distance(closestCenter, p) - r1;\\n}\\n\\n// #pragma glslify: export(sdTorus)\\n\\n\\n// END ../common/sdf3d/sdTorus.glsl\\n// START ../common/sdf3d/sdSphere.glsl\\nfloat sdSphere(float radius, vec3 p) {\\n  return length(p) - radius;\\n}\\n\\n// #pragma glslify: export(sdSphere)\\n\\n\\n// END ../common/sdf3d/sdSphere.glsl\\n// START ../common/sdf3d/sdCylinder.glsl\\nfloat sdCylinder(float radius, float z, vec3 p) {\\n  vec2 d = vec2(length(p.xy), abs(p.z)) - vec2(radius, z);\\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\\n}\\n\\n// #pragma glslify: export(sdCylinder)\\n\\n\\n// END ../common/sdf3d/sdCylinder.glsl\\n// START ../common/sdf2d/addChamfer.glsl\\n\\nfloat addChamfer(float d, float a, float b) {\\n  // exact variant, but abs is larger when a and b aren't perpendicular\\n  // which is worse than underestimating, which is what the simple version does.\\n  //  vec2 p = vec2(a, b);\\n  //  if (p.x < d && p.y < d) {\\n  //    p = rot2(0.25 * PI) * p;\\n  //    p.y = abs(p.y);\\n  //    p.y -= min(p.y, d * SQRT1_2);\\n  //    p.x -= d * SQRT1_2;\\n  //    //    p -= vec2(SQRT1_2) * clamp(dot(p, vec2(SQRT1_2)), 0.0, d);\\n  //    float fillet = -length(p);\\n  //    return -sign(p.x) * fillet;\\n  //  } else {\\n  //  }\\n  float tillet = (a + b - d) * SQRT1_2;\\n  return min(tillet, min(a, b));\\n}\\n\\n// #pragma glslify: export(addChamfer)\\n\\n\\n// END ../common/sdf2d/addChamfer.glsl\\n// START ../common/sdf2d/addFillet.glsl\\nfloat addFillet(float r, float a, float b) {\\n  if (a < r && b < r) {\\n    return r - distance(vec2(a, b), vec2(r));\\n  } else {\\n    return min(a, b);\\n  }\\n}\\n\\n// #pragma glslify: export(addFillet)\\n\\n\\n// END ../common/sdf2d/addFillet.glsl\\n// START ../common/sdf3d/sdBox.glsl\\n\\nfloat sdBox(vec3 r, vec3 p) {\\n  vec3 q = abs(p) - r;\\n  return length(max(q, 0.0)) + min(max3(q), 0.0);\\n}\\n\\nfloat sdBox(vec3 r, float r2, vec3 p) {\\n  return sdBox(r - r2, p) - r2;\\n}\\n\\n// #pragma glslify: export(sdBox)\\n\\n\\n// END ../common/sdf3d/sdBox.glsl\\n// START ../common/sdf3d/add.glsl\\nfloat add(float a, float b) {\\n  return min(a, b);\\n}\\n\\n// #pragma glslify: export(add)\\n\\n\\n// END ../common/sdf3d/add.glsl\\n// START ../common/sdf3d/sub.glsl\\nfloat sub(float from, float what) {\\n  return max(from, -what);\\n}\\n\\n// #pragma glslify: export(sub)\\n\\n\\n// END ../common/sdf3d/sub.glsl\\n\\nuniform sampler2D texture;\\nuniform float iTime;\\nuniform vec2 iMouse;\\nuniform vec2 iResolution;\\nuniform vec4 colorPrimary;\\nuniform vec4 colorSecondary;\\nuniform vec4 colorBackground;\\nuniform float a;\\nuniform float b;\\nuniform float c;\\nuniform float d;\\nuniform int bandCount;\\nuniform vec3 campos;\\nin float n;\\nin vec2 coord;\\nout vec4 fragColor;\\n\\n\\nconst vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\\nconst vec4 yellow = vec4(1.0, 1.0, 0.0, 1.0);\\nconst vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\\nconst vec4 blue = vec4(0.0, 0.0, 1.0, 1.0);\\nconst vec4 purple = vec4(0.5, 0.0, 0.5, 1.0);\\nconst vec4 red = vec4(1.0, 0.0, 0.0, 1.0);\\n\\nstruct RMHit {\\n  float distance;\\n  vec4 color;\\n};\\nRMHit mixa(RMHit a, RMHit b, float t) {\\n  return RMHit(mix(a.distance, b.distance, t), mix(a.color, b.color, t));\\n}\\nfloat skybox(vec3 p) {\\n  return 32.0 - max3(abs(p));\\n}\\n\\nfloat perlinSphere(float radius, vec3 p) {\\n  vec3 cp = normalize(p);\\n  float alpha = atan(cp.y, cp.x);\\n  float beta = asin(cp.z);\\n  return length(p) -\\n  radius +\\n  0.1 *\\n    perlin2D(vec2(0.0 / 100.0, 0.0) + (vec2(5.0) + vec2(alpha, beta)) * 8.0);\\n}\\n\\nfloat cylCircle(vec3 p) {\\n  float d = 10e9;\\n  for (int i = 0; i < 10; i++) {\\n    d = min(\\n      d,\\n      sdCylinder(0.2, 2.0, p + fromPolar(3.0, TAU * float(i) / 10.0, 1.0))\\n    );\\n  }\\n\\n  return d;\\n}\\n\\nfloat rblock(float r, vec3 p) {\\n  return sdBox(vec3(r), p);\\n}\\n\\nRMHit add(RMHit a, RMHit b) {\\n  //    return a.distance < b.distance\\n  //        ? RMHit(a.distance, a.color)\\n  //        : RMHit(b.distance, b.color);\\n  return mixa(a, b, float(b.distance < a.distance));\\n}\\n\\nfloat wtf(vec3 p) {\\n  vec3 center = p - mod(p, 3.0) + vec3(1.5);\\n  return rblock(0.4 + 0.3 * sin(iTime + center.x), p - center);\\n}\\n\\nRMHit addFillet(float r, RMHit a, RMHit b) {\\n  if (a.distance < r && b.distance < r) {\\n    return RMHit(\\n      r - distance(vec2(a.distance, b.distance), vec2(r)),\\n      mix(a.color, b.color, (a.distance - b.distance) / r * 0.5 + 0.5)\\n    );\\n  } else {\\n    return add(a, b);\\n  }\\n}\\n\\nRMHit addFillet(float r, RMHit a, RMHit b, vec4 tilletColor) {\\n  if (a.distance < r && b.distance < r) {\\n    return RMHit(\\n      r - distance(vec2(a.distance, b.distance), vec2(r)),\\n      tilletColor\\n    );\\n  } else {\\n    return add(a, b);\\n  }\\n}\\nRMHit addFillet2(float r, RMHit a, RMHit b) {\\n  float h = smoothstep(-r, r, a.distance - b.distance);\\n  return RMHit(\\n    mix(a.distance, b.distance, h) - r * h * (1.0 - h),\\n    mix(a.color, b.color, h)\\n  );\\n}\\n\\nRMHit neg(RMHit a) {\\n  return RMHit(-a.distance, a.color);\\n}\\nRMHit sub(RMHit from, RMHit what) {\\n  RMHit whatNeg = neg(what);\\n  return mixa(from, whatNeg, float(whatNeg.distance > from.distance));\\n}\\n\\nvec3 modv(vec3 v, vec3 dir1, float y) {\\n  float t = dot(v, dir1);\\n  return v - floor(t / y) * y * dir1;\\n}\\nvec3 modRotZ(vec3 p, float count) {\\n  vec2 polarXY = toPolar(p.xy);\\n  return fromPolar(polarXY.x, mod(polarXY.y, TAU / count), p.z);\\n}\\n\\nRMHit sdf(vec3 p) {\\n  RMHit r = RMHit(skybox(p), colorBackground);\\n  r = add(r, RMHit(sdBox(vec3(6.0, 6.0, 1.0), p), colorSecondary));\\n  vec3 rotp = rotZ(0.1) * p;\\n  vec3 floorTiles = vec3(mod(rotp.xy, 0.1), rotp.z);\\n  float ftd = sdBox(\\n    vec3(0.045),\\n    rotY(d) * floorTiles - vec3(0.05, 0.05, -0.04)\\n  );\\n  float ftdl = max(ftd, sdBox(vec3(6), p));\\n  //    r = addFillet2(.01, r, RMHit(ftdl, colorSecondary));\\n  float dSphere = sdSphere(7.0, p);\\n  if (dSphere < 0.0) {\\n    RMHit m = RMHit(100000.0, black);\\n    for (int i = 0; i < 50; i++) {\\n      //            m = (addFillet(a, (m),\\n      m = addFillet2(\\n        a,\\n        m,\\n        //            m = (add((m),\\n        RMHit(\\n          sdTorus(\\n            0.5 + float(i) * 0.1,\\n            0.05,\\n            rotX(2.0 + sin(iTime * 0.01) * 0.2) * rotZ(float(i) * 0.2) * p\\n          ),\\n          vec4(hsl2rgb(float(i) / 50.0, 0.99, 0.25), 1.0)\\n        )\\n      );\\n    }\\n    //        float b = sdBox(vec3(-5.,-5.,0.),vec3(5., 5., .2), p);\\n    //        m = neg(add(neg(m),neg(RMHit(b, black))));\\n    //    r = sub(r, RMHit(m.distance - 0.2, colorSecondary));\\n    r = addFillet(0.3, r, m);\\n  } else {\\n    r = add(r, RMHit(dSphere + 1.0, black));\\n  }\\n  r = neg(addFillet(0.3, neg(r), RMHit(sdSphere(c, p - extra), black)));\\n  //    vec3 rotSyma = modRotZ(p, 7.);\\n  //    vec3 rotSym = rotZ(b) *rotY(c) * (vec3(1., sin(rotSyma.x)*d, 1.) + rotSyma);\\n  //    vec3 tiled = vec3(mod(rotSym.x, 10. *a), rotSym.yz);\\n  //    float q = sdSphere(1., tiled - vec3(5.*a, 0., 0.));\\n  //    r = add(r, RMHit(q, blue));\\n  //    for (int i = 0; i < 300; i++) {\\n  //        float f = unmix(0., 300., float(i));\\n  //        vec3 spherepos = fromPolar(mix(-6., 6., f), abs(mix(-10., 10., f)) + PI / 2., 0.);\\n  r = add(r, RMHit(sdSphere(0.1, p - campos), black));\\n  //    }\\n  //    r = (addFillet(0.1, (r), RMHit(sdTorus(1.5, 0.5, rotX(iTime*6.) * p), colorSecondary)));\\n  //    r = (addFillet(0.1, (r), RMHit(sdTorus(3.9, 0.5, rotY(iTime*3.) * p), blue)));\\n  //    r = neg(addFillet(.2, neg(r), RMHit(sdBox(vec3(-1., -1., -2.), vec3(1., 1., 2.), p), red)));\\n  //    r = add(r, wtf(p));\\n  //    r = add(r, RMHit(perlinSphere(1., p - vec3(-2.0, 0.0, 3.0)), purple));\\n  //    r = add(r, cylCircle(p));\\n\\n  //    r = add(r, sdSphere(p - vec3(3., 3., 0.)));\\n  //    r = sub(r, RMHit(\\n  //        cylinder(1.3, 4.5, rotX(iTime/30. * TAU) * p- vec3(2.0, 0.0, 0.0) - vec3(0., 0., -2.25)),\\n  //        blue));\\n  //    r = add(r, cylinder(0.8, 4., rotX(iTime/30. * TAU) * p- vec3(2.0, 0.0, 0.0) - vec3(0., 0., -2.)));\\n  //    r = sub(r, cylCircle(p));\\n  return r;\\n}\\nfloat sdff(vec3 p) {\\n  return sdf(p).distance;\\n}\\n\\nstruct RMResult {\\n  float distance;\\n  vec3 pos;\\n  vec4 color;\\n};\\nRMResult raymarching2(vec3 start, vec3 dir1) {\\n  vec3 pos = start;\\n  RMHit hit;\\n  for (int i = 0; i < 200; i++) {\\n    hit = sdf(pos);\\n    if (hit.distance < 0.0) break;\\n    pos = pos + dir1 * hit.distance;\\n  }\\n  return RMResult(hit.distance, pos, hit.color);\\n}\\n\\nfloat softshadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {\\n  float res = 1.0;\\n  float t = 0.1;\\n  for (int i = 0; i < 1000 && t < maxt; i++) {\\n    float h = sdff(ro + rd * t);\\n    if (h < 0.001) return 0.0;\\n    res = min(res, k * h / t);\\n    t += h;\\n  }\\n  return res;\\n}\\n\\nconst float eps = 1e-5;\\nvec3 sdfNormal1(vec3 p, float d) {\\n  return normalize(\\n    vec3(\\n      sdff(p + vec3(eps, 0.0, 0.0)),\\n      sdff(p + vec3(0.0, eps, 0.0)),\\n      sdff(p + vec3(0.0, 0.0, eps))\\n    ) -\\n      vec3(d)\\n  );\\n}\\n//layout (depth_greater) out float gl_FragDepth;\\nvoid main() {\\n  vec3 camPos =\\n    vec3(20, 0, 10) +\\n    (-1.0 == iMouse.x\\n      ? vec3(0)\\n      : vec3(0, (iMouse / iResolution * 2.0 - 1.0) * 10.0));\\n  mat4 modelView =\\n    perspective(40.0, iResolution.x / iResolution.y, 0.1, 20.0) *\\n    lookAt(camPos, vec3(0, 0, 1), vec3(0, 0, 1));\\n  mat4 modelViewInverse = inverse(modelView);\\n\\n  vec3 light = normalize(vec3(-1.0, -2.0, -2));\\n\\n  vec3 a = vec3(coord * 2.0 - 1.0, -1.0);\\n  vec3 b = vec3(coord * 2.0 - 1.0, 1.0);\\n  vec3 aWC = transform(modelViewInverse, a);\\n  vec3 bWC = transform(modelViewInverse, b);\\n  vec3 lookDir1 = normalize(bWC - aWC);\\n  //  vec3 light = normalize(vec3(-1.0, -2.0, -2));\\n  //\\n  //  vec3 a = vec3(coord, -1.0);\\n  //  vec3 b = vec3(coord, 1.0);\\n  //  vec3 aWC = transform(llli, a);\\n  //  vec3 bWC = transform(llli, b);\\n  //  vec3 lookDir1 = normalize(bWC - aWC);\\n\\n  RMResult hitWC = raymarching2(aWC, lookDir1);\\n  vec3 hitn1 = sdfNormal1(hitWC.pos, hitWC.distance);\\n  float dWC = distance(aWC, hitWC.pos);\\n  //  vec3 hitNDC = transform(lll, hitWC.pos);\\n\\n  //    vec3 sunPoint = raymarching2(hitWC.pos +hitn1 *.1, -light).pos;\\n  //    float inSun = float(distance(hitWC.pos, sunPoint) > 30.);\\n  float inSun = softshadow(hitWC.pos + hitn1 * 0.1, -light, 0.1, 30.0, 64.0);\\n  //    float inSun=1.;\\n\\n  vec3 reflectionDirection = reflect(light, hitn1);\\n  vec3 eyeDirection = -lookDir1;\\n  float uMaterialShininess = 256.0;\\n  float specularLightWeighting = pow(\\n    max(dot(reflectionDirection, eyeDirection), 0.0),\\n    uMaterialShininess\\n  );\\n  //    float lightIntensity = 0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.);\\n  float lightIntensity =\\n    0.2 +\\n    0.5 * clamp(-dot(light, hitn1), 0.0, 1.0) +\\n    0.3 * specularLightWeighting;\\n  //    fragColor = visualize(blue, red, mix(0.5, 1.0, inSun) * lightIntensity);\\n  fragColor = mix(\\n    hitWC.color,\\n    colorBackground,\\n    mix(0.5, 1.0, inSun) * clamp(lightIntensity, 0.0, 1.0)\\n  );\\n  fragColor /= 4.0;\\n  fragColor.a = 1.0;\\n  //    fragColor = visualize(hitWC.pos.x/10.);\\n  //    fragColor = hitWC.color;\\n  //    fragColor = visualize(blue, red, distance(hitWC, sunPoint)/20.);\\n  //    fragColor = vec4(coord,0.,1.);\\n  //    fragColor = vec4(aWC, 1.0);\\n  // remap [-1, 1] to [0, 1]\\n  // gl_FragDepth = hitNDC.z * 0.5 + 0.5;\\n  //    gl_FragDepth = .9999999;\\n}\\n\"\nconst sourceMap = {\"version\":3,\"sources\":[\"/home/runner/work/workshop/workshop/src/sdfs/demoTemple.frag\",\"/home/runner/work/workshop/workshop/src/common/banded.glsl\",\"/home/runner/work/workshop/workshop/src/common/between.glsl\",\"/home/runner/work/workshop/workshop/src/common/max3.glsl\",\"/home/runner/work/workshop/workshop/src/common/constants.glsl\",\"/home/runner/work/workshop/workshop/src/common/hexFns.glsl\",\"/home/runner/work/workshop/workshop/src/common/transform.glsl\",\"/home/runner/work/workshop/workshop/src/common/perlin2DTexture.glsl\",\"/home/runner/work/workshop/workshop/src/common/hsl2rgb.glsl\",\"/home/runner/work/workshop/workshop/src/common/unmix.glsl\",\"/home/runner/work/workshop/workshop/src/common/fromPolar.glsl\",\"/home/runner/work/workshop/workshop/src/common/toPolar.glsl\",\"/home/runner/work/workshop/workshop/src/common/polar.glsl\",\"/home/runner/work/workshop/workshop/src/common/remix.glsl\",\"/home/runner/work/workshop/workshop/src/common/visualize.glsl\",\"/home/runner/work/workshop/workshop/src/common/waves.glsl\",\"/home/runner/work/workshop/workshop/src/common/matrices.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdTorus.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdSphere.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdCylinder.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf2d/addChamfer.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf2d/addFillet.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdBox.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/add.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sub.glsl\"],\"names\":[],\"mappings\":\"AAAA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AhBtEA;;AiBjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;;AxBoBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA\"}\nexport { sourceMap };\n","\nexport default \"#version 300 es\\n\\nprecision highp float;\\n\\n// START ../common/sdf2d/sdSegment.glsl\\nfloat sdSegment(vec2 a, vec2 b, vec2 p) {\\n  vec2 ab = b - a;\\n  float t = dot(ab, p - a) / dot(ab, ab);\\n  t = clamp(t, 0.0, 1.0);\\n  vec2 closest = a + ab * t;\\n\\n  return distance(closest, p);\\n}\\n\\n// #pragma glslify: export(sdSegment)\\n\\n\\n// END ../common/sdf2d/sdSegment.glsl\\n// START ../common/unmix.glsl\\nfloat unmix(float a, float b, float value) {\\n  return (value - a) / (b - a);\\n}\\n\\n// #pragma glslify: export(unmix)\\n\\n\\n// END ../common/unmix.glsl\\n// START ../common/banded.glsl\\nfloat banded(float bandCount, float t) {\\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\\n}\\nfloat banded(int bandCount, float t) {\\n  return banded(float(bandCount), t);\\n}\\n\\n// #pragma glslify: export(banded)\\n\\n\\n// END ../common/banded.glsl\\n// START ../common/between.glsl\\nbool between(float min, float max, float value) {\\n  return min <= value && value <= max;\\n}\\n\\n// #pragma glslify: export(between)\\n\\n\\n// END ../common/between.glsl\\n// START ../common/hexFns.glsl\\n// START ./max3.glsl\\nfloat max3(float a, float b, float c) {\\n  return max(a, max(b, c));\\n}\\nfloat max3(vec3 v) {\\n  return max(v.x, max(v.y, v.z));\\n}\\n\\n// #pragma glslify: export(max3)\\n\\n\\n// END ./max3.glsl\\n// START ./constants.glsl\\nconst float SQRT1_2 = 0.7071067811865476;\\nconst float SQRT1_3 = 0.57735026919;\\nconst float SQRT2 = 1.4142135623730951;\\nconst float SQRT3 = 1.732050807568877;\\n// sqrt(3)/2 = sin(60*)\\nconst float SQRT3_2 = 0.86602540378;\\nconst float GOLDEN_RATIO = 1.61803398875;\\nconst float PI = 3.141592653589793;\\nconst float TAU = 6.28318530718;\\n/**\\n * One degree in radians. Use like `sin(30 * DEG)`.\\n */\\nconst float DEGREE = 0.017453292519943295;\\n\\n// END ./constants.glsl\\n\\nvec3 hexRound(vec3 hex) {\\n  vec3 r = floor(hex + 0.5);\\n  vec3 diff = abs(r - hex);\\n\\n  if (diff.x > diff.y && diff.x > diff.z) {\\n    r.x = -(r.y + r.z);\\n  } else if (diff.y > diff.z) {\\n    r.y = -(r.x + r.z);\\n  } else {\\n    r.z = -(r.x + r.y);\\n  }\\n\\n  return r;\\n}\\nvec2 hex2Ra(vec3 hex) {\\n  float y = hex.t * SQRT3_2;\\n  float x = hex.s + hex.t / 2.0;\\n  return vec2(x, y);\\n}\\n\\nfloat hexSdf(vec3 hex) {\\n  return max3(abs(hex.yzx + hex.zxy / 2.0));\\n}\\nvec3 ra2Hex(vec2 xy) {\\n  float hex_t = xy.y / SQRT3_2;\\n  float hex_s = xy.x - hex_t / 2.0;\\n  return vec3(hex_s, hex_t, -(hex_s + hex_t));\\n}\\n\\n// END ../common/hexFns.glsl\\n// START ../common/perlin2DTexture.glsl\\nuniform sampler2D gradients;\\n/* Create random direction vector\\n */\\nvec2 randomGradient(vec2 i) {\\n  // Random float. No precomputed gradients mean this works for any number of grid coordinates\\n  float random =\\n    2920.0 *\\n    sin(float(i.x) * 2.1942 + float(i.y) * 1.71324 + 8.912) *\\n    cos(float(i.x) * 2.3157 * float(i.y) * 2.17832 + 9.758);\\n  //    random = (i.x + 1667.) * (i.x + 2083.) * (i.y + 2659.) * (i.y * 50.77 + .3769);\\n  //    random = sin(SQRT2 * i.x) + cos(GOLDEN_RATIO * i.y) + tan((i.x + i.y) * SQRT3);\\n  return vec2(cos(random), sin(random));\\n}\\nfloat dotGridGradient(vec2 cell, vec2 pos) {\\n  vec2 d = cell - pos;\\n\\n  //  vec2 gradient = texelFetch(gradients, ivec2(cell), 0).xy;\\n  vec2 gradient = randomGradient(vec2(cell));\\n\\n  return dot(gradient, d);\\n}\\n\\nfloat mixx(float a, float b, float t) {\\n  return mix(a, b, smoothstep(0.0, 1.0, t));\\n  //    return mix(a, b, t);\\n}\\n\\n// resulting range is [-0.68, 0.68]. Use unmix to normalize if necessary.\\nfloat perlin2D(vec2 xy) {\\n  float x0 = floor(xy.x);\\n  float x1 = x0 + 1.0;\\n  float y0 = floor(xy.y);\\n  float y1 = y0 + 1.0;\\n\\n  // Interpolate between grid point gradients\\n  float n00 = dotGridGradient(vec2(x0, y0), xy);\\n  float n10 = dotGridGradient(vec2(x1, y0), xy);\\n  float ny0 = mixx(n00, n10, xy.x - x0);\\n\\n  float n01 = dotGridGradient(vec2(x0, y1), xy);\\n  float n11 = dotGridGradient(vec2(x1, y1), xy);\\n  float ny1 = mixx(n01, n11, xy.x - x0);\\n\\n  return mixx(ny0, ny1, xy.y - y0);\\n}\\n\\n// #pragma glslify: export(perlin2D)\\n\\n\\n// END ../common/perlin2DTexture.glsl\\n// START ../common/polar.glsl\\n// START ../common/fromPolar.glsl\\n\\nvec3 fromPolar(float radius, float phi, float z) {\\n  return vec3(radius * cos(phi), radius * sin(phi), z);\\n}\\n\\nvec2 fromPolar(float radius, float phi) {\\n  return vec2(radius * cos(phi), radius * sin(phi));\\n}\\n\\nvec2 fromPolar(vec2 polar) {\\n  return fromPolar(polar.x, polar.y);\\n}\\n\\n// #pragma glslify: export(fromPolar)\\n\\n\\n// END ../common/fromPolar.glsl\\n// START ../common/toPolar.glsl\\n\\nvec2 toPolar(vec2 xy) {\\n  return vec2(length(xy), atan(xy.y, xy.x));\\n}\\n\\nmat2 toPolarDerivate(vec2 xy) {\\n  return mat2(xy.x * xy.x, xy.y * xy.y, -xy.y, xy.x) / dot(xy, xy);\\n}\\n\\n// #pragma glslify: export(toPolar)\\n\\n\\n// END ../common/toPolar.glsl\\n\\n// END ../common/polar.glsl\\n// START ../common/remix.glsl\\n\\nfloat remix(float fromA, float fromB, float toA, float toB, float value) {\\n  return mix(toA, toB, unmix(fromA, fromB, value));\\n}\\n\\nvec4 remix(float fromA, float fromB, vec4 toA, vec4 toB, float value) {\\n  return mix(toA, toB, unmix(fromA, fromB, value));\\n}\\n\\n// #pragma glslify: export(remix)\\n\\n\\n// END ../common/remix.glsl\\n// START ../common/visualize.glsl\\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\\n  float isLow = float(t < 0.0);\\n  float isHigh = float(t > 1.0);\\n  float isMid = 1.0 - isLow - isHigh;\\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\\n}\\n\\nvec4 visualize(float t) {\\n  const vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\\n  const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\\n  return visualize(BLUE, RED, t);\\n}\\n\\n// #pragma glslify: export(visualize)\\n\\n\\n// END ../common/visualize.glsl\\n// START ../common/waves.glsl\\nfloat waves(vec4 color, vec2 position, vec2 direction, float highResTimeStamp) {\\n  return sin(\\n    dot(position, direction / pow(length(direction), 2.0)) +\\n      float(highResTimeStamp) / 200.0\\n  );\\n}\\n\\n// #pragma glslify: export(waves)\\n\\n\\n// END ../common/waves.glsl\\n// START ../common/matrices.glsl\\n\\nmat2 rot2(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat2(c, s, -s, c);\\n}\\nmat3 rotX(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\\n}\\nmat3 rotY(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\\n}\\nmat3 rotZ(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\\n}\\n/**\\n * Returns a matrix that puts the camera at the eye point `ex, ey, ez` looking\\n * toward the center point `cx, cy, cz` with an up direction of `ux, uy, uz`.\\n * This emulates the OpenGL function `gluLookAt()`.\\n */\\nmat4 lookAt(vec3 eye, vec3 focus, vec3 up) {\\n  vec3 f = normalize(eye - focus);\\n  vec3 s = normalize(cross(up, f));\\n  vec3 t = normalize(cross(f, s));\\n\\n  return mat4(\\n    vec4(s.x, t.x, f.x, 0.0),\\n    vec4(s.y, t.y, f.y, 0.0),\\n    vec4(s.z, t.z, f.z, 0.0),\\n    vec4(-dot(s, eye), -dot(t, eye), -dot(f, eye), 1)\\n  );\\n}\\n\\n// the OpenGL function `glFrustum()`.\\nmat4 frustum(\\n  float left,\\n  float right,\\n  float bottom,\\n  float top,\\n  float near,\\n  float far\\n) {\\n  return mat4(\\n    vec4(2.0 * near / (right - left), 0.0, 0.0, 0.0),\\n    vec4(0, 2.0 * near / (top - bottom), 0.0, 0.0),\\n    vec4(\\n      (right + left) / (right - left),\\n      (top + bottom) / (top - bottom),\\n      -(far + near) / (far - near),\\n      -1\\n    ),\\n    vec4(0.0, 0.0, -2.0 * far * near / (far - near), 0.0)\\n  );\\n}\\n\\nmat4 perspective(float fovDegrees, float aspect, float near, float far) {\\n  float y = tan(fovDegrees * DEGREE / 2.0) * near;\\n  float x = y * aspect;\\n  return frustum(-x, x, -y, y, near, far);\\n}\\nmat4 ortho(\\n  float left,\\n  float right,\\n  float bottom,\\n  float top,\\n  float near,\\n  float far\\n) {\\n  return mat4(\\n    vec4(2.0 / (right - left), 0.0, 0.0, 0.0),\\n    vec4(0.0, 2.0 / (top - bottom), 0.0, 0.0),\\n    vec4(0.0, 0.0, -2.0 / (far - near), 0.0),\\n    vec4(\\n      -(right + left) / (right - left),\\n      -(top + bottom) / (top - bottom),\\n      -(far + near) / (far - near),\\n      1.0\\n    )\\n  );\\n}\\n\\n// END ../common/matrices.glsl\\n\\n// START ../common/sdf3d/sdTorus.glsl\\nfloat sdTorus(float r0, float r1, vec3 p) {\\n  vec3 closestCenter = vec3(normalize(p.xy) * r0, 0.0);\\n  return distance(closestCenter, p) - r1;\\n}\\n\\n// #pragma glslify: export(sdTorus)\\n\\n\\n// END ../common/sdf3d/sdTorus.glsl\\n// START ../common/sdf3d/sdCapsule.glsl\\nfloat sdCapsule(vec3 a, vec3 b, float r, vec3 p) {\\n  vec3 pa = p - a;\\n  vec3 ba = b - a;\\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\\n  return length(pa - ba * h) - r;\\n}\\n// #pragma glslify: export(sdCapsule)\\n\\n// END ../common/sdf3d/sdCapsule.glsl\\n// START ../common/sdf3d/opElongate.glsl\\nvec3 opElongate(vec3 h, vec3 p) {\\n  return p - clamp(p, -h, h);\\n}\\n// #pragma glslify: export(opElongate)\\n\\n// END ../common/sdf3d/opElongate.glsl\\n// START ../common/sdf3d/sdSphere.glsl\\nfloat sdSphere(float radius, vec3 p) {\\n  return length(p) - radius;\\n}\\n\\n// #pragma glslify: export(sdSphere)\\n\\n\\n// END ../common/sdf3d/sdSphere.glsl\\n// START ../common/sdf3d/sdCylinder.glsl\\nfloat sdCylinder(float radius, float z, vec3 p) {\\n  vec2 d = vec2(length(p.xy), abs(p.z)) - vec2(radius, z);\\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\\n}\\n\\n// #pragma glslify: export(sdCylinder)\\n\\n\\n// END ../common/sdf3d/sdCylinder.glsl\\n// START ../common/sdf2d/addChamfer.glsl\\n\\nfloat addChamfer(float d, float a, float b) {\\n  // exact variant, but abs is larger when a and b aren't perpendicular\\n  // which is worse than underestimating, which is what the simple version does.\\n  //  vec2 p = vec2(a, b);\\n  //  if (p.x < d && p.y < d) {\\n  //    p = rot2(0.25 * PI) * p;\\n  //    p.y = abs(p.y);\\n  //    p.y -= min(p.y, d * SQRT1_2);\\n  //    p.x -= d * SQRT1_2;\\n  //    //    p -= vec2(SQRT1_2) * clamp(dot(p, vec2(SQRT1_2)), 0.0, d);\\n  //    float fillet = -length(p);\\n  //    return -sign(p.x) * fillet;\\n  //  } else {\\n  //  }\\n  float tillet = (a + b - d) * SQRT1_2;\\n  return min(tillet, min(a, b));\\n}\\n\\n// #pragma glslify: export(addChamfer)\\n\\n\\n// END ../common/sdf2d/addChamfer.glsl\\n// START ../common/sdf2d/addFillet.glsl\\nfloat addFillet(float r, float a, float b) {\\n  if (a < r && b < r) {\\n    return r - distance(vec2(a, b), vec2(r));\\n  } else {\\n    return min(a, b);\\n  }\\n}\\n\\n// #pragma glslify: export(addFillet)\\n\\n\\n// END ../common/sdf2d/addFillet.glsl\\n// START ../common/sdf3d/sdBox.glsl\\n\\nfloat sdBox(vec3 r, vec3 p) {\\n  vec3 q = abs(p) - r;\\n  return length(max(q, 0.0)) + min(max3(q), 0.0);\\n}\\n\\nfloat sdBox(vec3 r, float r2, vec3 p) {\\n  return sdBox(r - r2, p) - r2;\\n}\\n\\n// #pragma glslify: export(sdBox)\\n\\n\\n// END ../common/sdf3d/sdBox.glsl\\n// START ../common/sdf3d/sdOctahedron.glsl\\nfloat sdOctahedron(float s, vec3 p) {\\n  p = abs(p);\\n  float m = p.x + p.y + p.z - s;\\n  vec3 q;\\n  if (3.0 * p.x < m) q = p.xyz;\\n  else if (3.0 * p.y < m) q = p.yzx;\\n  else if (3.0 * p.z < m) q = p.zxy;\\n  else return m * 0.57735027;\\n\\n  float k = clamp(0.5 * (q.z - q.y + s), 0.0, s);\\n  return length(vec3(q.x, q.y - s + k, q.z - k));\\n}\\n// #pragma glslify: export(sdOctahedron)\\n\\nfloat sdOctahedron(vec3 p, float s) {\\n  p = abs(p);\\n\\n  float m = p.x + p.y + p.z - s;\\n  //find point on octohedron surf nearest to p\\n  vec3 projPoint = p - vec3(0.333333 * m); //project onto surface plane\\n  //now push projected point, if outside triangle edge, perpendicular to edge, to edge\\n  vec3 toMove = min(projPoint, 0.0); //if projpoint.x<0 move along (1.0,-0.5,-0.5) , etc\\n  float toMoveSum = dot(toMove, vec3(1.0)); //which is basically along (1.5,0,0) then vec3(-0.5)\\n\\n  vec3 movedPoint = projPoint + toMove * vec3(-1.5) + toMoveSum * vec3(0.5); //better to multiply toMove by a matrix (1s diagonal, 0.5 other)?\\n\\n  movedPoint = max(movedPoint, 0.0); //cap x,y,z to 0 then\\n  movedPoint *= s / dot(movedPoint, vec3(1.0)); //scale about 0,0,0\\n\\n  return length(p - movedPoint);\\n}\\n\\n// END ../common/sdf3d/sdOctahedron.glsl\\n// START ../common/sdf3d/add.glsl\\nfloat add(float a, float b) {\\n  return min(a, b);\\n}\\n\\n// #pragma glslify: export(add)\\n\\n\\n// END ../common/sdf3d/add.glsl\\n// START ../common/sdf3d/sub.glsl\\nfloat sub(float from, float what) {\\n  return max(from, -what);\\n}\\n\\n// #pragma glslify: export(sub)\\n\\n\\n// END ../common/sdf3d/sub.glsl\\n\\n// START ../common/complex.glsl\\n\\nvec2 complexConj(vec2 z) {\\n  return vec2(z.x, -z.y);\\n}\\n\\nvec2 complexMul(vec2 a, vec2 b) {\\n  return vec2(a.x * b.x - a.y * b.y, a.y * b.x + a.x * b.y);\\n}\\n\\nvec2 complexDiv(vec2 a, vec2 b) {\\n  vec2 bConj = vec2(b.x, -b.y);\\n  float divisor = complexMul(b, bConj).x;\\n  return complexMul(a, bConj) / divisor;\\n}\\n\\n// return e^z\\nvec2 complexPow(vec2 z) {\\n  // e^(re + i * im)\\n  // = e^re * e^(i * im)\\n  return fromPolar(exp(z.x), z.y);\\n}\\n\\n// return w^z\\nvec2 complexPow(vec2 w, float z) {\\n  // w = r * e ^ (i * phi)\\n  // ln(w) = ln(r) + i * phi\\n  // w^z = e^(z * log(w)) = e^(z * (ln(r) + i * (phi))\\n  vec2 wPolar = toPolar(w);\\n  vec2 eExp = z * vec2(log(wPolar.x), wPolar.y);\\n  return complexPow(eExp);\\n}\\n\\n// END ../common/complex.glsl\\n// START ../common/quaternion.glsl\\nvec4 quatMult(vec4 a, vec4 b) {\\n  return vec4(\\n    a[0] * b[0] - a[1] * b[1] - a[2] * b[2] - a[3] * b[3],\\n    a[0] * b[1] + a[1] * b[0] + a[2] * b[3] - a[3] * b[2],\\n    a[0] * b[2] - a[1] * b[3] + a[2] * b[0] + a[3] * b[1],\\n    a[0] * b[3] + a[1] * b[2] - a[2] * b[1] + a[3] * b[0]\\n  );\\n}\\n\\nvec4 quatMult2(vec4 a, vec4 b) {\\n  return vec4(\\n    a.x * b.x - dot(a.yzw, b.yzw),\\n    a.x * b.yzw + b.x * a.yzw + cross(a.yzw, b.yzw)\\n  );\\n}\\n\\nvec4 quatMult(vec4 a, vec4 b, vec4 c) {\\n  return quatMult(quatMult(a, b), c);\\n}\\n\\nvec4 quatConjugate(vec4 a) {\\n  return vec4(a[0], -a[1], -a[2], -a[3]);\\n}\\nvec4 quatConjugate2(vec4 a) {\\n  return vec4(a.x, -a.yzw);\\n}\\n\\nfloat quatNorm(vec4 a) {\\n  return length(a);\\n}\\n\\nvec4 quatInverse(vec4 a) {\\n  return quatConjugate(a) / dot(a, a);\\n}\\n\\nvec4 quatRotation(vec3 axis1, float angleRad) {\\n  return vec4(cos(0.5 * angleRad), axis1 * sin(0.5 * angleRad));\\n}\\n\\nvec4 quatPower(vec4 q, float x) {\\n  float a = q.x;\\n  vec3 vv = q.yzw;\\n  vec3 n1 = normalize(vv);\\n  float phi = atan(length(vv), a);\\n  return pow(quatNorm(q), x) * vec4(cos(x * phi), n1 * sin(x * phi));\\n}\\nvec4 quatExp(vec4 q) {\\n  float a = q.x;\\n  vec3 vv = q.yzw;\\n  return exp(a) * vec4(cos(length(vv)), normalize(vv) * sin(length(vv)));\\n}\\n\\nvec4 rotatePoint(vec4 quat, vec3 p) {\\n  return quatMult(quat, vec4(0, p), quatInverse(quat));\\n}\\n\\n// END ../common/quaternion.glsl\\n\\nuniform sampler2D texture;\\nuniform float secs;\\nuniform mat4 lll;\\nuniform mat4 llli;\\nuniform vec4 colorPrimary;\\nuniform vec4 colorSecondary;\\nuniform vec4 colorBackground;\\nuniform float a;\\nuniform float b;\\nuniform float c;\\nuniform float d;\\nuniform float highResTimeStamp;\\nuniform int bandCount;\\nuniform vec3 campos;\\nin float n;\\nin vec2 coord;\\nout vec4 fragColor;\\n\\nstruct FxDFx {\\n  float fx;\\n  vec2 dfx;\\n};\\n\\n// f(r,a) = r - 1 + sin(3a+2r2)/2\\n//float f(vec2 polar) {\\n//  float r = length()polar.x;\\n//  float a = polar.y;\\n//  return r - 1.0 + sin(25.0 * a + 20.0 * r * r) / 2.0;\\n//}\\n//vec2 df(vec2 x) {\\n//  float r = length(x);\\n//  float a = atan(x.y, x.x);\\n//  vec2 da = vec2(x.y, -x.x) / (r * r);\\n//  return x / r + (1.5 * da + 2.0 * x) * cos(3.0 * a + 2.0 * r * r);\\n//}\\n\\nFxDFx ff(vec2 p) {\\n  float r = length(p);\\n  float a = atan(p.x, p.y);\\n  float fx = r - 1.0 + 0.5 * sin(3.0 * a + 2.0 * r * r);\\n  vec2 da = vec2(p.y, -p.x) / (r * r);\\n  vec2 dfx = p / r + (1.5 * da + 2.0 * p) * cos(3.0 * a + 2.0 * r * r);\\n  return FxDFx(fx, dfx);\\n}\\n\\n#define CHAIN(NAME, F, G)                                                      \\\\\\n  FxDFx NAME(vec2 p) {                                                         \\\\\\n    FxDFx gResult = G(x);                                                      \\\\\\n    return FxDFx();                                                            \\\\\\n  }\\n\\nfloat f(vec2 x) {\\n  float r = length(x);\\n  float a = atan(x.y, x.x);\\n  return r - 1.0 + 0.5 * sin(5.0 * a + 2.0 * r * r);\\n}\\nvec2 grad(vec2 x) {\\n  vec2 h = vec2(0.01, 0.0);\\n  return vec2(f(x + h.xy) - f(x - h.xy), f(x + h.yx) - f(x - h.yx)) /\\n  (2.0 * h.x);\\n}\\nuniform vec2 iMouse;\\nuniform vec2 iResolution;\\n\\nfloat pointGrid(float scale, vec2 p) {\\n  p -= 0.5;\\n  p /= scale;\\n  vec2 pCenter = round(p);\\n  return smoothstep(-0.5, -0.4, -distance(pCenter, p) * scale);\\n}\\n\\nfloat lineGrid(float scale, vec2 p) {\\n  p -= 0.5;\\n  p /= scale;\\n  vec2 pCenter = round(p);\\n  vec2 d = abs(p - pCenter);\\n  return smoothstep(-0.5, -0.4, -min(d.x, d.y) * scale);\\n}\\nfloat lineGrid(float scale, vec2 p, vec2 dp) {\\n  p -= 0.5;\\n  p /= scale;\\n  vec2 pCenter = round(p);\\n  vec2 d = abs((p - pCenter) / dp);\\n  return smoothstep(-0.5, -0.4, -min(d.x, d.y) * scale);\\n}\\n/**\\n * Renders a transform of a coordinate system as a line grid.\\n *\\n * E.g.\\n *\\n * `p` should be p(fragCoord)\\n *\\n * and\\n *\\n * `scale` should be dp/dx(fragCoord)\\n *\\n * For a linear transformation (mat2 mi), you pass\\n * `lineGrid(mi * fragCoord, mi)`\\n */\\nfloat lineGrid(vec2 p, mat2 scale) {\\n  //  p -= 0.5;\\n  vec2 pCenter = round(p);\\n  vec2 gradX = vec2(1, 0) * scale;\\n  vec2 gradY = vec2(0, 1) * scale;\\n  vec2 d = abs(p - pCenter);\\n  float m = min(d.x / length(gradX), d.y / length(gradY));\\n  //  return float(m < 3.0);\\n  return smoothstep(-1.5, -0.0, -m);\\n}\\nfloat lineCross(float scale, vec2 p, mat2 dp) {\\n  p -= 0.5;\\n  p /= scale;\\n  dp /= scale;\\n  //  vec2 d = abs(p * inverse(dp));\\n  //  vec2 d = abs(inverse(dp) * p);\\n  //  vec2 d = abs(dp * p);\\n  vec2 d = abs(p);\\n  //  vec2 d = abs(p * dp);\\n  return smoothstep(-0.5, -0.4, -min(d.x, d.y));\\n}\\nconst vec3 white = vec3(1);\\nconst vec3 red = vec3(1, 0, 0);\\n\\nvec2 fff2(vec2 x) {\\n  vec2 p = toPolar(x);\\n  return fromPolar(p.x, p.x);\\n}\\nvec2 fff(vec2 x) {\\n  vec2 p = toPolar(x);\\n  vec2 pp = vec2(p.x, p.y + 0.01 * p.x);\\n  return fromPolar(pp);\\n}\\n\\nvec2 ff3(vec2 x) {\\n  return 1.0 + cos(x / 50.0) * 30.0 / 50.0;\\n  return 1.0 + cos(x / 50.0) * 30.0 * a / 50.0;\\n}\\nvec2 cPow(vec2 fragCoord, float it) {\\n  vec2 w = fragCoord / a / 50.0;\\n  float z = 1.0 / c;\\n  // w = r * e ^ (i * phi)\\n  // ln(w) = ln(r) + i * phi\\n  // w^z = e^(z * log(w)) = e^(z * (ln(r) + i * (phi))\\n  vec2 wPolar = toPolar(w);\\n  wPolar.y += it * TAU;\\n  vec2 eExp = z * vec2(log(wPolar.x), wPolar.y);\\n  if (!between(-PI, PI, eExp.y)) {\\n    return vec2(0);\\n  }\\n  return complexPow(eExp);\\n}\\n\\n#define DERIVATIVE_2_2(NAME, F, EPS)                                           \\\\\\n  mat2 NAME(vec2 x) {                                                          \\\\\\n    vec2 fx = F(x);                                                            \\\\\\n    vec2 fx1 = F(x + vec2(EPS, 0));                                            \\\\\\n    vec2 fx2 = F(x + vec2(0, EPS));                                            \\\\\\n    return mat2(fx1 - fx, fx2 - fx) / (EPS);                                   \\\\\\n  }\\n\\nDERIVATIVE_2_2(dfff, fff, 1e-4)\\nDERIVATIVE_2_2(dff3, ff3, 1e-4)\\nmat2 dCPow(vec2 x, float it) {\\n  const float EPS = 1e-3;\\n  vec2 fx = cPow(x, it);\\n  vec2 fx1 = cPow(x + vec2(EPS, 0), it);\\n  vec2 fx2 = cPow(x + vec2(0, EPS), it);\\n  return mat2(fx1 - fx, fx2 - fx) / EPS;\\n}\\n\\n#define MIX_MAT(genMType)                                                      \\\\\\n  genMType mixMat(genMType a, genMType b, float t) {                           \\\\\\n    return (1.0 - t) * a + t * b;                                              \\\\\\n  }\\n\\nMIX_MAT(mat2)\\n\\n#define MIN3(G)                                                                \\\\\\n  G min3(G a, G b, G c) {                                                      \\\\\\n    return min(min(a, b), c);                                                  \\\\\\n  }\\n\\nMIN3(vec2)\\n\\nuniform float iTime;\\nvec3 ungamma(vec4 col) {\\n  return pow(col.rgb, vec3(2.2));\\n}\\n\\nvoid main() {\\n  vec2 fragCoord = coord * iResolution;\\n  //  //  vec2 p = toPolar(coord * 2.0);\\n  vec2 crd = coord;\\n  crd *= 2.0;\\n  //  FxDFx r = ff(crd);\\n  //  float fx = r.fx;\\n  //  vec2 dfx = r.dfx;\\n  //  float de = abs(fx) / length(dfx);\\n  //  //  fx = abs(fx);\\n  //  //  de = smoothstep(0.01, 0.02, de);\\n  //  //  vec3 color = vec3(fx);\\n  //  fragColor = visualize(de);\\n  //  //  fragColor = vec4(color, 1.0);\\n\\n  vec4 z = vec4(coord, 0.0, 0.0);\\n  const vec4 c = vec4(-0.4, 0.6, 0.0, 0.0);\\n  int i = 0;\\n  for (; i < 30; i++) {\\n    z = quatMult(z, z) + c;\\n    const vec4 c2 = vec4(-0.4, 0.6, 0.0, 0.0);\\n    int i = 0;\\n    for (; i < 30; i++) {\\n      z = quatMult(z, z) + c2;\\n      if (length(z) > 1.2) {\\n        break;\\n      }\\n    }\\n\\n    //  vec3 color=mix(bl)\\n\\n    vec2 x = crd;\\n    float v = f(x);\\n    vec2 g = grad(x);\\n    float de = abs(v) / length(g);\\n    vec3 color;\\n    //  fragColor = visualize(pow(de, 0.5));\\n    color = mix(vec3(1.0), vec3(0.0, 0.0, 1.0), float(i) / 30.0);\\n\\n    {\\n      int i = 0;\\n      vec4 z = vec4(iMouse, 0, 0);\\n      for (; i < 30; i++) {\\n        vec4 prevZ = z;\\n        z = quatMult(z, z) + c;\\n        if (sdSegment(prevZ.xy, z.xy, coord) < 0.002) {\\n          color = mix(vec3(0, 0, 0), vec3(0.1, 1.0, 0), float(i) / 30.0);\\n          break;\\n        }\\n        if (length(z) > 1.2) {\\n          break;\\n        }\\n      }\\n    }\\n    if (distance(vec2(0), coord) < 0.05) {\\n      color = vec3(1, 0, 0);\\n    }\\n    if (distance(c.xy, coord) < 0.05) {\\n      color = vec3(0, 1, 0);\\n    }\\n    //  fragColor = visualize(sdSegment(vec2(0), iMouse, coord));\\n    //  color = mix(white, vec3(1, 0, 1), pointGrid(20.0, fragCoord));\\n    //  fragCoord += sin(fragCoord / 50.0) * 30.0;\\n    //    fragCoord -= 800.0;\\n    //  fragCoord *= 2.0;\\n    //  fragCoord = ff3(fragCoord);\\n    //  vec2 dFragCoord = 1.0 + cos(fragCoord / 50.0) * 30.0 / 50.0;\\n    mat2 dFragCoord = dfff(fragCoord);\\n    color = mix(white, vec3(1, 0, 1), lineGrid(20.0, fragCoord, vec2(1.0)));\\n    fragColor = vec4(color, 1.0);\\n    fragColor = visualize(determinant(dFragCoord));\\n    if (distance(c2.xy, coord) < 0.05) {\\n      color = vec3(0, 1, 0);\\n    }\\n\\n    color = pow(color, vec3(1.0 / 2.2)); // gamma correction\\n    //  color = mix(white, vec3(1, 0, 1), pointGrid(20.0, fragCoord));\\n    //  fragCoord += sin(fragCoord / 50.0) * 30.0;\\n    vec2 p = fragCoord;\\n    p -= 0.5 * iResolution;\\n    //  p.y *= -1.0;\\n    //  p *= 2.0;\\n    //  p = ff3(p);\\n    //  vec2 dFragCoord = 1.0 + cos(p / 50.0) * 30.0 / 50.0;\\n    mat2 mi = inverse(\\n      mat2(\\n        1.0, 0.0,\\n        0.0, 1.0\\n      ) *\\n        a *\\n        20.0\\n    );\\n    mat2 id = mat2(\\n      1.0, 0.0,\\n      0.0, 1.0\\n    );\\n    float t = 0.0;\\n    color = white;\\n    //  color = mix(\\n    //    color,\\n    //    vec3(cPow(p) / 4.0, 0),\\n    //    lineGrid(cPow(p), dCPow(p))\\n    //  );\\n\\n    //  for (int i = -100; i < 100; i++) {\\n    //    vec2 p = vec2(i, 2.0);\\n    //    p = cPow(p, 0.0);\\n    //    p *= 10.0;\\n    //    float xxx = float(distance(p, p) < 5.0);\\n    //    color = mix(color, vec3(float(i + 100) / 100.0, 0, 0), xxx);\\n    //  }\\n    // TODO: save this line grid/complex mult demo\\n    //    for (float it = -2.0; it <= 2.0; it++) {\\n    //      //    p += it * vec2(1.0) * d;\\n    //      color = mix(\\n    //        color,\\n    //        vec3(0.5),\\n    //        //      vec3(cPow(p, it) / 4.0, 0),\\n    //        lineGrid(cPow(p, it), dCPow(p, it))\\n    //      );\\n    //    }\\n    vec3 color0 = colorBackground.rgb;\\n    vec3 color1 = colorPrimary.rgb;\\n    vec3 color2 = colorSecondary.rgb;\\n    float val = 1000.0;\\n    //    const vec3 orange = vec3(1.0, 0.843, 0);\\n    //    color = mix(color, color1, float(distance(a, fragCoord) < 10.0));\\n    //    color = mix(color, color1, float(distance(b, fragCoord) < 10.0));\\n    //    color = mix(color, color1, float(distance(c, fragCoord) < 10.0));\\n    //    color = mix(color, color2, float(sdSegment(a, b, fragCoord) < 3.0));\\n    //    color = vec3(fragCoord, 0.0);\\n    color = pow(color, vec3(1.0 / 2.2)); // gamma correction\\n    fragColor = vec4(color, 1.0);\\n    //  fragColor = visualize(determinant(dFragCoord));\\n  }\\n}\\n\\n\"\nconst sourceMap = {\"version\":3,\"sources\":[\"/home/runner/work/workshop/workshop/src/sdfs/fractals.frag\",\"/home/runner/work/workshop/workshop/src/common/sdf2d/sdSegment.glsl\",\"/home/runner/work/workshop/workshop/src/common/unmix.glsl\",\"/home/runner/work/workshop/workshop/src/common/banded.glsl\",\"/home/runner/work/workshop/workshop/src/common/between.glsl\",\"/home/runner/work/workshop/workshop/src/common/max3.glsl\",\"/home/runner/work/workshop/workshop/src/common/constants.glsl\",\"/home/runner/work/workshop/workshop/src/common/hexFns.glsl\",\"/home/runner/work/workshop/workshop/src/common/perlin2DTexture.glsl\",\"/home/runner/work/workshop/workshop/src/common/fromPolar.glsl\",\"/home/runner/work/workshop/workshop/src/common/toPolar.glsl\",\"/home/runner/work/workshop/workshop/src/common/polar.glsl\",\"/home/runner/work/workshop/workshop/src/common/remix.glsl\",\"/home/runner/work/workshop/workshop/src/common/visualize.glsl\",\"/home/runner/work/workshop/workshop/src/common/waves.glsl\",\"/home/runner/work/workshop/workshop/src/common/matrices.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdTorus.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdCapsule.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/opElongate.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdSphere.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdCylinder.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf2d/addChamfer.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf2d/addFillet.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdBox.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sdOctahedron.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/add.glsl\",\"/home/runner/work/workshop/workshop/src/common/sdf3d/sub.glsl\",\"/home/runner/work/workshop/workshop/src/common/complex.glsl\",\"/home/runner/work/workshop/workshop/src/common/quaternion.glsl\"],\"names\":[],\"mappings\":\"AAAA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AftEA;;AgBjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACPA;AACA;AACA;AACA;AACA;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;;A1BwBA;;A2B7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A5BrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA\"}\nexport { sourceMap };\n","\nexport default \"#version 300 es\\nprecision highp float;\\n\\n// START ../common/banded.glsl\\nfloat banded(float bandCount, float t) {\\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\\n}\\nfloat banded(int bandCount, float t) {\\n  return banded(float(bandCount), t);\\n}\\n\\n// #pragma glslify: export(banded)\\n\\n\\n// END ../common/banded.glsl\\n// START ../common/between.glsl\\nbool between(float min, float max, float value) {\\n  return min <= value && value <= max;\\n}\\n\\n// #pragma glslify: export(between)\\n\\n\\n// END ../common/between.glsl\\n// START ../common/perlin2DTexture.glsl\\nuniform sampler2D gradients;\\n/* Create random direction vector\\n */\\nvec2 randomGradient(vec2 i) {\\n  // Random float. No precomputed gradients mean this works for any number of grid coordinates\\n  float random =\\n    2920.0 *\\n    sin(float(i.x) * 2.1942 + float(i.y) * 1.71324 + 8.912) *\\n    cos(float(i.x) * 2.3157 * float(i.y) * 2.17832 + 9.758);\\n  //    random = (i.x + 1667.) * (i.x + 2083.) * (i.y + 2659.) * (i.y * 50.77 + .3769);\\n  //    random = sin(SQRT2 * i.x) + cos(GOLDEN_RATIO * i.y) + tan((i.x + i.y) * SQRT3);\\n  return vec2(cos(random), sin(random));\\n}\\nfloat dotGridGradient(vec2 cell, vec2 pos) {\\n  vec2 d = cell - pos;\\n\\n  //  vec2 gradient = texelFetch(gradients, ivec2(cell), 0).xy;\\n  vec2 gradient = randomGradient(vec2(cell));\\n\\n  return dot(gradient, d);\\n}\\n\\nfloat mixx(float a, float b, float t) {\\n  return mix(a, b, smoothstep(0.0, 1.0, t));\\n  //    return mix(a, b, t);\\n}\\n\\n// resulting range is [-0.68, 0.68]. Use unmix to normalize if necessary.\\nfloat perlin2D(vec2 xy) {\\n  float x0 = floor(xy.x);\\n  float x1 = x0 + 1.0;\\n  float y0 = floor(xy.y);\\n  float y1 = y0 + 1.0;\\n\\n  // Interpolate between grid point gradients\\n  float n00 = dotGridGradient(vec2(x0, y0), xy);\\n  float n10 = dotGridGradient(vec2(x1, y0), xy);\\n  float ny0 = mixx(n00, n10, xy.x - x0);\\n\\n  float n01 = dotGridGradient(vec2(x0, y1), xy);\\n  float n11 = dotGridGradient(vec2(x1, y1), xy);\\n  float ny1 = mixx(n01, n11, xy.x - x0);\\n\\n  return mixx(ny0, ny1, xy.y - y0);\\n}\\n\\n// #pragma glslify: export(perlin2D)\\n\\n\\n// END ../common/perlin2DTexture.glsl\\n// START ../common/remix.glsl\\n// START ./unmix.glsl\\nfloat unmix(float a, float b, float value) {\\n  return (value - a) / (b - a);\\n}\\n\\n// #pragma glslify: export(unmix)\\n\\n\\n// END ./unmix.glsl\\n\\nfloat remix(float fromA, float fromB, float toA, float toB, float value) {\\n  return mix(toA, toB, unmix(fromA, fromB, value));\\n}\\n\\nvec4 remix(float fromA, float fromB, vec4 toA, vec4 toB, float value) {\\n  return mix(toA, toB, unmix(fromA, fromB, value));\\n}\\n\\n// #pragma glslify: export(remix)\\n\\n\\n// END ../common/remix.glsl\\n// START ../common/waves.glsl\\nfloat waves(vec4 color, vec2 position, vec2 direction, float highResTimeStamp) {\\n  return sin(\\n    dot(position, direction / pow(length(direction), 2.0)) +\\n      float(highResTimeStamp) / 200.0\\n  );\\n}\\n\\n// #pragma glslify: export(waves)\\n\\n\\n// END ../common/waves.glsl\\n// START ../common/visualize.glsl\\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\\n  float isLow = float(t < 0.0);\\n  float isHigh = float(t > 1.0);\\n  float isMid = 1.0 - isLow - isHigh;\\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\\n}\\n\\nvec4 visualize(float t) {\\n  const vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\\n  const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\\n  return visualize(BLUE, RED, t);\\n}\\n\\n// #pragma glslify: export(visualize)\\n\\n\\n// END ../common/visualize.glsl\\n// START ../common/hexFns.glsl\\n// START ./max3.glsl\\nfloat max3(float a, float b, float c) {\\n  return max(a, max(b, c));\\n}\\nfloat max3(vec3 v) {\\n  return max(v.x, max(v.y, v.z));\\n}\\n\\n// #pragma glslify: export(max3)\\n\\n\\n// END ./max3.glsl\\n// START ./constants.glsl\\nconst float SQRT1_2 = 0.7071067811865476;\\nconst float SQRT1_3 = 0.57735026919;\\nconst float SQRT2 = 1.4142135623730951;\\nconst float SQRT3 = 1.732050807568877;\\n// sqrt(3)/2 = sin(60*)\\nconst float SQRT3_2 = 0.86602540378;\\nconst float GOLDEN_RATIO = 1.61803398875;\\nconst float PI = 3.141592653589793;\\nconst float TAU = 6.28318530718;\\n/**\\n * One degree in radians. Use like `sin(30 * DEG)`.\\n */\\nconst float DEGREE = 0.017453292519943295;\\n\\n// END ./constants.glsl\\n\\nvec3 hexRound(vec3 hex) {\\n  vec3 r = floor(hex + 0.5);\\n  vec3 diff = abs(r - hex);\\n\\n  if (diff.x > diff.y && diff.x > diff.z) {\\n    r.x = -(r.y + r.z);\\n  } else if (diff.y > diff.z) {\\n    r.y = -(r.x + r.z);\\n  } else {\\n    r.z = -(r.x + r.y);\\n  }\\n\\n  return r;\\n}\\nvec2 hex2Ra(vec3 hex) {\\n  float y = hex.t * SQRT3_2;\\n  float x = hex.s + hex.t / 2.0;\\n  return vec2(x, y);\\n}\\n\\nfloat hexSdf(vec3 hex) {\\n  return max3(abs(hex.yzx + hex.zxy / 2.0));\\n}\\nvec3 ra2Hex(vec2 xy) {\\n  float hex_t = xy.y / SQRT3_2;\\n  float hex_s = xy.x - hex_t / 2.0;\\n  return vec3(hex_s, hex_t, -(hex_s + hex_t));\\n}\\n\\n// END ../common/hexFns.glsl\\n// START ../common/triFns.glsl\\n\\n// (x, y) -> (u, v, R)\\n// where u is horizontal, v is south-west to north-east\\n// and R is wether the it is in the right triangle\\nvec3 xy2tri(vec2 xy) {\\n  float v = xy.y / SQRT3_2;\\n  float u = xy.x - v / 2.0;\\n  float R = float(\\n    mod(u + v, 2.0) > 1.0 != (mod(floor(u) + floor(v), 2.0) == 1.0)\\n  );\\n  return vec3(u, v, R);\\n}\\nvec3 triCenter(vec3 uvR) {\\n  vec3 base = floor(uvR);\\n  vec2 centerOffset = mix(vec2(1.0 / 3.0), vec2(2.0 / 3.0), uvR.z);\\n  return base + vec3(centerOffset, 0.0);\\n}\\nvec2 tri2xy(vec3 uvR) {\\n  float y = uvR.t * SQRT3_2;\\n  float x = uvR.s + uvR.t / 2.0;\\n  return vec2(x, y);\\n}\\nvec2 tri2xy(vec2 uv) {\\n  float y = uv.t * SQRT3_2;\\n  float x = uv.s + uv.t / 2.0;\\n  return vec2(x, y);\\n}\\nfloat triSdf(vec2 uv) {\\n  vec3 hex = vec3(uv.x, uv.y, -uv.x - uv.y);\\n  return max3(hex);\\n}\\n\\n// END ../common/triFns.glsl\\n\\nuniform sampler2D texture;\\nuniform vec4 colorPrimary;\\nuniform float highResTimeStamp;\\nuniform vec4 colorSecondary;\\nuniform vec4 colorBackground;\\nuniform float a;\\nuniform int bandCount;\\nin float n;\\nin vec2 coord;\\nout vec4 fragColor;\\n\\nmat2 rot2(float angle) {\\n  float c = cos(angle),\\n    s = sin(angle);\\n  return mat2(c, -s, s, c);\\n}\\n\\nfloat perlin01(vec2 pos) {\\n  return unmix(-0.68, 0.68, perlin2D(pos));\\n}\\n\\nvec2 fc(vec2 z, vec2 c) {\\n  return complexMul(z, z) + c;\\n}\\n\\nfloat mandelbrot(vec2 c) {\\n  vec2 z = vec2(0);\\n  for (int i = 0; i < bandCount * 2; i++) {\\n    z = fc(z, c);\\n  }\\n  return length(z);\\n}\\nvec2 mandelbrotz(vec2 c) {\\n  vec2 z = vec2(0);\\n  for (int i = 0; i < bandCount * 2; i++) {\\n    z = fc(z, c);\\n  }\\n  return z;\\n}\\n\\nint mandelbrotcount(vec2 c) {\\n  vec2 z = vec2(0);\\n  int i;\\n  for (i = 0; i < bandCount * 2; i++) {\\n    z = fc(z, c);\\n    if (length(z) > 1024.0) {\\n      break;\\n    }\\n  }\\n  return i;\\n}\\n\\nvoid main() {\\n  vec2 cc = coord / pow(10.0, a * 10.0) - vec2(0.5301, 0.5);\\n  vec2 f = mandelbrotz(cc);\\n  float inside = float(length(f) < 1024.0);\\n  int c = mandelbrotcount(cc);\\n\\n  //    fragColor =\\n  //        visualize(blue, red, f / 1000.0);\\n\\n  //    fragColor = vec4(f.xy, 0.0, 1.0);\\n  float val = pow(float(c) / float(bandCount), 1.0 / 2.0);\\n  fragColor = mix(colorBackground, colorPrimary, val);\\n  //    fragColor = visualize(blue, red, val);\\n}\\n\"\nconst sourceMap = {\"version\":3,\"sources\":[\"/home/runner/work/workshop/workshop/src/sdfs/mandelbrot.frag\",\"/home/runner/work/workshop/workshop/src/common/banded.glsl\",\"/home/runner/work/workshop/workshop/src/common/between.glsl\",\"/home/runner/work/workshop/workshop/src/common/perlin2DTexture.glsl\",\"/home/runner/work/workshop/workshop/src/common/unmix.glsl\",\"/home/runner/work/workshop/workshop/src/common/remix.glsl\",\"/home/runner/work/workshop/workshop/src/common/waves.glsl\",\"/home/runner/work/workshop/workshop/src/common/visualize.glsl\",\"/home/runner/work/workshop/workshop/src/common/max3.glsl\",\"/home/runner/work/workshop/workshop/src/common/constants.glsl\",\"/home/runner/work/workshop/workshop/src/common/hexFns.glsl\",\"/home/runner/work/workshop/workshop/src/common/triFns.glsl\"],\"names\":[],\"mappings\":\"AAAA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AXnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA\"}\nexport { sourceMap };\n","var map = {\n\t\"./demoLego.frag\": 2965,\n\t\"./demoTemple.frag\": 6026,\n\t\"./fractals.frag\": 383,\n\t\"./mandelbrot.frag\": 4818\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 8261;"],"names":["_optionalChain","ops","lastAccessLHS","value","i","length","op","fn","args","call","undefined","GenericDemo","sx","animate","state","Renderer","focusable","rendererRef","rendererRef2","useRef","fps","setFps","useState","anchorEl","setAnchorEl","renderProgress","setRenderProgress","render","useCallback","async","event","dim","currentTarget","dataset","split","map","x","current","url","URL","createObjectURL","renderImage","e","console","error","useEffect","openMenu","resolutionScale","setResolutionScale","resolutionScales","window","devicePixelRatio","closeMenu","Card","position","Menu","open","onClose","MenuItem","onClick","ListItem","ListItemText","Select","onChange","target","size","key","Box","margin","right","CircularProgress","variant","Fab","MoreVert","left","CardMedia","component","ReactGlCanvas","onFps","width","height","canvasRef","renderer1","start","destroy","theme","useTheme","Object","assign","dyn","colorBackground","palette","background","default","gl","colorPrimary","primary","main","colorSecondary","secondary","ref","style","SimpleCanvasRenderer","__init","this","mousePos","__init2","__init3","__init4","stop","constructor","fragShader","canvas","prototype","__init5","create","alpha","premultipliedAlpha","fixCanvasRes","clientWidth","clientHeight","viewport","log","addEventListener","getBoundingClientRect","offsetX","offsetY","planeMesh","plane","startX","startY","compile","fpsController","FPSController","makeCurrent","updateShader","buildShader","f","lastResult","lastArgs","some","v","memoizeLast","vs","fs","sourceMap","fsSrc","shader","clear","sourceMapConsumer","SourceMapConsumer","newMessage","message","replace","match","line","originalPosition","originalPositionFor","column","source","bind","abs","_","_2","tick","_3","uniforms","iResolution","iMouse","iTime","draw","onProgress","_4","document","createElement","renderer","step","enable","SCISSOR_TEST","donePixels","y","scissorWidth","Math","min","scissorHeight","scissor","_5","Promise","resolve","reject","toBlob","blob","initialState","a","b","c","d","frag","resolution","setResolution","setState","setStatePartial","o","s","cam","children","disabled","floor","format","padStart","container","spacing","padding","item","xs","md","lg","checked","prop","inputProps","getSwitchBaseUtilityClass","slot","generateUtilityClass","generateUtilityClasses","_excluded","SwitchBaseRoot","styled","ButtonBase","ownerState","borderRadius","edge","marginLeft","marginRight","SwitchBaseInput","cursor","opacity","top","zIndex","props","autoFocus","checkedProp","checkedIcon","className","defaultChecked","disabledProp","disableFocusRipple","icon","id","inputRef","name","onBlur","onFocus","readOnly","required","tabIndex","type","other","setCheckedState","useControlled","controlled","Boolean","muiFormControl","useFormControl","hasLabelFor","classes","slots","root","capitalize","input","composeClasses","useUtilityClasses","clsx","centerRipple","focusRipple","role","nativeEvent","defaultPrevented","newChecked","createSvgIcon","getCheckboxUtilityClass","CheckboxRoot","shouldForwardProp","overridesResolver","styles","indeterminate","color","vars","text","disableRipple","backgroundColor","action","activeChannel","mainChannel","hoverOpacity","active","defaultCheckedIcon","CheckBox","defaultIcon","CheckBoxOutlineBlank","defaultIndeterminateIcon","IndeterminateCheckBox","inProps","_icon$props$fontSize","_indeterminateIcon$pr","useThemeProps","iconProp","indeterminateIcon","indeterminateIconProp","composedClasses","fontSize","webpackContext","req","webpackContextResolve","__webpack_require__","Error","code","keys","module","exports"],"sourceRoot":""}