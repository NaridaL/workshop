"use strict";(self.webpackChunkworkshop=self.webpackChunkworkshop||[]).push([[628],{3671:(n,t,e)=>{e.d(t,{PM:()=>a,Qn:()=>s,X$:()=>i,XJ:()=>l,YQ:()=>g,_x:()=>f,hv:()=>u,kC:()=>p,li:()=>h,nl:()=>m,oe:()=>d,q3:()=>c,t1:()=>v});var o=e(9526),r=e(2182);const a=25.4,i=n=>(0,r.At)(n/r.Co,-1)+"°",l=(n,t)=>t/2/Math.sin(r.gc/n/2),s=(n,t)=>2*t*Math.sin(r.gc/n/2),c=(n,t)=>t/2/Math.tan(r.gc/n/2),d=(n,t)=>t/Math.cos(r.gc/n/2),f=(n,t)=>2*t*Math.tan(r.gc/n/2);function u({sides:n,radius:t,startAngle:e=0,sideLength:a,...i}){if(void 0!==a==(void 0!==t))throw new Error("must set either sideLength or radius");void 0===t&&(t=l(n,a));const{x:s,y:c}=r.V3.polar(t,e);return o.createElement("path",{d:m`
        M${s},${c}
        ${(0,r.hS)(0,n).map((o=>m`L${r.V3.polar(t,e+o*(r.gc/n))}`))}Z`,...i})}function p({id:n,children:t,count:e,stepDeg:a}){return o.createElement(o.Fragment,null,o.createElement("g",{id:n},t),(0,r.hS)(0,e-1).map((t=>o.createElement("use",{key:t,href:"#"+n,transform:`rotate(${(t+1)*a} 0 0)`}))))}const h=[[841,1189,"A0"],[594,841,"A1"],[420,594,"A2"],[297,420,"A3"],[210,297,"A4"],[148,210,"A5"],[105,148,"A6"],[74,105,"A7"],[52,74,"A8"],[37,52,"A9"],[26,37,"A10"],[150,150,"Origami 15cm"],[100,100,"Origami 10cm"],[75,75,"Origami 7.5cm"],[215.9,279.4,"Letter"],[215.9,355.6,"Legal"]],v=h.find((([,,n])=>n.includes("A4")));function m(n,...t){const e=n=>"number"==typeof n?""+n:"string"==typeof n?n:Array.isArray(n)?n.map(e).join(" "):n.x+","+n.y;let o=n[0];for(let r=0;r<t.length;r++)o+=e(t[r]),o+=n[r+1];return o}const g=n=>{const t=window.open(n,"_blank","noopener,noreferrer");t&&(t.opener=null)}},1641:(n,t,e)=>{e.d(t,{q:()=>f});var o=e(6897),r=e.n(o),a=e(508),i=e.n(a),l=e(9526);const s=n=>"#"+Object.entries(n).map((([n,t])=>encodeURIComponent(n)+"="+encodeURIComponent(t))).join("&"),c=n=>i()(n,(n=>"true"===n||"false"!==n&&("NaN"===n?NaN:"undefined"===n?void 0:"null"===n?null:""===n?"":isNaN(+n)?n:+n))),d=n=>i()(n,(n=>""+n));function f(n,{deserialize:t=c,serialize:e=d,wait:o=1e3}={}){const a=(0,l.useCallback)((()=>{const o="function"==typeof n?n():n,r=t(Object.assign(e(o),(a=document.location.hash)?a.substr(1).split("&").map((n=>{const[t,e]=n.split("=");return[decodeURIComponent(t),decodeURIComponent(e)]})).reduce(((n,[t,e])=>(n[t]=e,n)),{}):{}));var a;return history.pushState(void 0,document.title,s(e(r))),r}),[t,n,e]),[i,f]=(0,l.useState)(a),u=(0,l.useRef)();return u.current||(u.current=r()((function(n){history.pushState(void 0,document.title,s(e(n)))}),o)),(0,l.useEffect)((()=>u.current(i)),[i]),(0,l.useEffect)((()=>{const n=()=>{f(a())};return window.addEventListener("hashchange",n),()=>{window.removeEventListener("hashchange",n)}}),[a]),[i,f]}},7463:(n,t,e)=>{e.r(t),e.d(t,{default:()=>mn});var o=e(8864),r=e(5069),a=e(4854),i=e(871),l=e(897),s=e(2039),c=e(6498),d=e(8051),f=e(3121);function u(n,t){for(var e=0;e<t.length;e++){var o=t[e];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(n,o.key,o)}}function p(n,t){return function(n){if(Array.isArray(n))return n}(n)||function(n,t){if("undefined"!=typeof Symbol&&Symbol.iterator in Object(n)){var e=[],o=!0,r=!1,a=void 0;try{for(var i,l=n[Symbol.iterator]();!(o=(i=l.next()).done)&&(e.push(i.value),!t||e.length!==t);o=!0);}catch(n){r=!0,a=n}finally{try{o||null==l.return||l.return()}finally{if(r)throw a}}return e}}(n,t)||v(n,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function h(n){return function(n){if(Array.isArray(n))return m(n)}(n)||function(n){if("undefined"!=typeof Symbol&&Symbol.iterator in Object(n))return Array.from(n)}(n)||v(n)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function v(n,t){if(n){if("string"==typeof n)return m(n,t);var e=Object.prototype.toString.call(n).slice(8,-1);return"Object"===e&&n.constructor&&(e=n.constructor.name),"Map"===e||"Set"===e?Array.from(e):"Arguments"===e||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e)?m(n,t):void 0}}function m(n,t){(null==t||t>n.length)&&(t=n.length);for(var e=0,o=new Array(t);e<t;e++)o[e]=n[e];return o}function g(n){if("undefined"==typeof Symbol||null==n[Symbol.iterator]){if(Array.isArray(n)||(n=v(n))){var t=0,e=function(){};return{s:e,n:function(){return t>=n.length?{done:!0}:{done:!1,value:n[t++]}},e:function(n){throw n},f:e}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var o,r,a=!0,i=!1;return{s:function(){o=n[Symbol.iterator]()},n:function(){var n=o.next();return a=n.done,n},e:function(n){i=!0,r=n},f:function(){try{a||null==o.return||o.return()}finally{if(i)throw r}}}}var y=0;function x(n){return"__private_"+y+++"_"+n}function b(n,t){if(!Object.prototype.hasOwnProperty.call(n,t))throw new TypeError("attempted to use private field on non-instance");return n}var C=function(){function n(){!function(n,t){if(!(n instanceof t))throw new TypeError("Cannot call a class as a function")}(this,n)}return t=n,e=[{key:"format",value:function(t,e){return e in b(n,_)[_]||(b(n,_)[_][e]=n._generateMap(n.styles[e])),function(n,t){var e,o="",r=g(n);try{for(r.s();!(e=r.n()).done;){var a=e.value;o+=t.get(a)||a}}catch(n){r.e(n)}finally{r.f()}return o}(t,b(n,_)[_][e])}},{key:"_generateMap",value:function(t){var e,o=new Map,r=t.hasOwnProperty("exceptions");if(r)for(var a in e=[],Object.keys(t.exceptions).forEach((function(n){e=[].concat(h(e),h(n))})),t.exceptions){var i,l=t.exceptions[a],s=0,c=g(a);try{for(c.s();!(i=c.n()).done;){var d=i.value,f=String.fromCodePoint(s+l);o.set(d,f),s++}}catch(n){c.e(n)}finally{c.f()}}for(var u in!t.hasOwnProperty("upper")&&t.hasOwnProperty("lower")?t.upper=t.lower:!t.hasOwnProperty("lower")&&t.hasOwnProperty("upper")&&(t.lower=t.upper),b(n,w)[w])if("number"==typeof t[u]){var p,v=g(b(n,w)[w][u].chars);try{for(v.s();!(p=v.n()).done;){var m=p.value;if(!r||!e.includes(m)){var y=m.codePointAt(0),x=String.fromCodePoint(y+t[u]-b(n,w)[w][u]["lower-bound"]);o.set(m,x)}}}catch(n){v.e(n)}finally{v.f()}}return o}},{key:"unformat",value:function(t){void 0===b(n,M)[M]&&n._generateReverseMap();var e,o="",r=g(t);try{for(r.s();!(e=r.n()).done;){var a=e.value;o+=b(n,M)[M].get(a)||a}}catch(n){r.e(n)}finally{r.f()}return o}},{key:"_generateReverseMap",value:function(){for(var t={},e=arguments.length,o=new Array(e),r=0;r<e;r++)o[r]=arguments[r];if(0===o.length)for(var a in t=n.styles,b(n,w)[w]){var i=b(n,w)[w][a]["lower-bound"];t.normal=i}else o.forEach((function(e){t.push(n.styles[e])}));for(var l in b(n,M)[M]=new Map,t){var s,c=g(l in b(n,_)[_]?b(n,_)[_][l]:n._generateMap(t[l]));try{for(c.s();!(s=c.n()).done;){var d=p(s.value,2),f=d[0],u=d[1];b(n,M)[M].set(u,f)}}catch(n){c.e(n)}finally{c.f()}}}}],null&&u(t.prototype,null),e&&u(t,e),n;var t,e}(),w=x("charaters"),_=x("styleDict"),M=x("styleReverseMap");C.styles={"serf-bold":{upper:119808,lower:119834,digits:120783,zero:120782},"serf-italic":{upper:119860,lower:119886,exceptions:{h:8462}},"serf-bold-italic":{upper:119912,lower:119938},"sans-serf":{upper:120224,lower:120250,digits:120803,zero:120802},"sans-serf-bold":{upper:120276,lower:120302,digits:120813,zero:120812},"sans-serf-italic":{upper:120328,lower:120354},"sans-serf-bold-italic":{upper:120380,lower:120406},script:{upper:119964,lower:119990,exceptions:{B:8492,EF:8496,H:8459,I:8464,L:8466,M:8499,R:8475,e:8495,g:8458,o:8500}},"script-bold":{upper:120016,lower:120042},fraktur:{upper:120068,lower:120094,exceptions:{C:8493,H:8460,I:8465,R:8476,Z:8488}},"fraktur-bold":{upper:120172,lower:120198},monospace:{upper:120432,lower:120458,digits:120823,zero:120822},"double-struck":{upper:120120,lower:120146,digits:120793,zero:120792,exceptions:{C:8450,H:8461,N:8469,P:8473,Q:8474,R:8477,Z:8484}},circled:{upper:9398,lower:9424,digits:9312,zero:127243},"negative-circled":{upper:127312,zero:9471},"parenthesized-small":{lower:9372,digits:9332},"parenthesized-large":{upper:127248},squared:{upper:127280},"negative-squared":{upper:127344}},Object.defineProperty(C,w,{writable:!0,value:{lower:{chars:"abcdefghijklmnopqrstuvwxyz","lower-bound":97},upper:{chars:"ABCDEFGHIJKLMNOPQRSTUVWXYZ","lower-bound":65},digits:{chars:"123456789","lower-bound":49},zero:{chars:"0","lower-bound":48}}}),Object.defineProperty(C,_,{writable:!0,value:{}}),Object.defineProperty(C,M,{writable:!0,value:void 0});const R=C;var z=e(7392),k=e(3059),S=e(9526),E=e(2182),P=e(2004),H=e(3671),L=e(1641);function A({state:n,prop:t,setStatePartial:e,...o}){return S.createElement(f.Z,{variant:"outlined",size:"small",type:"number",value:n[t],onChange:n=>e({[t]:+n.target.value}),label:t,...o})}function O(n){let t,e=n[0],o=1;for(;o<n.length;){const r=n[o],a=n[o+1];if(o+=2,("optionalAccess"===r||"optionalCall"===r)&&null==e)return;"access"===r||"optionalAccess"===r?(t=e,e=a(e)):"call"!==r&&"optionalCall"!==r||(e=a(((...n)=>e.call(t,...n))),t=void 0)}return e}const T=z.$_("red").gl(),q=z.$_("green").gl(),Z=z.$_("blue").gl(),V=P.$R,I={anchor:E.V3.O,dir1:E.V3.X},B={anchor:E.V3.O,dir1:E.V3.Y},D={anchor:E.V3.O,dir1:E.V3.Z};class W{__init(){this.meshes={}}__init2(){this.highlight=0}__init3(){this.offsetGC=void 0}__init4(){this.dragging=0}constructor(n,t,e,o,r,a){this.gl=n,this.pos=t,this.onHover=e,this.onStartDragging=o,this.onStopDragging=r,this.onChange=a,W.prototype.__init.call(this),W.prototype.__init2.call(this),W.prototype.__init3.call(this),W.prototype.__init4.call(this),W.prototype.__init5.call(this),W.prototype.__init6.call(this),W.prototype.__init7.call(this),this.meshes.vector=P.Kj.rotation([(0,E.V)(0,.04),(0,E.V)(.8,.04),(0,E.V)(.85,.06),(0,E.V)(1,0)],I,E.gc,8,!0),this.meshes.vector.computeNormalsFromFlatTriangles(),this.meshes.vector.compile();const i=E.M4.rotateX(-90*E.Co).translate(E.V3.X);this.meshes.rotater=P.Kj.rotation((0,E.hS)(0,9).map((n=>i.transformPoint(E.V3.polar(.04,-E.gc*n/8)))),{anchor:E.V3.O,dir1:E.V3.Z},101.25*E.Co,8,!1),this.meshes.rotater.computeNormalsFromFlatTriangles(),this.meshes.rotater.compile()}drawVector(n,t,e,o=1){if(n.likeO())return;this.gl.pushMatrix();const r=n.getPerpendicular().unit();this.gl.multMatrix(E.M4.forSys(n.unit(),r,n.cross(r).unit(),t)),e.draw(this.meshes.vector),this.gl.popMatrix()}render(n){const t=this.gl;t.enable(t.CULL_FACE),t.cullFace(t.BACK),t.pushMatrix(),t.multMatrix(this.pos),t.cullFace(t.FRONT),n.uniforms({color:V,normalOffset:.01}),1!==this.highlight&&1!==this.dragging||this.drawVector(E.V3.X,E.V3.O,n,.1),2!==this.highlight&&2!==this.dragging||this.drawVector(E.V3.Y,E.V3.O,n,.1),3!==this.highlight&&3!==this.dragging||this.drawVector(E.V3.Z,E.V3.O,n,.1),t.cullFace(t.BACK),n.uniforms({normalOffset:0}),this.drawVector(E.V3.X,E.V3.O,n.uniforms({color:T}),.1),this.drawVector(E.V3.Y,E.V3.O,n.uniforms({color:q}),.1),this.drawVector(E.V3.Z,E.V3.O,n.uniforms({color:Z}),.1),n.uniforms({color:Z}).draw(this.meshes.rotater),t.rotate(-90,0,1,0),n.uniforms({color:T}).draw(this.meshes.rotater),t.rotate(-90,1,0,0),n.uniforms({color:q}).draw(this.meshes.rotater),t.popMatrix()}registerListeners(n,t){return this.getCameraMatrix=t,O([this,"access",n=>n.unregister,"optionalCall",n=>n()]),n.addEventListener("mousemove",this.mousemove),n.addEventListener("mousedown",this.mousedown),n.addEventListener("mouseup",this.mouseup),this.unregister=()=>{n.removeEventListener("mousemove",this.mousemove),n.removeEventListener("mousedown",this.mousedown),n.removeEventListener("mouseup",this.mouseup)}}unregisterListeners(){O([this,"access",n=>n.unregister,"optionalCall",n=>n()])}__init5(){this.mousemove=n=>{const t=(0,E.V)(n.offsetX,n.offsetY),e=n.target.getBoundingClientRect();e.width;const o=function(n,t,e){const o=(0,E.V)(2*n.x/t.width-1,2*-n.y/t.height+1,-1),r=(0,E.V)(2*n.x/t.width-1,2*-n.y/t.height+1,1),a=e.inversed(),i=a.transformPoint(o);return{anchor:i,dir1:a.transformPoint(r).minus(i).unit()}}(t,e,this.getCameraMatrix());if(this.dragging){const r=[E.V3.O,E.V3.X,E.V3.Y,E.V3.Z][this.dragging],a=j(o,{anchor:this.pos.getTranslation(),dir1:this.pos.transformVector(r).unit()}),i=this.pos.transformVector(this.offsetGC),l=a.lineClosest.minus(i);this.pos=this.pos.translate(this.pos.getTranslation().to(l)),this.onChange(this.pos)}else{const s=this.pos.inversed(),c={anchor:s.transformPoint(o.anchor),dir1:s.transformVector(o.dir1).unit()};let d;function f(n){const t=j(c,n);return d=N(n,(0,E.uZ)(t.lineT,0,1)),d.distanceTo(t.thClosest)}const u=this.highlight;f(I)<.1?(this.highlight=1,this.offsetGC=d):f(B)<.1?(this.highlight=2,this.offsetGC=d):f(D)<.1?(this.highlight=3,this.offsetGC=d):(this.highlight=0,this.offsetGC=void 0),this.highlight!==u&&O([this,"access",n=>n.onHover,"optionalCall",n=>n(this.highlight)])}}}__init6(){this.mousedown=n=>{this.highlight&&(this.dragging=this.highlight,this.onStartDragging())}}__init7(){this.mouseup=n=>{this.dragging&&(this.dragging=0,this.onStopDragging())}}}function N(n,t){return n.anchor.plus(n.dir1.times(t))}function j(n,t){if(function(n,t){return(0,E.eq)(1,Math.abs(n.dir1.dot(t.dir1)))}(n,t))return{t:NaN,s:NaN,distance:n.distanceToLine(t)};const e=t.anchor,o=t.dir1,r=n.anchor,a=n.dir1,i=o.dot(a),l=o.squared(),s=a.squared(),c=e.minus(r),d=i*i-s*l,f=(c.dot(o)*i-c.dot(a)*l)/d,u=(c.dot(o)*s-c.dot(a)*i)/d;return{thT:f,lineT:u,thClosest:N(n,f),lineClosest:N(t,u),distance:N(n,f).distanceTo(N(t,u))}}function G(n){let t,e=n[0],o=1;for(;o<n.length;){const r=n[o],a=n[o+1];if(o+=2,("optionalAccess"===r||"optionalCall"===r)&&null==e)return;"access"===r||"optionalAccess"===r?(t=e,e=a(e)):"call"!==r&&"optionalCall"!==r||(e=a(((...n)=>e.call(t,...n))),t=void 0)}return e}class ${__init(){this.lastPos=E.V3.O}__init2(){this.pressedKeys={}}__init3(){this.pauseCam=!1}constructor(n,t,e){this.state=n,this.onChange=t,this.lockUp=e,$.prototype.__init.call(this),$.prototype.__init2.call(this),$.prototype.__init3.call(this),$.prototype.__init4.call(this),$.prototype.__init5.call(this),$.prototype.__init6.call(this),$.prototype.__init7.call(this)}__init4(){this.setState=n=>{n!==this.state&&E.M4.copy(n,this.state)}}registerListeners(n,t=n){return G([this,"access",n=>n.unregister,"optionalCall",n=>n()]),n.addEventListener("mousemove",this.mousemove),t.addEventListener("keydown",this.keydown),t.addEventListener("keyup",this.keyup),this.unregister=()=>{n.removeEventListener("mousemove",this.mousemove),t.removeEventListener("keydown",this.keydown),t.removeEventListener("keyup",this.keyup)}}unregisterListeners(){G([this,"access",n=>n.unregister,"optionalCall",n=>n()])}tick(){const n=new E.V3(+!!this.pressedKeys.a-+!!this.pressedKeys.d,+!!this.pressedKeys.q+ +!!this.pressedKeys.Control-+!!this.pressedKeys.e-+!!this.pressedKeys[" "],+!!this.pressedKeys.w-+!!this.pressedKeys.s);n.likeO()||(this.state=this.state.translate(n.toLength(.05)),G([this,"access",n=>n.onChange,"optionalCall",n=>n(this.state)]))}__init5(){this.mousemove=n=>{const t=(0,E.V)(n.pageX,n.pageY),e=this.lastPos.to(t);if(1&n.buttons&&!this.pauseCam){const n=E.M4.rotateY(.25*e.x*E.Co).rotateX(.25*e.y*E.Co);this.state=n.times(this.state),G([this,"access",n=>n.onChange,"optionalCall",n=>n(this.state)])}this.lastPos=t}}__init6(){this.keydown=n=>{this.pressedKeys[n.key]=!0,n.preventDefault()}}__init7(){this.keyup=n=>{this.pressedKeys[n.key]=void 0,n.preventDefault()}}getLookAt(){return this.state}static invertLookAt(n){const t=n.transposed().scale(-1);return{eye:t.transformVector(n.getTranslation(),!1),dir:t.transformVector(E.V3.Z,!1),up:t.transformVector(E.V3.Y.negated(),!1)}}static toShortString(n,t=100){const e=(n,t)=>[n.x,n.y,n.z].map((n=>Math.floor(n*t))).join("."),{eye:o,dir:r,up:a}=$.invertLookAt(n);return e(o,t)+"~"+e(r.unit(),100)+"~"+e(a,100)}static fromShortString(n,t=100){const e=(n,t)=>(0,E.V)(n.split(".").map((n=>+n/t))),[o,r,a]=n.split("~"),i=e(o,t);return E.M4.lookAt(i,i.plus(e(r,100)),e(a,100))}}class Y{__init(){this.count=0}__init2(){this.lastTime=performance.now()}constructor(n){this.notify=n,Y.prototype.__init.call(this),Y.prototype.__init2.call(this)}tick(n=performance.now()){if(this.count=(this.count+1)%10,0===this.count){const t=Math.floor(1e4/(n-this.lastTime));this.notify(t),this.lastTime=n}}}function F(n){let t,e=n[0],o=1;for(;o<n.length;){const r=n[o],a=n[o+1];if(o+=2,("optionalAccess"===r||"optionalCall"===r)&&null==e)return;"access"===r||"optionalAccess"===r?(t=e,e=a(e)):"call"!==r&&"optionalCall"!==r||(e=a(((...n)=>e.call(t,...n))),t=void 0)}return e}const K=["zoomIn","zoomOut","left","right","up","down"];class X{__init(){this.lastPos=E.V3.O}__init2(){this.pressedKeys={zoomIn:!1,zoomOut:!1,left:!1,right:!1,up:!1,down:!1}}__init3(){this.pauseCam=!1}__init4(){this.udRot=.1}__init5(){this.rot=0}__init6(){this.dist=10}constructor(n,t={zoomIn:"w",zoomOut:"s",left:"a",right:"d",up:" ",down:"Control"}){this.onChange=n,this.keys=t,X.prototype.__init.call(this),X.prototype.__init2.call(this),X.prototype.__init3.call(this),X.prototype.__init4.call(this),X.prototype.__init5.call(this),X.prototype.__init6.call(this),X.prototype.__init7.call(this),X.prototype.__init8.call(this),X.prototype.__init9.call(this),X.prototype.__init10.call(this),X.prototype.__init11.call(this),X.prototype.__init12.call(this)}__init7(){this.setState=n=>{console.log("setStaet"),[this.udRot,this.rot,this.dist]=X.toOrbitCameraState(n)}}static toOrbitCameraState(n){if(n instanceof E.M4){const t=n.transposed().scale(-1).transformVector(n.getTranslation(),!1);return[Math.atan(t.z/t.lengthXY()),t.angleXY(),t.length()]}return n}registerListeners(n,t=n){return F([this,"access",n=>n.unregister,"optionalCall",n=>n()]),n.addEventListener("mousemove",this.mousemove),n.addEventListener("wheel",this.wheel),t.addEventListener("keydown",this.keydown),t.addEventListener("keyup",this.keyup),t.addEventListener("blur",this.keyup),this.unregister=()=>{n.removeEventListener("mousemove",this.mousemove),n.removeEventListener("wheel",this.wheel),t.removeEventListener("keydown",this.keydown),t.removeEventListener("keyup",this.keyup),t.removeEventListener("keyup",this.keyup)}}__init8(){this.blur=()=>{}}unregisterListeners(){F([this,"access",n=>n.unregister,"optionalCall",n=>n()])}tick(){const n=.1*(+this.pressedKeys.zoomOut-+this.pressedKeys.zoomIn),t=.1*(-+this.pressedKeys.left+ +this.pressedKeys.right),e=(0,E.uZ)(this.udRot+.1*(+this.pressedKeys.up-+this.pressedKeys.down),.5*-Math.PI,.5*Math.PI);0===n&&0===t&&e===this.udRot||(this.dist+=n,this.rot+=t,this.udRot=e,F([this,"access",n=>n.onChange,"optionalCall",n=>n(this.ss)]))}__init9(){this.mousemove=n=>{const t=(0,E.V)(n.pageX,n.pageY),e=this.lastPos.to(t);if(1&n.buttons&&!this.pauseCam){const t=e.x/100,o=(0,E.uZ)(this.udRot+e.y/100,.5*-Math.PI,.5*Math.PI);o===this.udRot&&0===t||(this.udRot=o,this.rot+=t,F([this,"access",n=>n.onChange,"optionalCall",n=>n(this.ss)]),n.stopImmediatePropagation(),n.preventDefault())}this.lastPos=t}}__init10(){this.wheel=n=>{const t=(0,E.uZ)(this.dist+n.deltaY,.1,1e3);t!==this.dist&&(this.dist=t,n.stopImmediatePropagation(),n.preventDefault(),F([this,"access",n=>n.onChange,"optionalCall",n=>n(this.ss)]))}}get ss(){return[this.udRot,this.rot,this.dist]}__init11(){this.keydown=n=>{for(const t of K)if(this.keys[t]===n.key)return this.pressedKeys[t]=!0,n.stopImmediatePropagation(),void n.preventDefault()}}__init12(){this.keyup=n=>{for(const t of K)if(this.keys[t]===n.key)return this.pressedKeys[t]=!1,n.stopImmediatePropagation(),void n.preventDefault()}}getLookAt(){return X.getLookAt(this.ss)}static getLookAt([n,t,e]){return E.M4.rotateZ(t).rotateY(n).transform(E.M4.lookAt((0,E.V)(e,0,0),E.V3.O,E.V3.Z))}static invertLookAt(n){const t=n.transposed().scale(-1);return{eye:t.transformVector(n.getTranslation(),!1),dir:t.transformVector(E.V3.Z,!1),up:t.transformVector(E.V3.Y.negated(),!1)}}static toShortString(n,t=100){const[e,o,r]=this.toOrbitCameraState(n),a=(n,t)=>Math.floor(n*t);return a(e,100)+"~"+a(o,100)+"~"+a(r,100)}static fromShortString(n,t=100){const e=(n,t)=>+n/t,[o,r,a]=n.split("~");return[e(o,100),e(r,100),e(a,100)]}}var U=e(5583);function Q(n){let t,e=n[0],o=1;for(;o<n.length;){const r=n[o],a=n[o+1];if(o+=2,("optionalAccess"===r||"optionalCall"===r)&&null==e)return;"access"===r||"optionalAccess"===r?(t=e,e=a(e)):"call"!==r&&"optionalCall"!==r||(e=a(((...n)=>e.call(t,...n))),t=void 0)}return e}function J(n){return{sdf:P.ex.create(e(3363),e(9794),n),singleColor:P.ex.create(e(1507),e(7080),n)}}function nn(n){let t,e=n[0],o=1;for(;o<n.length;){const r=n[o],a=n[o+1];if(o+=2,("optionalAccess"===r||"optionalCall"===r)&&null==e)return;"access"===r||"optionalAccess"===r?(t=e,e=a(e)):"call"!==r&&"optionalCall"!==r||(e=a(((...n)=>e.call(t,...n))),t=void 0)}return e}const tn={a:.2,b:.2,c:.2,d:.2,cam:"999.999.999~-56.-58.-61~-44.-44.79"};function en(n){n.makeCurrent();const t=P.Kj.plane({startX:-1,startY:-1,width:2,height:2});return t.coords=[[-1,-1],[1,-1],[-1,1],[1,1]],t.compile(),{planeMesh:t,shaders:J(n)}}function on(n,{shaders:t,planeMesh:e},o,r,a,i,l){n.makeCurrent();const s=o.inversed();t.sdf.uniforms({colorPrimary:r.primary,colorSecondary:r.secondary,colorBg:r.background,highResTimeStamp:i,secs:i/1e3,gradients:1,extra:l,...a,lll:o,llli:s}).draw(e)}function rn({children:n,label:t,onFocus:e,onBlur:o}){return S.createElement(s.Z,{onFocus:e,onBlur:o,label:t,inputComponent:"textarea",value:n.toString()})}function an(n){let t=0;function e(n){const t=""+n;return t.includes(".")?t:t+".0"}function o([n,t,o]){return"vec3("+e(n)+", "+e(t)+", "+e(o)+")"}const[r,a,i]=function n(r){let a,i,l;function s(n){a="p"+t++,i="d"+t++,l=`float ${i} = ${n(a)};\n`}for(const c of r)if("sphere"===c.type)s((n=>`sdSphere(${e(c.radius)}, ${n})`));else if("box"===c.type)s((n=>`betterBox(${o(c.radius)}, ${n})`));else if("octahedron"===c.type)s((n=>`sdOctahedron(${e(c.radius)}, ${n})`));else if("donut"===c.type)s((n=>`sdDonut(${e(c.r0)}, ${e(c.r1)}, ${n})`));else if("translate"===c.type){const n=a;a="p"+t++,l=`vec3 ${n} = ${a} + ${o(c.by)};\n`+l}else if("expand"===c.type){const n=i;i="d"+t++,l+=`float ${i} = ${n} - ${e(c.by)};\n`}else if("add"===c.type||"sub"===c.type){const[t,e,o]=n(c.what);l=l+`vec3 ${e} = ${a};\n`+t+`${i} = `+("add"===c.type?`min(${i}, ${o})`:`max(${i}, -${o})`)+";\n"}return[l,a,i]}(n);let l=`RMHit sdf(vec3 ${a}) {\n`;return l+=r,l+=`return RMHit(${i}, black);\n`,l+="}\n",l}function ln({value:n,onChange:t}){const e=(0,S.useCallback)((e=>t({...n,radius:+e.target.value},n)),[t]);return S.createElement("div",null,"Sphere"," ",S.createElement(f.Z,{value:n.radius,onChange:e,inputProps:{type:"number"}}))}function sn({value:n,onChange:t}){const e=(0,S.useCallback)((e=>t({...n,radius:e},n)),[n,t]);return S.createElement("div",{style:{display:"flex"}},"Box ",S.createElement(dn,{value:n.radius,onChange:e}))}function cn({value:n,onChange:t}){const e=(0,S.useCallback)((e=>t({...n,by:+e.target.value},n)),[n,t]);return S.createElement("div",{style:{display:"flex"}},"Expand"," ",S.createElement(f.Z,{value:n.by,onChange:e,type:"number",inputProps:{}}))}function dn({value:n,onChange:t,gizmoControl:e}){const r=(0,S.useCallback)((e=>{const o=n.slice();o[e.target.name]=+e.target.value,t(o,n)}),[n,t]),a=(0,S.useCallback)((()=>e.take(n,t)),[e,t,n]);return S.createElement(S.Fragment,null,S.createElement(o.Z,{onClick:a},"X"),[0,1,2].map((t=>S.createElement(f.Z,{key:t,name:""+t,value:n[t],onChange:r,inputProps:{type:"number"}}))))}function fn({value:n,onChange:t,gizmoControl:e}){const o=(0,S.useCallback)((e=>t({...n,by:e},n)),[n,t]);return S.createElement("div",{style:{display:"flex"}},"Translate"," ",S.createElement(dn,{value:n.by,onChange:o,gizmoControl:e}))}function un({value:n,onChange:t,gizmoControl:e}){const o=(0,S.useCallback)((e=>t({...n,[e.target.name]:+e.target.value},n)),[n,t]);return S.createElement("div",{style:{display:"flex"}},"Donut"," ",["r0","r1"].map((t=>S.createElement(f.Z,{key:t,name:t,value:n[t],onChange:o,inputProps:{type:"number"}}))))}function pn({value:n,onChange:t,gizmoControl:e}){const o=(0,S.useCallback)((e=>t({...n,[e.target.name]:+e.target.value},n)),[n,t]);return S.createElement("div",{style:{display:"flex"}},"Octahedron"," ",["radius"].map((t=>S.createElement(f.Z,{key:t,name:t,value:n[t],onChange:o,inputProps:{type:"number"}}))))}function hn({value:n,onChange:t,gizmoControl:e}){const o=(0,S.useCallback)((e=>t({...n,type:e.target.value},n)),[n,t]),r=(0,S.useCallback)((e=>t({...n,what:e},n)),[n,t]);return S.createElement("div",{style:{display:"flex"}},S.createElement(c.Z,{value:n.type,name:"type",onChange:o},S.createElement(l.Z,{value:"add"},"Add"),S.createElement(l.Z,{value:"sub"},"Sub"))," ",S.createElement(vn,{value:n.what,onChange:r,gizmoControl:e}))}function vn({value:n,onChange:t,gizmoControl:e}){const o=(0,S.useCallback)(((e,o)=>t(n.map((n=>n===o?e:n)))),[t,n]);return S.createElement("div",null,n.map(((n,t)=>{const r={sphere:ln,expand:cn,add:hn,sub:hn,box:sn,donut:un,translate:fn,octahedron:pn}[n.type];return r&&S.createElement(r,{key:t,value:n,onChange:o,gizmoControl:e})})))}const mn=()=>{const n=(0,S.useRef)(null),[t,s]=(0,S.useState)(void 0),[f,u]=(0,S.useState)(E.M4.IDENTITY),[p,h]=(0,S.useState)(512),[v,m]=(0,S.useState)(!1),[g,y]=(0,L.q)(tn),x=(0,S.useCallback)((n=>y((t=>({...t,...n})))),[y]),[b,C]=(0,S.useState)(0),[w,_]=(0,S.useState)(0),M=(0,S.useRef)(Object.assign({},g)),O=(0,S.useRef)(),[T,q]=(0,S.useState)([{type:"sphere",radius:1},{type:"translate",by:[1,2,3]},{type:"add",what:[{type:"box",radius:[1,2,3]},{type:"translate",by:[.1,.1,.1]},{type:"expand",by:.3}]},{type:"add",what:[{type:"octahedron",radius:2},{type:"translate",by:[.1,.1,.1]}]},{type:"add",what:[{type:"donut",r0:2,r1:.2},{type:"translate",by:[.1,.1,.1]}]}]),Z=(0,d.Z)(),V=(0,S.useMemo)((()=>({background:z.iv(Z.palette.background.default).gl(),primary:z.iv(Z.palette.primary.main).gl(),secondary:z.iv(Z.palette.secondary.main).gl()})),[Z.palette]),I=(0,S.useCallback)((async([n,t])=>{const e=URL.createObjectURL(await async function([n,t],e,o,r){Q([r,"optionalCall",n=>n(0)]),await(0,U.Z)(10);const a=document.createElement("canvas");a.width=n,a.height=t;const i=200,l=P.ZG.create({canvas:a});l.enable(l.SCISSOR_TEST);const s=e(l);let c=0;for(let e=0;e<n;e+=i)for(let a=0;a<t;a+=i){const d=Math.min(i,n-e),f=Math.min(i,t-a);l.scissor(e,a,d,f),o(l,s),await(0,U.Z)(0),c+=d*f,Q([r,"optionalCall",e=>e(c/(n*t))])}return new Promise(((n,t)=>a.toBlob((e=>e?n(e):t("error")),"png")))}([n,t],en,((e,o)=>{on(e,o,E.M4.product(E.M4.perspective(70,n/t,.1,50),X.getLookAt(X.fromShortString(g.cam))),V,g,2e3,f.getTranslation())}),s));s(void 0),(0,H.YQ)(e)}),[f,V,g]);(0,S.useEffect)((()=>{console.log("creating context");const t=P.ZG.create({canvas:n.current,alpha:!0,premultipliedAlpha:!0,throwOnError:!0});return console.log(t.getParameter(t.MAX_SAMPLES)),O.current=function(n,t,o,r,a,i,l,s,c){n.canvas.addEventListener("keydown",(n=>"r"===n.key&&I([1920,1080])));const d=new X(i);let f=E.M4.IDENTITY;const u=new W(n,E.M4.rotateZ(20*E.Co).translate(5,5,1),l,(()=>d.pauseCam=!0),(()=>d.pauseCam=!1),s);u.registerListeners(n.canvas,(()=>f)),n.clearColor(...t.background),n.clearColor(0,0,0,1),n.clear(n.COLOR_BUFFER_BIT),n.cullFace(n.BACK),n.pointSize(10),n.disable(n.CULL_FACE),n.disable(n.DEPTH_TEST),n.disable(n.BLEND),n.blendFunc(n.ONE,n.ONE),n.blendEquation(n.FUNC_ADD),n.canvas.contentEditable="true",n.canvas.focus(),d.registerListeners(n.canvas);const p=new Y(r),h=en(n);return{updateShader(n){h.shaders.ed=P.ex.create(e(3363),n)},teardown:n.animate((function(e,r){n.clear(n.COLOR_BUFFER_BIT),n.makeCurrent(),d.tick(),p.tick(e),f=E.M4.product(E.M4.perspective(70,n.canvas.offsetWidth/n.canvas.offsetHeight,.1,50),d.getLookAt()),on(n,h,f,t,o,e,u.pos.getTranslation()),n.matrixMode(n.PROJECTION),n.loadMatrix(f),n.matrixMode(n.MODELVIEW),n.loadIdentity(),u.render(h.shaders.singleColor)})),setCam:d.setState}}(t,V,M.current,_,0,(0,k.debounce)((n=>{x({cam:X.toShortString(n)})})),C,u),()=>{nn([O,"access",n=>n.current,"optionalAccess",n=>n.teardown,"call",n=>n()])}}),[]),(0,S.useEffect)((()=>{}),[g.cam]),(0,S.useEffect)((()=>{nn([O,"access",n=>n.current,"optionalAccess",n=>n.updateShader,"call",n=>n("#version 300 es\n\nprecision highp float;\n#define GLSLIFY 1\n\nfloat hue2rgb(float f1, float f2, float hue) {\n    if (hue < 0.0)\n        hue += 1.0;\n    else if (hue > 1.0)\n        hue -= 1.0;\n    float res;\n    if ((6.0 * hue) < 1.0)\n        res = f1 + (f2 - f1) * 6.0 * hue;\n    else if ((2.0 * hue) < 1.0)\n        res = f2;\n    else if ((3.0 * hue) < 2.0)\n        res = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;\n    else\n        res = f1;\n    return res;\n}\n\nvec3 hsl2rgb(vec3 hsl) {\n    vec3 rgb;\n    \n    if (hsl.y == 0.0) {\n        rgb = vec3(hsl.z); // Luminance\n    } else {\n        float f2;\n        \n        if (hsl.z < 0.5)\n            f2 = hsl.z * (1.0 + hsl.y);\n        else\n            f2 = hsl.z + hsl.y - hsl.y * hsl.z;\n            \n        float f1 = 2.0 * hsl.z - f2;\n        \n        rgb.r = hue2rgb(f1, f2, hsl.x + (1.0/3.0));\n        rgb.g = hue2rgb(f1, f2, hsl.x);\n        rgb.b = hue2rgb(f1, f2, hsl.x - (1.0/3.0));\n    }   \n    return rgb;\n}\n\nvec3 hsl2rgb(float h, float s, float l) {\n    return hsl2rgb(vec3(h, s, l));\n}\n\nfloat banded(float bandCount, float t) {\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\n}\nfloat banded(int bandCount, float t) {\n  return banded(float(bandCount), t);\n}\n\nbool between(float min, float max, float value) {\n  return min <= value && value <= max;\n}\n\nvec2 hex2Ra(vec3 hex) {\n  float y = hex.t * 0.866;\n  float x = hex.s + hex.t / 2.0;\n  return vec2(x, y);\n}\n\nvec3 hexRound(vec3 hex) {\n  vec3 r = floor(hex + 0.5);\n  vec3 diff = abs(r - hex);\n\n  if (diff.x > diff.y && diff.x > diff.z) {\n    r.x = -(r.y + r.z);\n  } else if (diff.y > diff.z) {\n    r.y = -(r.x + r.z);\n  } else {\n    r.z = -(r.x + r.y);\n  }\n\n  return r;\n}\n\nfloat max3(float a, float b, float c) {\n  return max(a, max(b, c));\n}\nfloat max3(vec3 v) {\n  return max(v.x, max(v.y, v.z));\n}\n\nfloat hexSdf(vec3 hex) {\n  return max3(abs(hex.yzx + hex.zxy / 2.0));\n}\n\nuniform sampler2D gradients;\n\nfloat dotGridGradient(vec2 cell, vec2 pos) {\n  vec2 d = cell - pos;\n\n  vec2 gradient = texelFetch(gradients, ivec2(cell), 0).xy;\n  return dot(gradient, d);\n}\n\nfloat mixx(float a, float b, float t) {\n  return mix(a, b, smoothstep(0.0, 1.0, t));\n  //    return mix(a, b, t);\n}\n\n// resulting range is [-0.68, 0.68]. Use unmix to normalize if necessary.\nfloat perlin2D(vec2 xy) {\n  float x0 = floor(xy.x);\n  float x1 = x0 + 1.0;\n  float y0 = floor(xy.y);\n  float y1 = y0 + 1.0;\n\n  // Interpolate between grid point gradients\n  float n00 = dotGridGradient(vec2(x0, y0), xy);\n  float n10 = dotGridGradient(vec2(x1, y0), xy);\n  float ny0 = mixx(n00, n10, xy.x - x0);\n\n  float n01 = dotGridGradient(vec2(x0, y1), xy);\n  float n11 = dotGridGradient(vec2(x1, y1), xy);\n  float ny1 = mixx(n01, n11, xy.x - x0);\n\n  return mixx(ny0, ny1, xy.y - y0);\n}\n\nfloat unmix(float a, float b, float value) {\n  return (value - a) / (b - a);\n}\n\nvec3 fromPolar(float radius, float phi, float z) {\n  return vec3(radius * cos(phi), radius * sin(phi), z);\n}\n\nvec2 fromPolar(float radius, float phi) {\n  return vec2(radius * cos(phi), radius * sin(phi));\n}\n\nvec2 fromPolar(vec2 polar) {\n  return fromPolar(polar.x, polar.y);\n}\n\nvec2 toPolar(vec2 xy) {\n  return vec2(length(xy), atan(xy.y, xy.x));\n}\n\nvec3 raToHex(vec2 xy) {\n  float hex_t = xy.y / 0.866;\n  float hex_s = xy.x - hex_t / 2.0;\n  return vec3(hex_s, hex_t, -(hex_s + hex_t));\n}\n\nfloat remix(float fromA, float fromB, float toA, float toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\nvec4 remix(float fromA, float fromB, vec4 toA, vec4 toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\nconst vec4 blue_0 = vec4(0.0, 0.0, 1.0, 1.0);\nconst vec4 red_0 = vec4(1.0, 0.0, 0.0, 1.0);\n\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\n  float isLow = float(t < 0.0);\n  float isHigh = float(t > 1.0);\n  float isMid = 1.0 - isLow - isHigh;\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\n}\n\nvec4 visualize(float t) {\n  return visualize(blue_0, red_0, t);\n}\n\nuniform float highResTimeStamp_0;\n\nfloat waves(vec4 color, vec2 position, vec2 direction) {\n  return sin(\n    dot(position, direction / pow(length(direction), 2.0)) +\n      float(highResTimeStamp_0) / 200.0\n  );\n}\n\nmat3 rotX(float angle) {\n  float c = cos(angle),\n    s = sin(angle);\n  return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\n}\n\nmat3 rotY(float angle) {\n  float c = cos(angle),\n    s = sin(angle);\n  return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\n}\n\nmat3 rotZ(float angle) {\n  float c = cos(angle),\n    s = sin(angle);\n  return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\n}\n\nfloat sdDonut(float r0, float r1, vec3 p) {\n  vec3 closestCenter = vec3(normalize(p.xy) * r0, 0.0);\n  return distance(closestCenter, p) - r1;\n}\n\nfloat sdCapsule(vec3 a, vec3 b, float r, vec3 p) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h) - r;\n}\n\nvec3 opElongate(vec3 h, vec3 p) {\n  return p - clamp(p, -h, h);\n}\n\nfloat sdSphere(float radius, vec3 p) {\n  return length(p) - radius;\n}\n\nfloat sdCylinder(float radius, float height, vec3 p) {\n  vec2 d = vec2(length(p.xy), abs(p.z)) - vec2(radius, height);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nconst float SQRT1_2_1921068617 = 0.7071067811865476;\n\nfloat addChamfer(float d, float a, float b) {\n  float tillet = (a + b - d) * SQRT1_2_1921068617;\n  return min(tillet, min(a, b));\n}\n\nfloat addTillet(float r, float a, float b) {\n  if (a < r && b < r) {\n    return r - distance(vec2(a, b), vec2(r));\n  } else {\n    return min(a, b);\n  }\n}\n\nfloat sdBox(vec3 r, vec3 p) {\n  vec3 q = abs(p) - r;\n  return length(max(q, 0.0)) + min(max3(q), 0.0);\n}\n\nfloat sdBox(vec3 r, float r2, vec3 p) {\n  return sdBox(r - r2, p) - r2;\n}\n\nfloat sdOctahedron(float s, vec3 p) {\n  p = abs(p);\n  float m = p.x + p.y + p.z - s;\n  vec3 q;\n  if (3.0 * p.x < m) q = p.xyz;\n  else if (3.0 * p.y < m) q = p.yzx;\n  else if (3.0 * p.z < m) q = p.zxy;\n  else return m * 0.57735027;\n\n  float k = clamp(0.5 * (q.z - q.y + s), 0.0, s);\n  return length(vec3(q.x, q.y - s + k, q.z - k));\n}\n\nfloat sdOctahedron(vec3 p, float s) {\n  p = abs(p);\n\n  float m = p.x + p.y + p.z - s;\n  //find point on octohedron surf nearest to p\n  vec3 projPoint = p - vec3(0.333333 * m); //project onto surface plane\n  //now push projected point, if outside triangle edge, perpendicular to edge, to edge\n  vec3 toMove = min(projPoint, 0.0); //if projpoint.x<0 move along (1.0,-0.5,-0.5) , etc\n  float toMoveSum = dot(toMove, vec3(1.0)); //which is basically along (1.5,0,0) then vec3(-0.5)\n\n  vec3 movedPoint = projPoint + toMove * vec3(-1.5) + toMoveSum * vec3(0.5); //better to multiply toMove by a matrix (1s diagonal, 0.5 other)?\n\n  movedPoint = max(movedPoint, 0.0); //cap x,y,z to 0 then\n  movedPoint *= s / dot(movedPoint, vec3(1.0)); //scale about 0,0,0\n\n  return length(p - movedPoint);\n}\n\nfloat add(float a, float b) {\n  return min(a, b);\n}\n\nfloat sub(float from, float what) {\n  return max(from, -what);\n}\n\nuniform sampler2D texture;\nuniform float secs;\nuniform mat4 lll;\nuniform mat4 llli;\nuniform vec4 colorPrimary;\nuniform vec4 colorSecondary;\nuniform vec4 colorBg;\nuniform float a;\nuniform float b;\nuniform float c;\nuniform float d;\nuniform float highResTimeStamp;\nuniform int bandCount;\nuniform vec3 extra;\nuniform vec3 campos;\nin float n;\nin vec2 coord;\nout vec4 fragColor;\n\nconst float TAU = 6.283185307179586;\nconst float SQRT1_2 = 0.7071067811865476;\nconst float SQRT2 = 1.4142135623730951;\nconst float PI = 3.141592653589793;\n\nconst vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\nconst vec4 yellow = vec4(1.0, 1.0, 0.0, 1.0);\nconst vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\nconst vec4 blue = vec4(0.0, 0.0, 1.0, 1.0);\nconst vec4 purple = vec4(0.5, 0.0, 0.5, 1.0);\nconst vec4 red = vec4(1.0, 0.0, 0.0, 1.0);\n\nstruct RMHit {\n  float distance;\n  vec4 color;\n};\nRMHit mixa(RMHit a, RMHit b, float t) {\n  return RMHit(mix(a.distance, b.distance, t), mix(a.color, b.color, t));\n}\nfloat skybox(vec3 p) {\n  return 32.0 - max3(abs(p));\n}\n\nfloat perlinSphere(float radius, vec3 p) {\n  vec3 cp = normalize(p);\n  float alpha = atan(cp.y, cp.x);\n  float beta = asin(cp.z);\n  return length(p) -\n  radius +\n  0.1 *\n    perlin2D(vec2(0.0 / 100.0, 0.0) + (vec2(5.0) + vec2(alpha, beta)) * 8.0);\n}\n\nfloat cylCircle(vec3 p) {\n  float d = 10e9;\n  for (int i = 0; i < 10; i++) {\n    d = min(\n      d,\n      sdCylinder(0.2, 2.0, p + fromPolar(3.0, TAU * float(i) / 10.0, 1.0))\n    );\n  }\n\n  return d;\n}\n\nfloat rblock(float r, out vec3 p) {\n  return sdBox(vec3(r), p);\n}\n\nRMHit add(RMHit a, RMHit b) {\n  //    return a.distance < b.distance\n  //        ? RMHit(a.distance, a.color)\n  //        : RMHit(b.distance, b.color);\n  return mixa(a, b, float(b.distance < a.distance));\n}\n\nfloat wtf(vec3 p) {\n  vec3 center = p - mod(p, 3.0) + vec3(1.5);\n  return rblock(0.4 + 0.3 * sin(secs + center.x), center);\n}\n\nRMHit addTillet(float r, RMHit a, RMHit b) {\n  if (a.distance < r && b.distance < r) {\n    return RMHit(\n      r - distance(vec2(a.distance, b.distance), vec2(r)),\n      mix(a.color, b.color, (a.distance - b.distance) / r * 0.5 + 0.5)\n    );\n  } else {\n    return add(a, b);\n  }\n}\n\nRMHit addTillet(float r, RMHit a, RMHit b, vec4 tilletColor) {\n  if (a.distance < r && b.distance < r) {\n    return RMHit(\n      r - distance(vec2(a.distance, b.distance), vec2(r)),\n      tilletColor\n    );\n  } else {\n    return add(a, b);\n  }\n}\nRMHit addTillet2(float r, RMHit a, RMHit b) {\n  float h = smoothstep(-r, r, a.distance - b.distance);\n  return RMHit(\n    mix(a.distance, b.distance, h) - r * h * (1.0 - h),\n    mix(a.color, b.color, h)\n  );\n}\n\nRMHit neg(RMHit a) {\n  return RMHit(-a.distance, a.color);\n}\nRMHit sub(RMHit from, RMHit what) {\n  RMHit whatNeg = neg(what);\n  return mixa(from, whatNeg, float(whatNeg.distance > from.distance));\n}\n\nvec3 modv(vec3 v, vec3 dir1, float y) {\n  float t = dot(v, dir1);\n  return v - floor(t / y) * y * dir1;\n}\nvec3 modRotZ(vec3 p, float count) {\n  vec2 polarXY = toPolar(p.xy);\n  return fromPolar(polarXY.x, mod(polarXY.y, TAU / count), p.z);\n}\n\nfloat sin01(float x) {\n  return 0.5 + 0.5 * sin(x);\n}\nfloat cos01(float x) {\n  return 0.5 + 0.5 * cos(x);\n}\n\nfloat betterBox(vec3 r, vec3 p) {\n  vec3 q = abs(p) - r;\n  return length(max(q, 0.0)) + min(max3(q), 0.0);\n  p = abs(p);\n  return max3(p - r);\n}\n\nfloat sdConeB(vec2 c, float h, vec3 p) {\n  float q = length(p.xz);\n  return max(dot(c.xy, vec2(q, p.y)), -h - p.y);\n}\n\nfloat sdCone(vec2 c, float h, vec3 p) {\n  vec2 q = h * vec2(c.x / c.y, -1.0);\n  vec2 w = vec2(length(p.xz), p.y);\n  vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);\n  vec2 b = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0);\n  float k = sign(q.y);\n  float d = min(dot(a, a), dot(b, b));\n  float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));\n  return sqrt(d) * sign(s);\n}\n\nfloat sdEllipsoidB(vec3 r, vec3 p) {\n  float k0 = length(p / r);\n  float k1 = length(p / (r * r));\n  return k0 * (k0 - 1.0) / k1;\n}\nfloat sdOctahedronB(float s, vec3 p) {\n  p = abs(p);\n  return (p.x + p.y + p.z - s) * 0.57735027;\n}\nfloat donutc(float r0, float r1, vec3 p) {\n  vec3 closestCenter = vec3(normalize(p.xy) * r0, 0.0);\n  return distance(closestCenter, p) - r1;\n}\n\nfloat smoothmin(float r, float a, float b) {\n  float h = smoothstep(-r, r, a - b);\n  return mix(a, b, h) - r * h * (1.0 - h);\n}\n\nRMHit sdf(vec3 p) {\n  return RMHit(0.0, black);\n}\n\nfloat sdff(vec3 p) {\n  return sdf(p).distance;\n}\n\nstruct RMResult {\n  float distance;\n  vec3 pos;\n  vec4 color;\n};\nRMResult raymarching2(vec3 start, vec3 dir1) {\n  vec3 pos = start;\n  RMHit hit;\n  for (int i = 0; i < 200; i++) {\n    hit = sdf(pos);\n    if (hit.distance < 0.0001) break;\n    pos = pos + dir1 * hit.distance;\n  }\n  return RMResult(hit.distance, pos, hit.color);\n}\nvec3 pt(mat4 pm, vec3 p) {\n  vec4 pStar = pm * vec4(p, 1.0);\n  return pStar.xyz / pStar.w;\n}\n\nfloat softshadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {\n  float res = 1.0;\n  float t = 0.1;\n  for (int i = 0; i < 1000 && t < maxt; i++) {\n    float h = sdff(ro + rd * t);\n    if (h < 0.001) return 0.0;\n    res = min(res, k * h / t);\n    t += h;\n  }\n  return res;\n}\n\nconst float eps = 1e-4;\nvec3 sdfNormal1(vec3 p, float d) {\n  return normalize(\n    vec3(\n      sdff(p + vec3(eps, 0.0, 0.0)),\n      sdff(p + vec3(0.0, eps, 0.0)),\n      sdff(p + vec3(0.0, 0.0, eps))\n    ) -\n      sdff(p)\n  );\n}\n\nfloat ambientOcclusion(vec3 pWC, vec3 n1WC) {\n  float k = 1.0;\n  float distance = sdff(pWC + n1WC * k);\n  return clamp(distance / k, 0.0, 1.0);\n}\n\n//layout (depth_greater) out float gl_FragDepth;\nvoid main() {\n  vec3 light = normalize(vec3(-1.0, -2.0, -2));\n\n  vec3 a = vec3(coord, -1.0);\n  vec3 b = vec3(coord, 1.0);\n  vec3 aWC = pt(llli, a);\n  vec3 bWC = pt(llli, b);\n  vec3 lookDir1 = normalize(bWC - aWC);\n\n  RMResult hitWC = raymarching2(aWC, lookDir1);\n  vec3 hitn1 = sdfNormal1(hitWC.pos, hitWC.distance);\n  float dWC = distance(aWC, hitWC.pos);\n  vec3 hitNDC = pt(lll, hitWC.pos);\n\n  vec3 sunPoint = raymarching2(hitWC.pos + hitn1 * 0.1, -light).pos;\n  //    float inSun = float(distance(hitWC.pos, sunPoint) > 30.);\n  float inSun = softshadow(\n    hitWC.pos + hitn1 * 0.05,\n    -light,\n    0.0001,\n    300.0,\n    8.0\n  );\n  //    float inSun=1.;\n\n  vec3 material = vec3(0.0, 0.2, 0.0);\n  if (dWC > 100.0) {\n    material = vec3(0.0, 0.0, 0.0);\n  }\n\n  const vec3 sunlightColor = vec3(8.0, 6.0, 1.0);\n\n  float aOcc = ambientOcclusion(hitWC.pos, hitn1);\n\n  vec3 reflectionDirection = reflect(light, hitn1);\n\n  vec3 color = vec3(0.0);\n  color += material * aOcc;\n  color += inSun * sunlightColor * material * max(0.0, dot(-light, hitn1));\n  //    color = (hitn1);\n\n  vec3 camPos = aWC;\n\n  vec3 eyeDirection = -lookDir1;\n  float uMaterialShininess = 256.0;\n  float specularLightWeighting = pow(\n    max(dot(reflectionDirection, eyeDirection), 0.0),\n    uMaterialShininess\n  );\n  color += specularLightWeighting;\n  //    float lightIntensity = 0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.);\n  //    float lightIntensity =\n  //        0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.) + 0.3*specularLightWeighting;\n  //    fragColor = visualize(blue, red, mix(0.5, 1.0, inSun) * lightIntensity);\n  //    fragColor = mix(hitWC.color, colorBg, mix(0.5, 1.0, inSun) * clamp(lightIntensity, 0., 1.));\n  color = pow(color, vec3(1.0 / 2.2)); // gamma correction\n  fragColor = vec4(color, 1.0);\n  //    fragColor = visualize(hitWC.pos.x/10.);\n  //    fragColor = hitWC.color;\n  //    fragColor = visualize(blue, red, distance(hitWC, sunPoint)/20.);\n  //    fragColor = vec4(coord,0.,1.);\n  //    fragColor = vec4(aWC, 1.0);\n  // remap [-1, 1] to [0, 1]\n  // gl_FragDepth = hitNDC.z * 0.5 + 0.5;\n  //    gl_FragDepth = .9999999;\n}\n".replace(/RMHit sdf\(vec3 p\) {[\s\S]*?}/,an(T)))])}),[T]),(0,S.useEffect)((()=>{Object.assign(M.current,g)}),[g]);const B=(0,S.useCallback)((({dim:n,children:e})=>{return S.createElement(o.Z,{variant:"contained",onClick:()=>I(n),disabled:void 0!==t},void 0===t?e:"Rendering... "+(r=""+Math.floor(100*t),R.format(r,"monospace")).padStart(3," ")+"%");var r}),[I,t]);function D({cam:n}){const t=$.fromShortString(n);x({cam:X.toShortString(t)})}return S.createElement(i.ZP,{container:!0,style:{height:"99%"}},S.createElement(i.ZP,{item:!0,xs:12,md:9},S.createElement("div",{style:{height:"100%"}},S.createElement("canvas",{ref:n,style:{width:"100%",height:"100%",cursor:0===b?"move":"grab"},width:p,height:p,tabIndex:0}))),S.createElement(i.ZP,{item:!0,xs:12,md:3,sx:{display:"flex",flexDirection:"column",width:"100%",padding:2,alignItems:"stretch",gap:2}},S.createElement(r.Z,null,S.createElement(a.Z,null,"Raymarching demo.")),S.createElement(c.Z,{onChange:n=>h(+n.target.value),value:p},S.createElement(l.Z,{value:256},"256x256"),S.createElement(l.Z,{value:512},"512x512")),S.createElement(A,{state:g,setStatePartial:x,prop:"a",inputProps:{step:.05}})," ",S.createElement(A,{state:g,setStatePartial:x,prop:"b",inputProps:{step:.05}}),S.createElement(A,{state:g,setStatePartial:x,prop:"c",inputProps:{step:.05}})," ",S.createElement(A,{state:g,setStatePartial:x,prop:"d",inputProps:{step:.05}}),S.createElement(B,{dim:[1920,1080]},"render hd"),S.createElement(B,{dim:[3840,2160]},"render 4k"),S.createElement(o.Z,{color:"secondary",variant:"outlined",onClick:()=>D({cam:"999.999.999~-56.-58.-61~-44.-44.79"})},"Cam 0"),S.createElement(o.Z,{color:"secondary",variant:"outlined",onClick:()=>D({cam:"57.427.96~1.-100.-8~7.-7.99"})},"Cam 1"),S.createElement(o.Z,{color:"secondary",variant:"outlined",onClick:()=>D({cam:"53.80.892~-9.-8.-100~-18.-99.8"})},"Cam 2"),S.createElement("div",null,"cam: ",g.cam),S.createElement("div",null,"fps: ",w),S.createElement(rn,{label:"gp",onFocus:()=>setEditing(!0),onBlur:()=>setEditing(!1)},f),S.createElement("div",null,S.createElement(vn,{value:T,onChange:q})),S.createElement("div",null,S.createElement("pre",null,S.createElement("code",null,an(T))))))}},5069:(n,t,e)=>{e.d(t,{Z:()=>m});var o=e(7692),r=e(1972),a=e(9526),i=(e(2652),e(3060)),l=e(6031),s=e(7014),c=e(7260),d=e(3172),f=e(4969);function u(n){return(0,f.Z)("MuiCard",n)}(0,e(2926).Z)("MuiCard",["root"]);var p=e(7557);const h=["className","raised"],v=(0,s.ZP)(d.Z,{name:"MuiCard",slot:"Root",overridesResolver:(n,t)=>t.root})((()=>({overflow:"hidden"}))),m=a.forwardRef((function(n,t){const e=(0,c.Z)({props:n,name:"MuiCard"}),{className:a,raised:s=!1}=e,d=(0,r.Z)(e,h),f=(0,o.Z)({},e,{raised:s}),m=(n=>{const{classes:t}=n;return(0,l.Z)({root:["root"]},u,t)})(f);return(0,p.jsx)(v,(0,o.Z)({className:(0,i.Z)(m.root,a),elevation:s?8:void 0,ref:t,ownerState:f},d))}))},4854:(n,t,e)=>{e.d(t,{Z:()=>v});var o=e(7692),r=e(1972),a=e(9526),i=(e(2652),e(3060)),l=e(6031),s=e(7014),c=e(7260),d=e(4969);function f(n){return(0,d.Z)("MuiCardContent",n)}(0,e(2926).Z)("MuiCardContent",["root"]);var u=e(7557);const p=["className","component"],h=(0,s.ZP)("div",{name:"MuiCardContent",slot:"Root",overridesResolver:(n,t)=>t.root})((()=>({padding:16,"&:last-child":{paddingBottom:24}}))),v=a.forwardRef((function(n,t){const e=(0,c.Z)({props:n,name:"MuiCardContent"}),{className:a,component:s="div"}=e,d=(0,r.Z)(e,p),v=(0,o.Z)({},e,{component:s}),m=(n=>{const{classes:t}=n;return(0,l.Z)({root:["root"]},f,t)})(v);return(0,u.jsx)(h,(0,o.Z)({as:s,className:(0,i.Z)(m.root,a),ownerState:v,ref:t},d))}))},3363:n=>{n.exports="#version 300 es\nprecision highp float;\n#define GLSLIFY 1\n\nin vec4 ts_Vertex;\nin vec2 ts_TexCoord;\nout vec2 coord;\nvoid main() {\n  gl_Position = ts_Vertex;\n  coord = ts_TexCoord;\n}\n"},9794:n=>{n.exports="#version 300 es\n\nprecision highp float;\n#define GLSLIFY 1\n\nfloat hue2rgb(float f1, float f2, float hue) {\n    if (hue < 0.0)\n        hue += 1.0;\n    else if (hue > 1.0)\n        hue -= 1.0;\n    float res;\n    if ((6.0 * hue) < 1.0)\n        res = f1 + (f2 - f1) * 6.0 * hue;\n    else if ((2.0 * hue) < 1.0)\n        res = f2;\n    else if ((3.0 * hue) < 2.0)\n        res = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;\n    else\n        res = f1;\n    return res;\n}\n\nvec3 hsl2rgb(vec3 hsl) {\n    vec3 rgb;\n    \n    if (hsl.y == 0.0) {\n        rgb = vec3(hsl.z); // Luminance\n    } else {\n        float f2;\n        \n        if (hsl.z < 0.5)\n            f2 = hsl.z * (1.0 + hsl.y);\n        else\n            f2 = hsl.z + hsl.y - hsl.y * hsl.z;\n            \n        float f1 = 2.0 * hsl.z - f2;\n        \n        rgb.r = hue2rgb(f1, f2, hsl.x + (1.0/3.0));\n        rgb.g = hue2rgb(f1, f2, hsl.x);\n        rgb.b = hue2rgb(f1, f2, hsl.x - (1.0/3.0));\n    }   \n    return rgb;\n}\n\nvec3 hsl2rgb(float h, float s, float l) {\n    return hsl2rgb(vec3(h, s, l));\n}\n\nfloat banded(float bandCount, float t) {\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\n}\nfloat banded(int bandCount, float t) {\n  return banded(float(bandCount), t);\n}\n\nbool between(float min, float max, float value) {\n  return min <= value && value <= max;\n}\n\nfloat unmix(float a, float b, float value) {\n  return (value - a) / (b - a);\n}\n\nvec3 fromPolar(float radius, float phi, float z) {\n  return vec3(radius * cos(phi), radius * sin(phi), z);\n}\n\nvec2 fromPolar(float radius, float phi) {\n  return vec2(radius * cos(phi), radius * sin(phi));\n}\n\nvec2 fromPolar(vec2 polar) {\n  return fromPolar(polar.x, polar.y);\n}\n\nvec2 hex2Ra(vec3 hex) {\n  float y = hex.t * 0.866;\n  float x = hex.s + hex.t / 2.0;\n  return vec2(x, y);\n}\n\nvec3 hexRound(vec3 hex) {\n  vec3 r = floor(hex + 0.5);\n  vec3 diff = abs(r - hex);\n\n  if (diff.x > diff.y && diff.x > diff.z) {\n    r.x = -(r.y + r.z);\n  } else if (diff.y > diff.z) {\n    r.y = -(r.x + r.z);\n  } else {\n    r.z = -(r.x + r.y);\n  }\n\n  return r;\n}\n\nfloat max3(float a, float b, float c) {\n  return max(a, max(b, c));\n}\nfloat max3(vec3 v) {\n  return max(v.x, max(v.y, v.z));\n}\n\nfloat hexSdf(vec3 hex) {\n  return max3(abs(hex.yzx + hex.zxy / 2.0));\n}\n\nuniform sampler2D gradients;\n\nfloat dotGridGradient(vec2 cell, vec2 pos) {\n  vec2 d = cell - pos;\n\n  vec2 gradient = texelFetch(gradients, ivec2(cell), 0).xy;\n  return dot(gradient, d);\n}\n\nfloat mixx(float a, float b, float t) {\n  return mix(a, b, smoothstep(0.0, 1.0, t));\n  //    return mix(a, b, t);\n}\n\n// resulting range is [-0.68, 0.68]. Use unmix to normalize if necessary.\nfloat perlin2D(vec2 xy) {\n  float x0 = floor(xy.x);\n  float x1 = x0 + 1.0;\n  float y0 = floor(xy.y);\n  float y1 = y0 + 1.0;\n\n  // Interpolate between grid point gradients\n  float n00 = dotGridGradient(vec2(x0, y0), xy);\n  float n10 = dotGridGradient(vec2(x1, y0), xy);\n  float ny0 = mixx(n00, n10, xy.x - x0);\n\n  float n01 = dotGridGradient(vec2(x0, y1), xy);\n  float n11 = dotGridGradient(vec2(x1, y1), xy);\n  float ny1 = mixx(n01, n11, xy.x - x0);\n\n  return mixx(ny0, ny1, xy.y - y0);\n}\n\nvec3 raToHex(vec2 xy) {\n  float hex_t = xy.y / 0.866;\n  float hex_s = xy.x - hex_t / 2.0;\n  return vec3(hex_s, hex_t, -(hex_s + hex_t));\n}\n\nfloat remix(float fromA, float fromB, float toA, float toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\nvec4 remix(float fromA, float fromB, vec4 toA, vec4 toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\nmat3 rotX(float angle) {\n  float c = cos(angle),\n    s = sin(angle);\n  return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\n}\n\nmat3 rotY(float angle) {\n  float c = cos(angle),\n    s = sin(angle);\n  return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\n}\n\nmat3 rotZ(float angle) {\n  float c = cos(angle),\n    s = sin(angle);\n  return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\n}\n\nvec2 toPolar(vec2 xy) {\n  return vec2(length(xy), atan(xy.y, xy.x));\n}\n\nconst vec4 blue_0 = vec4(0.0, 0.0, 1.0, 1.0);\nconst vec4 red_0 = vec4(1.0, 0.0, 0.0, 1.0);\n\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\n  float isLow = float(t < 0.0);\n  float isHigh = float(t > 1.0);\n  float isMid = 1.0 - isLow - isHigh;\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\n}\n\nvec4 visualize(float t) {\n  return visualize(blue_0, red_0, t);\n}\n\nuniform float highResTimeStamp_0;\n\nfloat waves(vec4 color, vec2 position, vec2 direction) {\n  return sin(\n    dot(position, direction / pow(length(direction), 2.0)) +\n      float(highResTimeStamp_0) / 200.0\n  );\n}\n\nfloat add(float a, float b) {\n  return min(a, b);\n}\n\nconst float SQRT1_2_2197045468 = 0.7071067811865476;\n\nfloat addChamfer(float d, float a, float b) {\n  float tillet = (a + b - d) * SQRT1_2_2197045468;\n  return min(tillet, min(a, b));\n}\n\nfloat addTillet(float r, float a, float b) {\n  if (a < r && b < r) {\n    return r - distance(vec2(a, b), vec2(r));\n  } else {\n    return min(a, b);\n  }\n}\n\nvec3 opElongate(vec3 h, vec3 p) {\n  return p - clamp(p, -h, h);\n}\n\nvec3 opRepLim(vec3 p, vec3 cellSize, vec3 limit) {\n  return p - cellSize * clamp(round(p / cellSize), vec3(0.0), limit);\n}\nvec2 opRepLim(vec2 p, vec2 cellSize, vec2 limit) {\n  return p - cellSize * clamp(round(p / cellSize), vec2(0.0), limit);\n}\nfloat opRepLim(float p, float cellSize, float limit) {\n  return p - cellSize * clamp(round(p / cellSize), 0.0, limit);\n}\n\nfloat sdBox(vec3 r, vec3 p) {\n  vec3 q = abs(p) - r;\n  return length(max(q, 0.0)) + min(max3(q), 0.0);\n}\n\nfloat sdBox(vec3 r, float r2, vec3 p) {\n  return sdBox(r - r2, p) - r2;\n}\n\nfloat sdCylinder(float radius, float height, vec3 p) {\n  vec2 d = vec2(length(p.xy), abs(p.z)) - vec2(radius, height);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdDonut(float r0, float r1, vec3 p) {\n  vec3 closestCenter = vec3(normalize(p.xy) * r0, 0.0);\n  return distance(closestCenter, p) - r1;\n}\n\nconst float GOLDEN_RATIO_2645608689 = 1.61803398875;\n// NN = 1/GOLDEN_RATIO = GOLDEN_RATIO - 1\nconst float K = GOLDEN_RATIO_2645608689 * 0.5;\n// the three vertices of the icosahedron triangle which\n// is fully inside the +++ octant. (edge length = 1)\nconst vec3 a_0 = vec3(0.5, K, 0.0);\nconst vec3 b_0 = vec3(0.0, 0.5, K);\nconst vec3 c_0 = vec3(K, 0.0, 0.5);\nconst vec3 ab1 = b_0 - a_0; // values chosen so edge length is 1\nconst vec3 n1 = normalize(cross(a_0, b_0));\nconst vec3 n2 = normalize(cross(b_0, c_0));\nconst vec3 n3 = normalize(cross(c_0, a_0));\nconst vec3 xyz1 = normalize(vec3(1.0));\n// for edge-length 1\nconst float INSCRIBED_SPHERE_RADIUS_2645608689 = 0.7557613141;\n\n// signed distance function for icosahedron\n// cf. https://en.wikipedia.org/wiki/Regular_icosahedron\n// s: edge length\n// p: point to evaluate function for\nfloat sdIcosahedron(float s, vec3 p) {\n  // we use a rotation where the icosahedron is symmetric\n  // in all three coordinate planes, and reduce the problem\n  // to the +++ octant\n  p = abs(p);\n\n  // there is one complete triangle in the +++ octant\n  // mirror on planes which go through origin and the\n  // complete triangles sides.\n  if (dot(p, n1) < 0.0) {\n    p += -2.0 * dot(p, n1) * n1;\n  }\n  if (dot(p, n2) < 0.0) {\n    p += -2.0 * dot(p, n2) * n2;\n  }\n  if (dot(p, n3) < 0.0) {\n    p += -2.0 * dot(p, n3) * n3;\n  }\n\n  // rotate space around (1,1,1) vector so that all sides of the triangle\n  // end up mapped on the ab side.\n  vec3 dirs = vec3(-dot(n1, p), -dot(n2, p), -dot(n3, p));\n  if (dirs.y > dirs.x && dirs.y > dirs.z) {\n    p = p.yzx;\n  } else if (dirs.z > dirs.x && dirs.z > dirs.y) {\n    p = p.zxy;\n  }\n\n  // check if the point is directly (perpendicular) above the triangle.\n  // as we have rotated the space, we only need to check if it is\n  // inside one edge.\n  vec3 midAB = (a_0 + b_0) / 2.0;\n  vec3 pn = normalize(c_0 - midAB);\n  float w = dot(midAB, pn);\n  if (dot(p, pn) > w * s) {\n    // if not, return the distance to the plane the triangle is in\n    return dot(xyz1, p) - INSCRIBED_SPHERE_RADIUS_2645608689 * s;\n  }\n\n  // project the point onto segment ab, and return the distance to it\n  float d3 = dot(ab1, p);\n  d3 = clamp(d3, -0.5 * s, 0.5 * s);\n  vec3 closestp = midAB * s + d3 * ab1;\n  return distance(closestp, p);\n}\n\nfloat sdOctahedron(float s, vec3 p) {\n  p = abs(p);\n  float m = p.x + p.y + p.z - s;\n  vec3 q;\n  if (3.0 * p.x < m) q = p.xyz;\n  else if (3.0 * p.y < m) q = p.yzx;\n  else if (3.0 * p.z < m) q = p.zxy;\n  else return m * 0.57735027;\n\n  float k = clamp(0.5 * (q.z - q.y + s), 0.0, s);\n  return length(vec3(q.x, q.y - s + k, q.z - k));\n}\n\nfloat sdOctahedron(vec3 p, float s) {\n  p = abs(p);\n\n  float m = p.x + p.y + p.z - s;\n  //find point on octohedron surf nearest to p\n  vec3 projPoint = p - vec3(0.333333 * m); //project onto surface plane\n  //now push projected point, if outside triangle edge, perpendicular to edge, to edge\n  vec3 toMove = min(projPoint, 0.0); //if projpoint.x<0 move along (1.0,-0.5,-0.5) , etc\n  float toMoveSum = dot(toMove, vec3(1.0)); //which is basically along (1.5,0,0) then vec3(-0.5)\n\n  vec3 movedPoint = projPoint + toMove * vec3(-1.5) + toMoveSum * vec3(0.5); //better to multiply toMove by a matrix (1s diagonal, 0.5 other)?\n\n  movedPoint = max(movedPoint, 0.0); //cap x,y,z to 0 then\n  movedPoint *= s / dot(movedPoint, vec3(1.0)); //scale about 0,0,0\n\n  return length(p - movedPoint);\n}\n\n// Pyramid with tip at (0,0,0), up = z\n// c is the bottom corner. c.xy should be positive, c.z negative.\nvec2 sdPyramid(vec3 c, vec3 p) {\n  // pyramid is symmetric in XZ and YZ planes\n  p.xy = abs(p.xy);\n  bool flip = p.y * c.x > p.x * c.y; // p.y/p.x > c.y/c.x\n  c.xy = flip ? c.yx : c.xy;\n  p.xy = flip ? p.yx : p.xy;\n  vec3 cc = c / dot(c, c);\n  vec3 qx1 = normalize(vec3(-c.z, 0.0, c.x));\n  vec3 pOnQx = p - qx1 * dot(p, qx1);\n  float dx = dot(p, qx1);\n  float maxY = c.y * (pOnQx.x / c.x);\n  if (p.z <= c.z || pOnQx.z <= c.z) {\n    if (p.x <= c.x) {\n      // vertically underneath pyramid\n      return vec2(-p.z + c.z, 2.0);\n    } else {\n      float aa = distance(p, vec3(c.x, min(c.y, p.y), c.z));\n      return vec2(aa, 3.0);\n    }\n  } else if (pOnQx.y > maxY || pOnQx.z > 0.0) {\n    float xx = dot(cc, p);\n    float aa = length(p - clamp(xx, 0.0, 1.0) * c);\n\n    return vec2(aa, 1.0);\n  } else {\n    // need max for negativ values above base\n    return vec2(max(dx, -p.z + c.z), 0.0);\n  }\n}\n\nfloat sdSphere(float radius, vec3 p) {\n  return length(p) - radius;\n}\n\nfloat sub(float from, float what) {\n  return max(from, -what);\n}\n\nuniform sampler2D texture;\nuniform float secs;\nuniform mat4 lll;\nuniform mat4 llli;\nuniform vec4 colorPrimary;\nuniform vec4 colorSecondary;\nuniform vec4 colorBg;\nuniform float a;\nuniform float b;\nuniform float c;\nuniform float d;\nuniform float highResTimeStamp;\nuniform int bandCount;\nuniform vec3 extra;\nuniform vec3 campos;\nin float n;\nin vec2 coord;\nout vec4 fragColor;\n\nconst float TAU = 6.283185307179586;\nconst float SQRT1_2 = 0.7071067811865476;\nconst float SQRT2 = 1.4142135623730951;\nconst float PI = 3.141592653589793;\n\nconst vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\nconst vec4 yellow = vec4(1.0, 1.0, 0.0, 1.0);\nconst vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\nconst vec4 blue = vec4(0.0, 0.0, 1.0, 1.0);\nconst vec4 purple = vec4(0.5, 0.0, 0.5, 1.0);\nconst vec4 red = vec4(1.0, 0.0, 0.0, 1.0);\n\nstruct RMHit {\n  float distance;\n  vec4 color;\n};\nRMHit mixa(RMHit a, RMHit b, float t) {\n  return RMHit(mix(a.distance, b.distance, t), mix(a.color, b.color, t));\n}\nfloat skybox(vec3 p) {\n  return 32.0 - max3(abs(p));\n}\n\nfloat perlinSphere(float radius, vec3 p) {\n  vec3 cp = normalize(p);\n  float alpha = atan(cp.y, cp.x);\n  float beta = asin(cp.z);\n  return length(p) -\n  radius +\n  0.1 *\n    perlin2D(vec2(0.0 / 100.0, 0.0) + (vec2(5.0) + vec2(alpha, beta)) * 8.0);\n}\n\nfloat cylCircle(vec3 p) {\n  float d = 10e9;\n  for (int i = 0; i < 10; i++) {\n    d = min(\n      d,\n      sdCylinder(0.2, 2.0, p + fromPolar(3.0, TAU * float(i) / 10.0, 1.0))\n    );\n  }\n\n  return d;\n}\n\nfloat rblock(float r, vec3 p) {\n  return sdBox(vec3(r), p);\n}\n\nRMHit add(RMHit a, RMHit b) {\n  //    return a.distance < b.distance\n  //        ? RMHit(a.distance, a.color)\n  //        : RMHit(b.distance, b.color);\n  return mixa(a, b, float(b.distance < a.distance));\n}\n\nfloat wtf(vec3 p) {\n  vec3 center = p - mod(p, 3.0) + vec3(1.5);\n  return rblock(0.4 + 0.3 * sin(secs + center.x), p - center);\n}\n\nRMHit addTillet(float r, RMHit a, RMHit b) {\n  if (a.distance < r && b.distance < r) {\n    return RMHit(\n      r - distance(vec2(a.distance, b.distance), vec2(r)),\n      mix(a.color, b.color, (a.distance - b.distance) / r * 0.5 + 0.5)\n    );\n  } else {\n    return add(a, b);\n  }\n}\n\nRMHit addTillet(float r, RMHit a, RMHit b, vec4 tilletColor) {\n  if (a.distance < r && b.distance < r) {\n    return RMHit(\n      r - distance(vec2(a.distance, b.distance), vec2(r)),\n      tilletColor\n    );\n  } else {\n    return add(a, b);\n  }\n}\nRMHit addTillet2(float r, RMHit a, RMHit b) {\n  float h = smoothstep(-r, r, a.distance - b.distance);\n  return RMHit(\n    mix(a.distance, b.distance, h) - r * h * (1.0 - h),\n    mix(a.color, b.color, h)\n  );\n}\n\nRMHit neg(RMHit a) {\n  return RMHit(-a.distance, a.color);\n}\nRMHit sub(RMHit from, RMHit what) {\n  RMHit whatNeg = neg(what);\n  return mixa(from, whatNeg, float(whatNeg.distance > from.distance));\n}\n\nvec3 modv(vec3 v, vec3 dir1, float y) {\n  float t = dot(v, dir1);\n  return v - floor(t / y) * y * dir1;\n}\nvec3 modRotZ(vec3 p, float count) {\n  vec2 polarXY = toPolar(p.xy);\n  return fromPolar(polarXY.x, mod(polarXY.y, TAU / count), p.z);\n}\n\nfloat sin01(float x) {\n  return 0.5 + 0.5 * sin(x);\n}\nfloat cos01(float x) {\n  return 0.5 + 0.5 * cos(x);\n}\n\nfloat betterBox(vec3 r, vec3 p) {\n  vec3 q = abs(p) - r;\n  return length(max(q, 0.0)) + min(max3(q), 0.0);\n  p = abs(p);\n  return max3(p - r);\n}\n\nfloat roundedBlock(vec3 r, float cr, vec3 p) {\n  return betterBox(r - vec3(cr), p) - cr;\n}\n\nfloat sdConeB(vec2 c, float h, vec3 p) {\n  float q = length(p.xz);\n  return max(dot(c.xy, vec2(q, p.y)), -h - p.y);\n}\n\nfloat sdCone(vec2 c, float h, vec3 p) {\n  vec2 q = h * vec2(c.x / c.y, -1.0);\n  vec2 w = vec2(length(p.xz), p.y);\n  vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);\n  vec2 b = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0);\n  float k = sign(q.y);\n  float d = min(dot(a, a), dot(b, b));\n  float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));\n  return sqrt(d) * sign(s);\n}\n\nfloat sdCapsule(vec3 a, vec3 b, float r, vec3 p) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h) - r;\n}\nfloat sdEllipsoidB(vec3 r, vec3 p) {\n  float k0 = length(p / r);\n  float k1 = length(p / (r * r));\n  return k0 * (k0 - 1.0) / k1;\n}\nfloat sdOctahedronB(float s, vec3 p) {\n  p = abs(p);\n  return (p.x + p.y + p.z - s) * 0.57735027;\n}\nfloat donutc(float r0, float r1, vec3 p) {\n  vec3 closestCenter = vec3(normalize(p.xy) * r0, 0.0);\n  return distance(closestCenter, p) - r1;\n}\n\nfloat sdCappedCylinder(float h, float r, vec3 p) {\n  vec2 d = vec2(length(p.xy), abs(p.z)) - vec2(r, h);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\nfloat smoothmin(float r, float a, float b) {\n  float h = smoothstep(-r, r, a - b);\n  return mix(a, b, h) - r * h * (1.0 - h);\n}\nfloat queen(vec3 p) {\n  float lxy = length(p.xy);\n  float d;\n  d = lxy - 1.1;\n  d += 0.16 * p.z;\n  d -= -c * (1.0 - pow(sin01(b + p.z * 2.5), 1.5));\n  d += 0.1 * normalize(p.xy).x * smoothstep(2.0, 0.5, p.z);\n  d +=\n    0.02 * sin(15.0 * atan(p.y, p.x) - p.z * 5.0) * smoothstep(2.0, 0.5, p.z);\n  //    float d = sdCappedCylinder(a, b, p);\n  d = max(d, -p.z);\n  d = max(d, p.z - 4.0);\n\n  float head = sdSphere(0.55, p - vec3(0.0, 0.0, 4.4));\n  d = smoothmin(0.15, d, head);\n  float crown = sdCone(\n    fromPolar(vec2(1.0, 1.15)),\n    1.0,\n    -(p - vec3(0.0, 0.0, 4.5)).yzx\n  );\n  d = min(d, crown);\n  d *= 0.5;\n  return d;\n}\nfloat lego(vec3 p) {\n  vec2 c = vec2(4.0, 2.0);\n  //    p.xy = mod(p.xy + c * 0.5, c) - c * 0.5;\n  float lxy = length(p.xy);\n  p -= vec3(0.0, 0.0, 0.6);\n  float d;\n  const float cr = 0.02;\n  d = sdBox(vec3(2.0, 1.0, 0.6), cr, p);\n  //    vec3 p8 = vec3(fract(p.xy + 0.5) - 0.5, p.z);\n  vec3 p8 = vec3(abs(abs(p.xy) - vec2(1.0, 0.0)), p.z) - vec3(0.5, 0.5, 0.6);\n  float dCyl = sdCylinder(0.35 - 0.04, 0.2, p8) - 0.04;\n  d = min(d, dCyl);\n  return d;\n}\n\nvec2 project(vec2 a, vec2 onto1) {\n  return onto1 * (dot(a, onto1) / dot(onto1, onto1));\n}\n\nvec3 reject(vec3 a, vec3 b1) {\n  return a - b1 * dot(a, b1);\n}\n\nRMHit sdf(vec3 p) {\n  const vec4 red = vec4(0.2, 0.0, 0.0, 1.0);\n  //    RMHit d = RMHit(block(vec3(-1., -1., -1.), vec3(1., 1., 1.), p), black);\n  //    RMHit d = RMHit(sphere(2., p), black);\n  //    RMHit d = RMHit(betterBox(vec3(1.), p), black);\n  //    RMHit d = RMHit(roundedBlock(vec3(1.), 0.1, p), black);\n  //    RMHit d = RMHit(donut(2., 0.5, p), black);\n  //    RMHit d = RMHit(sdCapsule(vec3(-a,-a,0.), vec3(a,a,0.), b, p), black);\n  //    RMHit d = RMHit(sdEllipsoidB(vec3(-a,-b,1.), p), black);\n  //    RMHit d = RMHit(sdOctahedron(1., p)-a, red) ;\n  //    RMHit d = RMHit(queen(p), black) ;\n  //    RMHit d = RMHit(lego(p), black) ;\n  //- vec3(0.0, 0.0, 1.0)\n  vec3 h = vec3(0.5, 0.0, 0.0);\n  vec3 q = abs(p) - h;\n  //    vec2 pyr = sdPyramid(\n  //        vec3(2.0, 2.0, -2.0),\n  //        opElongate(h,\n  //            rotZ(highResTimeStamp/1000.) *\n  //                rotX(c) *\n  //                opRepLim(p - vec3(-8., -8., 2.), vec3(8.), vec3(2., 2., 0.))));\n  vec3 p2 = rotX(highResTimeStamp * 0.0) * p;\n  vec2 xx = vec2(sdIcosahedron(d, p2) - c, 1.0);\n  vec4 cc = red;\n  cc.xyz = cc.xyz * xx.y * 0.1;\n  RMHit d = RMHit(xx.x, cc);\n  //    RMHit d = RMHit(sdCone(fromPolar(vec2(1., a)), b, p.yzx - vec3(0.,2., 0.)), black);\n  //    d.distance = abs(d.distance) - 0.4;\n  //    d.distance = abs(d.distance) - 0.1;\n  //    d.distance = abs(d.distance) - 0.02;\n  float s = length(p - vec3(1.0, 1.0, 0.0)) - 1.0;\n  //    d.distance = s;\n  //    d.distance = max(d.distance, -s);\n\n  vec3 color = 0.1 * sin(abs(vec3(0.0, PI, 0.0) + vec3(d.distance * PI * 2.0)));\n  //    color.z = .1*xx.y;\n  RMHit base = RMHit(sdBox(vec3(10.0, 10.0, 0.0), p), vec4(color, 1.0));\n\n  //    d = base;\n  d = add(base, d);\n  if (b > 1.0) {\n    d = base;\n  }\n  //    d.distance *=0.5;\n  return d;\n}\nfloat sdff(vec3 p) {\n  return sdf(p).distance;\n}\nfloat ambientOcclusion(vec3 pWC, vec3 n1WC) {\n  float k = 1.0;\n  float distance = sdff(pWC + n1WC * k);\n  return clamp(distance / k, 0.0, 1.0);\n}\n\nstruct RMResult {\n  float distance;\n  vec3 pos;\n  vec4 color;\n};\nRMResult raymarching2(vec3 start, vec3 dir1) {\n  vec3 pos = start;\n  RMHit hit;\n  for (int i = 0; i < 200; i++) {\n    hit = sdf(pos);\n    if (hit.distance < 0.0001 * hit.distance) break;\n    pos = pos + dir1 * hit.distance;\n  }\n  return RMResult(hit.distance, pos, hit.color);\n}\nvec3 pt(mat4 pm, vec3 p) {\n  vec4 pStar = pm * vec4(p, 1.0);\n  return pStar.xyz / pStar.w;\n}\n\nfloat softshadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {\n  float res = 1.0;\n  float t = 0.1;\n  for (int i = 0; i < 1000 && t < maxt; i++) {\n    float h = sdff(ro + rd * t);\n    if (h < 0.001) return 0.0;\n    res = min(res, k * h / t);\n    t += h;\n  }\n  return res;\n}\n\nconst float eps = 1e-4;\nvec3 sdfNormal1(vec3 p, float d) {\n  return normalize(\n    vec3(\n      sdff(p + vec3(eps, 0.0, 0.0)),\n      sdff(p + vec3(0.0, eps, 0.0)),\n      sdff(p + vec3(0.0, 0.0, eps))\n    ) -\n      vec3(sdff(p))\n  );\n}\n\n//layout (depth_greater) out float gl_FragDepth;\nvoid main() {\n  vec3 light = normalize(vec3(-1.0, -2.0, -2));\n\n  vec3 a = vec3(coord, -1.0);\n  vec3 b = vec3(coord, 1.0);\n  vec3 aWC = pt(llli, a);\n  vec3 bWC = pt(llli, b);\n  vec3 lookDir1 = normalize(bWC - aWC);\n\n  RMResult hitWC = raymarching2(aWC, lookDir1);\n  vec3 hitn1 = sdfNormal1(hitWC.pos, hitWC.distance);\n  float dWC = distance(aWC, hitWC.pos);\n  vec3 hitNDC = pt(lll, hitWC.pos);\n  vec3 p = hitWC.pos;\n  float inSun = softshadow(\n    hitWC.pos + hitn1 * 0.05,\n    -light,\n    0.0001,\n    300.0,\n    8.0\n  );\n  //    float inSun=1.;\n\n  vec3 material = hitWC.color.xyz;\n  if (dWC > 100.0) {\n    material = vec3(0.0, 0.0, 0.0);\n    //    } else if (p.z >= 0.001) {\n    //        material = vec3(0.2, 0.0, 0.0);\n    //    } else {\n    //        vec2 c = vec2(4.0, 2.0);\n    //        vec2 id = floor(((p.xy - c * 0.5) / c) );\n    //        material += .15 * cos(vec3(id.x, id.y + 2., id.x + id.y + 4.));\n  }\n\n  const vec3 sunlightColor = vec3(8.0, 6.0, 1.0);\n\n  float aOcc = ambientOcclusion(hitWC.pos, hitn1);\n\n  vec3 reflectionDirection = reflect(light, hitn1);\n\n  vec3 color = vec3(0.0);\n  color += material * aOcc;\n  color += inSun * sunlightColor * material * max(0.0, dot(-light, hitn1));\n  //    color = (hitn1);\n\n  vec3 camPos = aWC;\n\n  vec3 eyeDirection = -lookDir1;\n  float uMaterialShininess = 256.0;\n  float specularLightWeighting = pow(\n    max(dot(reflectionDirection, eyeDirection), 0.0),\n    uMaterialShininess\n  );\n  color += specularLightWeighting;\n  //    float lightIntensity = 0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.);\n  //    float lightIntensity =\n  //        0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.) + 0.3*specularLightWeighting;\n  //    fragColor = visualize(blue, red, mix(0.5, 1.0, inSun) * lightIntensity);\n  //    fragColor = mix(hitWC.color, colorBg, mix(0.5, 1.0, inSun) * clamp(lightIntensity, 0., 1.));\n  color = pow(color, vec3(1.0 / 2.2)); // gamma correction\n  fragColor = vec4(color, 1.0);\n}\n"},7080:n=>{n.exports="#version 300 es\n\nprecision highp float;\n#define GLSLIFY 1\n\nconst vec4 blue = vec4(0.0, 0.0, 1.0, 1.0);\nconst vec4 red = vec4(1.0, 0.0, 0.0, 1.0);\n\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\n  float isLow = float(t < 0.0);\n  float isHigh = float(t > 1.0);\n  float isMid = 1.0 - isLow - isHigh;\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\n}\n\nvec4 visualize(float t) {\n  return visualize(blue, red, t);\n}\n\nfloat banded(float bandCount, float t) {\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\n}\nfloat banded(int bandCount, float t) {\n  return banded(float(bandCount), t);\n}\n\nuniform vec4 color;\n\nout vec4 fragColor;\n\nvoid main() {\n  fragColor = color;\n}\n"},1507:n=>{n.exports="#version 300 es\nprecision highp float;\n#define GLSLIFY 1\n\nuniform mat4 ts_ModelViewProjectionMatrix;\nuniform float normalOffset;\nin vec3 ts_Normal;\nin vec4 ts_Vertex;\n\nvoid main() {\n  gl_Position =\n    ts_ModelViewProjectionMatrix *\n    (ts_Vertex + normalOffset * vec4(ts_Normal, 0.0));\n}\n"},5583:(n,t,e)=>{e.d(t,{Z:()=>a});var o=setTimeout;function r(n,t){var e=t.useCachedSetTimeout?o:setTimeout;return new Promise((function(t){e(t,n)}))}const a=function(n){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},e=t.useCachedSetTimeout,o=r(n,{useCachedSetTimeout:e});function a(n){return o.then((function(){return n}))}return a.then=function(){return o.then.apply(o,arguments)},a.catch=Promise.resolve().catch,a}}}]);