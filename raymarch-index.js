"use strict";(self.webpackChunkworkshop=self.webpackChunkworkshop||[]).push([[501],{1906:(n,e,t)=>{t.r(e),t.d(e,{default:()=>K});var o=t(5201),a=t(2917),r=t(3015),l=t(9557),i=t(5101),s=t(1455),c=t(2763),d=t(9552),f=t(8647),m=t(555),p=t(4529),u=t(7810),v=t(3856),h=t(4639),g=t(1363),x=t(7755),y=t(8066),b=t(2168);function C(n){let e,t=n[0],o=1;for(;o<n.length;){const a=n[o],r=n[o+1];if(o+=2,("optionalAccess"===a||"optionalCall"===a)&&null==t)return;"access"===a||"optionalAccess"===a?(e=t,t=r(t)):"call"!==a&&"optionalCall"!==a||(t=r((...n)=>t.call(e,...n)),e=void 0)}return t}const R=m.yW("red").gl(),T=m.yW("green").gl(),S=m.yW("blue").gl(),E=h._z,w={anchor:v.V3.O,dir1:v.V3.X},A={anchor:v.V3.O,dir1:v.V3.Y},z={anchor:v.V3.O,dir1:v.V3.Z};class M{__init(){this.meshes={}}__init2(){this.highlight=0}__init3(){this.offsetGC=void 0}__init4(){this.dragging=0}constructor(n,e,t,o,a,r){this.gl=n,this.pos=e,this.onHover=t,this.onStartDragging=o,this.onStopDragging=a,this.onChange=r,M.prototype.__init.call(this),M.prototype.__init2.call(this),M.prototype.__init3.call(this),M.prototype.__init4.call(this),M.prototype.__init5.call(this),M.prototype.__init6.call(this),M.prototype.__init7.call(this),this.meshes.vector=h.e.rotation([(0,v.V)(0,.04),(0,v.V)(.8,.04),(0,v.V)(.85,.06),(0,v.V)(1,0)],w,v.DD,8,!0),this.meshes.vector.computeNormalsFromFlatTriangles(),this.meshes.vector.compile();const l=v.M4.rotateX(-90*v.Bt).translate(v.V3.X);this.meshes.rotater=h.e.rotation((0,v.F3)(0,9).map(n=>l.transformPoint(v.V3.polar(.04,-v.DD*n/8))),{anchor:v.V3.O,dir1:v.V3.Z},101.25*v.Bt,8,!1),this.meshes.rotater.computeNormalsFromFlatTriangles(),this.meshes.rotater.compile()}drawVector(n,e,t,o=1){if(n.likeO())return;this.gl.pushMatrix();const a=n.getPerpendicular().unit();this.gl.multMatrix(v.M4.forSys(n.unit(),a,n.cross(a).unit(),e)),t.draw(this.meshes.vector),this.gl.popMatrix()}render(n){const e=this.gl;e.enable(e.CULL_FACE),e.cullFace(e.BACK),e.pushMatrix(),e.multMatrix(this.pos),e.cullFace(e.FRONT),n.uniforms({color:E,normalOffset:.01}),1!==this.highlight&&1!==this.dragging||this.drawVector(v.V3.X,v.V3.O,n,.1),2!==this.highlight&&2!==this.dragging||this.drawVector(v.V3.Y,v.V3.O,n,.1),3!==this.highlight&&3!==this.dragging||this.drawVector(v.V3.Z,v.V3.O,n,.1),e.cullFace(e.BACK),n.uniforms({normalOffset:0}),this.drawVector(v.V3.X,v.V3.O,n.uniforms({color:R}),.1),this.drawVector(v.V3.Y,v.V3.O,n.uniforms({color:T}),.1),this.drawVector(v.V3.Z,v.V3.O,n.uniforms({color:S}),.1),n.uniforms({color:S}).draw(this.meshes.rotater),e.rotate(-90,0,1,0),n.uniforms({color:R}).draw(this.meshes.rotater),e.rotate(-90,1,0,0),n.uniforms({color:T}).draw(this.meshes.rotater),e.popMatrix()}registerListeners(n,e){return this.getCameraMatrix=e,C([this,"access",n=>n.unregister,"optionalCall",n=>n()]),n.addEventListener("mousemove",this.mousemove),n.addEventListener("mousedown",this.mousedown),n.addEventListener("mouseup",this.mouseup),this.unregister=()=>{n.removeEventListener("mousemove",this.mousemove),n.removeEventListener("mousedown",this.mousedown),n.removeEventListener("mouseup",this.mouseup)}}unregisterListeners(){C([this,"access",n=>n.unregister,"optionalCall",n=>n()])}__init5(){this.mousemove=n=>{const e=(0,v.V)(n.offsetX,n.offsetY),t=n.target.getBoundingClientRect();t.width;const o=function(n,e,t){const o=(0,v.V)(2*n.x/e.width-1,2*-n.y/e.height+1,-1),a=(0,v.V)(2*n.x/e.width-1,2*-n.y/e.height+1,1),r=t.inversed(),l=r.transformPoint(o);return{anchor:l,dir1:r.transformPoint(a).minus(l).unit()}}(e,t,this.getCameraMatrix());if(this.dragging){const a=[v.V3.O,v.V3.X,v.V3.Y,v.V3.Z][this.dragging],r=k(o,{anchor:this.pos.getTranslation(),dir1:this.pos.transformVector(a).unit()}),l=this.pos.transformVector(this.offsetGC),i=r.lineClosest.minus(l);this.pos=this.pos.translate(this.pos.getTranslation().to(i)),this.onChange(this.pos)}else{const s=this.pos.inversed(),c={anchor:s.transformPoint(o.anchor),dir1:s.transformVector(o.dir1).unit()};let d;function f(n){const e=k(c,n);return d=D(n,(0,v.qE)(e.lineT,0,1)),d.distanceTo(e.thClosest)}const m=this.highlight;f(w)<.1?(this.highlight=1,this.offsetGC=d):f(A)<.1?(this.highlight=2,this.offsetGC=d):f(z)<.1?(this.highlight=3,this.offsetGC=d):(this.highlight=0,this.offsetGC=void 0),this.highlight!==m&&C([this,"access",n=>n.onHover,"optionalCall",n=>n(this.highlight)])}}}__init6(){this.mousedown=n=>{this.highlight&&(this.dragging=this.highlight,this.onStartDragging())}}__init7(){this.mouseup=n=>{this.dragging&&(this.dragging=0,this.onStopDragging())}}}function D(n,e){return n.anchor.plus(n.dir1.times(e))}function k(n,e){if(function(n,e){return(0,v.eq)(1,Math.abs(n.dir1.dot(e.dir1)))}(n,e))return{t:NaN,s:NaN,distance:10};const t=e.anchor,o=e.dir1,a=n.anchor,r=n.dir1,l=o.dot(r),i=o.squared(),s=r.squared(),c=t.minus(a),d=l*l-s*i,f=(c.dot(o)*l-c.dot(r)*i)/d,m=(c.dot(o)*s-c.dot(r)*l)/d;return{thT:f,lineT:m,thClosest:D(n,f),lineClosest:D(e,m),distance:D(n,f).distanceTo(D(e,m))}}var H=t(8600),N=t(7157),P=t(4394);function _(n){let e,t=n[0],o=1;for(;o<n.length;){const a=n[o],r=n[o+1];if(o+=2,("optionalAccess"===a||"optionalCall"===a)&&null==t)return;"access"===a||"optionalAccess"===a?(e=t,t=r(t)):"call"!==a&&"optionalCall"!==a||(t=r((...n)=>t.call(e,...n)),e=void 0)}return t}function B(n){return{sdf:h.Mt.create(t(2798).A,t(4077).A,n),singleColor:h.Mt.create(t(9096).A,t(5445).A,n)}}function O(n){let e,t=n[0],o=1;for(;o<n.length;){const a=n[o],r=n[o+1];if(o+=2,("optionalAccess"===a||"optionalCall"===a)&&null==t)return;"access"===a||"optionalAccess"===a?(e=t,t=r(t)):"call"!==a&&"optionalCall"!==a||(t=r((...n)=>t.call(e,...n)),e=void 0)}return t}const q={a:.2,b:.2,c:.2,d:.2,cam:"999.999.999~-56.-58.-61~-44.-44.79"};function L(n){n.makeCurrent();const e=h.e.plane({startX:-1,startY:-1,width:2,height:2});return e.coords=[[-1,-1],[1,-1],[-1,1],[1,1]],e.compile(),{planeMesh:e,shaders:B(n)}}function W(n,{shaders:e,planeMesh:t},o,a,r,l,i){n.makeCurrent();const s=o.inversed();e.sdf.uniforms({colorPrimary:a.primary,colorSecondary:a.secondary,colorBackground:a.background,highResTimeStamp:l,secs:l/1e3,gradients:1,extra:i,...r,lll:o,llli:s}).draw(t)}function V({children:n,label:e,onFocus:t,onBlur:o}){return u.createElement(s.A,{onFocus:t,onBlur:o,label:e,inputComponent:"textarea",value:n.toString()})}function G(n){let e=0;function t(n){const e=""+n;return e.includes(".")?e:e+".0"}function o([n,e,o]){return"vec3("+t(n)+", "+t(e)+", "+t(o)+")"}const[a,r,l]=function n(a){let r,l,i;function s(n){r="p"+e++,l="d"+e++,i=`float ${l} = ${n(r)};\n`}for(const c of a)if("sphere"===c.type)s(n=>`sdSphere(${t(c.radius)}, ${n})`);else if("box"===c.type)s(n=>`betterBox(${o(c.radius)}, ${n})`);else if("octahedron"===c.type)s(n=>`sdOctahedron(${t(c.radius)}, ${n})`);else if("donut"===c.type)s(n=>`sdTorus(${t(c.r0)}, ${t(c.r1)}, ${n})`);else if("translate"===c.type){const n=r;r="p"+e++,i=`vec3 ${n} = ${r} + ${o(c.by)};\n`+i}else if("expand"===c.type){const n=l;l="d"+e++,i+=`float ${l} = ${n} - ${t(c.by)};\n`}else if("add"===c.type||"sub"===c.type){const[e,t,o]=n(c.what);i=i+`vec3 ${t} = ${r};\n`+e+`${l} = `+("add"===c.type?`min(${l}, ${o})`:`max(${l}, -${o})`)+";\n"}return[i,r,l]}(n);let i=`RMHit sdf(vec3 ${r}) {\n`;return i+=a,i+=`return RMHit(${l}, black);\n`,i+="}\n",i}function I({value:n,onChange:e}){const t=(0,u.useCallback)(t=>e({...n,radius:+t.target.value},n),[e]);return u.createElement("div",null,"Sphere"," ",u.createElement(f.A,{value:n.radius,onChange:t,inputProps:{type:"number"}}))}function F({value:n,onChange:e}){const t=(0,u.useCallback)(t=>e({...n,radius:t},n),[n,e]);return u.createElement("div",{style:{display:"flex"}},"Box ",u.createElement(Q,{value:n.radius,onChange:t}))}function $({value:n,onChange:e}){const t=(0,u.useCallback)(t=>e({...n,by:+t.target.value},n),[n,e]);return u.createElement("div",{style:{display:"flex"}},"Expand"," ",u.createElement(f.A,{value:n.by,onChange:t,type:"number",inputProps:{}}))}function Q({value:n,onChange:e,gizmoControl:t}){const a=(0,u.useCallback)(t=>{const o=n.slice();o[t.target.name]=+t.target.value,e(o,n)},[n,e]),r=(0,u.useCallback)(()=>t.take(n,e),[t,e,n]);return u.createElement(u.Fragment,null,u.createElement(o.A,{onClick:r},"X"),[0,1,2].map(e=>u.createElement(f.A,{key:e,name:""+e,value:n[e],onChange:a,inputProps:{type:"number"}})))}function j({value:n,onChange:e,gizmoControl:t}){const o=(0,u.useCallback)(t=>e({...n,by:t},n),[n,e]);return u.createElement("div",{style:{display:"flex"}},"Translate"," ",u.createElement(Q,{value:n.by,onChange:o,gizmoControl:t}))}function U({value:n,onChange:e,gizmoControl:t}){const o=(0,u.useCallback)(t=>e({...n,[t.target.name]:+t.target.value},n),[n,e]);return u.createElement("div",{style:{display:"flex"}},"Donut"," ",["r0","r1"].map(e=>u.createElement(f.A,{key:e,name:e,value:n[e],onChange:o,inputProps:{type:"number"}})))}function X({value:n,onChange:e,gizmoControl:t}){const o=(0,u.useCallback)(t=>e({...n,[t.target.name]:+t.target.value},n),[n,e]);return u.createElement("div",{style:{display:"flex"}},"Octahedron"," ",["radius"].map(e=>u.createElement(f.A,{key:e,name:e,value:n[e],onChange:o,inputProps:{type:"number"}})))}function Y({value:n,onChange:e,gizmoControl:t}){const o=(0,u.useCallback)(t=>e({...n,type:t.target.value},n),[n,e]),a=(0,u.useCallback)(t=>e({...n,what:t},n),[n,e]);return u.createElement("div",{style:{display:"flex"}},u.createElement(c.A,{value:n.type,name:"type",onChange:o},u.createElement(i.A,{value:"add"},"Add"),u.createElement(i.A,{value:"sub"},"Sub"))," ",u.createElement(Z,{value:n.what,onChange:a,gizmoControl:t}))}function Z({value:n,onChange:e,gizmoControl:t}){const o=(0,u.useCallback)((t,o)=>e(n.map(n=>n===o?t:n)),[e,n]);return u.createElement("div",null,n.map((n,e)=>{const a={sphere:I,expand:$,add:Y,sub:Y,box:F,donut:U,translate:j,octahedron:X}[n.type];return a&&u.createElement(a,{key:e,value:n,onChange:o,gizmoControl:t})}))}const K=()=>{const n=(0,u.useRef)(null),[e,s]=(0,u.useState)(void 0),[f,C]=(0,u.useState)(v.M4.IDENTITY),[R,T]=(0,u.useState)(512),[S,E]=(0,u.useState)(!1),[w,A]=(0,y.N)(q),z=(0,u.useCallback)(n=>A(e=>({...e,...n})),[A]),[D,k]=(0,u.useState)(0),[B,I]=(0,u.useState)(0),F=(0,u.useRef)(Object.assign({},w)),$=(0,u.useRef)(),[Q,j]=(0,u.useState)([{type:"sphere",radius:1},{type:"translate",by:[1,2,3]},{type:"add",what:[{type:"box",radius:[1,2,3]},{type:"translate",by:[.1,.1,.1]},{type:"expand",by:.3}]},{type:"add",what:[{type:"octahedron",radius:2},{type:"translate",by:[.1,.1,.1]}]},{type:"add",what:[{type:"donut",r0:2,r1:.2},{type:"translate",by:[.1,.1,.1]}]}]),U=(0,d.A)(),X=(0,u.useMemo)(()=>({background:m.AH(U.palette.background.default).gl(),primary:m.AH(U.palette.primary.main).gl(),secondary:m.AH(U.palette.secondary.main).gl()}),[U.palette]),Y=(0,u.useCallback)(async([n,e])=>{const t=URL.createObjectURL(await async function([n,e],t,o,a){_([a,"optionalCall",n=>n(0)]),await(0,P.A)(10);const r=document.createElement("canvas");r.width=n,r.height=e;const l=200,i=h.ks.create({canvas:r});i.enable(i.SCISSOR_TEST);const s=t(i);let c=0;for(let t=0;t<n;t+=l)for(let r=0;r<e;r+=l){const d=Math.min(l,n-t),f=Math.min(l,e-r);i.scissor(t,r,d,f),o(i,s),await(0,P.A)(0),c+=d*f,_([a,"optionalCall",t=>t(c/(n*e))])}return new Promise((n,e)=>r.toBlob(t=>t?n(t):e("error"),"png"))}([n,e],L,(t,o)=>{W(t,o,v.M4.product(v.M4.perspective(70,n/e,.1,50),N.w.getLookAt(N.w.fromShortString(w.cam))),X,w,2e3,f.getTranslation())},s));s(void 0),(0,b.V3)(t)},[f,X,w]);(0,u.useEffect)(()=>{console.log("creating context");const e=h.ks.create({canvas:n.current,alpha:!0,premultipliedAlpha:!0,throwOnError:!0});return console.log(e.getParameter(e.MAX_SAMPLES)),$.current=function(n,e,o,a,r,l,i,s){n.canvas.addEventListener("keydown",n=>"r"===n.key&&Y([1920,1080]));const c=new N.w(l);let d=v.M4.IDENTITY;const f=new M(n,v.M4.rotateZ(20*v.Bt).translate(5,5,1),i,()=>c.pauseCam=!0,()=>c.pauseCam=!1,s);f.registerListeners(n.canvas,()=>d),n.clearColor(...e.background),n.clearColor(0,0,0,1),n.clear(n.COLOR_BUFFER_BIT),n.cullFace(n.BACK),n.pointSize(10),n.disable(n.CULL_FACE),n.disable(n.DEPTH_TEST),n.disable(n.BLEND),n.blendFunc(n.ONE,n.ONE),n.blendEquation(n.FUNC_ADD),n.canvas.contentEditable="true",n.canvas.focus(),c.registerListeners(n.canvas);const m=new x.W(a),p=L(n);return{updateShader(n){p.shaders.ed=h.Mt.create(t(2798).A,n)},teardown:n.animate(function(t,a){n.clear(n.COLOR_BUFFER_BIT),n.makeCurrent(),c.tick(),m.tick(t),d=v.M4.product(v.M4.perspective(70,n.canvas.offsetWidth/n.canvas.offsetHeight,.1,50),c.getLookAt()),W(n,p,d,e,o,t,f.pos.getTranslation()),n.matrixMode(n.PROJECTION),n.loadMatrix(d),n.matrixMode(n.MODELVIEW),n.loadIdentity(),f.render(p.shaders.singleColor)}),setCam:c.setState}}(e,X,F.current,I,0,(0,p.debounce)(n=>{z({cam:N.w.toShortString(n)})}),k,C),()=>{O([$,"access",n=>n.current,"optionalAccess",n=>n.teardown,"call",n=>n()])}},[]),(0,u.useEffect)(()=>{},[w.cam]),(0,u.useEffect)(()=>{O([$,"access",n=>n.current,"optionalAccess",n=>n.updateShader,"call",n=>n("#version 300 es\n\nprecision highp float;\n\n// START ../common/banded.glsl\nfloat banded(float bandCount, float t) {\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\n}\nfloat banded(int bandCount, float t) {\n  return banded(float(bandCount), t);\n}\n\n// #pragma glslify: export(banded)\n\n\n// END ../common/banded.glsl\n// START ../common/between.glsl\nbool between(float min, float max, float value) {\n  return min <= value && value <= max;\n}\n\n// #pragma glslify: export(between)\n\n\n// END ../common/between.glsl\n// START ../common/hexFns.glsl\n// START ./max3.glsl\nfloat max3(float a, float b, float c) {\n  return max(a, max(b, c));\n}\nfloat max3(vec3 v) {\n  return max(v.x, max(v.y, v.z));\n}\n\n// #pragma glslify: export(max3)\n\n\n// END ./max3.glsl\n// START ./constants.glsl\nconst float SQRT1_2 = 0.7071067811865476;\nconst float SQRT1_3 = 0.57735026919;\nconst float SQRT2 = 1.4142135623730951;\nconst float SQRT3 = 1.732050807568877;\n// sqrt(3)/2 = sin(60*)\nconst float SQRT3_2 = 0.86602540378;\nconst float GOLDEN_RATIO = 1.61803398875;\nconst float PI = 3.141592653589793;\nconst float TAU = 6.28318530718;\n/**\n * One degree in radians. Use like `sin(30 * DEG)`.\n */\nconst float DEGREE = 0.017453292519943295;\n\n// END ./constants.glsl\n\nvec3 hexRound(vec3 hex) {\n  vec3 r = floor(hex + 0.5);\n  vec3 diff = abs(r - hex);\n\n  if (diff.x > diff.y && diff.x > diff.z) {\n    r.x = -(r.y + r.z);\n  } else if (diff.y > diff.z) {\n    r.y = -(r.x + r.z);\n  } else {\n    r.z = -(r.x + r.y);\n  }\n\n  return r;\n}\nvec2 hex2Ra(vec3 hex) {\n  float y = hex.t * SQRT3_2;\n  float x = hex.s + hex.t / 2.0;\n  return vec2(x, y);\n}\n\nfloat hexSdf(vec3 hex) {\n  return max3(abs(hex.yzx + hex.zxy / 2.0));\n}\nvec3 ra2Hex(vec2 xy) {\n  float hex_t = xy.y / SQRT3_2;\n  float hex_s = xy.x - hex_t / 2.0;\n  return vec3(hex_s, hex_t, -(hex_s + hex_t));\n}\n\n// END ../common/hexFns.glsl\n// START ../common/matrices.glsl\n\nmat2 rot2(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat2(c, s, -s, c);\n}\nmat3 rotX(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\n}\nmat3 rotY(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\n}\nmat3 rotZ(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\n}\n/**\n * Returns a matrix that puts the camera at the eye point `ex, ey, ez` looking\n * toward the center point `cx, cy, cz` with an up direction of `ux, uy, uz`.\n * This emulates the OpenGL function `gluLookAt()`.\n */\nmat4 lookAt(vec3 eye, vec3 focus, vec3 up) {\n  vec3 f = normalize(eye - focus);\n  vec3 s = normalize(cross(up, f));\n  vec3 t = normalize(cross(f, s));\n\n  return mat4(\n    vec4(s.x, t.x, f.x, 0.0),\n    vec4(s.y, t.y, f.y, 0.0),\n    vec4(s.z, t.z, f.z, 0.0),\n    vec4(-dot(s, eye), -dot(t, eye), -dot(f, eye), 1)\n  );\n}\n\n// the OpenGL function `glFrustum()`.\nmat4 frustum(\n  float left,\n  float right,\n  float bottom,\n  float top,\n  float near,\n  float far\n) {\n  return mat4(\n    vec4(2.0 * near / (right - left), 0.0, 0.0, 0.0),\n    vec4(0, 2.0 * near / (top - bottom), 0.0, 0.0),\n    vec4(\n      (right + left) / (right - left),\n      (top + bottom) / (top - bottom),\n      -(far + near) / (far - near),\n      -1\n    ),\n    vec4(0.0, 0.0, -2.0 * far * near / (far - near), 0.0)\n  );\n}\n\nmat4 perspective(float fovDegrees, float aspect, float near, float far) {\n  float y = tan(fovDegrees * DEGREE / 2.0) * near;\n  float x = y * aspect;\n  return frustum(-x, x, -y, y, near, far);\n}\nmat4 ortho(\n  float left,\n  float right,\n  float bottom,\n  float top,\n  float near,\n  float far\n) {\n  return mat4(\n    vec4(2.0 / (right - left), 0.0, 0.0, 0.0),\n    vec4(0.0, 2.0 / (top - bottom), 0.0, 0.0),\n    vec4(0.0, 0.0, -2.0 / (far - near), 0.0),\n    vec4(\n      -(right + left) / (right - left),\n      -(top + bottom) / (top - bottom),\n      -(far + near) / (far - near),\n      1.0\n    )\n  );\n}\n\n// END ../common/matrices.glsl\n// START ../common/perlin2DTexture.glsl\nuniform sampler2D gradients;\n/* Create random direction vector\n */\nvec2 randomGradient(vec2 i) {\n  // Random float. No precomputed gradients mean this works for any number of grid coordinates\n  float random =\n    2920.0 *\n    sin(float(i.x) * 2.1942 + float(i.y) * 1.71324 + 8.912) *\n    cos(float(i.x) * 2.3157 * float(i.y) * 2.17832 + 9.758);\n  //    random = (i.x + 1667.) * (i.x + 2083.) * (i.y + 2659.) * (i.y * 50.77 + .3769);\n  //    random = sin(SQRT2 * i.x) + cos(GOLDEN_RATIO * i.y) + tan((i.x + i.y) * SQRT3);\n  return vec2(cos(random), sin(random));\n}\nfloat dotGridGradient(vec2 cell, vec2 pos) {\n  vec2 d = cell - pos;\n\n  //  vec2 gradient = texelFetch(gradients, ivec2(cell), 0).xy;\n  vec2 gradient = randomGradient(vec2(cell));\n\n  return dot(gradient, d);\n}\n\nfloat mixx(float a, float b, float t) {\n  return mix(a, b, smoothstep(0.0, 1.0, t));\n  //    return mix(a, b, t);\n}\n\n// resulting range is [-0.68, 0.68]. Use unmix to normalize if necessary.\nfloat perlin2D(vec2 xy) {\n  float x0 = floor(xy.x);\n  float x1 = x0 + 1.0;\n  float y0 = floor(xy.y);\n  float y1 = y0 + 1.0;\n\n  // Interpolate between grid point gradients\n  float n00 = dotGridGradient(vec2(x0, y0), xy);\n  float n10 = dotGridGradient(vec2(x1, y0), xy);\n  float ny0 = mixx(n00, n10, xy.x - x0);\n\n  float n01 = dotGridGradient(vec2(x0, y1), xy);\n  float n11 = dotGridGradient(vec2(x1, y1), xy);\n  float ny1 = mixx(n01, n11, xy.x - x0);\n\n  return mixx(ny0, ny1, xy.y - y0);\n}\n\n// #pragma glslify: export(perlin2D)\n\n\n// END ../common/perlin2DTexture.glsl\n// START ../common/polar.glsl\n// START ../common/fromPolar.glsl\n// START ./unmix.glsl\nfloat unmix(float a, float b, float value) {\n  return (value - a) / (b - a);\n}\n\n// #pragma glslify: export(unmix)\n\n\n// END ./unmix.glsl\n\nvec3 fromPolar(float radius, float phi, float z) {\n  return vec3(radius * cos(phi), radius * sin(phi), z);\n}\n\nvec2 fromPolar(float radius, float phi) {\n  return vec2(radius * cos(phi), radius * sin(phi));\n}\n\nvec2 fromPolar(vec2 polar) {\n  return fromPolar(polar.x, polar.y);\n}\n\n// #pragma glslify: export(fromPolar)\n\n\n// END ../common/fromPolar.glsl\n// START ../common/toPolar.glsl\n\nvec2 toPolar(vec2 xy) {\n  return vec2(length(xy), atan(xy.y, xy.x));\n}\n\nmat2 toPolarDerivate(vec2 xy) {\n  return mat2(xy.x * xy.x, xy.y * xy.y, -xy.y, xy.x) / dot(xy, xy);\n}\n\n// #pragma glslify: export(toPolar)\n\n\n// END ../common/toPolar.glsl\n\n// END ../common/polar.glsl\n// START ../common/remix.glsl\n\nfloat remix(float fromA, float fromB, float toA, float toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\nvec4 remix(float fromA, float fromB, vec4 toA, vec4 toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\n// #pragma glslify: export(remix)\n\n\n// END ../common/remix.glsl\n// START ../common/transform.glsl\nvec3 transform(mat4 pm, vec3 p) {\n  vec4 pStar = pm * vec4(p, 1);\n  return pStar.xyz / pStar.w;\n}\n\nvec2 transform(mat4 pm, vec2 p) {\n  vec4 pStar = pm * vec4(p, 0, 1);\n  return pStar.xy / pStar.w;\n}\n\n// END ../common/transform.glsl\n// START ../common/visualize.glsl\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\n  float isLow = float(t < 0.0);\n  float isHigh = float(t > 1.0);\n  float isMid = 1.0 - isLow - isHigh;\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\n}\n\nvec4 visualize(float t) {\n  const vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\n  const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\n  return visualize(BLUE, RED, t);\n}\n\n// #pragma glslify: export(visualize)\n\n\n// END ../common/visualize.glsl\n// START ../common/waves.glsl\nfloat waves(vec4 color, vec2 position, vec2 direction, float highResTimeStamp) {\n  return sin(\n    dot(position, direction / pow(length(direction), 2.0)) +\n      float(highResTimeStamp) / 200.0\n  );\n}\n\n// #pragma glslify: export(waves)\n\n\n// END ../common/waves.glsl\n\n// START ../common/sdf3d/sdTorus.glsl\nfloat sdTorus(float r0, float r1, vec3 p) {\n  vec3 closestCenter = vec3(normalize(p.xy) * r0, 0.0);\n  return distance(closestCenter, p) - r1;\n}\n\n// #pragma glslify: export(sdTorus)\n\n\n// END ../common/sdf3d/sdTorus.glsl\n// START ../common/sdf3d/sdCapsule.glsl\nfloat sdCapsule(vec3 a, vec3 b, float r, vec3 p) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h) - r;\n}\n// #pragma glslify: export(sdCapsule)\n\n// END ../common/sdf3d/sdCapsule.glsl\n// START ../common/sdf3d/opElongate.glsl\nvec3 opElongate(vec3 h, vec3 p) {\n  return p - clamp(p, -h, h);\n}\n// #pragma glslify: export(opElongate)\n\n// END ../common/sdf3d/opElongate.glsl\n// START ../common/sdf3d/sdSphere.glsl\nfloat sdSphere(float radius, vec3 p) {\n  return length(p) - radius;\n}\n\n// #pragma glslify: export(sdSphere)\n\n\n// END ../common/sdf3d/sdSphere.glsl\n// START ../common/sdf3d/sdCylinder.glsl\nfloat sdCylinder(float radius, float z, vec3 p) {\n  vec2 d = vec2(length(p.xy), abs(p.z)) - vec2(radius, z);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// #pragma glslify: export(sdCylinder)\n\n\n// END ../common/sdf3d/sdCylinder.glsl\n// START ../common/sdf3d/sdCone.glsl\n\n/**\n * Signed distance function (SDF) of a cone. The tip of the cone is at the\n * origin and points towards +Z. q is a point on the rim of the cone.\n */\nfloat sdCone(vec2 c, float h, vec3 p) {\n  vec2 q = h * vec2(c.x / c.y, -1.0);\n  vec2 w = vec2(length(p.xz), p.y);\n  vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);\n  vec2 b = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0);\n  float k = sign(q.y);\n  float d = min(dot(a, a), dot(b, b));\n  float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));\n  return sqrt(d) * sign(s);\n}\n// #pragma glslify: export(sdBox)\n\nfloat sdConeB(vec2 c, float h, vec3 p) {\n  float q = length(p.xz);\n  return max(dot(c.xy, vec2(q, p.y)), -h - p.y);\n}\n\n// END ../common/sdf3d/sdCone.glsl\n// START ../common/sdf2d/addChamfer.glsl\n\nfloat addChamfer(float d, float a, float b) {\n  // exact variant, but abs is larger when a and b aren't perpendicular\n  // which is worse than underestimating, which is what the simple version does.\n  //  vec2 p = vec2(a, b);\n  //  if (p.x < d && p.y < d) {\n  //    p = rot2(0.25 * PI) * p;\n  //    p.y = abs(p.y);\n  //    p.y -= min(p.y, d * SQRT1_2);\n  //    p.x -= d * SQRT1_2;\n  //    //    p -= vec2(SQRT1_2) * clamp(dot(p, vec2(SQRT1_2)), 0.0, d);\n  //    float fillet = -length(p);\n  //    return -sign(p.x) * fillet;\n  //  } else {\n  //  }\n  float tillet = (a + b - d) * SQRT1_2;\n  return min(tillet, min(a, b));\n}\n\n// #pragma glslify: export(addChamfer)\n\n\n// END ../common/sdf2d/addChamfer.glsl\n// START ../common/sdf2d/addFillet.glsl\nfloat addFillet(float r, float a, float b) {\n  if (a < r && b < r) {\n    return r - distance(vec2(a, b), vec2(r));\n  } else {\n    return min(a, b);\n  }\n}\n\n// #pragma glslify: export(addFillet)\n\n\n// END ../common/sdf2d/addFillet.glsl\n// START ../common/sdf3d/sdBox.glsl\n\nfloat sdBox(vec3 r, vec3 p) {\n  vec3 q = abs(p) - r;\n  return length(max(q, 0.0)) + min(max3(q), 0.0);\n}\n\nfloat sdBox(vec3 r, float r2, vec3 p) {\n  return sdBox(r - r2, p) - r2;\n}\n\n// #pragma glslify: export(sdBox)\n\n\n// END ../common/sdf3d/sdBox.glsl\n// START ../common/sdf3d/sdOctahedron.glsl\nfloat sdOctahedron(float s, vec3 p) {\n  p = abs(p);\n  float m = p.x + p.y + p.z - s;\n  vec3 q;\n  if (3.0 * p.x < m) q = p.xyz;\n  else if (3.0 * p.y < m) q = p.yzx;\n  else if (3.0 * p.z < m) q = p.zxy;\n  else return m * 0.57735027;\n\n  float k = clamp(0.5 * (q.z - q.y + s), 0.0, s);\n  return length(vec3(q.x, q.y - s + k, q.z - k));\n}\n// #pragma glslify: export(sdOctahedron)\n\nfloat sdOctahedron(vec3 p, float s) {\n  p = abs(p);\n\n  float m = p.x + p.y + p.z - s;\n  //find point on octohedron surf nearest to p\n  vec3 projPoint = p - vec3(0.333333 * m); //project onto surface plane\n  //now push projected point, if outside triangle edge, perpendicular to edge, to edge\n  vec3 toMove = min(projPoint, 0.0); //if projpoint.x<0 move along (1.0,-0.5,-0.5) , etc\n  float toMoveSum = dot(toMove, vec3(1.0)); //which is basically along (1.5,0,0) then vec3(-0.5)\n\n  vec3 movedPoint = projPoint + toMove * vec3(-1.5) + toMoveSum * vec3(0.5); //better to multiply toMove by a matrix (1s diagonal, 0.5 other)?\n\n  movedPoint = max(movedPoint, 0.0); //cap x,y,z to 0 then\n  movedPoint *= s / dot(movedPoint, vec3(1.0)); //scale about 0,0,0\n\n  return length(p - movedPoint);\n}\n\n// END ../common/sdf3d/sdOctahedron.glsl\n// START ../common/sdf3d/add.glsl\nfloat add(float a, float b) {\n  return min(a, b);\n}\n\n// #pragma glslify: export(add)\n\n\n// END ../common/sdf3d/add.glsl\n// START ../common/sdf3d/sub.glsl\nfloat sub(float from, float what) {\n  return max(from, -what);\n}\n\n// #pragma glslify: export(sub)\n\n\n// END ../common/sdf3d/sub.glsl\n\nuniform sampler2D texture;\nuniform float secs;\nuniform mat4 lll;\nuniform mat4 llli;\nuniform vec4 colorPrimary;\nuniform vec4 colorSecondary;\nuniform vec4 colorBackground;\nuniform float a;\nuniform float b;\nuniform float c;\nuniform float d;\nuniform float highResTimeStamp;\nuniform int bandCount;\nuniform vec3 campos;\nin float n;\nin vec2 coord;\nout vec4 fragColor;\n\n\nconst vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\nconst vec4 yellow = vec4(1.0, 1.0, 0.0, 1.0);\nconst vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\nconst vec4 blue = vec4(0.0, 0.0, 1.0, 1.0);\nconst vec4 purple = vec4(0.5, 0.0, 0.5, 1.0);\nconst vec4 red = vec4(1.0, 0.0, 0.0, 1.0);\n\nstruct RMHit {\n  float distance;\n  vec4 color;\n};\nRMHit mixa(RMHit a, RMHit b, float t) {\n  return RMHit(mix(a.distance, b.distance, t), mix(a.color, b.color, t));\n}\nfloat skybox(vec3 p) {\n  return 32.0 - max3(abs(p));\n}\n\nfloat perlinSphere(float radius, vec3 p) {\n  vec3 cp = normalize(p);\n  float alpha = atan(cp.y, cp.x);\n  float beta = asin(cp.z);\n  return length(p) -\n  radius +\n  0.1 *\n    perlin2D(vec2(0.0 / 100.0, 0.0) + (vec2(5.0) + vec2(alpha, beta)) * 8.0);\n}\n\nfloat cylCircle(vec3 p) {\n  float d = 10e9;\n  for (int i = 0; i < 10; i++) {\n    d = min(\n      d,\n      sdCylinder(0.2, 2.0, p + fromPolar(3.0, TAU * float(i) / 10.0, 1.0))\n    );\n  }\n\n  return d;\n}\n\nfloat rblock(float r, out vec3 p) {\n  return sdBox(vec3(r), p);\n}\n\nRMHit add(RMHit a, RMHit b) {\n  //    return a.distance < b.distance\n  //        ? RMHit(a.distance, a.color)\n  //        : RMHit(b.distance, b.color);\n  return mixa(a, b, float(b.distance < a.distance));\n}\n\nfloat wtf(vec3 p) {\n  vec3 center = p - mod(p, 3.0) + vec3(1.5);\n  return rblock(0.4 + 0.3 * sin(secs + center.x), center);\n}\n\nRMHit addFillet(float r, RMHit a, RMHit b) {\n  if (a.distance < r && b.distance < r) {\n    return RMHit(\n      r - distance(vec2(a.distance, b.distance), vec2(r)),\n      mix(a.color, b.color, (a.distance - b.distance) / r * 0.5 + 0.5)\n    );\n  } else {\n    return add(a, b);\n  }\n}\n\nRMHit addFillet(float r, RMHit a, RMHit b, vec4 tilletColor) {\n  if (a.distance < r && b.distance < r) {\n    return RMHit(\n      r - distance(vec2(a.distance, b.distance), vec2(r)),\n      tilletColor\n    );\n  } else {\n    return add(a, b);\n  }\n}\nRMHit addFillet2(float r, RMHit a, RMHit b) {\n  float h = smoothstep(-r, r, a.distance - b.distance);\n  return RMHit(\n    mix(a.distance, b.distance, h) - r * h * (1.0 - h),\n    mix(a.color, b.color, h)\n  );\n}\n\nRMHit neg(RMHit a) {\n  return RMHit(-a.distance, a.color);\n}\nRMHit sub(RMHit from, RMHit what) {\n  RMHit whatNeg = neg(what);\n  return mixa(from, whatNeg, float(whatNeg.distance > from.distance));\n}\n\nvec3 modv(vec3 v, vec3 dir1, float y) {\n  float t = dot(v, dir1);\n  return v - floor(t / y) * y * dir1;\n}\nvec3 modRotZ(vec3 p, float count) {\n  vec2 polarXY = toPolar(p.xy);\n  return fromPolar(polarXY.x, mod(polarXY.y, TAU / count), p.z);\n}\n\nfloat sin01(float x) {\n  return 0.5 + 0.5 * sin(x);\n}\nfloat cos01(float x) {\n  return 0.5 + 0.5 * cos(x);\n}\n\nfloat betterBox(vec3 r, vec3 p) {\n  vec3 q = abs(p) - r;\n  return length(max(q, 0.0)) + min(max3(q), 0.0);\n  p = abs(p);\n  return max3(p - r);\n}\n\nfloat sdEllipsoidB(vec3 r, vec3 p) {\n  float k0 = length(p / r);\n  float k1 = length(p / (r * r));\n  return k0 * (k0 - 1.0) / k1;\n}\nfloat sdOctahedronB(float s, vec3 p) {\n  p = abs(p);\n  return (p.x + p.y + p.z - s) * 0.57735027;\n}\nfloat donutc(float r0, float r1, vec3 p) {\n  vec3 closestCenter = vec3(normalize(p.xy) * r0, 0.0);\n  return distance(closestCenter, p) - r1;\n}\n\nfloat smoothmin(float r, float a, float b) {\n  float h = smoothstep(-r, r, a - b);\n  return mix(a, b, h) - r * h * (1.0 - h);\n}\n\nRMHit sdf(vec3 p) {\n  return RMHit(0.0, black);\n}\n\nfloat sdff(vec3 p) {\n  return sdf(p).distance;\n}\n\nstruct RMResult {\n  float distance;\n  vec3 pos;\n  vec4 color;\n};\nRMResult raymarching2(vec3 start, vec3 dir1) {\n  vec3 pos = start;\n  RMHit hit;\n  for (int i = 0; i < 200; i++) {\n    hit = sdf(pos);\n    if (hit.distance < 0.0001) break;\n    pos = pos + dir1 * hit.distance;\n  }\n  return RMResult(hit.distance, pos, hit.color);\n}\n\nfloat softshadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {\n  float res = 1.0;\n  float t = 0.1;\n  for (int i = 0; i < 1000 && t < maxt; i++) {\n    float h = sdff(ro + rd * t);\n    if (h < 0.001) return 0.0;\n    res = min(res, k * h / t);\n    t += h;\n  }\n  return res;\n}\n\nconst float eps = 1e-4;\nvec3 sdfNormal1(vec3 p, float d) {\n  return normalize(\n    vec3(\n      sdff(p + vec3(eps, 0.0, 0.0)),\n      sdff(p + vec3(0.0, eps, 0.0)),\n      sdff(p + vec3(0.0, 0.0, eps))\n    ) -\n      sdff(p)\n  );\n}\n\nfloat ambientOcclusion(vec3 pWC, vec3 n1WC) {\n  float k = 1.0;\n  float distance = sdff(pWC + n1WC * k);\n  return clamp(distance / k, 0.0, 1.0);\n}\n\n//layout (depth_greater) out float gl_FragDepth;\nvoid main() {\n  vec3 light = normalize(vec3(-1.0, -2.0, -2));\n\n  vec3 a = vec3(coord, -1.0);\n  vec3 b = vec3(coord, 1.0);\n  vec3 aWC = transform(llli, a);\n  vec3 bWC = transform(llli, b);\n  vec3 lookDir1 = normalize(bWC - aWC);\n\n  RMResult hitWC = raymarching2(aWC, lookDir1);\n  vec3 hitn1 = sdfNormal1(hitWC.pos, hitWC.distance);\n  float dWC = distance(aWC, hitWC.pos);\n  vec3 hitNDC = transform(lll, hitWC.pos);\n\n  vec3 sunPoint = raymarching2(hitWC.pos + hitn1 * 0.1, -light).pos;\n  //    float inSun = float(distance(hitWC.pos, sunPoint) > 30.);\n  float inSun = softshadow(\n    hitWC.pos + hitn1 * 0.05,\n    -light,\n    0.0001,\n    300.0,\n    8.0\n  );\n  //    float inSun=1.;\n\n  vec3 material = vec3(0.0, 0.2, 0.0);\n  if (dWC > 100.0) {\n    material = vec3(0.0, 0.0, 0.0);\n  }\n\n  const vec3 sunlightColor = vec3(8.0, 6.0, 1.0);\n\n  float aOcc = ambientOcclusion(hitWC.pos, hitn1);\n\n  vec3 reflectionDirection = reflect(light, hitn1);\n\n  vec3 color = vec3(0.0);\n  color += material * aOcc;\n  color += inSun * sunlightColor * material * max(0.0, dot(-light, hitn1));\n  //    color = (hitn1);\n\n  vec3 camPos = aWC;\n\n  vec3 eyeDirection = -lookDir1;\n  float uMaterialShininess = 256.0;\n  float specularLightWeighting = pow(\n    max(dot(reflectionDirection, eyeDirection), 0.0),\n    uMaterialShininess\n  );\n  color += specularLightWeighting;\n  //    float lightIntensity = 0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.);\n  //    float lightIntensity =\n  //        0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.) + 0.3*specularLightWeighting;\n  //    fragColor = visualize(blue, red, mix(0.5, 1.0, inSun) * lightIntensity);\n  //    fragColor = mix(hitWC.color, colorBackground, mix(0.5, 1.0, inSun) * clamp(lightIntensity, 0., 1.));\n  color = pow(color, vec3(1.0 / 2.2)); // gamma correction\n  fragColor = vec4(color, 1.0);\n  //    fragColor = visualize(hitWC.pos.x/10.);\n  //    fragColor = hitWC.color;\n  //    fragColor = visualize(blue, red, distance(hitWC, sunPoint)/20.);\n  //    fragColor = vec4(coord,0.,1.);\n  //    fragColor = vec4(aWC, 1.0);\n  // remap [-1, 1] to [0, 1]\n  // gl_FragDepth = hitNDC.z * 0.5 + 0.5;\n  //    gl_FragDepth = .9999999;\n}\n".replace(/RMHit sdf\(vec3 p\) {[\s\S]*?}/,G(Q)))])},[Q]),(0,u.useEffect)(()=>{Object.assign(F.current,w)},[w]);const K=(0,u.useCallback)(({dim:n,children:t})=>u.createElement(o.A,{variant:"contained",onClick:()=>Y(n),disabled:void 0!==e},void 0===e?t:"Rendering... "+(""+Math.floor(100*e)).padStart(3,"â€‡")+"%"),[Y,e]);function J({cam:n}){const e=H.l.fromShortString(n);z({cam:N.w.toShortString(e)})}return u.createElement(l.A,{container:!0,style:{height:"99%"}},u.createElement(l.A,{size:{xs:12,md:9}},u.createElement("div",{style:{height:"100%"}},u.createElement("canvas",{ref:n,style:{width:"100%",height:"100%",cursor:0===D?"move":"grab"},width:R,height:R,tabIndex:0}))),u.createElement(l.A,{size:{xs:12,md:3},sx:{display:"flex",flexDirection:"column",width:"100%",padding:2,alignItems:"stretch",gap:2}},u.createElement(a.A,null,u.createElement(r.A,null,"Raymarching demo.")),u.createElement(c.A,{onChange:n=>T(+n.target.value),value:R},u.createElement(i.A,{value:256},"256x256"),u.createElement(i.A,{value:512},"512x512")),u.createElement(g._,{state:w,setStatePartial:z,prop:"a",inputProps:{step:.05}})," ",u.createElement(g._,{state:w,setStatePartial:z,prop:"b",inputProps:{step:.05}}),u.createElement(g._,{state:w,setStatePartial:z,prop:"c",inputProps:{step:.05}})," ",u.createElement(g._,{state:w,setStatePartial:z,prop:"d",inputProps:{step:.05}}),u.createElement(K,{dim:[1920,1080]},"render hd"),u.createElement(K,{dim:[3840,2160]},"render 4k"),u.createElement(o.A,{color:"secondary",variant:"outlined",onClick:()=>J({cam:"999.999.999~-56.-58.-61~-44.-44.79"})},"Cam 0"),u.createElement(o.A,{color:"secondary",variant:"outlined",onClick:()=>J({cam:"57.427.96~1.-100.-8~7.-7.99"})},"Cam 1"),u.createElement(o.A,{color:"secondary",variant:"outlined",onClick:()=>J({cam:"53.80.892~-9.-8.-100~-18.-99.8"})},"Cam 2"),u.createElement("div",null,"cam: ",w.cam),u.createElement("div",null,"fps: ",B),u.createElement(V,{label:"gp",onFocus:()=>setEditing(!0),onBlur:()=>setEditing(!1)},f),u.createElement("div",null,u.createElement(Z,{value:Q,onChange:j})),u.createElement("div",null,u.createElement("pre",null,u.createElement("code",null,G(Q))))))}},2917:(n,e,t)=>{t.d(e,{A:()=>u});var o=t(7810),a=t(4164),r=t(1870),l=t(6551),i=t(3166),s=t(8667),c=t(3152),d=t(3200);function f(n){return(0,d.Ay)("MuiCard",n)}(0,c.A)("MuiCard",["root"]);var m=t(4922);const p=(0,l.Ay)(s.A,{name:"MuiCard",slot:"Root"})({overflow:"hidden"}),u=o.forwardRef(function(n,e){const t=(0,i.b)({props:n,name:"MuiCard"}),{className:o,raised:l=!1,...s}=t,c={...t,raised:l},d=(n=>{const{classes:e}=n;return(0,r.A)({root:["root"]},f,e)})(c);return(0,m.jsx)(p,{className:(0,a.A)(d.root,o),elevation:l?8:void 0,ref:e,ownerState:c,...s})})},3015:(n,e,t)=>{t.d(e,{A:()=>p});var o=t(7810),a=t(4164),r=t(1870),l=t(6551),i=t(3166),s=t(3152),c=t(3200);function d(n){return(0,c.Ay)("MuiCardContent",n)}(0,s.A)("MuiCardContent",["root"]);var f=t(4922);const m=(0,l.Ay)("div",{name:"MuiCardContent",slot:"Root"})({padding:16,"&:last-child":{paddingBottom:24}}),p=o.forwardRef(function(n,e){const t=(0,i.b)({props:n,name:"MuiCardContent"}),{className:o,component:l="div",...s}=t,c={...t,component:l},p=(n=>{const{classes:e}=n;return(0,r.A)({root:["root"]},d,e)})(c);return(0,f.jsx)(m,{as:l,className:(0,a.A)(p.root,o),ownerState:c,ref:e,...s})})},4077:(n,e,t)=>{t.d(e,{A:()=>o});const o="#version 300 es\n\nprecision highp float;\n\n// START ../common/banded.glsl\nfloat banded(float bandCount, float t) {\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\n}\nfloat banded(int bandCount, float t) {\n  return banded(float(bandCount), t);\n}\n\n// #pragma glslify: export(banded)\n\n\n// END ../common/banded.glsl\n// START ../common/between.glsl\nbool between(float min, float max, float value) {\n  return min <= value && value <= max;\n}\n\n// #pragma glslify: export(between)\n\n\n// END ../common/between.glsl\n// START ../common/hexFns.glsl\n// START ./max3.glsl\nfloat max3(float a, float b, float c) {\n  return max(a, max(b, c));\n}\nfloat max3(vec3 v) {\n  return max(v.x, max(v.y, v.z));\n}\n\n// #pragma glslify: export(max3)\n\n\n// END ./max3.glsl\n// START ./constants.glsl\nconst float SQRT1_2 = 0.7071067811865476;\nconst float SQRT1_3 = 0.57735026919;\nconst float SQRT2 = 1.4142135623730951;\nconst float SQRT3 = 1.732050807568877;\n// sqrt(3)/2 = sin(60*)\nconst float SQRT3_2 = 0.86602540378;\nconst float GOLDEN_RATIO = 1.61803398875;\nconst float PI = 3.141592653589793;\nconst float TAU = 6.28318530718;\n/**\n * One degree in radians. Use like `sin(30 * DEG)`.\n */\nconst float DEGREE = 0.017453292519943295;\n\n// END ./constants.glsl\n\nvec3 hexRound(vec3 hex) {\n  vec3 r = floor(hex + 0.5);\n  vec3 diff = abs(r - hex);\n\n  if (diff.x > diff.y && diff.x > diff.z) {\n    r.x = -(r.y + r.z);\n  } else if (diff.y > diff.z) {\n    r.y = -(r.x + r.z);\n  } else {\n    r.z = -(r.x + r.y);\n  }\n\n  return r;\n}\nvec2 hex2Ra(vec3 hex) {\n  float y = hex.t * SQRT3_2;\n  float x = hex.s + hex.t / 2.0;\n  return vec2(x, y);\n}\n\nfloat hexSdf(vec3 hex) {\n  return max3(abs(hex.yzx + hex.zxy / 2.0));\n}\nvec3 ra2Hex(vec2 xy) {\n  float hex_t = xy.y / SQRT3_2;\n  float hex_s = xy.x - hex_t / 2.0;\n  return vec3(hex_s, hex_t, -(hex_s + hex_t));\n}\n\n// END ../common/hexFns.glsl\n// START ../common/matrices.glsl\n\nmat2 rot2(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat2(c, s, -s, c);\n}\nmat3 rotX(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\n}\nmat3 rotY(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\n}\nmat3 rotZ(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\n}\n/**\n * Returns a matrix that puts the camera at the eye point `ex, ey, ez` looking\n * toward the center point `cx, cy, cz` with an up direction of `ux, uy, uz`.\n * This emulates the OpenGL function `gluLookAt()`.\n */\nmat4 lookAt(vec3 eye, vec3 focus, vec3 up) {\n  vec3 f = normalize(eye - focus);\n  vec3 s = normalize(cross(up, f));\n  vec3 t = normalize(cross(f, s));\n\n  return mat4(\n    vec4(s.x, t.x, f.x, 0.0),\n    vec4(s.y, t.y, f.y, 0.0),\n    vec4(s.z, t.z, f.z, 0.0),\n    vec4(-dot(s, eye), -dot(t, eye), -dot(f, eye), 1)\n  );\n}\n\n// the OpenGL function `glFrustum()`.\nmat4 frustum(\n  float left,\n  float right,\n  float bottom,\n  float top,\n  float near,\n  float far\n) {\n  return mat4(\n    vec4(2.0 * near / (right - left), 0.0, 0.0, 0.0),\n    vec4(0, 2.0 * near / (top - bottom), 0.0, 0.0),\n    vec4(\n      (right + left) / (right - left),\n      (top + bottom) / (top - bottom),\n      -(far + near) / (far - near),\n      -1\n    ),\n    vec4(0.0, 0.0, -2.0 * far * near / (far - near), 0.0)\n  );\n}\n\nmat4 perspective(float fovDegrees, float aspect, float near, float far) {\n  float y = tan(fovDegrees * DEGREE / 2.0) * near;\n  float x = y * aspect;\n  return frustum(-x, x, -y, y, near, far);\n}\nmat4 ortho(\n  float left,\n  float right,\n  float bottom,\n  float top,\n  float near,\n  float far\n) {\n  return mat4(\n    vec4(2.0 / (right - left), 0.0, 0.0, 0.0),\n    vec4(0.0, 2.0 / (top - bottom), 0.0, 0.0),\n    vec4(0.0, 0.0, -2.0 / (far - near), 0.0),\n    vec4(\n      -(right + left) / (right - left),\n      -(top + bottom) / (top - bottom),\n      -(far + near) / (far - near),\n      1.0\n    )\n  );\n}\n\n// END ../common/matrices.glsl\n// START ../common/perlin2DTexture.glsl\nuniform sampler2D gradients;\n/* Create random direction vector\n */\nvec2 randomGradient(vec2 i) {\n  // Random float. No precomputed gradients mean this works for any number of grid coordinates\n  float random =\n    2920.0 *\n    sin(float(i.x) * 2.1942 + float(i.y) * 1.71324 + 8.912) *\n    cos(float(i.x) * 2.3157 * float(i.y) * 2.17832 + 9.758);\n  //    random = (i.x + 1667.) * (i.x + 2083.) * (i.y + 2659.) * (i.y * 50.77 + .3769);\n  //    random = sin(SQRT2 * i.x) + cos(GOLDEN_RATIO * i.y) + tan((i.x + i.y) * SQRT3);\n  return vec2(cos(random), sin(random));\n}\nfloat dotGridGradient(vec2 cell, vec2 pos) {\n  vec2 d = cell - pos;\n\n  //  vec2 gradient = texelFetch(gradients, ivec2(cell), 0).xy;\n  vec2 gradient = randomGradient(vec2(cell));\n\n  return dot(gradient, d);\n}\n\nfloat mixx(float a, float b, float t) {\n  return mix(a, b, smoothstep(0.0, 1.0, t));\n  //    return mix(a, b, t);\n}\n\n// resulting range is [-0.68, 0.68]. Use unmix to normalize if necessary.\nfloat perlin2D(vec2 xy) {\n  float x0 = floor(xy.x);\n  float x1 = x0 + 1.0;\n  float y0 = floor(xy.y);\n  float y1 = y0 + 1.0;\n\n  // Interpolate between grid point gradients\n  float n00 = dotGridGradient(vec2(x0, y0), xy);\n  float n10 = dotGridGradient(vec2(x1, y0), xy);\n  float ny0 = mixx(n00, n10, xy.x - x0);\n\n  float n01 = dotGridGradient(vec2(x0, y1), xy);\n  float n11 = dotGridGradient(vec2(x1, y1), xy);\n  float ny1 = mixx(n01, n11, xy.x - x0);\n\n  return mixx(ny0, ny1, xy.y - y0);\n}\n\n// #pragma glslify: export(perlin2D)\n\n\n// END ../common/perlin2DTexture.glsl\n// START ../common/polar.glsl\n// START ../common/fromPolar.glsl\n// START ./unmix.glsl\nfloat unmix(float a, float b, float value) {\n  return (value - a) / (b - a);\n}\n\n// #pragma glslify: export(unmix)\n\n\n// END ./unmix.glsl\n\nvec3 fromPolar(float radius, float phi, float z) {\n  return vec3(radius * cos(phi), radius * sin(phi), z);\n}\n\nvec2 fromPolar(float radius, float phi) {\n  return vec2(radius * cos(phi), radius * sin(phi));\n}\n\nvec2 fromPolar(vec2 polar) {\n  return fromPolar(polar.x, polar.y);\n}\n\n// #pragma glslify: export(fromPolar)\n\n\n// END ../common/fromPolar.glsl\n// START ../common/toPolar.glsl\n\nvec2 toPolar(vec2 xy) {\n  return vec2(length(xy), atan(xy.y, xy.x));\n}\n\nmat2 toPolarDerivate(vec2 xy) {\n  return mat2(xy.x * xy.x, xy.y * xy.y, -xy.y, xy.x) / dot(xy, xy);\n}\n\n// #pragma glslify: export(toPolar)\n\n\n// END ../common/toPolar.glsl\n\n// END ../common/polar.glsl\n// START ../common/remix.glsl\n\nfloat remix(float fromA, float fromB, float toA, float toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\nvec4 remix(float fromA, float fromB, vec4 toA, vec4 toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\n// #pragma glslify: export(remix)\n\n\n// END ../common/remix.glsl\n// START ../common/transform.glsl\nvec3 transform(mat4 pm, vec3 p) {\n  vec4 pStar = pm * vec4(p, 1);\n  return pStar.xyz / pStar.w;\n}\n\nvec2 transform(mat4 pm, vec2 p) {\n  vec4 pStar = pm * vec4(p, 0, 1);\n  return pStar.xy / pStar.w;\n}\n\n// END ../common/transform.glsl\n// START ../common/visualize.glsl\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\n  float isLow = float(t < 0.0);\n  float isHigh = float(t > 1.0);\n  float isMid = 1.0 - isLow - isHigh;\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\n}\n\nvec4 visualize(float t) {\n  const vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\n  const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\n  return visualize(BLUE, RED, t);\n}\n\n// #pragma glslify: export(visualize)\n\n\n// END ../common/visualize.glsl\n// START ../common/waves.glsl\nfloat waves(vec4 color, vec2 position, vec2 direction, float highResTimeStamp) {\n  return sin(\n    dot(position, direction / pow(length(direction), 2.0)) +\n      float(highResTimeStamp) / 200.0\n  );\n}\n\n// #pragma glslify: export(waves)\n\n\n// END ../common/waves.glsl\n\n// START ../common/sdf3d/add.glsl\nfloat add(float a, float b) {\n  return min(a, b);\n}\n\n// #pragma glslify: export(add)\n\n\n// END ../common/sdf3d/add.glsl\n// START ../common/sdf2d/addChamfer.glsl\n\nfloat addChamfer(float d, float a, float b) {\n  // exact variant, but abs is larger when a and b aren't perpendicular\n  // which is worse than underestimating, which is what the simple version does.\n  //  vec2 p = vec2(a, b);\n  //  if (p.x < d && p.y < d) {\n  //    p = rot2(0.25 * PI) * p;\n  //    p.y = abs(p.y);\n  //    p.y -= min(p.y, d * SQRT1_2);\n  //    p.x -= d * SQRT1_2;\n  //    //    p -= vec2(SQRT1_2) * clamp(dot(p, vec2(SQRT1_2)), 0.0, d);\n  //    float fillet = -length(p);\n  //    return -sign(p.x) * fillet;\n  //  } else {\n  //  }\n  float tillet = (a + b - d) * SQRT1_2;\n  return min(tillet, min(a, b));\n}\n\n// #pragma glslify: export(addChamfer)\n\n\n// END ../common/sdf2d/addChamfer.glsl\n// START ../common/sdf2d/addFillet.glsl\nfloat addFillet(float r, float a, float b) {\n  if (a < r && b < r) {\n    return r - distance(vec2(a, b), vec2(r));\n  } else {\n    return min(a, b);\n  }\n}\n\n// #pragma glslify: export(addFillet)\n\n\n// END ../common/sdf2d/addFillet.glsl\n// START ../common/sdf3d/opElongate.glsl\nvec3 opElongate(vec3 h, vec3 p) {\n  return p - clamp(p, -h, h);\n}\n// #pragma glslify: export(opElongate)\n\n// END ../common/sdf3d/opElongate.glsl\n// START ../common/sdf3d/opRepLim.glsl\nvec3 opRepLim(vec3 p, vec3 cellSize, vec3 limit) {\n  return p - cellSize * clamp(round(p / cellSize), vec3(0.0), limit);\n}\nvec2 opRepLim(vec2 p, vec2 cellSize, vec2 limit) {\n  return p - cellSize * clamp(round(p / cellSize), vec2(0.0), limit);\n}\nfloat opRepLim(float p, float cellSize, float limit) {\n  return p - cellSize * clamp(round(p / cellSize), 0.0, limit);\n}\n\n// #pragma glslify: export(opRepLim)\n\n\n// END ../common/sdf3d/opRepLim.glsl\n// START ../common/sdf3d/sdBox.glsl\n\nfloat sdBox(vec3 r, vec3 p) {\n  vec3 q = abs(p) - r;\n  return length(max(q, 0.0)) + min(max3(q), 0.0);\n}\n\nfloat sdBox(vec3 r, float r2, vec3 p) {\n  return sdBox(r - r2, p) - r2;\n}\n\n// #pragma glslify: export(sdBox)\n\n\n// END ../common/sdf3d/sdBox.glsl\n// START ../common/sdf3d/sdCone.glsl\n\n/**\n * Signed distance function (SDF) of a cone. The tip of the cone is at the\n * origin and points towards +Z. q is a point on the rim of the cone.\n */\nfloat sdCone(vec2 c, float h, vec3 p) {\n  vec2 q = h * vec2(c.x / c.y, -1.0);\n  vec2 w = vec2(length(p.xz), p.y);\n  vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);\n  vec2 b = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0);\n  float k = sign(q.y);\n  float d = min(dot(a, a), dot(b, b));\n  float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));\n  return sqrt(d) * sign(s);\n}\n// #pragma glslify: export(sdBox)\n\nfloat sdConeB(vec2 c, float h, vec3 p) {\n  float q = length(p.xz);\n  return max(dot(c.xy, vec2(q, p.y)), -h - p.y);\n}\n\n// END ../common/sdf3d/sdCone.glsl\n// START ../common/sdf3d/sdCylinder.glsl\nfloat sdCylinder(float radius, float z, vec3 p) {\n  vec2 d = vec2(length(p.xy), abs(p.z)) - vec2(radius, z);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// #pragma glslify: export(sdCylinder)\n\n\n// END ../common/sdf3d/sdCylinder.glsl\n// START ../common/sdf3d/sdTorus.glsl\nfloat sdTorus(float r0, float r1, vec3 p) {\n  vec3 closestCenter = vec3(normalize(p.xy) * r0, 0.0);\n  return distance(closestCenter, p) - r1;\n}\n\n// #pragma glslify: export(sdTorus)\n\n\n// END ../common/sdf3d/sdTorus.glsl\n// START ../common/sdf3d/sdIcosahedron.glsl\n\n// signed distance function for icosahedron\n// cf. https://en.wikipedia.org/wiki/Regular_icosahedron\n// s: edge length\n// p: point to evaluate function for\nfloat sdIcosahedron(float s, vec3 p) {\n  // NN = 1/GOLDEN_RATIO = GOLDEN_RATIO - 1\n  const float K = GOLDEN_RATIO * 0.5;\n  // the three vertices of the icosahedron triangle which\n  // is fully inside the +++ octant. (edge length = 1)\n  const vec3 a = vec3(0.5, K, 0.0);\n  const vec3 b = vec3(0.0, 0.5, K);\n  const vec3 c = vec3(K, 0.0, 0.5);\n  const vec3 ab1 = b - a; // values chosen so edge length is 1\n  const vec3 n1 = normalize(cross(a, b));\n  const vec3 n2 = normalize(cross(b, c));\n  const vec3 n3 = normalize(cross(c, a));\n  const vec3 xyz1 = normalize(vec3(1.0));\n  // for edge-length 1\n  const float INSCRIBED_SPHERE_RADIUS = 0.7557613141;\n\n  // we use a rotation where the icosahedron is symmetric\n  // in all three coordinate planes, and reduce the problem\n  // to the +++ octant\n  p = abs(p);\n\n  // there is one complete triangle in the +++ octant\n  // mirror on planes which go through origin and the\n  // complete triangles sides.\n  if (dot(p, n1) < 0.0) {\n    p += -2.0 * dot(p, n1) * n1;\n  }\n  if (dot(p, n2) < 0.0) {\n    p += -2.0 * dot(p, n2) * n2;\n  }\n  if (dot(p, n3) < 0.0) {\n    p += -2.0 * dot(p, n3) * n3;\n  }\n\n  // rotate space around (1,1,1) vector so that all sides of the triangle\n  // end up mapped on the ab side.\n  vec3 dirs = vec3(-dot(n1, p), -dot(n2, p), -dot(n3, p));\n  if (dirs.y > dirs.x && dirs.y > dirs.z) {\n    p = p.yzx;\n  } else if (dirs.z > dirs.x && dirs.z > dirs.y) {\n    p = p.zxy;\n  }\n\n  // check if the point is directly (perpendicular) above the triangle.\n  // as we have rotated the space, we only need to check if it is\n  // inside one edge.\n  vec3 midAB = (a + b) / 2.0;\n  vec3 pn = normalize(c - midAB);\n  float w = dot(midAB, pn);\n  if (dot(p, pn) > w * s) {\n    // if not, return the distance to the plane the triangle is in\n    return dot(xyz1, p) - INSCRIBED_SPHERE_RADIUS * s;\n  }\n\n  // project the point onto segment ab, and return the distance to it\n  float d3 = dot(ab1, p);\n  d3 = clamp(d3, -0.5 * s, 0.5 * s);\n  vec3 closestp = midAB * s + d3 * ab1;\n  return distance(closestp, p);\n}\n// #pragma glslify: export(sdIcosahedron)\n\n// END ../common/sdf3d/sdIcosahedron.glsl\n// START ../common/sdf3d/sdOctahedron.glsl\nfloat sdOctahedron(float s, vec3 p) {\n  p = abs(p);\n  float m = p.x + p.y + p.z - s;\n  vec3 q;\n  if (3.0 * p.x < m) q = p.xyz;\n  else if (3.0 * p.y < m) q = p.yzx;\n  else if (3.0 * p.z < m) q = p.zxy;\n  else return m * 0.57735027;\n\n  float k = clamp(0.5 * (q.z - q.y + s), 0.0, s);\n  return length(vec3(q.x, q.y - s + k, q.z - k));\n}\n// #pragma glslify: export(sdOctahedron)\n\nfloat sdOctahedron(vec3 p, float s) {\n  p = abs(p);\n\n  float m = p.x + p.y + p.z - s;\n  //find point on octohedron surf nearest to p\n  vec3 projPoint = p - vec3(0.333333 * m); //project onto surface plane\n  //now push projected point, if outside triangle edge, perpendicular to edge, to edge\n  vec3 toMove = min(projPoint, 0.0); //if projpoint.x<0 move along (1.0,-0.5,-0.5) , etc\n  float toMoveSum = dot(toMove, vec3(1.0)); //which is basically along (1.5,0,0) then vec3(-0.5)\n\n  vec3 movedPoint = projPoint + toMove * vec3(-1.5) + toMoveSum * vec3(0.5); //better to multiply toMove by a matrix (1s diagonal, 0.5 other)?\n\n  movedPoint = max(movedPoint, 0.0); //cap x,y,z to 0 then\n  movedPoint *= s / dot(movedPoint, vec3(1.0)); //scale about 0,0,0\n\n  return length(p - movedPoint);\n}\n\n// END ../common/sdf3d/sdOctahedron.glsl\n// START ../common/sdf3d/sdPyramid.glsl\n// Pyramid with tip at (0,0,0), up = z\n// c is the bottom corner. c.xy should be positive, c.z negative.\nvec2 sdPyramid(vec3 c, vec3 p) {\n  // pyramid is symmetric in XZ and YZ planes\n  p.xy = abs(p.xy);\n  bool flip = p.y * c.x > p.x * c.y; // p.y/p.x > c.y/c.x\n  c.xy = flip ? c.yx : c.xy;\n  p.xy = flip ? p.yx : p.xy;\n  vec3 cc = c / dot(c, c);\n  vec3 qx1 = normalize(vec3(-c.z, 0.0, c.x));\n  vec3 pOnQx = p - qx1 * dot(p, qx1);\n  float dx = dot(p, qx1);\n  float maxY = c.y * (pOnQx.x / c.x);\n  if (p.z <= c.z || pOnQx.z <= c.z) {\n    if (p.x <= c.x) {\n      // vertically underneath pyramid\n      return vec2(-p.z + c.z, 2.0);\n    } else {\n      float aa = distance(p, vec3(c.x, min(c.y, p.y), c.z));\n      return vec2(aa, 3.0);\n    }\n  } else if (pOnQx.y > maxY || pOnQx.z > 0.0) {\n    float xx = dot(cc, p);\n    float aa = length(p - clamp(xx, 0.0, 1.0) * c);\n\n    return vec2(aa, 1.0);\n  } else {\n    // need max for negativ values above base\n    return vec2(max(dx, -p.z + c.z), 0.0);\n  }\n}\n\n// #pragma glslify: export(sdPyramid)\n\n\n// END ../common/sdf3d/sdPyramid.glsl\n// START ../common/sdf3d/sdSphere.glsl\nfloat sdSphere(float radius, vec3 p) {\n  return length(p) - radius;\n}\n\n// #pragma glslify: export(sdSphere)\n\n\n// END ../common/sdf3d/sdSphere.glsl\n// START ../common/sdf3d/sub.glsl\nfloat sub(float from, float what) {\n  return max(from, -what);\n}\n\n// #pragma glslify: export(sub)\n\n\n// END ../common/sdf3d/sub.glsl\n\nuniform sampler2D texture;\nuniform float secs;\nuniform mat4 lll;\nuniform mat4 llli;\nuniform vec4 colorPrimary;\nuniform vec4 colorSecondary;\nuniform vec4 colorBackground;\nuniform float a;\nuniform float b;\nuniform float c;\nuniform float d;\nuniform float highResTimeStamp;\nuniform int bandCount;\nuniform vec3 campos;\nin float n;\nin vec2 coord;\nout vec4 fragColor;\n\n\nconst vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\nconst vec4 yellow = vec4(1.0, 1.0, 0.0, 1.0);\nconst vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\nconst vec4 blue = vec4(0.0, 0.0, 1.0, 1.0);\nconst vec4 purple = vec4(0.5, 0.0, 0.5, 1.0);\nconst vec4 red = vec4(1.0, 0.0, 0.0, 1.0);\n\nstruct RMHit {\n  float distance;\n  vec4 color;\n};\nRMHit mixa(RMHit a, RMHit b, float t) {\n  return RMHit(mix(a.distance, b.distance, t), mix(a.color, b.color, t));\n}\nfloat skybox(vec3 p) {\n  return 32.0 - max3(abs(p));\n}\n\nfloat perlinSphere(float radius, vec3 p) {\n  vec3 cp = normalize(p);\n  float alpha = atan(cp.y, cp.x);\n  float beta = asin(cp.z);\n  return length(p) -\n  radius +\n  0.1 *\n    perlin2D(vec2(0.0 / 100.0, 0.0) + (vec2(5.0) + vec2(alpha, beta)) * 8.0);\n}\n\nfloat cylCircle(vec3 p) {\n  float d = 10e9;\n  for (int i = 0; i < 10; i++) {\n    d = min(\n      d,\n      sdCylinder(0.2, 2.0, p + fromPolar(3.0, TAU * float(i) / 10.0, 1.0))\n    );\n  }\n\n  return d;\n}\n\nfloat rblock(float r, vec3 p) {\n  return sdBox(vec3(r), p);\n}\n\nRMHit add(RMHit a, RMHit b) {\n  //    return a.distance < b.distance\n  //        ? RMHit(a.distance, a.color)\n  //        : RMHit(b.distance, b.color);\n  return mixa(a, b, float(b.distance < a.distance));\n}\n\nfloat wtf(vec3 p) {\n  vec3 center = p - mod(p, 3.0) + vec3(1.5);\n  return rblock(0.4 + 0.3 * sin(secs + center.x), p - center);\n}\n\nRMHit addFillet(float r, RMHit a, RMHit b) {\n  if (a.distance < r && b.distance < r) {\n    return RMHit(\n      r - distance(vec2(a.distance, b.distance), vec2(r)),\n      mix(a.color, b.color, (a.distance - b.distance) / r * 0.5 + 0.5)\n    );\n  } else {\n    return add(a, b);\n  }\n}\n\nRMHit addFillet(float r, RMHit a, RMHit b, vec4 tilletColor) {\n  if (a.distance < r && b.distance < r) {\n    return RMHit(\n      r - distance(vec2(a.distance, b.distance), vec2(r)),\n      tilletColor\n    );\n  } else {\n    return add(a, b);\n  }\n}\nRMHit addFillet2(float r, RMHit a, RMHit b) {\n  float h = smoothstep(-r, r, a.distance - b.distance);\n  return RMHit(\n    mix(a.distance, b.distance, h) - r * h * (1.0 - h),\n    mix(a.color, b.color, h)\n  );\n}\n\nRMHit neg(RMHit a) {\n  return RMHit(-a.distance, a.color);\n}\nRMHit sub(RMHit from, RMHit what) {\n  RMHit whatNeg = neg(what);\n  return mixa(from, whatNeg, float(whatNeg.distance > from.distance));\n}\n\nvec3 modv(vec3 v, vec3 dir1, float y) {\n  float t = dot(v, dir1);\n  return v - floor(t / y) * y * dir1;\n}\nvec3 modRotZ(vec3 p, float count) {\n  vec2 polarXY = toPolar(p.xy);\n  return fromPolar(polarXY.x, mod(polarXY.y, TAU / count), p.z);\n}\n\nfloat sin01(float x) {\n  return 0.5 + 0.5 * sin(x);\n}\nfloat cos01(float x) {\n  return 0.5 + 0.5 * cos(x);\n}\n\nfloat betterBox(vec3 r, vec3 p) {\n  vec3 q = abs(p) - r;\n  return length(max(q, 0.0)) + min(max3(q), 0.0);\n  p = abs(p);\n  return max3(p - r);\n}\n\nfloat roundedBlock(vec3 r, float cr, vec3 p) {\n  return betterBox(r - vec3(cr), p) - cr;\n}\n\nfloat sdCapsule(vec3 a, vec3 b, float r, vec3 p) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h) - r;\n}\nfloat sdEllipsoidB(vec3 r, vec3 p) {\n  float k0 = length(p / r);\n  float k1 = length(p / (r * r));\n  return k0 * (k0 - 1.0) / k1;\n}\nfloat sdOctahedronB(float s, vec3 p) {\n  p = abs(p);\n  return (p.x + p.y + p.z - s) * 0.57735027;\n}\nfloat donutc(float r0, float r1, vec3 p) {\n  vec3 closestCenter = vec3(normalize(p.xy) * r0, 0.0);\n  return distance(closestCenter, p) - r1;\n}\n\nfloat sdCappedCylinder(float h, float r, vec3 p) {\n  vec2 d = vec2(length(p.xy), abs(p.z)) - vec2(r, h);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\nfloat smoothmin(float r, float a, float b) {\n  float h = smoothstep(-r, r, a - b);\n  return mix(a, b, h) - r * h * (1.0 - h);\n}\nfloat queen(vec3 p) {\n  float lxy = length(p.xy);\n  float d;\n  d = lxy - 1.1;\n  d += 0.16 * p.z;\n  d -= -c * (1.0 - pow(sin01(b + p.z * 2.5), 1.5));\n  d += 0.1 * normalize(p.xy).x * smoothstep(2.0, 0.5, p.z);\n  d +=\n    0.02 * sin(15.0 * atan(p.y, p.x) - p.z * 5.0) * smoothstep(2.0, 0.5, p.z);\n  //    float d = sdCappedCylinder(a, b, p);\n  d = max(d, -p.z);\n  d = max(d, p.z - 4.0);\n\n  float head = sdSphere(0.55, p - vec3(0.0, 0.0, 4.4));\n  d = smoothmin(0.15, d, head);\n  float crown = sdCone(\n    fromPolar(vec2(1.0, 1.15)),\n    1.0,\n    -(p - vec3(0.0, 0.0, 4.5)).yzx\n  );\n  d = min(d, crown);\n  d *= 0.5;\n  return d;\n}\n\nvec2 project(vec2 a, vec2 onto1) {\n  return onto1 * (dot(a, onto1) / dot(onto1, onto1));\n}\n\nvec3 reject(vec3 a, vec3 b1) {\n  return a - b1 * dot(a, b1);\n}\n\nRMHit sdf(vec3 p) {\n  const vec4 red = vec4(0.2, 0.0, 0.0, 1.0);\n  //  RMHit d = RMHit(block(vec3(-1.0, -1.0, -1.0), vec3(1.0, 1.0, 1.0), p), black);\n  //    RMHit d = RMHit(sphere(2., p), black);\n  //    RMHit d = RMHit(betterBox(vec3(1.), p), black);\n  //    RMHit d = RMHit(roundedBlock(vec3(1.), 0.1, p), black);\n  //    RMHit d = RMHit(donut(2., 0.5, p), black);\n  //    RMHit d = RMHit(sdCapsule(vec3(-a,-a,0.), vec3(a,a,0.), b, p), black);\n  //    RMHit d = RMHit(sdEllipsoidB(vec3(-a,-b,1.), p), black);\n  //    RMHit d = RMHit(sdOctahedron(1., p)-a, red) ;\n  //    RMHit d = RMHit(queen(p), black) ;\n  //    RMHit d = RMHit(lego(p), black) ;\n  //- vec3(0.0, 0.0, 1.0)\n  vec3 h = vec3(0.5, 0.0, 0.0);\n  vec3 q = abs(p) - h;\n  //    vec2 pyr = sdPyramid(\n  //        vec3(2.0, 2.0, -2.0),\n  //        opElongate(h,\n  //            rotZ(highResTimeStamp/1000.) *\n  //                rotX(c) *\n  //                opRepLim(p - vec3(-8., -8., 2.), vec3(8.), vec3(2., 2., 0.))));\n  vec3 p2 = rotX(highResTimeStamp * 0.0) * p;\n  vec2 xx = vec2(sdIcosahedron(d, p2) - c, 1.0);\n  vec4 cc = red;\n  cc.xyz = cc.xyz * xx.y * 0.1;\n  RMHit d = RMHit(xx.x, cc);\n  //    RMHit d = RMHit(sdCone(fromPolar(vec2(1., a)), b, p.yzx - vec3(0.,2., 0.)), black);\n  //    d.distance = abs(d.distance) - 0.4;\n  //    d.distance = abs(d.distance) - 0.1;\n  //    d.distance = abs(d.distance) - 0.02;\n  float s = length(p - vec3(1.0, 1.0, 0.0)) - 1.0;\n  //    d.distance = s;\n  //    d.distance = max(d.distance, -s);\n\n  vec3 color = 0.1 * sin(abs(vec3(0.0, PI, 0.0) + vec3(d.distance * PI * 2.0)));\n  //    color.z = .1*xx.y;\n  RMHit base = RMHit(sdBox(vec3(10.0, 10.0, 0.0), p), vec4(color, 1.0));\n\n  //    d = base;\n  d = add(base, d);\n  if (b > 1.0) {\n    d = base;\n  }\n  //    d.distance *=0.5;\n  return d;\n}\nfloat sdff(vec3 p) {\n  return sdf(p).distance;\n}\nfloat ambientOcclusion(vec3 pWC, vec3 n1WC) {\n  float k = 1.0;\n  float distance = sdff(pWC + n1WC * k);\n  return clamp(distance / k, 0.0, 1.0);\n}\n\nstruct RMResult {\n  float distance;\n  vec3 pos;\n  vec4 color;\n};\nRMResult raymarching2(vec3 start, vec3 dir1) {\n  vec3 pos = start;\n  RMHit hit;\n  for (int i = 0; i < 200; i++) {\n    hit = sdf(pos);\n    if (hit.distance < 0.0001 * hit.distance) break;\n    pos = pos + dir1 * hit.distance;\n  }\n  return RMResult(hit.distance, pos, hit.color);\n}\n\nfloat softshadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {\n  float res = 1.0;\n  float t = 0.1;\n  for (int i = 0; i < 1000 && t < maxt; i++) {\n    float h = sdff(ro + rd * t);\n    if (h < 0.001) return 0.0;\n    res = min(res, k * h / t);\n    t += h;\n  }\n  return res;\n}\n\nconst float eps = 1e-4;\nvec3 sdfNormal1(vec3 p, float d) {\n  return normalize(\n    vec3(\n      sdff(p + vec3(eps, 0.0, 0.0)),\n      sdff(p + vec3(0.0, eps, 0.0)),\n      sdff(p + vec3(0.0, 0.0, eps))\n    ) -\n      vec3(sdff(p))\n  );\n}\n\n//layout (depth_greater) out float gl_FragDepth;\nvoid main() {\n  vec3 light = normalize(vec3(-1.0, -2.0, -2));\n\n  vec3 a = vec3(coord, -1.0);\n  vec3 b = vec3(coord, 1.0);\n  vec3 aWC = transform(llli, a);\n  vec3 bWC = transform(llli, b);\n  vec3 lookDir1 = normalize(bWC - aWC);\n\n  RMResult hitWC = raymarching2(aWC, lookDir1);\n  vec3 hitn1 = sdfNormal1(hitWC.pos, hitWC.distance);\n  float dWC = distance(aWC, hitWC.pos);\n  vec3 hitNDC = transform(lll, hitWC.pos);\n  vec3 p = hitWC.pos;\n  float inSun = softshadow(\n    hitWC.pos + hitn1 * 0.05,\n    -light,\n    0.0001,\n    300.0,\n    8.0\n  );\n  //    float inSun=1.;\n\n  vec3 material = hitWC.color.xyz;\n  if (dWC > 100.0) {\n    material = vec3(0.0, 0.0, 0.0);\n    //    } else if (p.z >= 0.001) {\n    //        material = vec3(0.2, 0.0, 0.0);\n    //    } else {\n    //        vec2 c = vec2(4.0, 2.0);\n    //        vec2 id = floor(((p.xy - c * 0.5) / c) );\n    //        material += .15 * cos(vec3(id.x, id.y + 2., id.x + id.y + 4.));\n  }\n\n  const vec3 sunlightColor = vec3(8.0, 6.0, 1.0);\n\n  float aOcc = ambientOcclusion(hitWC.pos, hitn1);\n\n  vec3 reflectionDirection = reflect(light, hitn1);\n\n  vec3 color = vec3(0.0);\n  color += material * aOcc;\n  color += inSun * sunlightColor * material * max(0.0, dot(-light, hitn1));\n  //    color = (hitn1);\n\n  vec3 camPos = aWC;\n\n  vec3 eyeDirection = -lookDir1;\n  float uMaterialShininess = 256.0;\n  float specularLightWeighting = pow(\n    max(dot(reflectionDirection, eyeDirection), 0.0),\n    uMaterialShininess\n  );\n  color += specularLightWeighting;\n  //    float lightIntensity = 0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.);\n  //    float lightIntensity =\n  //        0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.) + 0.3*specularLightWeighting;\n  //    fragColor = visualize(blue, red, mix(0.5, 1.0, inSun) * lightIntensity);\n  //    fragColor = mix(hitWC.color, colorBackground, mix(0.5, 1.0, inSun) * clamp(lightIntensity, 0., 1.));\n  color = pow(color, vec3(1.0 / 2.2)); // gamma correction\n  fragColor = vec4(color, 1.0);\n}\n"},4394:(n,e,t)=>{t.d(e,{A:()=>r});var o=setTimeout;function a(n,e){var t=e.useCachedSetTimeout?o:setTimeout;return new Promise(function(e){t(e,n)})}const r=function(n){var e=a(n,{useCachedSetTimeout:(arguments.length>1&&void 0!==arguments[1]?arguments[1]:{}).useCachedSetTimeout});function t(n){return e.then(function(){return n})}return t.then=function(){return e.then.apply(e,arguments)},t.catch=Promise.resolve().catch,t}},5101:(n,e,t)=>{t.d(e,{A:()=>T});var o=t(7810),a=t(4164),r=t(1870),l=t(243),i=t(6551),s=t(1978),c=t(3166),d=t(2659),f=t(7147),m=t(4053),p=t(809),u=t(3802),v=t(1488),h=t(1764),g=t(3152),x=t(3200);function y(n){return(0,x.Ay)("MuiMenuItem",n)}const b=(0,g.A)("MuiMenuItem",["root","focusVisible","dense","disabled","divider","gutters","selected"]);var C=t(4922);const R=(0,i.Ay)(f.A,{shouldForwardProp:n=>(0,l.A)(n)||"classes"===n,name:"MuiMenuItem",slot:"Root",overridesResolver:(n,e)=>{const{ownerState:t}=n;return[e.root,t.dense&&e.dense,t.divider&&e.divider,!t.disableGutters&&e.gutters]}})((0,s.A)(({theme:n})=>({...n.typography.body1,display:"flex",justifyContent:"flex-start",alignItems:"center",position:"relative",textDecoration:"none",minHeight:48,paddingTop:6,paddingBottom:6,boxSizing:"border-box",whiteSpace:"nowrap","&:hover":{textDecoration:"none",backgroundColor:(n.vars||n).palette.action.hover,"@media (hover: none)":{backgroundColor:"transparent"}},[`&.${b.selected}`]:{backgroundColor:n.alpha((n.vars||n).palette.primary.main,(n.vars||n).palette.action.selectedOpacity),[`&.${b.focusVisible}`]:{backgroundColor:n.alpha((n.vars||n).palette.primary.main,`${(n.vars||n).palette.action.selectedOpacity} + ${(n.vars||n).palette.action.focusOpacity}`)}},[`&.${b.selected}:hover`]:{backgroundColor:n.alpha((n.vars||n).palette.primary.main,`${(n.vars||n).palette.action.selectedOpacity} + ${(n.vars||n).palette.action.hoverOpacity}`),"@media (hover: none)":{backgroundColor:n.alpha((n.vars||n).palette.primary.main,(n.vars||n).palette.action.selectedOpacity)}},[`&.${b.focusVisible}`]:{backgroundColor:(n.vars||n).palette.action.focus},[`&.${b.disabled}`]:{opacity:(n.vars||n).palette.action.disabledOpacity},[`& + .${u.A.root}`]:{marginTop:n.spacing(1),marginBottom:n.spacing(1)},[`& + .${u.A.inset}`]:{marginLeft:52},[`& .${h.A.root}`]:{marginTop:0,marginBottom:0},[`& .${h.A.inset}`]:{paddingLeft:36},[`& .${v.A.root}`]:{minWidth:36},variants:[{props:({ownerState:n})=>!n.disableGutters,style:{paddingLeft:16,paddingRight:16}},{props:({ownerState:n})=>n.divider,style:{borderBottom:`1px solid ${(n.vars||n).palette.divider}`,backgroundClip:"padding-box"}},{props:({ownerState:n})=>!n.dense,style:{[n.breakpoints.up("sm")]:{minHeight:"auto"}}},{props:({ownerState:n})=>n.dense,style:{minHeight:32,paddingTop:4,paddingBottom:4,...n.typography.body2,[`& .${v.A.root} svg`]:{fontSize:"1.25rem"}}}]}))),T=o.forwardRef(function(n,e){const t=(0,c.b)({props:n,name:"MuiMenuItem"}),{autoFocus:l=!1,component:i="li",dense:s=!1,divider:f=!1,disableGutters:u=!1,focusVisibleClassName:v,role:h="menuitem",tabIndex:g,className:x,...b}=t,T=o.useContext(d.A),S=o.useMemo(()=>({dense:s||T.dense||!1,disableGutters:u}),[T.dense,s,u]),E=o.useRef(null);(0,m.A)(()=>{l&&E.current&&E.current.focus()},[l]);const w={...t,dense:S.dense,divider:f,disableGutters:u},A=(n=>{const{disabled:e,dense:t,divider:o,disableGutters:a,selected:l,classes:i}=n,s={root:["root",t&&"dense",e&&"disabled",!a&&"gutters",o&&"divider",l&&"selected"]},c=(0,r.A)(s,y,i);return{...i,...c}})(t),z=(0,p.A)(E,e);let M;return t.disabled||(M=void 0!==g?g:-1),(0,C.jsx)(d.A.Provider,{value:S,children:(0,C.jsx)(R,{ref:z,role:h,tabIndex:M,component:i,focusVisibleClassName:(0,a.A)(A.focusVisible,v),className:(0,a.A)(A.root,x),...b,ownerState:w,classes:A})})})},5445:(n,e,t)=>{t.d(e,{A:()=>o});const o="#version 300 es\n\nprecision highp float;\n\n// START ../common/visualize.glsl\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\n  float isLow = float(t < 0.0);\n  float isHigh = float(t > 1.0);\n  float isMid = 1.0 - isLow - isHigh;\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\n}\n\nvec4 visualize(float t) {\n  const vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\n  const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\n  return visualize(BLUE, RED, t);\n}\n\n// #pragma glslify: export(visualize)\n\n\n// END ../common/visualize.glsl\n// START ../common/banded.glsl\nfloat banded(float bandCount, float t) {\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\n}\nfloat banded(int bandCount, float t) {\n  return banded(float(bandCount), t);\n}\n\n// #pragma glslify: export(banded)\n\n\n// END ../common/banded.glsl\n\nuniform vec4 color;\n\nout vec4 fragColor;\n\nvoid main() {\n  fragColor = color;\n}\n"},9096:(n,e,t)=>{t.d(e,{A:()=>o});const o="#version 300 es\nprecision highp float;\n\nuniform mat4 ts_ModelViewProjectionMatrix;\nuniform float normalOffset;\nin vec3 ts_Normal;\nin vec4 ts_Vertex;\n\nvoid main() {\n  gl_Position =\n    ts_ModelViewProjectionMatrix *\n    (ts_Vertex + normalOffset * vec4(ts_Normal, 0.0));\n}\n"}}]);
//# sourceMappingURL=raymarch-index.js.map