"use strict";(self.webpackChunkworkshop=self.webpackChunkworkshop||[]).push([[628],{6178:(n,t,e)=>{e.r(t),e.d(t,{default:()=>J});var o=e(8864),a=e(5069),r=e(4854),l=e(871),i=e(897),s=e(2039),c=e(882),d=e(8051),f=e(3121),m=e(492),p=e(7392),u=e(3059),v=e(9526),h=e(2182),g=e(2004),x=e(9643),y=e(7189),b=e(4341),C=e(6415);function R(n){let t,e=n[0],o=1;for(;o<n.length;){const a=n[o],r=n[o+1];if(o+=2,("optionalAccess"===a||"optionalCall"===a)&&null==e)return;"access"===a||"optionalAccess"===a?(t=e,e=r(e)):"call"!==a&&"optionalCall"!==a||(e=r(((...n)=>e.call(t,...n))),t=void 0)}return e}const T=p.$_("red").gl(),S=p.$_("green").gl(),E=p.$_("blue").gl(),z=g.$R,w={anchor:h.V3.O,dir1:h.V3.X},M={anchor:h.V3.O,dir1:h.V3.Y},D={anchor:h.V3.O,dir1:h.V3.Z};class k{__init(){this.meshes={}}__init2(){this.highlight=0}__init3(){this.offsetGC=void 0}__init4(){this.dragging=0}constructor(n,t,e,o,a,r){this.gl=n,this.pos=t,this.onHover=e,this.onStartDragging=o,this.onStopDragging=a,this.onChange=r,k.prototype.__init.call(this),k.prototype.__init2.call(this),k.prototype.__init3.call(this),k.prototype.__init4.call(this),k.prototype.__init5.call(this),k.prototype.__init6.call(this),k.prototype.__init7.call(this),this.meshes.vector=g.Kj.rotation([(0,h.V)(0,.04),(0,h.V)(.8,.04),(0,h.V)(.85,.06),(0,h.V)(1,0)],w,h.gc,8,!0),this.meshes.vector.computeNormalsFromFlatTriangles(),this.meshes.vector.compile();const l=h.M4.rotateX(-90*h.Co).translate(h.V3.X);this.meshes.rotater=g.Kj.rotation((0,h.hS)(0,9).map((n=>l.transformPoint(h.V3.polar(.04,-h.gc*n/8)))),{anchor:h.V3.O,dir1:h.V3.Z},101.25*h.Co,8,!1),this.meshes.rotater.computeNormalsFromFlatTriangles(),this.meshes.rotater.compile()}drawVector(n,t,e,o=1){if(n.likeO())return;this.gl.pushMatrix();const a=n.getPerpendicular().unit();this.gl.multMatrix(h.M4.forSys(n.unit(),a,n.cross(a).unit(),t)),e.draw(this.meshes.vector),this.gl.popMatrix()}render(n){const t=this.gl;t.enable(t.CULL_FACE),t.cullFace(t.BACK),t.pushMatrix(),t.multMatrix(this.pos),t.cullFace(t.FRONT),n.uniforms({color:z,normalOffset:.01}),1!==this.highlight&&1!==this.dragging||this.drawVector(h.V3.X,h.V3.O,n,.1),2!==this.highlight&&2!==this.dragging||this.drawVector(h.V3.Y,h.V3.O,n,.1),3!==this.highlight&&3!==this.dragging||this.drawVector(h.V3.Z,h.V3.O,n,.1),t.cullFace(t.BACK),n.uniforms({normalOffset:0}),this.drawVector(h.V3.X,h.V3.O,n.uniforms({color:T}),.1),this.drawVector(h.V3.Y,h.V3.O,n.uniforms({color:S}),.1),this.drawVector(h.V3.Z,h.V3.O,n.uniforms({color:E}),.1),n.uniforms({color:E}).draw(this.meshes.rotater),t.rotate(-90,0,1,0),n.uniforms({color:T}).draw(this.meshes.rotater),t.rotate(-90,1,0,0),n.uniforms({color:S}).draw(this.meshes.rotater),t.popMatrix()}registerListeners(n,t){return this.getCameraMatrix=t,R([this,"access",n=>n.unregister,"optionalCall",n=>n()]),n.addEventListener("mousemove",this.mousemove),n.addEventListener("mousedown",this.mousedown),n.addEventListener("mouseup",this.mouseup),this.unregister=()=>{n.removeEventListener("mousemove",this.mousemove),n.removeEventListener("mousedown",this.mousedown),n.removeEventListener("mouseup",this.mouseup)}}unregisterListeners(){R([this,"access",n=>n.unregister,"optionalCall",n=>n()])}__init5(){this.mousemove=n=>{const t=(0,h.V)(n.offsetX,n.offsetY),e=n.target.getBoundingClientRect();e.width;const o=function(n,t,e){const o=(0,h.V)(2*n.x/t.width-1,2*-n.y/t.height+1,-1),a=(0,h.V)(2*n.x/t.width-1,2*-n.y/t.height+1,1),r=e.inversed(),l=r.transformPoint(o);return{anchor:l,dir1:r.transformPoint(a).minus(l).unit()}}(t,e,this.getCameraMatrix());if(this.dragging){const a=[h.V3.O,h.V3.X,h.V3.Y,h.V3.Z][this.dragging],r=H(o,{anchor:this.pos.getTranslation(),dir1:this.pos.transformVector(a).unit()}),l=this.pos.transformVector(this.offsetGC),i=r.lineClosest.minus(l);this.pos=this.pos.translate(this.pos.getTranslation().to(i)),this.onChange(this.pos)}else{const s=this.pos.inversed(),c={anchor:s.transformPoint(o.anchor),dir1:s.transformVector(o.dir1).unit()};let d;function f(n){const t=H(c,n);return d=A(n,(0,h.uZ)(t.lineT,0,1)),d.distanceTo(t.thClosest)}const m=this.highlight;f(w)<.1?(this.highlight=1,this.offsetGC=d):f(M)<.1?(this.highlight=2,this.offsetGC=d):f(D)<.1?(this.highlight=3,this.offsetGC=d):(this.highlight=0,this.offsetGC=void 0),this.highlight!==m&&R([this,"access",n=>n.onHover,"optionalCall",n=>n(this.highlight)])}}}__init6(){this.mousedown=n=>{this.highlight&&(this.dragging=this.highlight,this.onStartDragging())}}__init7(){this.mouseup=n=>{this.dragging&&(this.dragging=0,this.onStopDragging())}}}function A(n,t){return n.anchor.plus(n.dir1.times(t))}function H(n,t){if(function(n,t){return(0,h.eq)(1,Math.abs(n.dir1.dot(t.dir1)))}(n,t))return{t:NaN,s:NaN,distance:10};const e=t.anchor,o=t.dir1,a=n.anchor,r=n.dir1,l=o.dot(r),i=o.squared(),s=r.squared(),c=e.minus(a),d=l*l-s*i,f=(c.dot(o)*l-c.dot(r)*i)/d,m=(c.dot(o)*s-c.dot(r)*l)/d;return{thT:f,lineT:m,thClosest:A(n,f),lineClosest:A(t,m),distance:A(n,f).distanceTo(A(t,m))}}var P=e(4299),N=e(4838),_=e(5583);function O(n){let t,e=n[0],o=1;for(;o<n.length;){const a=n[o],r=n[o+1];if(o+=2,("optionalAccess"===a||"optionalCall"===a)&&null==e)return;"access"===a||"optionalAccess"===a?(t=e,e=r(e)):"call"!==a&&"optionalCall"!==a||(e=r(((...n)=>e.call(t,...n))),t=void 0)}return e}function B(n){return{sdf:g.ex.create(e(34).Z,e(4235).Z,n),singleColor:g.ex.create(e(5598).Z,e(5274).Z,n)}}function q(n){let t,e=n[0],o=1;for(;o<n.length;){const a=n[o],r=n[o+1];if(o+=2,("optionalAccess"===a||"optionalCall"===a)&&null==e)return;"access"===a||"optionalAccess"===a?(t=e,e=r(e)):"call"!==a&&"optionalCall"!==a||(e=r(((...n)=>e.call(t,...n))),t=void 0)}return e}const L={a:.2,b:.2,c:.2,d:.2,cam:"999.999.999~-56.-58.-61~-44.-44.79"};function W(n){n.makeCurrent();const t=g.Kj.plane({startX:-1,startY:-1,width:2,height:2});return t.coords=[[-1,-1],[1,-1],[-1,1],[1,1]],t.compile(),{planeMesh:t,shaders:B(n)}}function V(n,{shaders:t,planeMesh:e},o,a,r,l,i){n.makeCurrent();const s=o.inversed();t.sdf.uniforms({colorPrimary:a.primary,colorSecondary:a.secondary,colorBackground:a.background,highResTimeStamp:l,secs:l/1e3,gradients:1,extra:i,...r,lll:o,llli:s}).draw(e)}function Z({children:n,label:t,onFocus:e,onBlur:o}){return v.createElement(s.Z,{onFocus:e,onBlur:o,label:t,inputComponent:"textarea",value:n.toString()})}function F(n){let t=0;function e(n){const t=""+n;return t.includes(".")?t:t+".0"}function o([n,t,o]){return"vec3("+e(n)+", "+e(t)+", "+e(o)+")"}const[a,r,l]=function n(a){let r,l,i;function s(n){r="p"+t++,l="d"+t++,i=`float ${l} = ${n(r)};\n`}for(const c of a)if("sphere"===c.type)s((n=>`sdSphere(${e(c.radius)}, ${n})`));else if("box"===c.type)s((n=>`betterBox(${o(c.radius)}, ${n})`));else if("octahedron"===c.type)s((n=>`sdOctahedron(${e(c.radius)}, ${n})`));else if("donut"===c.type)s((n=>`sdTorus(${e(c.r0)}, ${e(c.r1)}, ${n})`));else if("translate"===c.type){const n=r;r="p"+t++,i=`vec3 ${n} = ${r} + ${o(c.by)};\n`+i}else if("expand"===c.type){const n=l;l="d"+t++,i+=`float ${l} = ${n} - ${e(c.by)};\n`}else if("add"===c.type||"sub"===c.type){const[t,e,o]=n(c.what);i=i+`vec3 ${e} = ${r};\n`+t+`${l} = `+("add"===c.type?`min(${l}, ${o})`:`max(${l}, -${o})`)+";\n"}return[i,r,l]}(n);let i=`RMHit sdf(vec3 ${r}) {\n`;return i+=a,i+=`return RMHit(${l}, black);\n`,i+="}\n",i}function G({value:n,onChange:t}){const e=(0,v.useCallback)((e=>t({...n,radius:+e.target.value},n)),[t]);return v.createElement("div",null,"Sphere"," ",v.createElement(f.Z,{value:n.radius,onChange:e,inputProps:{type:"number"}}))}function I({value:n,onChange:t}){const e=(0,v.useCallback)((e=>t({...n,radius:e},n)),[n,t]);return v.createElement("div",{style:{display:"flex"}},"Box ",v.createElement($,{value:n.radius,onChange:e}))}function Q({value:n,onChange:t}){const e=(0,v.useCallback)((e=>t({...n,by:+e.target.value},n)),[n,t]);return v.createElement("div",{style:{display:"flex"}},"Expand"," ",v.createElement(f.Z,{value:n.by,onChange:e,type:"number",inputProps:{}}))}function $({value:n,onChange:t,gizmoControl:e}){const a=(0,v.useCallback)((e=>{const o=n.slice();o[e.target.name]=+e.target.value,t(o,n)}),[n,t]),r=(0,v.useCallback)((()=>e.take(n,t)),[e,t,n]);return v.createElement(v.Fragment,null,v.createElement(o.Z,{onClick:r},"X"),[0,1,2].map((t=>v.createElement(f.Z,{key:t,name:""+t,value:n[t],onChange:a,inputProps:{type:"number"}}))))}function j({value:n,onChange:t,gizmoControl:e}){const o=(0,v.useCallback)((e=>t({...n,by:e},n)),[n,t]);return v.createElement("div",{style:{display:"flex"}},"Translate"," ",v.createElement($,{value:n.by,onChange:o,gizmoControl:e}))}function U({value:n,onChange:t,gizmoControl:e}){const o=(0,v.useCallback)((e=>t({...n,[e.target.name]:+e.target.value},n)),[n,t]);return v.createElement("div",{style:{display:"flex"}},"Donut"," ",["r0","r1"].map((t=>v.createElement(f.Z,{key:t,name:t,value:n[t],onChange:o,inputProps:{type:"number"}}))))}function X({value:n,onChange:t,gizmoControl:e}){const o=(0,v.useCallback)((e=>t({...n,[e.target.name]:+e.target.value},n)),[n,t]);return v.createElement("div",{style:{display:"flex"}},"Octahedron"," ",["radius"].map((t=>v.createElement(f.Z,{key:t,name:t,value:n[t],onChange:o,inputProps:{type:"number"}}))))}function Y({value:n,onChange:t,gizmoControl:e}){const o=(0,v.useCallback)((e=>t({...n,type:e.target.value},n)),[n,t]),a=(0,v.useCallback)((e=>t({...n,what:e},n)),[n,t]);return v.createElement("div",{style:{display:"flex"}},v.createElement(c.Z,{value:n.type,name:"type",onChange:o},v.createElement(i.Z,{value:"add"},"Add"),v.createElement(i.Z,{value:"sub"},"Sub"))," ",v.createElement(K,{value:n.what,onChange:a,gizmoControl:e}))}function K({value:n,onChange:t,gizmoControl:e}){const o=(0,v.useCallback)(((e,o)=>t(n.map((n=>n===o?e:n)))),[t,n]);return v.createElement("div",null,n.map(((n,t)=>{const a={sphere:G,expand:Q,add:Y,sub:Y,box:I,donut:U,translate:j,octahedron:X}[n.type];return a&&v.createElement(a,{key:t,value:n,onChange:o,gizmoControl:e})})))}const J=()=>{const n=(0,v.useRef)(null),[t,s]=(0,v.useState)(void 0),[f,R]=(0,v.useState)(h.M4.IDENTITY),[T,S]=(0,v.useState)(512),[E,z]=(0,v.useState)(!1),[w,M]=(0,b.q)(L),D=(0,v.useCallback)((n=>M((t=>({...t,...n})))),[M]),[A,H]=(0,v.useState)(0),[B,G]=(0,v.useState)(0),I=(0,v.useRef)(Object.assign({},w)),Q=(0,v.useRef)(),[$,j]=(0,v.useState)([{type:"sphere",radius:1},{type:"translate",by:[1,2,3]},{type:"add",what:[{type:"box",radius:[1,2,3]},{type:"translate",by:[.1,.1,.1]},{type:"expand",by:.3}]},{type:"add",what:[{type:"octahedron",radius:2},{type:"translate",by:[.1,.1,.1]}]},{type:"add",what:[{type:"donut",r0:2,r1:.2},{type:"translate",by:[.1,.1,.1]}]}]),U=(0,d.Z)(),X=(0,v.useMemo)((()=>({background:p.iv(U.palette.background.default).gl(),primary:p.iv(U.palette.primary.main).gl(),secondary:p.iv(U.palette.secondary.main).gl()})),[U.palette]),Y=(0,v.useCallback)((async([n,t])=>{const e=URL.createObjectURL(await async function([n,t],e,o,a){O([a,"optionalCall",n=>n(0)]),await(0,_.Z)(10);const r=document.createElement("canvas");r.width=n,r.height=t;const l=200,i=g.ZG.create({canvas:r});i.enable(i.SCISSOR_TEST);const s=e(i);let c=0;for(let e=0;e<n;e+=l)for(let r=0;r<t;r+=l){const d=Math.min(l,n-e),f=Math.min(l,t-r);i.scissor(e,r,d,f),o(i,s),await(0,_.Z)(0),c+=d*f,O([a,"optionalCall",e=>e(c/(n*t))])}return new Promise(((n,t)=>r.toBlob((e=>e?n(e):t("error")),"png")))}([n,t],W,((e,o)=>{V(e,o,h.M4.product(h.M4.perspective(70,n/t,.1,50),N.j.getLookAt(N.j.fromShortString(w.cam))),X,w,2e3,f.getTranslation())}),s));s(void 0),(0,C.YQ)(e)}),[f,X,w]);(0,v.useEffect)((()=>{console.log("creating context");const t=g.ZG.create({canvas:n.current,alpha:!0,premultipliedAlpha:!0,throwOnError:!0});return console.log(t.getParameter(t.MAX_SAMPLES)),Q.current=function(n,t,o,a,r,l,i,s,c){n.canvas.addEventListener("keydown",(n=>"r"===n.key&&Y([1920,1080])));const d=new N.j(l);let f=h.M4.IDENTITY;const m=new k(n,h.M4.rotateZ(20*h.Co).translate(5,5,1),i,(()=>d.pauseCam=!0),(()=>d.pauseCam=!1),s);m.registerListeners(n.canvas,(()=>f)),n.clearColor(...t.background),n.clearColor(0,0,0,1),n.clear(n.COLOR_BUFFER_BIT),n.cullFace(n.BACK),n.pointSize(10),n.disable(n.CULL_FACE),n.disable(n.DEPTH_TEST),n.disable(n.BLEND),n.blendFunc(n.ONE,n.ONE),n.blendEquation(n.FUNC_ADD),n.canvas.contentEditable="true",n.canvas.focus(),d.registerListeners(n.canvas);const p=new y.q(a),u=W(n);return{updateShader(n){u.shaders.ed=g.ex.create(e(34).Z,n)},teardown:n.animate((function(e,a){n.clear(n.COLOR_BUFFER_BIT),n.makeCurrent(),d.tick(),p.tick(e),f=h.M4.product(h.M4.perspective(70,n.canvas.offsetWidth/n.canvas.offsetHeight,.1,50),d.getLookAt()),V(n,u,f,t,o,e,m.pos.getTranslation()),n.matrixMode(n.PROJECTION),n.loadMatrix(f),n.matrixMode(n.MODELVIEW),n.loadIdentity(),m.render(u.shaders.singleColor)})),setCam:d.setState}}(t,X,I.current,G,0,(0,u.debounce)((n=>{D({cam:N.j.toShortString(n)})})),H,R),()=>{q([Q,"access",n=>n.current,"optionalAccess",n=>n.teardown,"call",n=>n()])}}),[]),(0,v.useEffect)((()=>{}),[w.cam]),(0,v.useEffect)((()=>{q([Q,"access",n=>n.current,"optionalAccess",n=>n.updateShader,"call",n=>n("#version 300 es\n\nprecision highp float;\n\n// START ../common/banded.glsl\nfloat banded(float bandCount, float t) {\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\n}\nfloat banded(int bandCount, float t) {\n  return banded(float(bandCount), t);\n}\n\n// #pragma glslify: export(banded)\n\n\n// END ../common/banded.glsl\n// START ../common/between.glsl\nbool between(float min, float max, float value) {\n  return min <= value && value <= max;\n}\n\n// #pragma glslify: export(between)\n\n\n// END ../common/between.glsl\n// START ../common/hexFns.glsl\n// START ./max3.glsl\nfloat max3(float a, float b, float c) {\n  return max(a, max(b, c));\n}\nfloat max3(vec3 v) {\n  return max(v.x, max(v.y, v.z));\n}\n\n// #pragma glslify: export(max3)\n\n\n// END ./max3.glsl\n// START ./constants.glsl\nconst float SQRT1_2 = 0.7071067811865476;\nconst float SQRT1_3 = 0.57735026919;\nconst float SQRT2 = 1.4142135623730951;\nconst float SQRT3 = 1.732050807568877;\n// sqrt(3)/2 = sin(60*)\nconst float SQRT3_2 = 0.86602540378;\nconst float GOLDEN_RATIO = 1.61803398875;\nconst float PI = 3.141592653589793;\nconst float TAU = 6.28318530718;\n/**\n * One degree in radians. Use like `sin(30 * DEG)`.\n */\nconst float DEGREE = 0.017453292519943295;\n\n// END ./constants.glsl\n\nvec3 hexRound(vec3 hex) {\n  vec3 r = floor(hex + 0.5);\n  vec3 diff = abs(r - hex);\n\n  if (diff.x > diff.y && diff.x > diff.z) {\n    r.x = -(r.y + r.z);\n  } else if (diff.y > diff.z) {\n    r.y = -(r.x + r.z);\n  } else {\n    r.z = -(r.x + r.y);\n  }\n\n  return r;\n}\nvec2 hex2Ra(vec3 hex) {\n  float y = hex.t * SQRT3_2;\n  float x = hex.s + hex.t / 2.0;\n  return vec2(x, y);\n}\n\nfloat hexSdf(vec3 hex) {\n  return max3(abs(hex.yzx + hex.zxy / 2.0));\n}\nvec3 ra2Hex(vec2 xy) {\n  float hex_t = xy.y / SQRT3_2;\n  float hex_s = xy.x - hex_t / 2.0;\n  return vec3(hex_s, hex_t, -(hex_s + hex_t));\n}\n\n// END ../common/hexFns.glsl\n// START ../common/matrices.glsl\n\nmat2 rot2(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat2(c, s, -s, c);\n}\nmat3 rotX(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\n}\nmat3 rotY(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\n}\nmat3 rotZ(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\n}\n/**\n * Returns a matrix that puts the camera at the eye point `ex, ey, ez` looking\n * toward the center point `cx, cy, cz` with an up direction of `ux, uy, uz`.\n * This emulates the OpenGL function `gluLookAt()`.\n */\nmat4 lookAt(vec3 eye, vec3 focus, vec3 up) {\n  vec3 f = normalize(eye - focus);\n  vec3 s = normalize(cross(up, f));\n  vec3 t = normalize(cross(f, s));\n\n  return mat4(\n    vec4(s.x, t.x, f.x, 0.0),\n    vec4(s.y, t.y, f.y, 0.0),\n    vec4(s.z, t.z, f.z, 0.0),\n    vec4(-dot(s, eye), -dot(t, eye), -dot(f, eye), 1)\n  );\n}\n\n// the OpenGL function `glFrustum()`.\nmat4 frustum(\n  float left,\n  float right,\n  float bottom,\n  float top,\n  float near,\n  float far\n) {\n  return mat4(\n    vec4(2.0 * near / (right - left), 0.0, 0.0, 0.0),\n    vec4(0, 2.0 * near / (top - bottom), 0.0, 0.0),\n    vec4(\n      (right + left) / (right - left),\n      (top + bottom) / (top - bottom),\n      -(far + near) / (far - near),\n      -1\n    ),\n    vec4(0.0, 0.0, -2.0 * far * near / (far - near), 0.0)\n  );\n}\n\nmat4 perspective(float fovDegrees, float aspect, float near, float far) {\n  float y = tan(fovDegrees * DEGREE / 2.0) * near;\n  float x = y * aspect;\n  return frustum(-x, x, -y, y, near, far);\n}\nmat4 ortho(\n  float left,\n  float right,\n  float bottom,\n  float top,\n  float near,\n  float far\n) {\n  return mat4(\n    vec4(2.0 / (right - left), 0.0, 0.0, 0.0),\n    vec4(0.0, 2.0 / (top - bottom), 0.0, 0.0),\n    vec4(0.0, 0.0, -2.0 / (far - near), 0.0),\n    vec4(\n      -(right + left) / (right - left),\n      -(top + bottom) / (top - bottom),\n      -(far + near) / (far - near),\n      1.0\n    )\n  );\n}\n\n// END ../common/matrices.glsl\n// START ../common/perlin2DTexture.glsl\nuniform sampler2D gradients;\n/* Create random direction vector\n */\nvec2 randomGradient(vec2 i) {\n  // Random float. No precomputed gradients mean this works for any number of grid coordinates\n  float random =\n    2920.0 *\n    sin(float(i.x) * 2.1942 + float(i.y) * 1.71324 + 8.912) *\n    cos(float(i.x) * 2.3157 * float(i.y) * 2.17832 + 9.758);\n  //    random = (i.x + 1667.) * (i.x + 2083.) * (i.y + 2659.) * (i.y * 50.77 + .3769);\n  //    random = sin(SQRT2 * i.x) + cos(GOLDEN_RATIO * i.y) + tan((i.x + i.y) * SQRT3);\n  return vec2(cos(random), sin(random));\n}\nfloat dotGridGradient(vec2 cell, vec2 pos) {\n  vec2 d = cell - pos;\n\n  //  vec2 gradient = texelFetch(gradients, ivec2(cell), 0).xy;\n  vec2 gradient = randomGradient(vec2(cell));\n\n  return dot(gradient, d);\n}\n\nfloat mixx(float a, float b, float t) {\n  return mix(a, b, smoothstep(0.0, 1.0, t));\n  //    return mix(a, b, t);\n}\n\n// resulting range is [-0.68, 0.68]. Use unmix to normalize if necessary.\nfloat perlin2D(vec2 xy) {\n  float x0 = floor(xy.x);\n  float x1 = x0 + 1.0;\n  float y0 = floor(xy.y);\n  float y1 = y0 + 1.0;\n\n  // Interpolate between grid point gradients\n  float n00 = dotGridGradient(vec2(x0, y0), xy);\n  float n10 = dotGridGradient(vec2(x1, y0), xy);\n  float ny0 = mixx(n00, n10, xy.x - x0);\n\n  float n01 = dotGridGradient(vec2(x0, y1), xy);\n  float n11 = dotGridGradient(vec2(x1, y1), xy);\n  float ny1 = mixx(n01, n11, xy.x - x0);\n\n  return mixx(ny0, ny1, xy.y - y0);\n}\n\n// #pragma glslify: export(perlin2D)\n\n\n// END ../common/perlin2DTexture.glsl\n// START ../common/polar.glsl\n// START ../common/fromPolar.glsl\n// START ./unmix.glsl\nfloat unmix(float a, float b, float value) {\n  return (value - a) / (b - a);\n}\n\n// #pragma glslify: export(unmix)\n\n\n// END ./unmix.glsl\n\nvec3 fromPolar(float radius, float phi, float z) {\n  return vec3(radius * cos(phi), radius * sin(phi), z);\n}\n\nvec2 fromPolar(float radius, float phi) {\n  return vec2(radius * cos(phi), radius * sin(phi));\n}\n\nvec2 fromPolar(vec2 polar) {\n  return fromPolar(polar.x, polar.y);\n}\n\n// #pragma glslify: export(fromPolar)\n\n\n// END ../common/fromPolar.glsl\n// START ../common/toPolar.glsl\n\nvec2 toPolar(vec2 xy) {\n  return vec2(length(xy), atan(xy.y, xy.x));\n}\n\nmat2 toPolarDerivate(vec2 xy) {\n  return mat2(xy.x * xy.x, xy.y * xy.y, -xy.y, xy.x) / dot(xy, xy);\n}\n\n// #pragma glslify: export(toPolar)\n\n\n// END ../common/toPolar.glsl\n\n// END ../common/polar.glsl\n// START ../common/remix.glsl\n\nfloat remix(float fromA, float fromB, float toA, float toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\nvec4 remix(float fromA, float fromB, vec4 toA, vec4 toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\n// #pragma glslify: export(remix)\n\n\n// END ../common/remix.glsl\n// START ../common/transform.glsl\nvec3 transform(mat4 pm, vec3 p) {\n  vec4 pStar = pm * vec4(p, 1);\n  return pStar.xyz / pStar.w;\n}\n\nvec2 transform(mat4 pm, vec2 p) {\n  vec4 pStar = pm * vec4(p, 0, 1);\n  return pStar.xy / pStar.w;\n}\n\n// END ../common/transform.glsl\n// START ../common/visualize.glsl\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\n  float isLow = float(t < 0.0);\n  float isHigh = float(t > 1.0);\n  float isMid = 1.0 - isLow - isHigh;\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\n}\n\nvec4 visualize(float t) {\n  const vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\n  const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\n  return visualize(BLUE, RED, t);\n}\n\n// #pragma glslify: export(visualize)\n\n\n// END ../common/visualize.glsl\n// START ../common/waves.glsl\nfloat waves(vec4 color, vec2 position, vec2 direction, float highResTimeStamp) {\n  return sin(\n    dot(position, direction / pow(length(direction), 2.0)) +\n      float(highResTimeStamp) / 200.0\n  );\n}\n\n// #pragma glslify: export(waves)\n\n\n// END ../common/waves.glsl\n\n// START ../common/sdf3d/sdTorus.glsl\nfloat sdTorus(float r0, float r1, vec3 p) {\n  vec3 closestCenter = vec3(normalize(p.xy) * r0, 0.0);\n  return distance(closestCenter, p) - r1;\n}\n\n// #pragma glslify: export(sdTorus)\n\n\n// END ../common/sdf3d/sdTorus.glsl\n// START ../common/sdf3d/sdCapsule.glsl\nfloat sdCapsule(vec3 a, vec3 b, float r, vec3 p) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h) - r;\n}\n// #pragma glslify: export(sdCapsule)\n\n// END ../common/sdf3d/sdCapsule.glsl\n// START ../common/sdf3d/opElongate.glsl\nvec3 opElongate(vec3 h, vec3 p) {\n  return p - clamp(p, -h, h);\n}\n// #pragma glslify: export(opElongate)\n\n// END ../common/sdf3d/opElongate.glsl\n// START ../common/sdf3d/sdSphere.glsl\nfloat sdSphere(float radius, vec3 p) {\n  return length(p) - radius;\n}\n\n// #pragma glslify: export(sdSphere)\n\n\n// END ../common/sdf3d/sdSphere.glsl\n// START ../common/sdf3d/sdCylinder.glsl\nfloat sdCylinder(float radius, float z, vec3 p) {\n  vec2 d = vec2(length(p.xy), abs(p.z)) - vec2(radius, z);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// #pragma glslify: export(sdCylinder)\n\n\n// END ../common/sdf3d/sdCylinder.glsl\n// START ../common/sdf3d/sdCone.glsl\n\n/**\n * Signed distance function (SDF) of a cone. The tip of the cone is at the\n * origin and points towards +Z. q is a point on the rim of the cone.\n */\nfloat sdCone(vec2 c, float h, vec3 p) {\n  vec2 q = h * vec2(c.x / c.y, -1.0);\n  vec2 w = vec2(length(p.xz), p.y);\n  vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);\n  vec2 b = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0);\n  float k = sign(q.y);\n  float d = min(dot(a, a), dot(b, b));\n  float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));\n  return sqrt(d) * sign(s);\n}\n// #pragma glslify: export(sdBox)\n\nfloat sdConeB(vec2 c, float h, vec3 p) {\n  float q = length(p.xz);\n  return max(dot(c.xy, vec2(q, p.y)), -h - p.y);\n}\n\n// END ../common/sdf3d/sdCone.glsl\n// START ../common/sdf2d/addChamfer.glsl\n\nfloat addChamfer(float d, float a, float b) {\n  // exact variant, but abs is larger when a and b aren't perpendicular\n  // which is worse than underestimating, which is what the simple version does.\n  //  vec2 p = vec2(a, b);\n  //  if (p.x < d && p.y < d) {\n  //    p = rot2(0.25 * PI) * p;\n  //    p.y = abs(p.y);\n  //    p.y -= min(p.y, d * SQRT1_2);\n  //    p.x -= d * SQRT1_2;\n  //    //    p -= vec2(SQRT1_2) * clamp(dot(p, vec2(SQRT1_2)), 0.0, d);\n  //    float fillet = -length(p);\n  //    return -sign(p.x) * fillet;\n  //  } else {\n  //  }\n  float tillet = (a + b - d) * SQRT1_2;\n  return min(tillet, min(a, b));\n}\n\n// #pragma glslify: export(addChamfer)\n\n\n// END ../common/sdf2d/addChamfer.glsl\n// START ../common/sdf2d/addFillet.glsl\nfloat addFillet(float r, float a, float b) {\n  if (a < r && b < r) {\n    return r - distance(vec2(a, b), vec2(r));\n  } else {\n    return min(a, b);\n  }\n}\n\n// #pragma glslify: export(addFillet)\n\n\n// END ../common/sdf2d/addFillet.glsl\n// START ../common/sdf3d/sdBox.glsl\n\nfloat sdBox(vec3 r, vec3 p) {\n  vec3 q = abs(p) - r;\n  return length(max(q, 0.0)) + min(max3(q), 0.0);\n}\n\nfloat sdBox(vec3 r, float r2, vec3 p) {\n  return sdBox(r - r2, p) - r2;\n}\n\n// #pragma glslify: export(sdBox)\n\n\n// END ../common/sdf3d/sdBox.glsl\n// START ../common/sdf3d/sdOctahedron.glsl\nfloat sdOctahedron(float s, vec3 p) {\n  p = abs(p);\n  float m = p.x + p.y + p.z - s;\n  vec3 q;\n  if (3.0 * p.x < m) q = p.xyz;\n  else if (3.0 * p.y < m) q = p.yzx;\n  else if (3.0 * p.z < m) q = p.zxy;\n  else return m * 0.57735027;\n\n  float k = clamp(0.5 * (q.z - q.y + s), 0.0, s);\n  return length(vec3(q.x, q.y - s + k, q.z - k));\n}\n// #pragma glslify: export(sdOctahedron)\n\nfloat sdOctahedron(vec3 p, float s) {\n  p = abs(p);\n\n  float m = p.x + p.y + p.z - s;\n  //find point on octohedron surf nearest to p\n  vec3 projPoint = p - vec3(0.333333 * m); //project onto surface plane\n  //now push projected point, if outside triangle edge, perpendicular to edge, to edge\n  vec3 toMove = min(projPoint, 0.0); //if projpoint.x<0 move along (1.0,-0.5,-0.5) , etc\n  float toMoveSum = dot(toMove, vec3(1.0)); //which is basically along (1.5,0,0) then vec3(-0.5)\n\n  vec3 movedPoint = projPoint + toMove * vec3(-1.5) + toMoveSum * vec3(0.5); //better to multiply toMove by a matrix (1s diagonal, 0.5 other)?\n\n  movedPoint = max(movedPoint, 0.0); //cap x,y,z to 0 then\n  movedPoint *= s / dot(movedPoint, vec3(1.0)); //scale about 0,0,0\n\n  return length(p - movedPoint);\n}\n\n// END ../common/sdf3d/sdOctahedron.glsl\n// START ../common/sdf3d/add.glsl\nfloat add(float a, float b) {\n  return min(a, b);\n}\n\n// #pragma glslify: export(add)\n\n\n// END ../common/sdf3d/add.glsl\n// START ../common/sdf3d/sub.glsl\nfloat sub(float from, float what) {\n  return max(from, -what);\n}\n\n// #pragma glslify: export(sub)\n\n\n// END ../common/sdf3d/sub.glsl\n\nuniform sampler2D texture;\nuniform float secs;\nuniform mat4 lll;\nuniform mat4 llli;\nuniform vec4 colorPrimary;\nuniform vec4 colorSecondary;\nuniform vec4 colorBackground;\nuniform float a;\nuniform float b;\nuniform float c;\nuniform float d;\nuniform float highResTimeStamp;\nuniform int bandCount;\nuniform vec3 campos;\nin float n;\nin vec2 coord;\nout vec4 fragColor;\n\n\nconst vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\nconst vec4 yellow = vec4(1.0, 1.0, 0.0, 1.0);\nconst vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\nconst vec4 blue = vec4(0.0, 0.0, 1.0, 1.0);\nconst vec4 purple = vec4(0.5, 0.0, 0.5, 1.0);\nconst vec4 red = vec4(1.0, 0.0, 0.0, 1.0);\n\nstruct RMHit {\n  float distance;\n  vec4 color;\n};\nRMHit mixa(RMHit a, RMHit b, float t) {\n  return RMHit(mix(a.distance, b.distance, t), mix(a.color, b.color, t));\n}\nfloat skybox(vec3 p) {\n  return 32.0 - max3(abs(p));\n}\n\nfloat perlinSphere(float radius, vec3 p) {\n  vec3 cp = normalize(p);\n  float alpha = atan(cp.y, cp.x);\n  float beta = asin(cp.z);\n  return length(p) -\n  radius +\n  0.1 *\n    perlin2D(vec2(0.0 / 100.0, 0.0) + (vec2(5.0) + vec2(alpha, beta)) * 8.0);\n}\n\nfloat cylCircle(vec3 p) {\n  float d = 10e9;\n  for (int i = 0; i < 10; i++) {\n    d = min(\n      d,\n      sdCylinder(0.2, 2.0, p + fromPolar(3.0, TAU * float(i) / 10.0, 1.0))\n    );\n  }\n\n  return d;\n}\n\nfloat rblock(float r, out vec3 p) {\n  return sdBox(vec3(r), p);\n}\n\nRMHit add(RMHit a, RMHit b) {\n  //    return a.distance < b.distance\n  //        ? RMHit(a.distance, a.color)\n  //        : RMHit(b.distance, b.color);\n  return mixa(a, b, float(b.distance < a.distance));\n}\n\nfloat wtf(vec3 p) {\n  vec3 center = p - mod(p, 3.0) + vec3(1.5);\n  return rblock(0.4 + 0.3 * sin(secs + center.x), center);\n}\n\nRMHit addFillet(float r, RMHit a, RMHit b) {\n  if (a.distance < r && b.distance < r) {\n    return RMHit(\n      r - distance(vec2(a.distance, b.distance), vec2(r)),\n      mix(a.color, b.color, (a.distance - b.distance) / r * 0.5 + 0.5)\n    );\n  } else {\n    return add(a, b);\n  }\n}\n\nRMHit addFillet(float r, RMHit a, RMHit b, vec4 tilletColor) {\n  if (a.distance < r && b.distance < r) {\n    return RMHit(\n      r - distance(vec2(a.distance, b.distance), vec2(r)),\n      tilletColor\n    );\n  } else {\n    return add(a, b);\n  }\n}\nRMHit addFillet2(float r, RMHit a, RMHit b) {\n  float h = smoothstep(-r, r, a.distance - b.distance);\n  return RMHit(\n    mix(a.distance, b.distance, h) - r * h * (1.0 - h),\n    mix(a.color, b.color, h)\n  );\n}\n\nRMHit neg(RMHit a) {\n  return RMHit(-a.distance, a.color);\n}\nRMHit sub(RMHit from, RMHit what) {\n  RMHit whatNeg = neg(what);\n  return mixa(from, whatNeg, float(whatNeg.distance > from.distance));\n}\n\nvec3 modv(vec3 v, vec3 dir1, float y) {\n  float t = dot(v, dir1);\n  return v - floor(t / y) * y * dir1;\n}\nvec3 modRotZ(vec3 p, float count) {\n  vec2 polarXY = toPolar(p.xy);\n  return fromPolar(polarXY.x, mod(polarXY.y, TAU / count), p.z);\n}\n\nfloat sin01(float x) {\n  return 0.5 + 0.5 * sin(x);\n}\nfloat cos01(float x) {\n  return 0.5 + 0.5 * cos(x);\n}\n\nfloat betterBox(vec3 r, vec3 p) {\n  vec3 q = abs(p) - r;\n  return length(max(q, 0.0)) + min(max3(q), 0.0);\n  p = abs(p);\n  return max3(p - r);\n}\n\nfloat sdEllipsoidB(vec3 r, vec3 p) {\n  float k0 = length(p / r);\n  float k1 = length(p / (r * r));\n  return k0 * (k0 - 1.0) / k1;\n}\nfloat sdOctahedronB(float s, vec3 p) {\n  p = abs(p);\n  return (p.x + p.y + p.z - s) * 0.57735027;\n}\nfloat donutc(float r0, float r1, vec3 p) {\n  vec3 closestCenter = vec3(normalize(p.xy) * r0, 0.0);\n  return distance(closestCenter, p) - r1;\n}\n\nfloat smoothmin(float r, float a, float b) {\n  float h = smoothstep(-r, r, a - b);\n  return mix(a, b, h) - r * h * (1.0 - h);\n}\n\nRMHit sdf(vec3 p) {\n  return RMHit(0.0, black);\n}\n\nfloat sdff(vec3 p) {\n  return sdf(p).distance;\n}\n\nstruct RMResult {\n  float distance;\n  vec3 pos;\n  vec4 color;\n};\nRMResult raymarching2(vec3 start, vec3 dir1) {\n  vec3 pos = start;\n  RMHit hit;\n  for (int i = 0; i < 200; i++) {\n    hit = sdf(pos);\n    if (hit.distance < 0.0001) break;\n    pos = pos + dir1 * hit.distance;\n  }\n  return RMResult(hit.distance, pos, hit.color);\n}\n\nfloat softshadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {\n  float res = 1.0;\n  float t = 0.1;\n  for (int i = 0; i < 1000 && t < maxt; i++) {\n    float h = sdff(ro + rd * t);\n    if (h < 0.001) return 0.0;\n    res = min(res, k * h / t);\n    t += h;\n  }\n  return res;\n}\n\nconst float eps = 1e-4;\nvec3 sdfNormal1(vec3 p, float d) {\n  return normalize(\n    vec3(\n      sdff(p + vec3(eps, 0.0, 0.0)),\n      sdff(p + vec3(0.0, eps, 0.0)),\n      sdff(p + vec3(0.0, 0.0, eps))\n    ) -\n      sdff(p)\n  );\n}\n\nfloat ambientOcclusion(vec3 pWC, vec3 n1WC) {\n  float k = 1.0;\n  float distance = sdff(pWC + n1WC * k);\n  return clamp(distance / k, 0.0, 1.0);\n}\n\n//layout (depth_greater) out float gl_FragDepth;\nvoid main() {\n  vec3 light = normalize(vec3(-1.0, -2.0, -2));\n\n  vec3 a = vec3(coord, -1.0);\n  vec3 b = vec3(coord, 1.0);\n  vec3 aWC = transform(llli, a);\n  vec3 bWC = transform(llli, b);\n  vec3 lookDir1 = normalize(bWC - aWC);\n\n  RMResult hitWC = raymarching2(aWC, lookDir1);\n  vec3 hitn1 = sdfNormal1(hitWC.pos, hitWC.distance);\n  float dWC = distance(aWC, hitWC.pos);\n  vec3 hitNDC = transform(lll, hitWC.pos);\n\n  vec3 sunPoint = raymarching2(hitWC.pos + hitn1 * 0.1, -light).pos;\n  //    float inSun = float(distance(hitWC.pos, sunPoint) > 30.);\n  float inSun = softshadow(\n    hitWC.pos + hitn1 * 0.05,\n    -light,\n    0.0001,\n    300.0,\n    8.0\n  );\n  //    float inSun=1.;\n\n  vec3 material = vec3(0.0, 0.2, 0.0);\n  if (dWC > 100.0) {\n    material = vec3(0.0, 0.0, 0.0);\n  }\n\n  const vec3 sunlightColor = vec3(8.0, 6.0, 1.0);\n\n  float aOcc = ambientOcclusion(hitWC.pos, hitn1);\n\n  vec3 reflectionDirection = reflect(light, hitn1);\n\n  vec3 color = vec3(0.0);\n  color += material * aOcc;\n  color += inSun * sunlightColor * material * max(0.0, dot(-light, hitn1));\n  //    color = (hitn1);\n\n  vec3 camPos = aWC;\n\n  vec3 eyeDirection = -lookDir1;\n  float uMaterialShininess = 256.0;\n  float specularLightWeighting = pow(\n    max(dot(reflectionDirection, eyeDirection), 0.0),\n    uMaterialShininess\n  );\n  color += specularLightWeighting;\n  //    float lightIntensity = 0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.);\n  //    float lightIntensity =\n  //        0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.) + 0.3*specularLightWeighting;\n  //    fragColor = visualize(blue, red, mix(0.5, 1.0, inSun) * lightIntensity);\n  //    fragColor = mix(hitWC.color, colorBackground, mix(0.5, 1.0, inSun) * clamp(lightIntensity, 0., 1.));\n  color = pow(color, vec3(1.0 / 2.2)); // gamma correction\n  fragColor = vec4(color, 1.0);\n  //    fragColor = visualize(hitWC.pos.x/10.);\n  //    fragColor = hitWC.color;\n  //    fragColor = visualize(blue, red, distance(hitWC, sunPoint)/20.);\n  //    fragColor = vec4(coord,0.,1.);\n  //    fragColor = vec4(aWC, 1.0);\n  // remap [-1, 1] to [0, 1]\n  // gl_FragDepth = hitNDC.z * 0.5 + 0.5;\n  //    gl_FragDepth = .9999999;\n}\n".replace(/RMHit sdf\(vec3 p\) {[\s\S]*?}/,F($)))])}),[$]),(0,v.useEffect)((()=>{Object.assign(I.current,w)}),[w]);const J=(0,v.useCallback)((({dim:n,children:e})=>{return v.createElement(o.Z,{variant:"contained",onClick:()=>Y(n),disabled:void 0!==t},void 0===t?e:"Rendering... "+(a=""+Math.floor(100*t),m.Z.format(a,"monospace")).padStart(3,"â€‡")+"%");var a}),[Y,t]);function nn({cam:n}){const t=P.k.fromShortString(n);D({cam:N.j.toShortString(t)})}return v.createElement(l.ZP,{container:!0,style:{height:"99%"}},v.createElement(l.ZP,{item:!0,xs:12,md:9},v.createElement("div",{style:{height:"100%"}},v.createElement("canvas",{ref:n,style:{width:"100%",height:"100%",cursor:0===A?"move":"grab"},width:T,height:T,tabIndex:0}))),v.createElement(l.ZP,{item:!0,xs:12,md:3,sx:{display:"flex",flexDirection:"column",width:"100%",padding:2,alignItems:"stretch",gap:2}},v.createElement(a.Z,null,v.createElement(r.Z,null,"Raymarching demo.")),v.createElement(c.Z,{onChange:n=>S(+n.target.value),value:T},v.createElement(i.Z,{value:256},"256x256"),v.createElement(i.Z,{value:512},"512x512")),v.createElement(x.V,{state:w,setStatePartial:D,prop:"a",inputProps:{step:.05}})," ",v.createElement(x.V,{state:w,setStatePartial:D,prop:"b",inputProps:{step:.05}}),v.createElement(x.V,{state:w,setStatePartial:D,prop:"c",inputProps:{step:.05}})," ",v.createElement(x.V,{state:w,setStatePartial:D,prop:"d",inputProps:{step:.05}}),v.createElement(J,{dim:[1920,1080]},"render hd"),v.createElement(J,{dim:[3840,2160]},"render 4k"),v.createElement(o.Z,{color:"secondary",variant:"outlined",onClick:()=>nn({cam:"999.999.999~-56.-58.-61~-44.-44.79"})},"Cam 0"),v.createElement(o.Z,{color:"secondary",variant:"outlined",onClick:()=>nn({cam:"57.427.96~1.-100.-8~7.-7.99"})},"Cam 1"),v.createElement(o.Z,{color:"secondary",variant:"outlined",onClick:()=>nn({cam:"53.80.892~-9.-8.-100~-18.-99.8"})},"Cam 2"),v.createElement("div",null,"cam: ",w.cam),v.createElement("div",null,"fps: ",B),v.createElement(Z,{label:"gp",onFocus:()=>setEditing(!0),onBlur:()=>setEditing(!1)},f),v.createElement("div",null,v.createElement(K,{value:$,onChange:j})),v.createElement("div",null,v.createElement("pre",null,v.createElement("code",null,F($))))))}},4235:(n,t,e)=>{e.d(t,{Z:()=>o});const o="#version 300 es\n\nprecision highp float;\n\n// START ../common/banded.glsl\nfloat banded(float bandCount, float t) {\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\n}\nfloat banded(int bandCount, float t) {\n  return banded(float(bandCount), t);\n}\n\n// #pragma glslify: export(banded)\n\n\n// END ../common/banded.glsl\n// START ../common/between.glsl\nbool between(float min, float max, float value) {\n  return min <= value && value <= max;\n}\n\n// #pragma glslify: export(between)\n\n\n// END ../common/between.glsl\n// START ../common/hexFns.glsl\n// START ./max3.glsl\nfloat max3(float a, float b, float c) {\n  return max(a, max(b, c));\n}\nfloat max3(vec3 v) {\n  return max(v.x, max(v.y, v.z));\n}\n\n// #pragma glslify: export(max3)\n\n\n// END ./max3.glsl\n// START ./constants.glsl\nconst float SQRT1_2 = 0.7071067811865476;\nconst float SQRT1_3 = 0.57735026919;\nconst float SQRT2 = 1.4142135623730951;\nconst float SQRT3 = 1.732050807568877;\n// sqrt(3)/2 = sin(60*)\nconst float SQRT3_2 = 0.86602540378;\nconst float GOLDEN_RATIO = 1.61803398875;\nconst float PI = 3.141592653589793;\nconst float TAU = 6.28318530718;\n/**\n * One degree in radians. Use like `sin(30 * DEG)`.\n */\nconst float DEGREE = 0.017453292519943295;\n\n// END ./constants.glsl\n\nvec3 hexRound(vec3 hex) {\n  vec3 r = floor(hex + 0.5);\n  vec3 diff = abs(r - hex);\n\n  if (diff.x > diff.y && diff.x > diff.z) {\n    r.x = -(r.y + r.z);\n  } else if (diff.y > diff.z) {\n    r.y = -(r.x + r.z);\n  } else {\n    r.z = -(r.x + r.y);\n  }\n\n  return r;\n}\nvec2 hex2Ra(vec3 hex) {\n  float y = hex.t * SQRT3_2;\n  float x = hex.s + hex.t / 2.0;\n  return vec2(x, y);\n}\n\nfloat hexSdf(vec3 hex) {\n  return max3(abs(hex.yzx + hex.zxy / 2.0));\n}\nvec3 ra2Hex(vec2 xy) {\n  float hex_t = xy.y / SQRT3_2;\n  float hex_s = xy.x - hex_t / 2.0;\n  return vec3(hex_s, hex_t, -(hex_s + hex_t));\n}\n\n// END ../common/hexFns.glsl\n// START ../common/matrices.glsl\n\nmat2 rot2(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat2(c, s, -s, c);\n}\nmat3 rotX(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\n}\nmat3 rotY(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\n}\nmat3 rotZ(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\n}\n/**\n * Returns a matrix that puts the camera at the eye point `ex, ey, ez` looking\n * toward the center point `cx, cy, cz` with an up direction of `ux, uy, uz`.\n * This emulates the OpenGL function `gluLookAt()`.\n */\nmat4 lookAt(vec3 eye, vec3 focus, vec3 up) {\n  vec3 f = normalize(eye - focus);\n  vec3 s = normalize(cross(up, f));\n  vec3 t = normalize(cross(f, s));\n\n  return mat4(\n    vec4(s.x, t.x, f.x, 0.0),\n    vec4(s.y, t.y, f.y, 0.0),\n    vec4(s.z, t.z, f.z, 0.0),\n    vec4(-dot(s, eye), -dot(t, eye), -dot(f, eye), 1)\n  );\n}\n\n// the OpenGL function `glFrustum()`.\nmat4 frustum(\n  float left,\n  float right,\n  float bottom,\n  float top,\n  float near,\n  float far\n) {\n  return mat4(\n    vec4(2.0 * near / (right - left), 0.0, 0.0, 0.0),\n    vec4(0, 2.0 * near / (top - bottom), 0.0, 0.0),\n    vec4(\n      (right + left) / (right - left),\n      (top + bottom) / (top - bottom),\n      -(far + near) / (far - near),\n      -1\n    ),\n    vec4(0.0, 0.0, -2.0 * far * near / (far - near), 0.0)\n  );\n}\n\nmat4 perspective(float fovDegrees, float aspect, float near, float far) {\n  float y = tan(fovDegrees * DEGREE / 2.0) * near;\n  float x = y * aspect;\n  return frustum(-x, x, -y, y, near, far);\n}\nmat4 ortho(\n  float left,\n  float right,\n  float bottom,\n  float top,\n  float near,\n  float far\n) {\n  return mat4(\n    vec4(2.0 / (right - left), 0.0, 0.0, 0.0),\n    vec4(0.0, 2.0 / (top - bottom), 0.0, 0.0),\n    vec4(0.0, 0.0, -2.0 / (far - near), 0.0),\n    vec4(\n      -(right + left) / (right - left),\n      -(top + bottom) / (top - bottom),\n      -(far + near) / (far - near),\n      1.0\n    )\n  );\n}\n\n// END ../common/matrices.glsl\n// START ../common/perlin2DTexture.glsl\nuniform sampler2D gradients;\n/* Create random direction vector\n */\nvec2 randomGradient(vec2 i) {\n  // Random float. No precomputed gradients mean this works for any number of grid coordinates\n  float random =\n    2920.0 *\n    sin(float(i.x) * 2.1942 + float(i.y) * 1.71324 + 8.912) *\n    cos(float(i.x) * 2.3157 * float(i.y) * 2.17832 + 9.758);\n  //    random = (i.x + 1667.) * (i.x + 2083.) * (i.y + 2659.) * (i.y * 50.77 + .3769);\n  //    random = sin(SQRT2 * i.x) + cos(GOLDEN_RATIO * i.y) + tan((i.x + i.y) * SQRT3);\n  return vec2(cos(random), sin(random));\n}\nfloat dotGridGradient(vec2 cell, vec2 pos) {\n  vec2 d = cell - pos;\n\n  //  vec2 gradient = texelFetch(gradients, ivec2(cell), 0).xy;\n  vec2 gradient = randomGradient(vec2(cell));\n\n  return dot(gradient, d);\n}\n\nfloat mixx(float a, float b, float t) {\n  return mix(a, b, smoothstep(0.0, 1.0, t));\n  //    return mix(a, b, t);\n}\n\n// resulting range is [-0.68, 0.68]. Use unmix to normalize if necessary.\nfloat perlin2D(vec2 xy) {\n  float x0 = floor(xy.x);\n  float x1 = x0 + 1.0;\n  float y0 = floor(xy.y);\n  float y1 = y0 + 1.0;\n\n  // Interpolate between grid point gradients\n  float n00 = dotGridGradient(vec2(x0, y0), xy);\n  float n10 = dotGridGradient(vec2(x1, y0), xy);\n  float ny0 = mixx(n00, n10, xy.x - x0);\n\n  float n01 = dotGridGradient(vec2(x0, y1), xy);\n  float n11 = dotGridGradient(vec2(x1, y1), xy);\n  float ny1 = mixx(n01, n11, xy.x - x0);\n\n  return mixx(ny0, ny1, xy.y - y0);\n}\n\n// #pragma glslify: export(perlin2D)\n\n\n// END ../common/perlin2DTexture.glsl\n// START ../common/polar.glsl\n// START ../common/fromPolar.glsl\n// START ./unmix.glsl\nfloat unmix(float a, float b, float value) {\n  return (value - a) / (b - a);\n}\n\n// #pragma glslify: export(unmix)\n\n\n// END ./unmix.glsl\n\nvec3 fromPolar(float radius, float phi, float z) {\n  return vec3(radius * cos(phi), radius * sin(phi), z);\n}\n\nvec2 fromPolar(float radius, float phi) {\n  return vec2(radius * cos(phi), radius * sin(phi));\n}\n\nvec2 fromPolar(vec2 polar) {\n  return fromPolar(polar.x, polar.y);\n}\n\n// #pragma glslify: export(fromPolar)\n\n\n// END ../common/fromPolar.glsl\n// START ../common/toPolar.glsl\n\nvec2 toPolar(vec2 xy) {\n  return vec2(length(xy), atan(xy.y, xy.x));\n}\n\nmat2 toPolarDerivate(vec2 xy) {\n  return mat2(xy.x * xy.x, xy.y * xy.y, -xy.y, xy.x) / dot(xy, xy);\n}\n\n// #pragma glslify: export(toPolar)\n\n\n// END ../common/toPolar.glsl\n\n// END ../common/polar.glsl\n// START ../common/remix.glsl\n\nfloat remix(float fromA, float fromB, float toA, float toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\nvec4 remix(float fromA, float fromB, vec4 toA, vec4 toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\n// #pragma glslify: export(remix)\n\n\n// END ../common/remix.glsl\n// START ../common/transform.glsl\nvec3 transform(mat4 pm, vec3 p) {\n  vec4 pStar = pm * vec4(p, 1);\n  return pStar.xyz / pStar.w;\n}\n\nvec2 transform(mat4 pm, vec2 p) {\n  vec4 pStar = pm * vec4(p, 0, 1);\n  return pStar.xy / pStar.w;\n}\n\n// END ../common/transform.glsl\n// START ../common/visualize.glsl\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\n  float isLow = float(t < 0.0);\n  float isHigh = float(t > 1.0);\n  float isMid = 1.0 - isLow - isHigh;\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\n}\n\nvec4 visualize(float t) {\n  const vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\n  const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\n  return visualize(BLUE, RED, t);\n}\n\n// #pragma glslify: export(visualize)\n\n\n// END ../common/visualize.glsl\n// START ../common/waves.glsl\nfloat waves(vec4 color, vec2 position, vec2 direction, float highResTimeStamp) {\n  return sin(\n    dot(position, direction / pow(length(direction), 2.0)) +\n      float(highResTimeStamp) / 200.0\n  );\n}\n\n// #pragma glslify: export(waves)\n\n\n// END ../common/waves.glsl\n\n// START ../common/sdf3d/add.glsl\nfloat add(float a, float b) {\n  return min(a, b);\n}\n\n// #pragma glslify: export(add)\n\n\n// END ../common/sdf3d/add.glsl\n// START ../common/sdf2d/addChamfer.glsl\n\nfloat addChamfer(float d, float a, float b) {\n  // exact variant, but abs is larger when a and b aren't perpendicular\n  // which is worse than underestimating, which is what the simple version does.\n  //  vec2 p = vec2(a, b);\n  //  if (p.x < d && p.y < d) {\n  //    p = rot2(0.25 * PI) * p;\n  //    p.y = abs(p.y);\n  //    p.y -= min(p.y, d * SQRT1_2);\n  //    p.x -= d * SQRT1_2;\n  //    //    p -= vec2(SQRT1_2) * clamp(dot(p, vec2(SQRT1_2)), 0.0, d);\n  //    float fillet = -length(p);\n  //    return -sign(p.x) * fillet;\n  //  } else {\n  //  }\n  float tillet = (a + b - d) * SQRT1_2;\n  return min(tillet, min(a, b));\n}\n\n// #pragma glslify: export(addChamfer)\n\n\n// END ../common/sdf2d/addChamfer.glsl\n// START ../common/sdf2d/addFillet.glsl\nfloat addFillet(float r, float a, float b) {\n  if (a < r && b < r) {\n    return r - distance(vec2(a, b), vec2(r));\n  } else {\n    return min(a, b);\n  }\n}\n\n// #pragma glslify: export(addFillet)\n\n\n// END ../common/sdf2d/addFillet.glsl\n// START ../common/sdf3d/opElongate.glsl\nvec3 opElongate(vec3 h, vec3 p) {\n  return p - clamp(p, -h, h);\n}\n// #pragma glslify: export(opElongate)\n\n// END ../common/sdf3d/opElongate.glsl\n// START ../common/sdf3d/opRepLim.glsl\nvec3 opRepLim(vec3 p, vec3 cellSize, vec3 limit) {\n  return p - cellSize * clamp(round(p / cellSize), vec3(0.0), limit);\n}\nvec2 opRepLim(vec2 p, vec2 cellSize, vec2 limit) {\n  return p - cellSize * clamp(round(p / cellSize), vec2(0.0), limit);\n}\nfloat opRepLim(float p, float cellSize, float limit) {\n  return p - cellSize * clamp(round(p / cellSize), 0.0, limit);\n}\n\n// #pragma glslify: export(opRepLim)\n\n\n// END ../common/sdf3d/opRepLim.glsl\n// START ../common/sdf3d/sdBox.glsl\n\nfloat sdBox(vec3 r, vec3 p) {\n  vec3 q = abs(p) - r;\n  return length(max(q, 0.0)) + min(max3(q), 0.0);\n}\n\nfloat sdBox(vec3 r, float r2, vec3 p) {\n  return sdBox(r - r2, p) - r2;\n}\n\n// #pragma glslify: export(sdBox)\n\n\n// END ../common/sdf3d/sdBox.glsl\n// START ../common/sdf3d/sdCone.glsl\n\n/**\n * Signed distance function (SDF) of a cone. The tip of the cone is at the\n * origin and points towards +Z. q is a point on the rim of the cone.\n */\nfloat sdCone(vec2 c, float h, vec3 p) {\n  vec2 q = h * vec2(c.x / c.y, -1.0);\n  vec2 w = vec2(length(p.xz), p.y);\n  vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);\n  vec2 b = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0);\n  float k = sign(q.y);\n  float d = min(dot(a, a), dot(b, b));\n  float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));\n  return sqrt(d) * sign(s);\n}\n// #pragma glslify: export(sdBox)\n\nfloat sdConeB(vec2 c, float h, vec3 p) {\n  float q = length(p.xz);\n  return max(dot(c.xy, vec2(q, p.y)), -h - p.y);\n}\n\n// END ../common/sdf3d/sdCone.glsl\n// START ../common/sdf3d/sdCylinder.glsl\nfloat sdCylinder(float radius, float z, vec3 p) {\n  vec2 d = vec2(length(p.xy), abs(p.z)) - vec2(radius, z);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// #pragma glslify: export(sdCylinder)\n\n\n// END ../common/sdf3d/sdCylinder.glsl\n// START ../common/sdf3d/sdTorus.glsl\nfloat sdTorus(float r0, float r1, vec3 p) {\n  vec3 closestCenter = vec3(normalize(p.xy) * r0, 0.0);\n  return distance(closestCenter, p) - r1;\n}\n\n// #pragma glslify: export(sdTorus)\n\n\n// END ../common/sdf3d/sdTorus.glsl\n// START ../common/sdf3d/sdIcosahedron.glsl\n\n// signed distance function for icosahedron\n// cf. https://en.wikipedia.org/wiki/Regular_icosahedron\n// s: edge length\n// p: point to evaluate function for\nfloat sdIcosahedron(float s, vec3 p) {\n  // NN = 1/GOLDEN_RATIO = GOLDEN_RATIO - 1\n  const float K = GOLDEN_RATIO * 0.5;\n  // the three vertices of the icosahedron triangle which\n  // is fully inside the +++ octant. (edge length = 1)\n  const vec3 a = vec3(0.5, K, 0.0);\n  const vec3 b = vec3(0.0, 0.5, K);\n  const vec3 c = vec3(K, 0.0, 0.5);\n  const vec3 ab1 = b - a; // values chosen so edge length is 1\n  const vec3 n1 = normalize(cross(a, b));\n  const vec3 n2 = normalize(cross(b, c));\n  const vec3 n3 = normalize(cross(c, a));\n  const vec3 xyz1 = normalize(vec3(1.0));\n  // for edge-length 1\n  const float INSCRIBED_SPHERE_RADIUS = 0.7557613141;\n\n  // we use a rotation where the icosahedron is symmetric\n  // in all three coordinate planes, and reduce the problem\n  // to the +++ octant\n  p = abs(p);\n\n  // there is one complete triangle in the +++ octant\n  // mirror on planes which go through origin and the\n  // complete triangles sides.\n  if (dot(p, n1) < 0.0) {\n    p += -2.0 * dot(p, n1) * n1;\n  }\n  if (dot(p, n2) < 0.0) {\n    p += -2.0 * dot(p, n2) * n2;\n  }\n  if (dot(p, n3) < 0.0) {\n    p += -2.0 * dot(p, n3) * n3;\n  }\n\n  // rotate space around (1,1,1) vector so that all sides of the triangle\n  // end up mapped on the ab side.\n  vec3 dirs = vec3(-dot(n1, p), -dot(n2, p), -dot(n3, p));\n  if (dirs.y > dirs.x && dirs.y > dirs.z) {\n    p = p.yzx;\n  } else if (dirs.z > dirs.x && dirs.z > dirs.y) {\n    p = p.zxy;\n  }\n\n  // check if the point is directly (perpendicular) above the triangle.\n  // as we have rotated the space, we only need to check if it is\n  // inside one edge.\n  vec3 midAB = (a + b) / 2.0;\n  vec3 pn = normalize(c - midAB);\n  float w = dot(midAB, pn);\n  if (dot(p, pn) > w * s) {\n    // if not, return the distance to the plane the triangle is in\n    return dot(xyz1, p) - INSCRIBED_SPHERE_RADIUS * s;\n  }\n\n  // project the point onto segment ab, and return the distance to it\n  float d3 = dot(ab1, p);\n  d3 = clamp(d3, -0.5 * s, 0.5 * s);\n  vec3 closestp = midAB * s + d3 * ab1;\n  return distance(closestp, p);\n}\n// #pragma glslify: export(sdIcosahedron)\n\n// END ../common/sdf3d/sdIcosahedron.glsl\n// START ../common/sdf3d/sdOctahedron.glsl\nfloat sdOctahedron(float s, vec3 p) {\n  p = abs(p);\n  float m = p.x + p.y + p.z - s;\n  vec3 q;\n  if (3.0 * p.x < m) q = p.xyz;\n  else if (3.0 * p.y < m) q = p.yzx;\n  else if (3.0 * p.z < m) q = p.zxy;\n  else return m * 0.57735027;\n\n  float k = clamp(0.5 * (q.z - q.y + s), 0.0, s);\n  return length(vec3(q.x, q.y - s + k, q.z - k));\n}\n// #pragma glslify: export(sdOctahedron)\n\nfloat sdOctahedron(vec3 p, float s) {\n  p = abs(p);\n\n  float m = p.x + p.y + p.z - s;\n  //find point on octohedron surf nearest to p\n  vec3 projPoint = p - vec3(0.333333 * m); //project onto surface plane\n  //now push projected point, if outside triangle edge, perpendicular to edge, to edge\n  vec3 toMove = min(projPoint, 0.0); //if projpoint.x<0 move along (1.0,-0.5,-0.5) , etc\n  float toMoveSum = dot(toMove, vec3(1.0)); //which is basically along (1.5,0,0) then vec3(-0.5)\n\n  vec3 movedPoint = projPoint + toMove * vec3(-1.5) + toMoveSum * vec3(0.5); //better to multiply toMove by a matrix (1s diagonal, 0.5 other)?\n\n  movedPoint = max(movedPoint, 0.0); //cap x,y,z to 0 then\n  movedPoint *= s / dot(movedPoint, vec3(1.0)); //scale about 0,0,0\n\n  return length(p - movedPoint);\n}\n\n// END ../common/sdf3d/sdOctahedron.glsl\n// START ../common/sdf3d/sdPyramid.glsl\n// Pyramid with tip at (0,0,0), up = z\n// c is the bottom corner. c.xy should be positive, c.z negative.\nvec2 sdPyramid(vec3 c, vec3 p) {\n  // pyramid is symmetric in XZ and YZ planes\n  p.xy = abs(p.xy);\n  bool flip = p.y * c.x > p.x * c.y; // p.y/p.x > c.y/c.x\n  c.xy = flip ? c.yx : c.xy;\n  p.xy = flip ? p.yx : p.xy;\n  vec3 cc = c / dot(c, c);\n  vec3 qx1 = normalize(vec3(-c.z, 0.0, c.x));\n  vec3 pOnQx = p - qx1 * dot(p, qx1);\n  float dx = dot(p, qx1);\n  float maxY = c.y * (pOnQx.x / c.x);\n  if (p.z <= c.z || pOnQx.z <= c.z) {\n    if (p.x <= c.x) {\n      // vertically underneath pyramid\n      return vec2(-p.z + c.z, 2.0);\n    } else {\n      float aa = distance(p, vec3(c.x, min(c.y, p.y), c.z));\n      return vec2(aa, 3.0);\n    }\n  } else if (pOnQx.y > maxY || pOnQx.z > 0.0) {\n    float xx = dot(cc, p);\n    float aa = length(p - clamp(xx, 0.0, 1.0) * c);\n\n    return vec2(aa, 1.0);\n  } else {\n    // need max for negativ values above base\n    return vec2(max(dx, -p.z + c.z), 0.0);\n  }\n}\n\n// #pragma glslify: export(sdPyramid)\n\n\n// END ../common/sdf3d/sdPyramid.glsl\n// START ../common/sdf3d/sdSphere.glsl\nfloat sdSphere(float radius, vec3 p) {\n  return length(p) - radius;\n}\n\n// #pragma glslify: export(sdSphere)\n\n\n// END ../common/sdf3d/sdSphere.glsl\n// START ../common/sdf3d/sub.glsl\nfloat sub(float from, float what) {\n  return max(from, -what);\n}\n\n// #pragma glslify: export(sub)\n\n\n// END ../common/sdf3d/sub.glsl\n\nuniform sampler2D texture;\nuniform float secs;\nuniform mat4 lll;\nuniform mat4 llli;\nuniform vec4 colorPrimary;\nuniform vec4 colorSecondary;\nuniform vec4 colorBackground;\nuniform float a;\nuniform float b;\nuniform float c;\nuniform float d;\nuniform float highResTimeStamp;\nuniform int bandCount;\nuniform vec3 campos;\nin float n;\nin vec2 coord;\nout vec4 fragColor;\n\n\nconst vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\nconst vec4 yellow = vec4(1.0, 1.0, 0.0, 1.0);\nconst vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\nconst vec4 blue = vec4(0.0, 0.0, 1.0, 1.0);\nconst vec4 purple = vec4(0.5, 0.0, 0.5, 1.0);\nconst vec4 red = vec4(1.0, 0.0, 0.0, 1.0);\n\nstruct RMHit {\n  float distance;\n  vec4 color;\n};\nRMHit mixa(RMHit a, RMHit b, float t) {\n  return RMHit(mix(a.distance, b.distance, t), mix(a.color, b.color, t));\n}\nfloat skybox(vec3 p) {\n  return 32.0 - max3(abs(p));\n}\n\nfloat perlinSphere(float radius, vec3 p) {\n  vec3 cp = normalize(p);\n  float alpha = atan(cp.y, cp.x);\n  float beta = asin(cp.z);\n  return length(p) -\n  radius +\n  0.1 *\n    perlin2D(vec2(0.0 / 100.0, 0.0) + (vec2(5.0) + vec2(alpha, beta)) * 8.0);\n}\n\nfloat cylCircle(vec3 p) {\n  float d = 10e9;\n  for (int i = 0; i < 10; i++) {\n    d = min(\n      d,\n      sdCylinder(0.2, 2.0, p + fromPolar(3.0, TAU * float(i) / 10.0, 1.0))\n    );\n  }\n\n  return d;\n}\n\nfloat rblock(float r, vec3 p) {\n  return sdBox(vec3(r), p);\n}\n\nRMHit add(RMHit a, RMHit b) {\n  //    return a.distance < b.distance\n  //        ? RMHit(a.distance, a.color)\n  //        : RMHit(b.distance, b.color);\n  return mixa(a, b, float(b.distance < a.distance));\n}\n\nfloat wtf(vec3 p) {\n  vec3 center = p - mod(p, 3.0) + vec3(1.5);\n  return rblock(0.4 + 0.3 * sin(secs + center.x), p - center);\n}\n\nRMHit addFillet(float r, RMHit a, RMHit b) {\n  if (a.distance < r && b.distance < r) {\n    return RMHit(\n      r - distance(vec2(a.distance, b.distance), vec2(r)),\n      mix(a.color, b.color, (a.distance - b.distance) / r * 0.5 + 0.5)\n    );\n  } else {\n    return add(a, b);\n  }\n}\n\nRMHit addFillet(float r, RMHit a, RMHit b, vec4 tilletColor) {\n  if (a.distance < r && b.distance < r) {\n    return RMHit(\n      r - distance(vec2(a.distance, b.distance), vec2(r)),\n      tilletColor\n    );\n  } else {\n    return add(a, b);\n  }\n}\nRMHit addFillet2(float r, RMHit a, RMHit b) {\n  float h = smoothstep(-r, r, a.distance - b.distance);\n  return RMHit(\n    mix(a.distance, b.distance, h) - r * h * (1.0 - h),\n    mix(a.color, b.color, h)\n  );\n}\n\nRMHit neg(RMHit a) {\n  return RMHit(-a.distance, a.color);\n}\nRMHit sub(RMHit from, RMHit what) {\n  RMHit whatNeg = neg(what);\n  return mixa(from, whatNeg, float(whatNeg.distance > from.distance));\n}\n\nvec3 modv(vec3 v, vec3 dir1, float y) {\n  float t = dot(v, dir1);\n  return v - floor(t / y) * y * dir1;\n}\nvec3 modRotZ(vec3 p, float count) {\n  vec2 polarXY = toPolar(p.xy);\n  return fromPolar(polarXY.x, mod(polarXY.y, TAU / count), p.z);\n}\n\nfloat sin01(float x) {\n  return 0.5 + 0.5 * sin(x);\n}\nfloat cos01(float x) {\n  return 0.5 + 0.5 * cos(x);\n}\n\nfloat betterBox(vec3 r, vec3 p) {\n  vec3 q = abs(p) - r;\n  return length(max(q, 0.0)) + min(max3(q), 0.0);\n  p = abs(p);\n  return max3(p - r);\n}\n\nfloat roundedBlock(vec3 r, float cr, vec3 p) {\n  return betterBox(r - vec3(cr), p) - cr;\n}\n\nfloat sdCapsule(vec3 a, vec3 b, float r, vec3 p) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h) - r;\n}\nfloat sdEllipsoidB(vec3 r, vec3 p) {\n  float k0 = length(p / r);\n  float k1 = length(p / (r * r));\n  return k0 * (k0 - 1.0) / k1;\n}\nfloat sdOctahedronB(float s, vec3 p) {\n  p = abs(p);\n  return (p.x + p.y + p.z - s) * 0.57735027;\n}\nfloat donutc(float r0, float r1, vec3 p) {\n  vec3 closestCenter = vec3(normalize(p.xy) * r0, 0.0);\n  return distance(closestCenter, p) - r1;\n}\n\nfloat sdCappedCylinder(float h, float r, vec3 p) {\n  vec2 d = vec2(length(p.xy), abs(p.z)) - vec2(r, h);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\nfloat smoothmin(float r, float a, float b) {\n  float h = smoothstep(-r, r, a - b);\n  return mix(a, b, h) - r * h * (1.0 - h);\n}\nfloat queen(vec3 p) {\n  float lxy = length(p.xy);\n  float d;\n  d = lxy - 1.1;\n  d += 0.16 * p.z;\n  d -= -c * (1.0 - pow(sin01(b + p.z * 2.5), 1.5));\n  d += 0.1 * normalize(p.xy).x * smoothstep(2.0, 0.5, p.z);\n  d +=\n    0.02 * sin(15.0 * atan(p.y, p.x) - p.z * 5.0) * smoothstep(2.0, 0.5, p.z);\n  //    float d = sdCappedCylinder(a, b, p);\n  d = max(d, -p.z);\n  d = max(d, p.z - 4.0);\n\n  float head = sdSphere(0.55, p - vec3(0.0, 0.0, 4.4));\n  d = smoothmin(0.15, d, head);\n  float crown = sdCone(\n    fromPolar(vec2(1.0, 1.15)),\n    1.0,\n    -(p - vec3(0.0, 0.0, 4.5)).yzx\n  );\n  d = min(d, crown);\n  d *= 0.5;\n  return d;\n}\n\nvec2 project(vec2 a, vec2 onto1) {\n  return onto1 * (dot(a, onto1) / dot(onto1, onto1));\n}\n\nvec3 reject(vec3 a, vec3 b1) {\n  return a - b1 * dot(a, b1);\n}\n\nRMHit sdf(vec3 p) {\n  const vec4 red = vec4(0.2, 0.0, 0.0, 1.0);\n  //  RMHit d = RMHit(block(vec3(-1.0, -1.0, -1.0), vec3(1.0, 1.0, 1.0), p), black);\n  //    RMHit d = RMHit(sphere(2., p), black);\n  //    RMHit d = RMHit(betterBox(vec3(1.), p), black);\n  //    RMHit d = RMHit(roundedBlock(vec3(1.), 0.1, p), black);\n  //    RMHit d = RMHit(donut(2., 0.5, p), black);\n  //    RMHit d = RMHit(sdCapsule(vec3(-a,-a,0.), vec3(a,a,0.), b, p), black);\n  //    RMHit d = RMHit(sdEllipsoidB(vec3(-a,-b,1.), p), black);\n  //    RMHit d = RMHit(sdOctahedron(1., p)-a, red) ;\n  //    RMHit d = RMHit(queen(p), black) ;\n  //    RMHit d = RMHit(lego(p), black) ;\n  //- vec3(0.0, 0.0, 1.0)\n  vec3 h = vec3(0.5, 0.0, 0.0);\n  vec3 q = abs(p) - h;\n  //    vec2 pyr = sdPyramid(\n  //        vec3(2.0, 2.0, -2.0),\n  //        opElongate(h,\n  //            rotZ(highResTimeStamp/1000.) *\n  //                rotX(c) *\n  //                opRepLim(p - vec3(-8., -8., 2.), vec3(8.), vec3(2., 2., 0.))));\n  vec3 p2 = rotX(highResTimeStamp * 0.0) * p;\n  vec2 xx = vec2(sdIcosahedron(d, p2) - c, 1.0);\n  vec4 cc = red;\n  cc.xyz = cc.xyz * xx.y * 0.1;\n  RMHit d = RMHit(xx.x, cc);\n  //    RMHit d = RMHit(sdCone(fromPolar(vec2(1., a)), b, p.yzx - vec3(0.,2., 0.)), black);\n  //    d.distance = abs(d.distance) - 0.4;\n  //    d.distance = abs(d.distance) - 0.1;\n  //    d.distance = abs(d.distance) - 0.02;\n  float s = length(p - vec3(1.0, 1.0, 0.0)) - 1.0;\n  //    d.distance = s;\n  //    d.distance = max(d.distance, -s);\n\n  vec3 color = 0.1 * sin(abs(vec3(0.0, PI, 0.0) + vec3(d.distance * PI * 2.0)));\n  //    color.z = .1*xx.y;\n  RMHit base = RMHit(sdBox(vec3(10.0, 10.0, 0.0), p), vec4(color, 1.0));\n\n  //    d = base;\n  d = add(base, d);\n  if (b > 1.0) {\n    d = base;\n  }\n  //    d.distance *=0.5;\n  return d;\n}\nfloat sdff(vec3 p) {\n  return sdf(p).distance;\n}\nfloat ambientOcclusion(vec3 pWC, vec3 n1WC) {\n  float k = 1.0;\n  float distance = sdff(pWC + n1WC * k);\n  return clamp(distance / k, 0.0, 1.0);\n}\n\nstruct RMResult {\n  float distance;\n  vec3 pos;\n  vec4 color;\n};\nRMResult raymarching2(vec3 start, vec3 dir1) {\n  vec3 pos = start;\n  RMHit hit;\n  for (int i = 0; i < 200; i++) {\n    hit = sdf(pos);\n    if (hit.distance < 0.0001 * hit.distance) break;\n    pos = pos + dir1 * hit.distance;\n  }\n  return RMResult(hit.distance, pos, hit.color);\n}\n\nfloat softshadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {\n  float res = 1.0;\n  float t = 0.1;\n  for (int i = 0; i < 1000 && t < maxt; i++) {\n    float h = sdff(ro + rd * t);\n    if (h < 0.001) return 0.0;\n    res = min(res, k * h / t);\n    t += h;\n  }\n  return res;\n}\n\nconst float eps = 1e-4;\nvec3 sdfNormal1(vec3 p, float d) {\n  return normalize(\n    vec3(\n      sdff(p + vec3(eps, 0.0, 0.0)),\n      sdff(p + vec3(0.0, eps, 0.0)),\n      sdff(p + vec3(0.0, 0.0, eps))\n    ) -\n      vec3(sdff(p))\n  );\n}\n\n//layout (depth_greater) out float gl_FragDepth;\nvoid main() {\n  vec3 light = normalize(vec3(-1.0, -2.0, -2));\n\n  vec3 a = vec3(coord, -1.0);\n  vec3 b = vec3(coord, 1.0);\n  vec3 aWC = transform(llli, a);\n  vec3 bWC = transform(llli, b);\n  vec3 lookDir1 = normalize(bWC - aWC);\n\n  RMResult hitWC = raymarching2(aWC, lookDir1);\n  vec3 hitn1 = sdfNormal1(hitWC.pos, hitWC.distance);\n  float dWC = distance(aWC, hitWC.pos);\n  vec3 hitNDC = transform(lll, hitWC.pos);\n  vec3 p = hitWC.pos;\n  float inSun = softshadow(\n    hitWC.pos + hitn1 * 0.05,\n    -light,\n    0.0001,\n    300.0,\n    8.0\n  );\n  //    float inSun=1.;\n\n  vec3 material = hitWC.color.xyz;\n  if (dWC > 100.0) {\n    material = vec3(0.0, 0.0, 0.0);\n    //    } else if (p.z >= 0.001) {\n    //        material = vec3(0.2, 0.0, 0.0);\n    //    } else {\n    //        vec2 c = vec2(4.0, 2.0);\n    //        vec2 id = floor(((p.xy - c * 0.5) / c) );\n    //        material += .15 * cos(vec3(id.x, id.y + 2., id.x + id.y + 4.));\n  }\n\n  const vec3 sunlightColor = vec3(8.0, 6.0, 1.0);\n\n  float aOcc = ambientOcclusion(hitWC.pos, hitn1);\n\n  vec3 reflectionDirection = reflect(light, hitn1);\n\n  vec3 color = vec3(0.0);\n  color += material * aOcc;\n  color += inSun * sunlightColor * material * max(0.0, dot(-light, hitn1));\n  //    color = (hitn1);\n\n  vec3 camPos = aWC;\n\n  vec3 eyeDirection = -lookDir1;\n  float uMaterialShininess = 256.0;\n  float specularLightWeighting = pow(\n    max(dot(reflectionDirection, eyeDirection), 0.0),\n    uMaterialShininess\n  );\n  color += specularLightWeighting;\n  //    float lightIntensity = 0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.);\n  //    float lightIntensity =\n  //        0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.) + 0.3*specularLightWeighting;\n  //    fragColor = visualize(blue, red, mix(0.5, 1.0, inSun) * lightIntensity);\n  //    fragColor = mix(hitWC.color, colorBackground, mix(0.5, 1.0, inSun) * clamp(lightIntensity, 0., 1.));\n  color = pow(color, vec3(1.0 / 2.2)); // gamma correction\n  fragColor = vec4(color, 1.0);\n}\n"},5274:(n,t,e)=>{e.d(t,{Z:()=>o});const o="#version 300 es\n\nprecision highp float;\n\n// START ../common/visualize.glsl\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\n  float isLow = float(t < 0.0);\n  float isHigh = float(t > 1.0);\n  float isMid = 1.0 - isLow - isHigh;\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\n}\n\nvec4 visualize(float t) {\n  const vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\n  const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\n  return visualize(BLUE, RED, t);\n}\n\n// #pragma glslify: export(visualize)\n\n\n// END ../common/visualize.glsl\n// START ../common/banded.glsl\nfloat banded(float bandCount, float t) {\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\n}\nfloat banded(int bandCount, float t) {\n  return banded(float(bandCount), t);\n}\n\n// #pragma glslify: export(banded)\n\n\n// END ../common/banded.glsl\n\nuniform vec4 color;\n\nout vec4 fragColor;\n\nvoid main() {\n  fragColor = color;\n}\n"},5598:(n,t,e)=>{e.d(t,{Z:()=>o});const o="#version 300 es\nprecision highp float;\n\nuniform mat4 ts_ModelViewProjectionMatrix;\nuniform float normalOffset;\nin vec3 ts_Normal;\nin vec4 ts_Vertex;\n\nvoid main() {\n  gl_Position =\n    ts_ModelViewProjectionMatrix *\n    (ts_Vertex + normalOffset * vec4(ts_Normal, 0.0));\n}\n"}}]);
//# sourceMappingURL=raymarch-index.js.map