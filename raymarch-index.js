"use strict";(self.webpackChunkworkshop=self.webpackChunkworkshop||[]).push([[628],{9764:(n,t,e)=>{e.d(t,{V:()=>r});var o=e(3121),a=e(9526);function r({state:n,prop:t,setStatePartial:e,...r}){return a.createElement(o.Z,{variant:"outlined",size:"small",type:"number",value:n[t],onChange:n=>e({[t]:+n.target.value}),label:t,...r})}},9248:(n,t,e)=>{e.d(t,{q:()=>o});class o{__init(){this.count=0}__init2(){this.lastTime=performance.now()}constructor(n,t=10){this.notify=n,this.window=t,o.prototype.__init.call(this),o.prototype.__init2.call(this)}tick(n=performance.now()){const t=this.window;if(this.count=(this.count+1)%t,0===this.count){const e=Math.floor(1e3*t/(n-this.lastTime));this.notify(e),this.lastTime=n}}}},9874:(n,t,e)=>{e.d(t,{q:()=>p});var o=e(6897),a=e.n(o),r=e(508),i=e.n(r),l=e(9526);const s=n=>n?n.substring(1).split("&").map((n=>{const[t,e]=n.split("=");return[decodeURIComponent(t),decodeURIComponent(e)]})).reduce(((n,[t,e])=>(n[t]=e,n)),{}):{},c=n=>"#"+Object.entries(n).map((([n,t])=>encodeURIComponent(n)+"="+encodeURIComponent(t))).join("&"),d=n=>i()(n,(n=>"true"===n||"false"!==n&&("NaN"===n?NaN:"undefined"===n?void 0:"null"===n?null:""===n?"":isNaN(+n)?n:+n))),f=n=>i()(n,(n=>""+n));function p(n,{deserialize:t=d,serialize:e=f,wait:o=1e3}={}){const r=(0,l.useCallback)((()=>{const o="function"==typeof n?n():n,a=t(Object.assign(e(o),s(document.location.hash)));return history.pushState(void 0,document.title,c(e(a))),a}),[t,n,e]),[i,p]=(0,l.useState)(r),m=(0,l.useRef)();return m.current||(m.current=a()((function(n){history.pushState(void 0,document.title,c(e(n)))}),o)),(0,l.useEffect)((()=>m.current(i)),[i]),(0,l.useEffect)((()=>{const n=()=>{p(r())};return window.addEventListener("hashchange",n),()=>{window.removeEventListener("hashchange",n)}}),[r]),[i,p]}},3671:(n,t,e)=>{e.d(t,{$Q:()=>g,PM:()=>r,PN:()=>v,Qn:()=>s,X$:()=>i,XJ:()=>l,YQ:()=>b,_x:()=>f,hv:()=>p,kC:()=>m,li:()=>u,nA:()=>h,nl:()=>x,oe:()=>d,q3:()=>c,t1:()=>y});var o=e(9526),a=e(2182);const r=25.4,i=n=>(0,a.At)(n/a.Co,-1)+"°",l=(n,t)=>t/2/Math.sin(a.gc/n/2),s=(n,t)=>2*t*Math.sin(a.gc/n/2),c=(n,t)=>t/2/Math.tan(a.gc/n/2),d=(n,t)=>t/Math.cos(a.gc/n/2),f=(n,t)=>2*t*Math.tan(a.gc/n/2);function p({sides:n,radius:t,startAngle:e=0,sideLength:r,...i}){if(void 0!==r==(void 0!==t))throw new Error("must set either sideLength or radius");void 0===t&&(t=l(n,r));const{x:s,y:c}=a.V3.polar(t,e);return o.createElement("path",{d:x`
        M${s},${c}
        ${(0,a.hS)(0,n).map((o=>x`L${a.V3.polar(t,e+o*(a.gc/n))}`))}Z`,...i})}function m({id:n,children:t,count:e,stepDeg:r}){return o.createElement(o.Fragment,null,o.createElement("g",{id:n},t),(0,a.hS)(0,e-1).map((t=>o.createElement("use",{key:t,xlinkHref:"#"+n,transform:`rotate(${(t+1)*r} 0 0)`}))))}const u=[[841,1189,"A0"],[594,841,"A1"],[420,594,"A2"],[297,420,"A3"],[210,297,"A4"],[148,210,"A5"],[105,148,"A6"],[74,105,"A7"],[52,74,"A8"],[37,52,"A9"],[26,37,"A10"],[150,150,"Origami 15cm"],[100,100,"Origami 10cm"],[75,75,"Origami 7.5cm"],[215.9,279.4,"Letter"],[215.9,355.6,"Legal"]];function h(n){const t=u.find((([,,t])=>t==n));if(t)return t;const[e,o]=n.split("x");return[+e,+o,"Custom"]}function v(n,t){return[n,t]=[n,t].sort(a.uK),null!=(e=u.find((([e,o])=>e===n&&o===t)))?e:(()=>[n,t,"Custom"])();var e}function g([n,t,e]){return"Custom"===e?n+"x"+t:e}const y=u.find((([,,n])=>"A4"===n));function x(n,...t){const e=n=>"number"==typeof n?""+n:"string"==typeof n?n:Array.isArray(n)?n.map(e).join(" "):n.x+","+n.y;let o=n[0];for(let a=0;a<t.length;a++)o+=e(t[a]),o+=n[a+1];return o}const b=n=>{const t=window.open(n,"_blank","noopener,noreferrer");t&&(t.opener=null)}},6810:(n,t,e)=>{e.d(t,{k:()=>r});var o=e(2182);function a(n){let t,e=n[0],o=1;for(;o<n.length;){const a=n[o],r=n[o+1];if(o+=2,("optionalAccess"===a||"optionalCall"===a)&&null==e)return;"access"===a||"optionalAccess"===a?(t=e,e=r(e)):"call"!==a&&"optionalCall"!==a||(e=r(((...n)=>e.call(t,...n))),t=void 0)}return e}class r{__init(){this.lastPos=o.V3.O}__init2(){this.pressedKeys={}}__init3(){this.pauseCam=!1}constructor(n,t,e){this.state=n,this.onChange=t,this.lockUp=e,r.prototype.__init.call(this),r.prototype.__init2.call(this),r.prototype.__init3.call(this),r.prototype.__init4.call(this),r.prototype.__init5.call(this),r.prototype.__init6.call(this),r.prototype.__init7.call(this)}__init4(){this.setState=n=>{n!==this.state&&o.M4.copy(n,this.state)}}registerListeners(n,t=n){return a([this,"access",n=>n.unregister,"optionalCall",n=>n()]),n.addEventListener("mousemove",this.mousemove),t.addEventListener("keydown",this.keydown),t.addEventListener("keyup",this.keyup),this.unregister=()=>{n.removeEventListener("mousemove",this.mousemove),t.removeEventListener("keydown",this.keydown),t.removeEventListener("keyup",this.keyup)}}unregisterListeners(){a([this,"access",n=>n.unregister,"optionalCall",n=>n()])}tick(){const n=new o.V3(+!!this.pressedKeys.a-+!!this.pressedKeys.d,+!!this.pressedKeys.q+ +!!this.pressedKeys.Control-+!!this.pressedKeys.e-+!!this.pressedKeys[" "],+!!this.pressedKeys.w-+!!this.pressedKeys.s);n.likeO()||(this.state=this.state.translate(n.toLength(.05)),a([this,"access",n=>n.onChange,"optionalCall",n=>n(this.state)]))}__init5(){this.mousemove=n=>{const t=(0,o.V)(n.pageX,n.pageY),e=this.lastPos.to(t);if(1&n.buttons&&!this.pauseCam){const n=o.M4.rotateY(.25*e.x*o.Co).rotateX(.25*e.y*o.Co);this.state=n.times(this.state),a([this,"access",n=>n.onChange,"optionalCall",n=>n(this.state)])}this.lastPos=t}}__init6(){this.keydown=n=>{this.pressedKeys[n.key]=!0,n.preventDefault()}}__init7(){this.keyup=n=>{this.pressedKeys[n.key]=void 0,n.preventDefault()}}getLookAt(){return this.state}static invertLookAt(n){const t=n.transposed().scale(-1);return{eye:t.transformVector(n.getTranslation(),!1),dir:t.transformVector(o.V3.Z,!1),up:t.transformVector(o.V3.Y.negated(),!1)}}static toShortString(n,t=100){const e=(n,t)=>[n.x,n.y,n.z].map((n=>Math.floor(n*t))).join("."),{eye:o,dir:a,up:i}=r.invertLookAt(n);return e(o,t)+"~"+e(a.unit(),100)+"~"+e(i,100)}static fromShortString(n,t=100){const e=(n,t)=>(0,o.V)(n.split(".").map((n=>+n/t))),[a,r,i]=n.split("~"),l=e(a,t);return o.M4.lookAt(l,l.plus(e(r,100)),e(i,100))}}},7044:(n,t,e)=>{e.d(t,{j:()=>i});var o=e(2182);function a(n){let t,e=n[0],o=1;for(;o<n.length;){const a=n[o],r=n[o+1];if(o+=2,("optionalAccess"===a||"optionalCall"===a)&&null==e)return;"access"===a||"optionalAccess"===a?(t=e,e=r(e)):"call"!==a&&"optionalCall"!==a||(e=r(((...n)=>e.call(t,...n))),t=void 0)}return e}const r=["zoomIn","zoomOut","left","right","up","down"];class i{__init(){this.lastPos=o.V3.O}__init2(){this.pressedKeys={zoomIn:!1,zoomOut:!1,left:!1,right:!1,up:!1,down:!1}}__init3(){this.pauseCam=!1}__init4(){this.udRot=.1}__init5(){this.rot=0}__init6(){this.dist=10}constructor(n,t={zoomIn:"w",zoomOut:"s",left:"a",right:"d",up:" ",down:"Control"}){this.onChange=n,this.keys=t,i.prototype.__init.call(this),i.prototype.__init2.call(this),i.prototype.__init3.call(this),i.prototype.__init4.call(this),i.prototype.__init5.call(this),i.prototype.__init6.call(this),i.prototype.__init7.call(this),i.prototype.__init8.call(this),i.prototype.__init9.call(this),i.prototype.__init10.call(this),i.prototype.__init11.call(this),i.prototype.__init12.call(this)}__init7(){this.setState=n=>{console.log("setStaet"),[this.udRot,this.rot,this.dist]=i.toOrbitCameraState(n)}}static toOrbitCameraState(n){if(n instanceof o.M4){const t=n.transposed().scale(-1).transformVector(n.getTranslation(),!1);return[Math.atan(t.z/t.lengthXY()),t.angleXY(),t.length()]}return n}registerListeners(n,t=n){return a([this,"access",n=>n.unregister,"optionalCall",n=>n()]),n.addEventListener("mousemove",this.mousemove),n.addEventListener("wheel",this.wheel),t.addEventListener("keydown",this.keydown),t.addEventListener("keyup",this.keyup),t.addEventListener("blur",this.keyup),this.unregister=()=>{n.removeEventListener("mousemove",this.mousemove),n.removeEventListener("wheel",this.wheel),t.removeEventListener("keydown",this.keydown),t.removeEventListener("keyup",this.keyup),t.removeEventListener("keyup",this.keyup)}}__init8(){this.blur=()=>{}}unregisterListeners(){a([this,"access",n=>n.unregister,"optionalCall",n=>n()])}tick(){const n=.1*(+this.pressedKeys.zoomOut-+this.pressedKeys.zoomIn),t=.1*(-+this.pressedKeys.left+ +this.pressedKeys.right),e=(0,o.uZ)(this.udRot+.1*(+this.pressedKeys.up-+this.pressedKeys.down),.5*-Math.PI,.5*Math.PI);0===n&&0===t&&e===this.udRot||(this.dist+=n,this.rot+=t,this.udRot=e,a([this,"access",n=>n.onChange,"optionalCall",n=>n(this.ss)]))}__init9(){this.mousemove=n=>{const t=(0,o.V)(n.pageX,n.pageY),e=this.lastPos.to(t);if(1&n.buttons&&!this.pauseCam){const t=e.x/100,r=(0,o.uZ)(this.udRot+e.y/100,.5*-Math.PI,.5*Math.PI);r===this.udRot&&0===t||(this.udRot=r,this.rot+=t,a([this,"access",n=>n.onChange,"optionalCall",n=>n(this.ss)]),n.stopImmediatePropagation(),n.preventDefault())}this.lastPos=t}}__init10(){this.wheel=n=>{const t=(0,o.uZ)(this.dist+n.deltaY,.1,1e3);t!==this.dist&&(this.dist=t,n.stopImmediatePropagation(),n.preventDefault(),a([this,"access",n=>n.onChange,"optionalCall",n=>n(this.ss)]))}}get ss(){return[this.udRot,this.rot,this.dist]}__init11(){this.keydown=n=>{for(const t of r)if(this.keys[t]===n.key)return this.pressedKeys[t]=!0,n.stopImmediatePropagation(),void n.preventDefault()}}__init12(){this.keyup=n=>{for(const t of r)if(this.keys[t]===n.key)return this.pressedKeys[t]=!1,n.stopImmediatePropagation(),void n.preventDefault()}}getLookAt(){return i.getLookAt(this.ss)}static getLookAt([n,t,e]){return o.M4.rotateZ(t).rotateY(n).transform(o.M4.lookAt((0,o.V)(e,0,0),o.V3.O,o.V3.Z))}static invertLookAt(n){const t=n.transposed().scale(-1);return{eye:t.transformVector(n.getTranslation(),!1),dir:t.transformVector(o.V3.Z,!1),up:t.transformVector(o.V3.Y.negated(),!1)}}static toShortString(n,t=100){const[e,o,a]=this.toOrbitCameraState(n),r=(n,t)=>Math.floor(n*t);return r(e,100)+"~"+r(o,100)+"~"+r(a,100)}static fromShortString(n,t=100){const e=(n,t)=>+n/t,[o,a,r]=n.split("~");return[e(o,100),e(a,100),e(r,100)]}}},4217:(n,t,e)=>{e.r(t),e.d(t,{default:()=>J});var o=e(8864),a=e(5069),r=e(4854),i=e(871),l=e(897),s=e(2039),c=e(882),d=e(8051),f=e(3121),p=e(492),m=e(7392),u=e(3059),h=e(9526),v=e(2182),g=e(2004),y=e(9764),x=e(9248),b=e(9874),C=e(3671);function R(n){let t,e=n[0],o=1;for(;o<n.length;){const a=n[o],r=n[o+1];if(o+=2,("optionalAccess"===a||"optionalCall"===a)&&null==e)return;"access"===a||"optionalAccess"===a?(t=e,e=r(e)):"call"!==a&&"optionalCall"!==a||(e=r(((...n)=>e.call(t,...n))),t=void 0)}return e}const w=m.$_("red").gl(),S=m.$_("green").gl(),E=m.$_("blue").gl(),T=g.$R,z={anchor:v.V3.O,dir1:v.V3.X},M={anchor:v.V3.O,dir1:v.V3.Y},_={anchor:v.V3.O,dir1:v.V3.Z};class k{__init(){this.meshes={}}__init2(){this.highlight=0}__init3(){this.offsetGC=void 0}__init4(){this.dragging=0}constructor(n,t,e,o,a,r){this.gl=n,this.pos=t,this.onHover=e,this.onStartDragging=o,this.onStopDragging=a,this.onChange=r,k.prototype.__init.call(this),k.prototype.__init2.call(this),k.prototype.__init3.call(this),k.prototype.__init4.call(this),k.prototype.__init5.call(this),k.prototype.__init6.call(this),k.prototype.__init7.call(this),this.meshes.vector=g.Kj.rotation([(0,v.V)(0,.04),(0,v.V)(.8,.04),(0,v.V)(.85,.06),(0,v.V)(1,0)],z,v.gc,8,!0),this.meshes.vector.computeNormalsFromFlatTriangles(),this.meshes.vector.compile();const i=v.M4.rotateX(-90*v.Co).translate(v.V3.X);this.meshes.rotater=g.Kj.rotation((0,v.hS)(0,9).map((n=>i.transformPoint(v.V3.polar(.04,-v.gc*n/8)))),{anchor:v.V3.O,dir1:v.V3.Z},101.25*v.Co,8,!1),this.meshes.rotater.computeNormalsFromFlatTriangles(),this.meshes.rotater.compile()}drawVector(n,t,e,o=1){if(n.likeO())return;this.gl.pushMatrix();const a=n.getPerpendicular().unit();this.gl.multMatrix(v.M4.forSys(n.unit(),a,n.cross(a).unit(),t)),e.draw(this.meshes.vector),this.gl.popMatrix()}render(n){const t=this.gl;t.enable(t.CULL_FACE),t.cullFace(t.BACK),t.pushMatrix(),t.multMatrix(this.pos),t.cullFace(t.FRONT),n.uniforms({color:T,normalOffset:.01}),1!==this.highlight&&1!==this.dragging||this.drawVector(v.V3.X,v.V3.O,n,.1),2!==this.highlight&&2!==this.dragging||this.drawVector(v.V3.Y,v.V3.O,n,.1),3!==this.highlight&&3!==this.dragging||this.drawVector(v.V3.Z,v.V3.O,n,.1),t.cullFace(t.BACK),n.uniforms({normalOffset:0}),this.drawVector(v.V3.X,v.V3.O,n.uniforms({color:w}),.1),this.drawVector(v.V3.Y,v.V3.O,n.uniforms({color:S}),.1),this.drawVector(v.V3.Z,v.V3.O,n.uniforms({color:E}),.1),n.uniforms({color:E}).draw(this.meshes.rotater),t.rotate(-90,0,1,0),n.uniforms({color:w}).draw(this.meshes.rotater),t.rotate(-90,1,0,0),n.uniforms({color:S}).draw(this.meshes.rotater),t.popMatrix()}registerListeners(n,t){return this.getCameraMatrix=t,R([this,"access",n=>n.unregister,"optionalCall",n=>n()]),n.addEventListener("mousemove",this.mousemove),n.addEventListener("mousedown",this.mousedown),n.addEventListener("mouseup",this.mouseup),this.unregister=()=>{n.removeEventListener("mousemove",this.mousemove),n.removeEventListener("mousedown",this.mousedown),n.removeEventListener("mouseup",this.mouseup)}}unregisterListeners(){R([this,"access",n=>n.unregister,"optionalCall",n=>n()])}__init5(){this.mousemove=n=>{const t=(0,v.V)(n.offsetX,n.offsetY),e=n.target.getBoundingClientRect();e.width;const o=function(n,t,e){const o=(0,v.V)(2*n.x/t.width-1,2*-n.y/t.height+1,-1),a=(0,v.V)(2*n.x/t.width-1,2*-n.y/t.height+1,1),r=e.inversed(),i=r.transformPoint(o);return{anchor:i,dir1:r.transformPoint(a).minus(i).unit()}}(t,e,this.getCameraMatrix());if(this.dragging){const a=[v.V3.O,v.V3.X,v.V3.Y,v.V3.Z][this.dragging],r=D(o,{anchor:this.pos.getTranslation(),dir1:this.pos.transformVector(a).unit()}),i=this.pos.transformVector(this.offsetGC),l=r.lineClosest.minus(i);this.pos=this.pos.translate(this.pos.getTranslation().to(l)),this.onChange(this.pos)}else{const s=this.pos.inversed(),c={anchor:s.transformPoint(o.anchor),dir1:s.transformVector(o.dir1).unit()};let d;function f(n){const t=D(c,n);return d=A(n,(0,v.uZ)(t.lineT,0,1)),d.distanceTo(t.thClosest)}const p=this.highlight;f(z)<.1?(this.highlight=1,this.offsetGC=d):f(M)<.1?(this.highlight=2,this.offsetGC=d):f(_)<.1?(this.highlight=3,this.offsetGC=d):(this.highlight=0,this.offsetGC=void 0),this.highlight!==p&&R([this,"access",n=>n.onHover,"optionalCall",n=>n(this.highlight)])}}}__init6(){this.mousedown=n=>{this.highlight&&(this.dragging=this.highlight,this.onStartDragging())}}__init7(){this.mouseup=n=>{this.dragging&&(this.dragging=0,this.onStopDragging())}}}function A(n,t){return n.anchor.plus(n.dir1.times(t))}function D(n,t){if(function(n,t){return(0,v.eq)(1,Math.abs(n.dir1.dot(t.dir1)))}(n,t))return{t:NaN,s:NaN,distance:n.distanceToLine(t)};const e=t.anchor,o=t.dir1,a=n.anchor,r=n.dir1,i=o.dot(r),l=o.squared(),s=r.squared(),c=e.minus(a),d=i*i-s*l,f=(c.dot(o)*i-c.dot(r)*l)/d,p=(c.dot(o)*s-c.dot(r)*i)/d;return{thT:f,lineT:p,thClosest:A(n,f),lineClosest:A(t,p),distance:A(n,f).distanceTo(A(t,p))}}var P=e(6810),N=e(7044),H=e(5583);function O(n){let t,e=n[0],o=1;for(;o<n.length;){const a=n[o],r=n[o+1];if(o+=2,("optionalAccess"===a||"optionalCall"===a)&&null==e)return;"access"===a||"optionalAccess"===a?(t=e,e=r(e)):"call"!==a&&"optionalCall"!==a||(e=r(((...n)=>e.call(t,...n))),t=void 0)}return e}function L(n){return{sdf:g.ex.create(e(7962).Z,e(7120).Z,n),singleColor:g.ex.create(e(1692).Z,e(2416).Z,n)}}function Z(n){let t,e=n[0],o=1;for(;o<n.length;){const a=n[o],r=n[o+1];if(o+=2,("optionalAccess"===a||"optionalCall"===a)&&null==e)return;"access"===a||"optionalAccess"===a?(t=e,e=r(e)):"call"!==a&&"optionalCall"!==a||(e=r(((...n)=>e.call(t,...n))),t=void 0)}return e}const q={a:.2,b:.2,c:.2,d:.2,cam:"999.999.999~-56.-58.-61~-44.-44.79"};function B(n){n.makeCurrent();const t=g.Kj.plane({startX:-1,startY:-1,width:2,height:2});return t.coords=[[-1,-1],[1,-1],[-1,1],[1,1]],t.compile(),{planeMesh:t,shaders:L(n)}}function V(n,{shaders:t,planeMesh:e},o,a,r,i,l){n.makeCurrent();const s=o.inversed();t.sdf.uniforms({colorPrimary:a.primary,colorSecondary:a.secondary,colorBackground:a.background,highResTimeStamp:i,secs:i/1e3,gradients:1,extra:l,...r,lll:o,llli:s}).draw(e)}function I({children:n,label:t,onFocus:e,onBlur:o}){return h.createElement(s.Z,{onFocus:e,onBlur:o,label:t,inputComponent:"textarea",value:n.toString()})}function W(n){let t=0;function e(n){const t=""+n;return t.includes(".")?t:t+".0"}function o([n,t,o]){return"vec3("+e(n)+", "+e(t)+", "+e(o)+")"}const[a,r,i]=function n(a){let r,i,l;function s(n){r="p"+t++,i="d"+t++,l=`float ${i} = ${n(r)};\n`}for(const c of a)if("sphere"===c.type)s((n=>`sdSphere(${e(c.radius)}, ${n})`));else if("box"===c.type)s((n=>`betterBox(${o(c.radius)}, ${n})`));else if("octahedron"===c.type)s((n=>`sdOctahedron(${e(c.radius)}, ${n})`));else if("donut"===c.type)s((n=>`sdDonut(${e(c.r0)}, ${e(c.r1)}, ${n})`));else if("translate"===c.type){const n=r;r="p"+t++,l=`vec3 ${n} = ${r} + ${o(c.by)};\n`+l}else if("expand"===c.type){const n=i;i="d"+t++,l+=`float ${i} = ${n} - ${e(c.by)};\n`}else if("add"===c.type||"sub"===c.type){const[t,e,o]=n(c.what);l=l+`vec3 ${e} = ${r};\n`+t+`${i} = `+("add"===c.type?`min(${i}, ${o})`:`max(${i}, -${o})`)+";\n"}return[l,r,i]}(n);let l=`RMHit sdf(vec3 ${r}) {\n`;return l+=a,l+=`return RMHit(${i}, black);\n`,l+="}\n",l}function j({value:n,onChange:t}){const e=(0,h.useCallback)((e=>t({...n,radius:+e.target.value},n)),[t]);return h.createElement("div",null,"Sphere"," ",h.createElement(f.Z,{value:n.radius,onChange:e,inputProps:{type:"number"}}))}function G({value:n,onChange:t}){const e=(0,h.useCallback)((e=>t({...n,radius:e},n)),[n,t]);return h.createElement("div",{style:{display:"flex"}},"Box ",h.createElement($,{value:n.radius,onChange:e}))}function F({value:n,onChange:t}){const e=(0,h.useCallback)((e=>t({...n,by:+e.target.value},n)),[n,t]);return h.createElement("div",{style:{display:"flex"}},"Expand"," ",h.createElement(f.Z,{value:n.by,onChange:e,type:"number",inputProps:{}}))}function $({value:n,onChange:t,gizmoControl:e}){const a=(0,h.useCallback)((e=>{const o=n.slice();o[e.target.name]=+e.target.value,t(o,n)}),[n,t]),r=(0,h.useCallback)((()=>e.take(n,t)),[e,t,n]);return h.createElement(h.Fragment,null,h.createElement(o.Z,{onClick:r},"X"),[0,1,2].map((t=>h.createElement(f.Z,{key:t,name:""+t,value:n[t],onChange:a,inputProps:{type:"number"}}))))}function K({value:n,onChange:t,gizmoControl:e}){const o=(0,h.useCallback)((e=>t({...n,by:e},n)),[n,t]);return h.createElement("div",{style:{display:"flex"}},"Translate"," ",h.createElement($,{value:n.by,onChange:o,gizmoControl:e}))}function U({value:n,onChange:t,gizmoControl:e}){const o=(0,h.useCallback)((e=>t({...n,[e.target.name]:+e.target.value},n)),[n,t]);return h.createElement("div",{style:{display:"flex"}},"Donut"," ",["r0","r1"].map((t=>h.createElement(f.Z,{key:t,name:t,value:n[t],onChange:o,inputProps:{type:"number"}}))))}function Q({value:n,onChange:t,gizmoControl:e}){const o=(0,h.useCallback)((e=>t({...n,[e.target.name]:+e.target.value},n)),[n,t]);return h.createElement("div",{style:{display:"flex"}},"Octahedron"," ",["radius"].map((t=>h.createElement(f.Z,{key:t,name:t,value:n[t],onChange:o,inputProps:{type:"number"}}))))}function Y({value:n,onChange:t,gizmoControl:e}){const o=(0,h.useCallback)((e=>t({...n,type:e.target.value},n)),[n,t]),a=(0,h.useCallback)((e=>t({...n,what:e},n)),[n,t]);return h.createElement("div",{style:{display:"flex"}},h.createElement(c.Z,{value:n.type,name:"type",onChange:o},h.createElement(l.Z,{value:"add"},"Add"),h.createElement(l.Z,{value:"sub"},"Sub"))," ",h.createElement(X,{value:n.what,onChange:a,gizmoControl:e}))}function X({value:n,onChange:t,gizmoControl:e}){const o=(0,h.useCallback)(((e,o)=>t(n.map((n=>n===o?e:n)))),[t,n]);return h.createElement("div",null,n.map(((n,t)=>{const a={sphere:j,expand:F,add:Y,sub:Y,box:G,donut:U,translate:K,octahedron:Q}[n.type];return a&&h.createElement(a,{key:t,value:n,onChange:o,gizmoControl:e})})))}const J=()=>{const n=(0,h.useRef)(null),[t,s]=(0,h.useState)(void 0),[f,R]=(0,h.useState)(v.M4.IDENTITY),[w,S]=(0,h.useState)(512),[E,T]=(0,h.useState)(!1),[z,M]=(0,b.q)(q),_=(0,h.useCallback)((n=>M((t=>({...t,...n})))),[M]),[A,D]=(0,h.useState)(0),[L,j]=(0,h.useState)(0),G=(0,h.useRef)(Object.assign({},z)),F=(0,h.useRef)(),[$,K]=(0,h.useState)([{type:"sphere",radius:1},{type:"translate",by:[1,2,3]},{type:"add",what:[{type:"box",radius:[1,2,3]},{type:"translate",by:[.1,.1,.1]},{type:"expand",by:.3}]},{type:"add",what:[{type:"octahedron",radius:2},{type:"translate",by:[.1,.1,.1]}]},{type:"add",what:[{type:"donut",r0:2,r1:.2},{type:"translate",by:[.1,.1,.1]}]}]),U=(0,d.Z)(),Q=(0,h.useMemo)((()=>({background:m.iv(U.palette.background.default).gl(),primary:m.iv(U.palette.primary.main).gl(),secondary:m.iv(U.palette.secondary.main).gl()})),[U.palette]),Y=(0,h.useCallback)((async([n,t])=>{const e=URL.createObjectURL(await async function([n,t],e,o,a){O([a,"optionalCall",n=>n(0)]),await(0,H.Z)(10);const r=document.createElement("canvas");r.width=n,r.height=t;const i=200,l=g.ZG.create({canvas:r});l.enable(l.SCISSOR_TEST);const s=e(l);let c=0;for(let e=0;e<n;e+=i)for(let r=0;r<t;r+=i){const d=Math.min(i,n-e),f=Math.min(i,t-r);l.scissor(e,r,d,f),o(l,s),await(0,H.Z)(0),c+=d*f,O([a,"optionalCall",e=>e(c/(n*t))])}return new Promise(((n,t)=>r.toBlob((e=>e?n(e):t("error")),"png")))}([n,t],B,((e,o)=>{V(e,o,v.M4.product(v.M4.perspective(70,n/t,.1,50),N.j.getLookAt(N.j.fromShortString(z.cam))),Q,z,2e3,f.getTranslation())}),s));s(void 0),(0,C.YQ)(e)}),[f,Q,z]);(0,h.useEffect)((()=>{console.log("creating context");const t=g.ZG.create({canvas:n.current,alpha:!0,premultipliedAlpha:!0,throwOnError:!0});return console.log(t.getParameter(t.MAX_SAMPLES)),F.current=function(n,t,o,a,r,i,l,s,c){n.canvas.addEventListener("keydown",(n=>"r"===n.key&&Y([1920,1080])));const d=new N.j(i);let f=v.M4.IDENTITY;const p=new k(n,v.M4.rotateZ(20*v.Co).translate(5,5,1),l,(()=>d.pauseCam=!0),(()=>d.pauseCam=!1),s);p.registerListeners(n.canvas,(()=>f)),n.clearColor(...t.background),n.clearColor(0,0,0,1),n.clear(n.COLOR_BUFFER_BIT),n.cullFace(n.BACK),n.pointSize(10),n.disable(n.CULL_FACE),n.disable(n.DEPTH_TEST),n.disable(n.BLEND),n.blendFunc(n.ONE,n.ONE),n.blendEquation(n.FUNC_ADD),n.canvas.contentEditable="true",n.canvas.focus(),d.registerListeners(n.canvas);const m=new x.q(a),u=B(n);return{updateShader(n){u.shaders.ed=g.ex.create(e(7962).Z,n)},teardown:n.animate((function(e,a){n.clear(n.COLOR_BUFFER_BIT),n.makeCurrent(),d.tick(),m.tick(e),f=v.M4.product(v.M4.perspective(70,n.canvas.offsetWidth/n.canvas.offsetHeight,.1,50),d.getLookAt()),V(n,u,f,t,o,e,p.pos.getTranslation()),n.matrixMode(n.PROJECTION),n.loadMatrix(f),n.matrixMode(n.MODELVIEW),n.loadIdentity(),p.render(u.shaders.singleColor)})),setCam:d.setState}}(t,Q,G.current,j,0,(0,u.debounce)((n=>{_({cam:N.j.toShortString(n)})})),D,R),()=>{Z([F,"access",n=>n.current,"optionalAccess",n=>n.teardown,"call",n=>n()])}}),[]),(0,h.useEffect)((()=>{}),[z.cam]),(0,h.useEffect)((()=>{Z([F,"access",n=>n.current,"optionalAccess",n=>n.updateShader,"call",n=>n("#version 300 es\n\nprecision highp float;\n// START ../common/banded.glsl\nfloat banded(float bandCount, float t) {\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\n}\nfloat banded(int bandCount, float t) {\n  return banded(float(bandCount), t);\n}\n\n// #pragma glslify: export(banded)\n\n\n// END ../common/banded.glsl\n// START ../common/between.glsl\nbool between(float min, float max, float value) {\n  return min <= value && value <= max;\n}\n\n// #pragma glslify: export(between)\n\n\n// END ../common/between.glsl\n// START ../common/hexFns.glsl\n// START ./max3.glsl\nfloat max3(float a, float b, float c) {\n  return max(a, max(b, c));\n}\nfloat max3(vec3 v) {\n  return max(v.x, max(v.y, v.z));\n}\n\n// #pragma glslify: export(max3)\n\n\n// END ./max3.glsl\n// START ./constants.glsl\nconst float SQRT1_2 = 0.7071067811865476;\nconst float SQRT1_3 = 0.57735026919;\nconst float SQRT2 = 1.4142135623730951;\nconst float SQRT3 = 1.732050807568877;\n// sqrt(3)/2 = sin(60*)\nconst float SQRT3_2 = 0.86602540378;\nconst float GOLDEN_RATIO = 1.61803398875;\nconst float PI = 3.141592653589793;\nconst float TAU = 6.28318530718;\n/**\n * One degree in radians. Use like `sin(30 * DEG)`.\n */\nconst float DEGREE = 0.017453292519943295;\n\n// END ./constants.glsl\n\nvec3 hexRound(vec3 hex) {\n  vec3 r = floor(hex + 0.5);\n  vec3 diff = abs(r - hex);\n\n  if (diff.x > diff.y && diff.x > diff.z) {\n    r.x = -(r.y + r.z);\n  } else if (diff.y > diff.z) {\n    r.y = -(r.x + r.z);\n  } else {\n    r.z = -(r.x + r.y);\n  }\n\n  return r;\n}\nvec2 hex2Ra(vec3 hex) {\n  float y = hex.t * SQRT3_2;\n  float x = hex.s + hex.t / 2.0;\n  return vec2(x, y);\n}\n\nfloat hexSdf(vec3 hex) {\n  return max3(abs(hex.yzx + hex.zxy / 2.0));\n}\nvec3 ra2Hex(vec2 xy) {\n  float hex_t = xy.y / SQRT3_2;\n  float hex_s = xy.x - hex_t / 2.0;\n  return vec3(hex_s, hex_t, -(hex_s + hex_t));\n}\n\n// END ../common/hexFns.glsl\n// START ../common/matrices.glsl\n\n\nmat2 rot2(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat2(c, -s, s, c);\n}\nmat3 rotX(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\n}\nmat3 rotY(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\n}\nmat3 rotZ(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\n}\n/**\n * Returns a matrix that puts the camera at the eye point `ex, ey, ez` looking\n * toward the center point `cx, cy, cz` with an up direction of `ux, uy, uz`.\n * This emulates the OpenGL function `gluLookAt()`.\n */\nmat4 lookAt(vec3 eye, vec3 focus, vec3 up) {\n  vec3 f = normalize(eye - focus);\n  vec3 s = normalize(cross(up, f));\n  vec3 t = normalize(cross(f, s));\n\n  return mat4(\n    vec4(s.x, t.x, f.x, 0.0),\n    vec4(s.y, t.y, f.y, 0.0),\n    vec4(s.z, t.z, f.z, 0.0),\n    vec4(-dot(s, eye), -dot(t, eye), -dot(f, eye), 1)\n  );\n}\n\n// the OpenGL function `glFrustum()`.\nmat4 frustum(\n  float left,\n  float right,\n  float bottom,\n  float top,\n  float near,\n  float far\n) {\n  return mat4(\n    vec4(2.0 * near / (right - left), 0.0, 0.0, 0.0),\n    vec4(0, 2.0 * near / (top - bottom), 0.0, 0.0),\n    vec4(\n      (right + left) / (right - left),\n      (top + bottom) / (top - bottom),\n      -(far + near) / (far - near),\n      -1\n    ),\n    vec4(0.0, 0.0, -2.0 * far * near / (far - near), 0.0)\n  );\n}\n\nmat4 perspective(float fovDegrees, float aspect, float near, float far) {\n  float y = tan(fovDegrees * DEGREE / 2.0) * near;\n  float x = y * aspect;\n  return frustum(-x, x, -y, y, near, far);\n}\n\n// END ../common/matrices.glsl\n\n// START ../common/perlin2DTexture.glsl\nuniform sampler2D gradients;\n/* Create random direction vector\n */\nvec2 randomGradient(vec2 i) {\n  // Random float. No precomputed gradients mean this works for any number of grid coordinates\n  float random =\n    2920.0 *\n    sin(float(i.x) * 2.1942 + float(i.y) * 1.71324 + 8.912) *\n    cos(float(i.x) * 2.3157 * float(i.y) * 2.17832 + 9.758);\n  //    random = (i.x + 1667.) * (i.x + 2083.) * (i.y + 2659.) * (i.y * 50.77 + .3769);\n  //    random = sin(SQRT2 * i.x) + cos(GOLDEN_RATIO * i.y) + tan((i.x + i.y) * SQRT3);\n  return vec2(cos(random), sin(random));\n}\nfloat dotGridGradient(vec2 cell, vec2 pos) {\n  vec2 d = cell - pos;\n\n  //  vec2 gradient = texelFetch(gradients, ivec2(cell), 0).xy;\n  vec2 gradient = randomGradient(vec2(cell));\n\n  return dot(gradient, d);\n}\n\nfloat mixx(float a, float b, float t) {\n  return mix(a, b, smoothstep(0.0, 1.0, t));\n  //    return mix(a, b, t);\n}\n\n// resulting range is [-0.68, 0.68]. Use unmix to normalize if necessary.\nfloat perlin2D(vec2 xy) {\n  float x0 = floor(xy.x);\n  float x1 = x0 + 1.0;\n  float y0 = floor(xy.y);\n  float y1 = y0 + 1.0;\n\n  // Interpolate between grid point gradients\n  float n00 = dotGridGradient(vec2(x0, y0), xy);\n  float n10 = dotGridGradient(vec2(x1, y0), xy);\n  float ny0 = mixx(n00, n10, xy.x - x0);\n\n  float n01 = dotGridGradient(vec2(x0, y1), xy);\n  float n11 = dotGridGradient(vec2(x1, y1), xy);\n  float ny1 = mixx(n01, n11, xy.x - x0);\n\n  return mixx(ny0, ny1, xy.y - y0);\n}\n\n// #pragma glslify: export(perlin2D)\n\n\n// END ../common/perlin2DTexture.glsl\n// START ../common/polar.glsl\n// START ../common/fromPolar.glsl\n// START ./unmix.glsl\nfloat unmix(float a, float b, float value) {\n  return (value - a) / (b - a);\n}\n\n// #pragma glslify: export(unmix)\n\n\n// END ./unmix.glsl\n\nvec3 fromPolar(float radius, float phi, float z) {\n  return vec3(radius * cos(phi), radius * sin(phi), z);\n}\n\nvec2 fromPolar(float radius, float phi) {\n  return vec2(radius * cos(phi), radius * sin(phi));\n}\n\nvec2 fromPolar(vec2 polar) {\n  return fromPolar(polar.x, polar.y);\n}\n\n// #pragma glslify: export(fromPolar)\n\n\n// END ../common/fromPolar.glsl\n// START ../common/toPolar.glsl\n\n\nvec2 toPolar(vec2 xy) {\n  return vec2(length(xy), atan(xy.y, xy.x));\n}\n\nmat2 toPolarDerivate(vec2 xy) {\n  return mat2(xy.x * xy.x, xy.y * xy.y, -xy.y, xy.x) / dot(xy, xy);\n}\n\n// #pragma glslify: export(toPolar)\n\n\n// END ../common/toPolar.glsl\n\n// END ../common/polar.glsl\n// START ../common/remix.glsl\n\n\nfloat remix(float fromA, float fromB, float toA, float toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\nvec4 remix(float fromA, float fromB, vec4 toA, vec4 toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\n// #pragma glslify: export(remix)\n\n\n// END ../common/remix.glsl\n// START ../common/transform.glsl\nvec3 transform(mat4 pm, vec3 p) {\n  vec4 pStar = pm * vec4(p, 1);\n  return pStar.xyz / pStar.w;\n}\n\nvec2 transform(mat4 pm, vec2 p) {\n  vec4 pStar = pm * vec4(p, 0, 1);\n  return pStar.xy / pStar.w;\n}\n\n// END ../common/transform.glsl\n\n// START ../common/visualize.glsl\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\n  float isLow = float(t < 0.0);\n  float isHigh = float(t > 1.0);\n  float isMid = 1.0 - isLow - isHigh;\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\n}\n\nvec4 visualize(float t) {\n  const vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\n  const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\n  return visualize(BLUE, RED, t);\n}\n\n// #pragma glslify: export(visualize)\n\n\n// END ../common/visualize.glsl\n// START ../common/waves.glsl\nfloat waves(vec4 color, vec2 position, vec2 direction, float highResTimeStamp) {\n  return sin(\n    dot(position, direction / pow(length(direction), 2.0)) +\n      float(highResTimeStamp) / 200.0\n  );\n}\n\n// #pragma glslify: export(waves)\n\n\n// END ../common/waves.glsl\n// START ../common/sdf3d/sdDonut.glsl\nfloat sdDonut(float r0, float r1, vec3 p) {\n  vec3 closestCenter = vec3(normalize(p.xy) * r0, 0.0);\n  return distance(closestCenter, p) - r1;\n}\n\n// #pragma glslify: export(sdDonut)\n\n\n// END ../common/sdf3d/sdDonut.glsl\n// START ../common/sdf3d/sdCapsule.glsl\nfloat sdCapsule(vec3 a, vec3 b, float r, vec3 p) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h) - r;\n}\n// #pragma glslify: export(sdCapsule)\n\n// END ../common/sdf3d/sdCapsule.glsl\n// START ../common/sdf3d/opElongate.glsl\nvec3 opElongate(vec3 h, vec3 p) {\n  return p - clamp(p, -h, h);\n}\n// #pragma glslify: export(opElongate)\n\n// END ../common/sdf3d/opElongate.glsl\n// START ../common/sdf3d/sdSphere.glsl\nfloat sdSphere(float radius, vec3 p) {\n  return length(p) - radius;\n}\n\n// #pragma glslify: export(sdSphere)\n\n\n// END ../common/sdf3d/sdSphere.glsl\n// START ../common/sdf3d/sdCylinder.glsl\nfloat sdCylinder(float radius, float z, vec3 p) {\n  vec2 d = vec2(length(p.xy), abs(p.z)) - vec2(radius, z);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// #pragma glslify: export(sdCylinder)\n\n\n// END ../common/sdf3d/sdCylinder.glsl\n// START ../common/sdf3d/sdCone.glsl\n\n\n/**\n * Signed distance function (SDF) of a cone. The tip of the cone is at the\n * origin and points towards +Z. q is a point on the rim of the cone.\n */\nfloat sdCone(vec2 c, float h, vec3 p) {\n  vec2 q = h * vec2(c.x / c.y, -1.0);\n  vec2 w = vec2(length(p.xz), p.y);\n  vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);\n  vec2 b = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0);\n  float k = sign(q.y);\n  float d = min(dot(a, a), dot(b, b));\n  float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));\n  return sqrt(d) * sign(s);\n}\n// #pragma glslify: export(sdBox)\n\nfloat sdConeB(vec2 c, float h, vec3 p) {\n  float q = length(p.xz);\n  return max(dot(c.xy, vec2(q, p.y)), -h - p.y);\n}\n\n// END ../common/sdf3d/sdCone.glsl\n// START ../common/sdf3d/addChamfer.glsl\n\n\nfloat addChamfer(float d, float a, float b) {\n  float tillet = (a + b - d) * SQRT1_2;\n  return min(tillet, min(a, b));\n}\n\n// #pragma glslify: export(addChamfer)\n\n\n// END ../common/sdf3d/addChamfer.glsl\n\n// START ../common/sdf3d/addTillet.glsl\nfloat addTillet(float r, float a, float b) {\n  if (a < r && b < r) {\n    return r - distance(vec2(a, b), vec2(r));\n  } else {\n    return min(a, b);\n  }\n}\n\n// #pragma glslify: export(addTillet)\n\n\n// END ../common/sdf3d/addTillet.glsl\n// START ../common/sdf3d/sdBox.glsl\n\n\nfloat sdBox(vec3 r, vec3 p) {\n  vec3 q = abs(p) - r;\n  return length(max(q, 0.0)) + min(max3(q), 0.0);\n}\n\nfloat sdBox(vec3 r, float r2, vec3 p) {\n  return sdBox(r - r2, p) - r2;\n}\n\n// #pragma glslify: export(sdBox)\n\n\n// END ../common/sdf3d/sdBox.glsl\n// START ../common/sdf3d/sdOctahedron.glsl\nfloat sdOctahedron(float s, vec3 p) {\n  p = abs(p);\n  float m = p.x + p.y + p.z - s;\n  vec3 q;\n  if (3.0 * p.x < m) q = p.xyz;\n  else if (3.0 * p.y < m) q = p.yzx;\n  else if (3.0 * p.z < m) q = p.zxy;\n  else return m * 0.57735027;\n\n  float k = clamp(0.5 * (q.z - q.y + s), 0.0, s);\n  return length(vec3(q.x, q.y - s + k, q.z - k));\n}\n// #pragma glslify: export(sdOctahedron)\n\nfloat sdOctahedron(vec3 p, float s) {\n  p = abs(p);\n\n  float m = p.x + p.y + p.z - s;\n  //find point on octohedron surf nearest to p\n  vec3 projPoint = p - vec3(0.333333 * m); //project onto surface plane\n  //now push projected point, if outside triangle edge, perpendicular to edge, to edge\n  vec3 toMove = min(projPoint, 0.0); //if projpoint.x<0 move along (1.0,-0.5,-0.5) , etc\n  float toMoveSum = dot(toMove, vec3(1.0)); //which is basically along (1.5,0,0) then vec3(-0.5)\n\n  vec3 movedPoint = projPoint + toMove * vec3(-1.5) + toMoveSum * vec3(0.5); //better to multiply toMove by a matrix (1s diagonal, 0.5 other)?\n\n  movedPoint = max(movedPoint, 0.0); //cap x,y,z to 0 then\n  movedPoint *= s / dot(movedPoint, vec3(1.0)); //scale about 0,0,0\n\n  return length(p - movedPoint);\n}\n\n// END ../common/sdf3d/sdOctahedron.glsl\n// START ../common/sdf3d/add.glsl\nfloat add(float a, float b) {\n  return min(a, b);\n}\n\n// #pragma glslify: export(add)\n\n\n// END ../common/sdf3d/add.glsl\n// START ../common/sdf3d/sub.glsl\nfloat sub(float from, float what) {\n  return max(from, -what);\n}\n\n// #pragma glslify: export(sub)\n\n\n// END ../common/sdf3d/sub.glsl\n\nuniform sampler2D texture;\nuniform float secs;\nuniform mat4 lll;\nuniform mat4 llli;\nuniform vec4 colorPrimary;\nuniform vec4 colorSecondary;\nuniform vec4 colorBackground;\nuniform float a;\nuniform float b;\nuniform float c;\nuniform float d;\nuniform float highResTimeStamp;\nuniform int bandCount;\nuniform vec3 extra;\nuniform vec3 campos;\nin float n;\nin vec2 coord;\nout vec4 fragColor;\n\n\nconst vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\nconst vec4 yellow = vec4(1.0, 1.0, 0.0, 1.0);\nconst vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\nconst vec4 blue = vec4(0.0, 0.0, 1.0, 1.0);\nconst vec4 purple = vec4(0.5, 0.0, 0.5, 1.0);\nconst vec4 red = vec4(1.0, 0.0, 0.0, 1.0);\n\nstruct RMHit {\n  float distance;\n  vec4 color;\n};\nRMHit mixa(RMHit a, RMHit b, float t) {\n  return RMHit(mix(a.distance, b.distance, t), mix(a.color, b.color, t));\n}\nfloat skybox(vec3 p) {\n  return 32.0 - max3(abs(p));\n}\n\nfloat perlinSphere(float radius, vec3 p) {\n  vec3 cp = normalize(p);\n  float alpha = atan(cp.y, cp.x);\n  float beta = asin(cp.z);\n  return length(p) -\n  radius +\n  0.1 *\n    perlin2D(vec2(0.0 / 100.0, 0.0) + (vec2(5.0) + vec2(alpha, beta)) * 8.0);\n}\n\nfloat cylCircle(vec3 p) {\n  float d = 10e9;\n  for (int i = 0; i < 10; i++) {\n    d = min(\n      d,\n      sdCylinder(0.2, 2.0, p + fromPolar(3.0, TAU * float(i) / 10.0, 1.0))\n    );\n  }\n\n  return d;\n}\n\nfloat rblock(float r, out vec3 p) {\n  return sdBox(vec3(r), p);\n}\n\nRMHit add(RMHit a, RMHit b) {\n  //    return a.distance < b.distance\n  //        ? RMHit(a.distance, a.color)\n  //        : RMHit(b.distance, b.color);\n  return mixa(a, b, float(b.distance < a.distance));\n}\n\nfloat wtf(vec3 p) {\n  vec3 center = p - mod(p, 3.0) + vec3(1.5);\n  return rblock(0.4 + 0.3 * sin(secs + center.x), center);\n}\n\nRMHit addTillet(float r, RMHit a, RMHit b) {\n  if (a.distance < r && b.distance < r) {\n    return RMHit(\n      r - distance(vec2(a.distance, b.distance), vec2(r)),\n      mix(a.color, b.color, (a.distance - b.distance) / r * 0.5 + 0.5)\n    );\n  } else {\n    return add(a, b);\n  }\n}\n\nRMHit addTillet(float r, RMHit a, RMHit b, vec4 tilletColor) {\n  if (a.distance < r && b.distance < r) {\n    return RMHit(\n      r - distance(vec2(a.distance, b.distance), vec2(r)),\n      tilletColor\n    );\n  } else {\n    return add(a, b);\n  }\n}\nRMHit addTillet2(float r, RMHit a, RMHit b) {\n  float h = smoothstep(-r, r, a.distance - b.distance);\n  return RMHit(\n    mix(a.distance, b.distance, h) - r * h * (1.0 - h),\n    mix(a.color, b.color, h)\n  );\n}\n\nRMHit neg(RMHit a) {\n  return RMHit(-a.distance, a.color);\n}\nRMHit sub(RMHit from, RMHit what) {\n  RMHit whatNeg = neg(what);\n  return mixa(from, whatNeg, float(whatNeg.distance > from.distance));\n}\n\nvec3 modv(vec3 v, vec3 dir1, float y) {\n  float t = dot(v, dir1);\n  return v - floor(t / y) * y * dir1;\n}\nvec3 modRotZ(vec3 p, float count) {\n  vec2 polarXY = toPolar(p.xy);\n  return fromPolar(polarXY.x, mod(polarXY.y, TAU / count), p.z);\n}\n\nfloat sin01(float x) {\n  return 0.5 + 0.5 * sin(x);\n}\nfloat cos01(float x) {\n  return 0.5 + 0.5 * cos(x);\n}\n\nfloat betterBox(vec3 r, vec3 p) {\n  vec3 q = abs(p) - r;\n  return length(max(q, 0.0)) + min(max3(q), 0.0);\n  p = abs(p);\n  return max3(p - r);\n}\n\nfloat sdEllipsoidB(vec3 r, vec3 p) {\n  float k0 = length(p / r);\n  float k1 = length(p / (r * r));\n  return k0 * (k0 - 1.0) / k1;\n}\nfloat sdOctahedronB(float s, vec3 p) {\n  p = abs(p);\n  return (p.x + p.y + p.z - s) * 0.57735027;\n}\nfloat donutc(float r0, float r1, vec3 p) {\n  vec3 closestCenter = vec3(normalize(p.xy) * r0, 0.0);\n  return distance(closestCenter, p) - r1;\n}\n\nfloat smoothmin(float r, float a, float b) {\n  float h = smoothstep(-r, r, a - b);\n  return mix(a, b, h) - r * h * (1.0 - h);\n}\n\nRMHit sdf(vec3 p) {\n  return RMHit(0.0, black);\n}\n\nfloat sdff(vec3 p) {\n  return sdf(p).distance;\n}\n\nstruct RMResult {\n  float distance;\n  vec3 pos;\n  vec4 color;\n};\nRMResult raymarching2(vec3 start, vec3 dir1) {\n  vec3 pos = start;\n  RMHit hit;\n  for (int i = 0; i < 200; i++) {\n    hit = sdf(pos);\n    if (hit.distance < 0.0001) break;\n    pos = pos + dir1 * hit.distance;\n  }\n  return RMResult(hit.distance, pos, hit.color);\n}\n\nfloat softshadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {\n  float res = 1.0;\n  float t = 0.1;\n  for (int i = 0; i < 1000 && t < maxt; i++) {\n    float h = sdff(ro + rd * t);\n    if (h < 0.001) return 0.0;\n    res = min(res, k * h / t);\n    t += h;\n  }\n  return res;\n}\n\nconst float eps = 1e-4;\nvec3 sdfNormal1(vec3 p, float d) {\n  return normalize(\n    vec3(\n      sdff(p + vec3(eps, 0.0, 0.0)),\n      sdff(p + vec3(0.0, eps, 0.0)),\n      sdff(p + vec3(0.0, 0.0, eps))\n    ) -\n      sdff(p)\n  );\n}\n\nfloat ambientOcclusion(vec3 pWC, vec3 n1WC) {\n  float k = 1.0;\n  float distance = sdff(pWC + n1WC * k);\n  return clamp(distance / k, 0.0, 1.0);\n}\n\n//layout (depth_greater) out float gl_FragDepth;\nvoid main() {\n  vec3 light = normalize(vec3(-1.0, -2.0, -2));\n\n  vec3 a = vec3(coord, -1.0);\n  vec3 b = vec3(coord, 1.0);\n  vec3 aWC = transform(llli, a);\n  vec3 bWC = transform(llli, b);\n  vec3 lookDir1 = normalize(bWC - aWC);\n\n  RMResult hitWC = raymarching2(aWC, lookDir1);\n  vec3 hitn1 = sdfNormal1(hitWC.pos, hitWC.distance);\n  float dWC = distance(aWC, hitWC.pos);\n  vec3 hitNDC = transform(lll, hitWC.pos);\n\n  vec3 sunPoint = raymarching2(hitWC.pos + hitn1 * 0.1, -light).pos;\n  //    float inSun = float(distance(hitWC.pos, sunPoint) > 30.);\n  float inSun = softshadow(\n    hitWC.pos + hitn1 * 0.05,\n    -light,\n    0.0001,\n    300.0,\n    8.0\n  );\n  //    float inSun=1.;\n\n  vec3 material = vec3(0.0, 0.2, 0.0);\n  if (dWC > 100.0) {\n    material = vec3(0.0, 0.0, 0.0);\n  }\n\n  const vec3 sunlightColor = vec3(8.0, 6.0, 1.0);\n\n  float aOcc = ambientOcclusion(hitWC.pos, hitn1);\n\n  vec3 reflectionDirection = reflect(light, hitn1);\n\n  vec3 color = vec3(0.0);\n  color += material * aOcc;\n  color += inSun * sunlightColor * material * max(0.0, dot(-light, hitn1));\n  //    color = (hitn1);\n\n  vec3 camPos = aWC;\n\n  vec3 eyeDirection = -lookDir1;\n  float uMaterialShininess = 256.0;\n  float specularLightWeighting = pow(\n    max(dot(reflectionDirection, eyeDirection), 0.0),\n    uMaterialShininess\n  );\n  color += specularLightWeighting;\n  //    float lightIntensity = 0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.);\n  //    float lightIntensity =\n  //        0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.) + 0.3*specularLightWeighting;\n  //    fragColor = visualize(blue, red, mix(0.5, 1.0, inSun) * lightIntensity);\n  //    fragColor = mix(hitWC.color, colorBackground, mix(0.5, 1.0, inSun) * clamp(lightIntensity, 0., 1.));\n  color = pow(color, vec3(1.0 / 2.2)); // gamma correction\n  fragColor = vec4(color, 1.0);\n  //    fragColor = visualize(hitWC.pos.x/10.);\n  //    fragColor = hitWC.color;\n  //    fragColor = visualize(blue, red, distance(hitWC, sunPoint)/20.);\n  //    fragColor = vec4(coord,0.,1.);\n  //    fragColor = vec4(aWC, 1.0);\n  // remap [-1, 1] to [0, 1]\n  // gl_FragDepth = hitNDC.z * 0.5 + 0.5;\n  //    gl_FragDepth = .9999999;\n}\n".replace(/RMHit sdf\(vec3 p\) {[\s\S]*?}/,W($)))])}),[$]),(0,h.useEffect)((()=>{Object.assign(G.current,z)}),[z]);const J=(0,h.useCallback)((({dim:n,children:e})=>{return h.createElement(o.Z,{variant:"contained",onClick:()=>Y(n),disabled:void 0!==t},void 0===t?e:"Rendering... "+(a=""+Math.floor(100*t),p.Z.format(a,"monospace")).padStart(3," ")+"%");var a}),[Y,t]);function nn({cam:n}){const t=P.k.fromShortString(n);_({cam:N.j.toShortString(t)})}return h.createElement(i.ZP,{container:!0,style:{height:"99%"}},h.createElement(i.ZP,{item:!0,xs:12,md:9},h.createElement("div",{style:{height:"100%"}},h.createElement("canvas",{ref:n,style:{width:"100%",height:"100%",cursor:0===A?"move":"grab"},width:w,height:w,tabIndex:0}))),h.createElement(i.ZP,{item:!0,xs:12,md:3,sx:{display:"flex",flexDirection:"column",width:"100%",padding:2,alignItems:"stretch",gap:2}},h.createElement(a.Z,null,h.createElement(r.Z,null,"Raymarching demo.")),h.createElement(c.Z,{onChange:n=>S(+n.target.value),value:w},h.createElement(l.Z,{value:256},"256x256"),h.createElement(l.Z,{value:512},"512x512")),h.createElement(y.V,{state:z,setStatePartial:_,prop:"a",inputProps:{step:.05}})," ",h.createElement(y.V,{state:z,setStatePartial:_,prop:"b",inputProps:{step:.05}}),h.createElement(y.V,{state:z,setStatePartial:_,prop:"c",inputProps:{step:.05}})," ",h.createElement(y.V,{state:z,setStatePartial:_,prop:"d",inputProps:{step:.05}}),h.createElement(J,{dim:[1920,1080]},"render hd"),h.createElement(J,{dim:[3840,2160]},"render 4k"),h.createElement(o.Z,{color:"secondary",variant:"outlined",onClick:()=>nn({cam:"999.999.999~-56.-58.-61~-44.-44.79"})},"Cam 0"),h.createElement(o.Z,{color:"secondary",variant:"outlined",onClick:()=>nn({cam:"57.427.96~1.-100.-8~7.-7.99"})},"Cam 1"),h.createElement(o.Z,{color:"secondary",variant:"outlined",onClick:()=>nn({cam:"53.80.892~-9.-8.-100~-18.-99.8"})},"Cam 2"),h.createElement("div",null,"cam: ",z.cam),h.createElement("div",null,"fps: ",L),h.createElement(I,{label:"gp",onFocus:()=>setEditing(!0),onBlur:()=>setEditing(!1)},f),h.createElement("div",null,h.createElement(X,{value:$,onChange:K})),h.createElement("div",null,h.createElement("pre",null,h.createElement("code",null,W($))))))}},5069:(n,t,e)=>{e.d(t,{Z:()=>g});var o=e(7692),a=e(1972),r=e(9526),i=e(3060),l=e(3957),s=e(949),c=e(7260),d=e(7290),f=e(7402),p=e(5111);function m(n){return(0,p.Z)("MuiCard",n)}(0,f.Z)("MuiCard",["root"]);var u=e(7557);const h=["className","raised"],v=(0,s.ZP)(d.Z,{name:"MuiCard",slot:"Root",overridesResolver:(n,t)=>t.root})((()=>({overflow:"hidden"}))),g=r.forwardRef((function(n,t){const e=(0,c.Z)({props:n,name:"MuiCard"}),{className:r,raised:s=!1}=e,d=(0,a.Z)(e,h),f=(0,o.Z)({},e,{raised:s}),p=(n=>{const{classes:t}=n;return(0,l.Z)({root:["root"]},m,t)})(f);return(0,u.jsx)(v,(0,o.Z)({className:(0,i.Z)(p.root,r),elevation:s?8:void 0,ref:t,ownerState:f},d))}))},4854:(n,t,e)=>{e.d(t,{Z:()=>v});var o=e(7692),a=e(1972),r=e(9526),i=e(3060),l=e(3957),s=e(949),c=e(7260),d=e(7402),f=e(5111);function p(n){return(0,f.Z)("MuiCardContent",n)}(0,d.Z)("MuiCardContent",["root"]);var m=e(7557);const u=["className","component"],h=(0,s.ZP)("div",{name:"MuiCardContent",slot:"Root",overridesResolver:(n,t)=>t.root})((()=>({padding:16,"&:last-child":{paddingBottom:24}}))),v=r.forwardRef((function(n,t){const e=(0,c.Z)({props:n,name:"MuiCardContent"}),{className:r,component:s="div"}=e,d=(0,a.Z)(e,u),f=(0,o.Z)({},e,{component:s}),v=(n=>{const{classes:t}=n;return(0,l.Z)({root:["root"]},p,t)})(f);return(0,m.jsx)(h,(0,o.Z)({as:s,className:(0,i.Z)(v.root,r),ownerState:f,ref:t},d))}))},7962:(n,t,e)=>{e.d(t,{Z:()=>o});const o="#version 300 es\nprecision highp float;\n\nin vec4 ts_Vertex;\nin vec2 ts_TexCoord;\nout vec2 coord;\nvoid main() {\n  gl_Position = ts_Vertex;\n  coord = ts_TexCoord;\n}\n"},7120:(n,t,e)=>{e.d(t,{Z:()=>o});const o="#version 300 es\n\nprecision highp float;\n// START ../common/banded.glsl\nfloat banded(float bandCount, float t) {\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\n}\nfloat banded(int bandCount, float t) {\n  return banded(float(bandCount), t);\n}\n\n// #pragma glslify: export(banded)\n\n\n// END ../common/banded.glsl\n// START ../common/between.glsl\nbool between(float min, float max, float value) {\n  return min <= value && value <= max;\n}\n\n// #pragma glslify: export(between)\n\n\n// END ../common/between.glsl\n// START ../common/hexFns.glsl\n// START ./max3.glsl\nfloat max3(float a, float b, float c) {\n  return max(a, max(b, c));\n}\nfloat max3(vec3 v) {\n  return max(v.x, max(v.y, v.z));\n}\n\n// #pragma glslify: export(max3)\n\n\n// END ./max3.glsl\n// START ./constants.glsl\nconst float SQRT1_2 = 0.7071067811865476;\nconst float SQRT1_3 = 0.57735026919;\nconst float SQRT2 = 1.4142135623730951;\nconst float SQRT3 = 1.732050807568877;\n// sqrt(3)/2 = sin(60*)\nconst float SQRT3_2 = 0.86602540378;\nconst float GOLDEN_RATIO = 1.61803398875;\nconst float PI = 3.141592653589793;\nconst float TAU = 6.28318530718;\n/**\n * One degree in radians. Use like `sin(30 * DEG)`.\n */\nconst float DEGREE = 0.017453292519943295;\n\n// END ./constants.glsl\n\nvec3 hexRound(vec3 hex) {\n  vec3 r = floor(hex + 0.5);\n  vec3 diff = abs(r - hex);\n\n  if (diff.x > diff.y && diff.x > diff.z) {\n    r.x = -(r.y + r.z);\n  } else if (diff.y > diff.z) {\n    r.y = -(r.x + r.z);\n  } else {\n    r.z = -(r.x + r.y);\n  }\n\n  return r;\n}\nvec2 hex2Ra(vec3 hex) {\n  float y = hex.t * SQRT3_2;\n  float x = hex.s + hex.t / 2.0;\n  return vec2(x, y);\n}\n\nfloat hexSdf(vec3 hex) {\n  return max3(abs(hex.yzx + hex.zxy / 2.0));\n}\nvec3 ra2Hex(vec2 xy) {\n  float hex_t = xy.y / SQRT3_2;\n  float hex_s = xy.x - hex_t / 2.0;\n  return vec3(hex_s, hex_t, -(hex_s + hex_t));\n}\n\n// END ../common/hexFns.glsl\n// START ../common/matrices.glsl\n\n\nmat2 rot2(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat2(c, -s, s, c);\n}\nmat3 rotX(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\n}\nmat3 rotY(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\n}\nmat3 rotZ(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\n}\n/**\n * Returns a matrix that puts the camera at the eye point `ex, ey, ez` looking\n * toward the center point `cx, cy, cz` with an up direction of `ux, uy, uz`.\n * This emulates the OpenGL function `gluLookAt()`.\n */\nmat4 lookAt(vec3 eye, vec3 focus, vec3 up) {\n  vec3 f = normalize(eye - focus);\n  vec3 s = normalize(cross(up, f));\n  vec3 t = normalize(cross(f, s));\n\n  return mat4(\n    vec4(s.x, t.x, f.x, 0.0),\n    vec4(s.y, t.y, f.y, 0.0),\n    vec4(s.z, t.z, f.z, 0.0),\n    vec4(-dot(s, eye), -dot(t, eye), -dot(f, eye), 1)\n  );\n}\n\n// the OpenGL function `glFrustum()`.\nmat4 frustum(\n  float left,\n  float right,\n  float bottom,\n  float top,\n  float near,\n  float far\n) {\n  return mat4(\n    vec4(2.0 * near / (right - left), 0.0, 0.0, 0.0),\n    vec4(0, 2.0 * near / (top - bottom), 0.0, 0.0),\n    vec4(\n      (right + left) / (right - left),\n      (top + bottom) / (top - bottom),\n      -(far + near) / (far - near),\n      -1\n    ),\n    vec4(0.0, 0.0, -2.0 * far * near / (far - near), 0.0)\n  );\n}\n\nmat4 perspective(float fovDegrees, float aspect, float near, float far) {\n  float y = tan(fovDegrees * DEGREE / 2.0) * near;\n  float x = y * aspect;\n  return frustum(-x, x, -y, y, near, far);\n}\n\n// END ../common/matrices.glsl\n\n// START ../common/perlin2DTexture.glsl\nuniform sampler2D gradients;\n/* Create random direction vector\n */\nvec2 randomGradient(vec2 i) {\n  // Random float. No precomputed gradients mean this works for any number of grid coordinates\n  float random =\n    2920.0 *\n    sin(float(i.x) * 2.1942 + float(i.y) * 1.71324 + 8.912) *\n    cos(float(i.x) * 2.3157 * float(i.y) * 2.17832 + 9.758);\n  //    random = (i.x + 1667.) * (i.x + 2083.) * (i.y + 2659.) * (i.y * 50.77 + .3769);\n  //    random = sin(SQRT2 * i.x) + cos(GOLDEN_RATIO * i.y) + tan((i.x + i.y) * SQRT3);\n  return vec2(cos(random), sin(random));\n}\nfloat dotGridGradient(vec2 cell, vec2 pos) {\n  vec2 d = cell - pos;\n\n  //  vec2 gradient = texelFetch(gradients, ivec2(cell), 0).xy;\n  vec2 gradient = randomGradient(vec2(cell));\n\n  return dot(gradient, d);\n}\n\nfloat mixx(float a, float b, float t) {\n  return mix(a, b, smoothstep(0.0, 1.0, t));\n  //    return mix(a, b, t);\n}\n\n// resulting range is [-0.68, 0.68]. Use unmix to normalize if necessary.\nfloat perlin2D(vec2 xy) {\n  float x0 = floor(xy.x);\n  float x1 = x0 + 1.0;\n  float y0 = floor(xy.y);\n  float y1 = y0 + 1.0;\n\n  // Interpolate between grid point gradients\n  float n00 = dotGridGradient(vec2(x0, y0), xy);\n  float n10 = dotGridGradient(vec2(x1, y0), xy);\n  float ny0 = mixx(n00, n10, xy.x - x0);\n\n  float n01 = dotGridGradient(vec2(x0, y1), xy);\n  float n11 = dotGridGradient(vec2(x1, y1), xy);\n  float ny1 = mixx(n01, n11, xy.x - x0);\n\n  return mixx(ny0, ny1, xy.y - y0);\n}\n\n// #pragma glslify: export(perlin2D)\n\n\n// END ../common/perlin2DTexture.glsl\n// START ../common/polar.glsl\n// START ../common/fromPolar.glsl\n// START ./unmix.glsl\nfloat unmix(float a, float b, float value) {\n  return (value - a) / (b - a);\n}\n\n// #pragma glslify: export(unmix)\n\n\n// END ./unmix.glsl\n\nvec3 fromPolar(float radius, float phi, float z) {\n  return vec3(radius * cos(phi), radius * sin(phi), z);\n}\n\nvec2 fromPolar(float radius, float phi) {\n  return vec2(radius * cos(phi), radius * sin(phi));\n}\n\nvec2 fromPolar(vec2 polar) {\n  return fromPolar(polar.x, polar.y);\n}\n\n// #pragma glslify: export(fromPolar)\n\n\n// END ../common/fromPolar.glsl\n// START ../common/toPolar.glsl\n\n\nvec2 toPolar(vec2 xy) {\n  return vec2(length(xy), atan(xy.y, xy.x));\n}\n\nmat2 toPolarDerivate(vec2 xy) {\n  return mat2(xy.x * xy.x, xy.y * xy.y, -xy.y, xy.x) / dot(xy, xy);\n}\n\n// #pragma glslify: export(toPolar)\n\n\n// END ../common/toPolar.glsl\n\n// END ../common/polar.glsl\n// START ../common/remix.glsl\n\n\nfloat remix(float fromA, float fromB, float toA, float toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\nvec4 remix(float fromA, float fromB, vec4 toA, vec4 toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\n// #pragma glslify: export(remix)\n\n\n// END ../common/remix.glsl\n// START ../common/transform.glsl\nvec3 transform(mat4 pm, vec3 p) {\n  vec4 pStar = pm * vec4(p, 1);\n  return pStar.xyz / pStar.w;\n}\n\nvec2 transform(mat4 pm, vec2 p) {\n  vec4 pStar = pm * vec4(p, 0, 1);\n  return pStar.xy / pStar.w;\n}\n\n// END ../common/transform.glsl\n\n// START ../common/visualize.glsl\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\n  float isLow = float(t < 0.0);\n  float isHigh = float(t > 1.0);\n  float isMid = 1.0 - isLow - isHigh;\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\n}\n\nvec4 visualize(float t) {\n  const vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\n  const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\n  return visualize(BLUE, RED, t);\n}\n\n// #pragma glslify: export(visualize)\n\n\n// END ../common/visualize.glsl\n// START ../common/waves.glsl\nfloat waves(vec4 color, vec2 position, vec2 direction, float highResTimeStamp) {\n  return sin(\n    dot(position, direction / pow(length(direction), 2.0)) +\n      float(highResTimeStamp) / 200.0\n  );\n}\n\n// #pragma glslify: export(waves)\n\n\n// END ../common/waves.glsl\n// START ../common/sdf3d/add.glsl\nfloat add(float a, float b) {\n  return min(a, b);\n}\n\n// #pragma glslify: export(add)\n\n\n// END ../common/sdf3d/add.glsl\n// START ../common/sdf3d/addChamfer.glsl\n\n\nfloat addChamfer(float d, float a, float b) {\n  float tillet = (a + b - d) * SQRT1_2;\n  return min(tillet, min(a, b));\n}\n\n// #pragma glslify: export(addChamfer)\n\n\n// END ../common/sdf3d/addChamfer.glsl\n// START ../common/sdf3d/addTillet.glsl\nfloat addTillet(float r, float a, float b) {\n  if (a < r && b < r) {\n    return r - distance(vec2(a, b), vec2(r));\n  } else {\n    return min(a, b);\n  }\n}\n\n// #pragma glslify: export(addTillet)\n\n\n// END ../common/sdf3d/addTillet.glsl\n// START ../common/sdf3d/opElongate.glsl\nvec3 opElongate(vec3 h, vec3 p) {\n  return p - clamp(p, -h, h);\n}\n// #pragma glslify: export(opElongate)\n\n// END ../common/sdf3d/opElongate.glsl\n// START ../common/sdf3d/opRepLim.glsl\nvec3 opRepLim(vec3 p, vec3 cellSize, vec3 limit) {\n  return p - cellSize * clamp(round(p / cellSize), vec3(0.0), limit);\n}\nvec2 opRepLim(vec2 p, vec2 cellSize, vec2 limit) {\n  return p - cellSize * clamp(round(p / cellSize), vec2(0.0), limit);\n}\nfloat opRepLim(float p, float cellSize, float limit) {\n  return p - cellSize * clamp(round(p / cellSize), 0.0, limit);\n}\n\n// #pragma glslify: export(opRepLim)\n\n\n// END ../common/sdf3d/opRepLim.glsl\n// START ../common/sdf3d/sdBox.glsl\n\n\nfloat sdBox(vec3 r, vec3 p) {\n  vec3 q = abs(p) - r;\n  return length(max(q, 0.0)) + min(max3(q), 0.0);\n}\n\nfloat sdBox(vec3 r, float r2, vec3 p) {\n  return sdBox(r - r2, p) - r2;\n}\n\n// #pragma glslify: export(sdBox)\n\n\n// END ../common/sdf3d/sdBox.glsl\n// START ../common/sdf3d/sdCone.glsl\n\n\n/**\n * Signed distance function (SDF) of a cone. The tip of the cone is at the\n * origin and points towards +Z. q is a point on the rim of the cone.\n */\nfloat sdCone(vec2 c, float h, vec3 p) {\n  vec2 q = h * vec2(c.x / c.y, -1.0);\n  vec2 w = vec2(length(p.xz), p.y);\n  vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);\n  vec2 b = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0);\n  float k = sign(q.y);\n  float d = min(dot(a, a), dot(b, b));\n  float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));\n  return sqrt(d) * sign(s);\n}\n// #pragma glslify: export(sdBox)\n\nfloat sdConeB(vec2 c, float h, vec3 p) {\n  float q = length(p.xz);\n  return max(dot(c.xy, vec2(q, p.y)), -h - p.y);\n}\n\n// END ../common/sdf3d/sdCone.glsl\n// START ../common/sdf3d/sdCylinder.glsl\nfloat sdCylinder(float radius, float z, vec3 p) {\n  vec2 d = vec2(length(p.xy), abs(p.z)) - vec2(radius, z);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// #pragma glslify: export(sdCylinder)\n\n\n// END ../common/sdf3d/sdCylinder.glsl\n// START ../common/sdf3d/sdDonut.glsl\nfloat sdDonut(float r0, float r1, vec3 p) {\n  vec3 closestCenter = vec3(normalize(p.xy) * r0, 0.0);\n  return distance(closestCenter, p) - r1;\n}\n\n// #pragma glslify: export(sdDonut)\n\n\n// END ../common/sdf3d/sdDonut.glsl\n// START ../common/sdf3d/sdIcosahedron.glsl\n\n\n// signed distance function for icosahedron\n// cf. https://en.wikipedia.org/wiki/Regular_icosahedron\n// s: edge length\n// p: point to evaluate function for\nfloat sdIcosahedron(float s, vec3 p) {\n  // NN = 1/GOLDEN_RATIO = GOLDEN_RATIO - 1\n  const float K = GOLDEN_RATIO * 0.5;\n  // the three vertices of the icosahedron triangle which\n  // is fully inside the +++ octant. (edge length = 1)\n  const vec3 a = vec3(0.5, K, 0.0);\n  const vec3 b = vec3(0.0, 0.5, K);\n  const vec3 c = vec3(K, 0.0, 0.5);\n  const vec3 ab1 = b - a; // values chosen so edge length is 1\n  const vec3 n1 = normalize(cross(a, b));\n  const vec3 n2 = normalize(cross(b, c));\n  const vec3 n3 = normalize(cross(c, a));\n  const vec3 xyz1 = normalize(vec3(1.0));\n  // for edge-length 1\n  const float INSCRIBED_SPHERE_RADIUS = 0.7557613141;\n\n  // we use a rotation where the icosahedron is symmetric\n  // in all three coordinate planes, and reduce the problem\n  // to the +++ octant\n  p = abs(p);\n\n  // there is one complete triangle in the +++ octant\n  // mirror on planes which go through origin and the\n  // complete triangles sides.\n  if (dot(p, n1) < 0.0) {\n    p += -2.0 * dot(p, n1) * n1;\n  }\n  if (dot(p, n2) < 0.0) {\n    p += -2.0 * dot(p, n2) * n2;\n  }\n  if (dot(p, n3) < 0.0) {\n    p += -2.0 * dot(p, n3) * n3;\n  }\n\n  // rotate space around (1,1,1) vector so that all sides of the triangle\n  // end up mapped on the ab side.\n  vec3 dirs = vec3(-dot(n1, p), -dot(n2, p), -dot(n3, p));\n  if (dirs.y > dirs.x && dirs.y > dirs.z) {\n    p = p.yzx;\n  } else if (dirs.z > dirs.x && dirs.z > dirs.y) {\n    p = p.zxy;\n  }\n\n  // check if the point is directly (perpendicular) above the triangle.\n  // as we have rotated the space, we only need to check if it is\n  // inside one edge.\n  vec3 midAB = (a + b) / 2.0;\n  vec3 pn = normalize(c - midAB);\n  float w = dot(midAB, pn);\n  if (dot(p, pn) > w * s) {\n    // if not, return the distance to the plane the triangle is in\n    return dot(xyz1, p) - INSCRIBED_SPHERE_RADIUS * s;\n  }\n\n  // project the point onto segment ab, and return the distance to it\n  float d3 = dot(ab1, p);\n  d3 = clamp(d3, -0.5 * s, 0.5 * s);\n  vec3 closestp = midAB * s + d3 * ab1;\n  return distance(closestp, p);\n}\n// #pragma glslify: export(sdIcosahedron)\n\n// END ../common/sdf3d/sdIcosahedron.glsl\n// START ../common/sdf3d/sdOctahedron.glsl\nfloat sdOctahedron(float s, vec3 p) {\n  p = abs(p);\n  float m = p.x + p.y + p.z - s;\n  vec3 q;\n  if (3.0 * p.x < m) q = p.xyz;\n  else if (3.0 * p.y < m) q = p.yzx;\n  else if (3.0 * p.z < m) q = p.zxy;\n  else return m * 0.57735027;\n\n  float k = clamp(0.5 * (q.z - q.y + s), 0.0, s);\n  return length(vec3(q.x, q.y - s + k, q.z - k));\n}\n// #pragma glslify: export(sdOctahedron)\n\nfloat sdOctahedron(vec3 p, float s) {\n  p = abs(p);\n\n  float m = p.x + p.y + p.z - s;\n  //find point on octohedron surf nearest to p\n  vec3 projPoint = p - vec3(0.333333 * m); //project onto surface plane\n  //now push projected point, if outside triangle edge, perpendicular to edge, to edge\n  vec3 toMove = min(projPoint, 0.0); //if projpoint.x<0 move along (1.0,-0.5,-0.5) , etc\n  float toMoveSum = dot(toMove, vec3(1.0)); //which is basically along (1.5,0,0) then vec3(-0.5)\n\n  vec3 movedPoint = projPoint + toMove * vec3(-1.5) + toMoveSum * vec3(0.5); //better to multiply toMove by a matrix (1s diagonal, 0.5 other)?\n\n  movedPoint = max(movedPoint, 0.0); //cap x,y,z to 0 then\n  movedPoint *= s / dot(movedPoint, vec3(1.0)); //scale about 0,0,0\n\n  return length(p - movedPoint);\n}\n\n// END ../common/sdf3d/sdOctahedron.glsl\n// START ../common/sdf3d/sdPyramid.glsl\n// Pyramid with tip at (0,0,0), up = z\n// c is the bottom corner. c.xy should be positive, c.z negative.\nvec2 sdPyramid(vec3 c, vec3 p) {\n  // pyramid is symmetric in XZ and YZ planes\n  p.xy = abs(p.xy);\n  bool flip = p.y * c.x > p.x * c.y; // p.y/p.x > c.y/c.x\n  c.xy = flip ? c.yx : c.xy;\n  p.xy = flip ? p.yx : p.xy;\n  vec3 cc = c / dot(c, c);\n  vec3 qx1 = normalize(vec3(-c.z, 0.0, c.x));\n  vec3 pOnQx = p - qx1 * dot(p, qx1);\n  float dx = dot(p, qx1);\n  float maxY = c.y * (pOnQx.x / c.x);\n  if (p.z <= c.z || pOnQx.z <= c.z) {\n    if (p.x <= c.x) {\n      // vertically underneath pyramid\n      return vec2(-p.z + c.z, 2.0);\n    } else {\n      float aa = distance(p, vec3(c.x, min(c.y, p.y), c.z));\n      return vec2(aa, 3.0);\n    }\n  } else if (pOnQx.y > maxY || pOnQx.z > 0.0) {\n    float xx = dot(cc, p);\n    float aa = length(p - clamp(xx, 0.0, 1.0) * c);\n\n    return vec2(aa, 1.0);\n  } else {\n    // need max for negativ values above base\n    return vec2(max(dx, -p.z + c.z), 0.0);\n  }\n}\n\n// #pragma glslify: export(sdPyramid)\n\n\n// END ../common/sdf3d/sdPyramid.glsl\n// START ../common/sdf3d/sdSphere.glsl\nfloat sdSphere(float radius, vec3 p) {\n  return length(p) - radius;\n}\n\n// #pragma glslify: export(sdSphere)\n\n\n// END ../common/sdf3d/sdSphere.glsl\n// START ../common/sdf3d/sub.glsl\nfloat sub(float from, float what) {\n  return max(from, -what);\n}\n\n// #pragma glslify: export(sub)\n\n\n// END ../common/sdf3d/sub.glsl\n\nuniform sampler2D texture;\nuniform float secs;\nuniform mat4 lll;\nuniform mat4 llli;\nuniform vec4 colorPrimary;\nuniform vec4 colorSecondary;\nuniform vec4 colorBackground;\nuniform float a;\nuniform float b;\nuniform float c;\nuniform float d;\nuniform float highResTimeStamp;\nuniform int bandCount;\nuniform vec3 extra;\nuniform vec3 campos;\nin float n;\nin vec2 coord;\nout vec4 fragColor;\n\n\nconst vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\nconst vec4 yellow = vec4(1.0, 1.0, 0.0, 1.0);\nconst vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\nconst vec4 blue = vec4(0.0, 0.0, 1.0, 1.0);\nconst vec4 purple = vec4(0.5, 0.0, 0.5, 1.0);\nconst vec4 red = vec4(1.0, 0.0, 0.0, 1.0);\n\nstruct RMHit {\n  float distance;\n  vec4 color;\n};\nRMHit mixa(RMHit a, RMHit b, float t) {\n  return RMHit(mix(a.distance, b.distance, t), mix(a.color, b.color, t));\n}\nfloat skybox(vec3 p) {\n  return 32.0 - max3(abs(p));\n}\n\nfloat perlinSphere(float radius, vec3 p) {\n  vec3 cp = normalize(p);\n  float alpha = atan(cp.y, cp.x);\n  float beta = asin(cp.z);\n  return length(p) -\n  radius +\n  0.1 *\n    perlin2D(vec2(0.0 / 100.0, 0.0) + (vec2(5.0) + vec2(alpha, beta)) * 8.0);\n}\n\nfloat cylCircle(vec3 p) {\n  float d = 10e9;\n  for (int i = 0; i < 10; i++) {\n    d = min(\n      d,\n      sdCylinder(0.2, 2.0, p + fromPolar(3.0, TAU * float(i) / 10.0, 1.0))\n    );\n  }\n\n  return d;\n}\n\nfloat rblock(float r, vec3 p) {\n  return sdBox(vec3(r), p);\n}\n\nRMHit add(RMHit a, RMHit b) {\n  //    return a.distance < b.distance\n  //        ? RMHit(a.distance, a.color)\n  //        : RMHit(b.distance, b.color);\n  return mixa(a, b, float(b.distance < a.distance));\n}\n\nfloat wtf(vec3 p) {\n  vec3 center = p - mod(p, 3.0) + vec3(1.5);\n  return rblock(0.4 + 0.3 * sin(secs + center.x), p - center);\n}\n\nRMHit addTillet(float r, RMHit a, RMHit b) {\n  if (a.distance < r && b.distance < r) {\n    return RMHit(\n      r - distance(vec2(a.distance, b.distance), vec2(r)),\n      mix(a.color, b.color, (a.distance - b.distance) / r * 0.5 + 0.5)\n    );\n  } else {\n    return add(a, b);\n  }\n}\n\nRMHit addTillet(float r, RMHit a, RMHit b, vec4 tilletColor) {\n  if (a.distance < r && b.distance < r) {\n    return RMHit(\n      r - distance(vec2(a.distance, b.distance), vec2(r)),\n      tilletColor\n    );\n  } else {\n    return add(a, b);\n  }\n}\nRMHit addTillet2(float r, RMHit a, RMHit b) {\n  float h = smoothstep(-r, r, a.distance - b.distance);\n  return RMHit(\n    mix(a.distance, b.distance, h) - r * h * (1.0 - h),\n    mix(a.color, b.color, h)\n  );\n}\n\nRMHit neg(RMHit a) {\n  return RMHit(-a.distance, a.color);\n}\nRMHit sub(RMHit from, RMHit what) {\n  RMHit whatNeg = neg(what);\n  return mixa(from, whatNeg, float(whatNeg.distance > from.distance));\n}\n\nvec3 modv(vec3 v, vec3 dir1, float y) {\n  float t = dot(v, dir1);\n  return v - floor(t / y) * y * dir1;\n}\nvec3 modRotZ(vec3 p, float count) {\n  vec2 polarXY = toPolar(p.xy);\n  return fromPolar(polarXY.x, mod(polarXY.y, TAU / count), p.z);\n}\n\nfloat sin01(float x) {\n  return 0.5 + 0.5 * sin(x);\n}\nfloat cos01(float x) {\n  return 0.5 + 0.5 * cos(x);\n}\n\nfloat betterBox(vec3 r, vec3 p) {\n  vec3 q = abs(p) - r;\n  return length(max(q, 0.0)) + min(max3(q), 0.0);\n  p = abs(p);\n  return max3(p - r);\n}\n\nfloat roundedBlock(vec3 r, float cr, vec3 p) {\n  return betterBox(r - vec3(cr), p) - cr;\n}\n\nfloat sdCapsule(vec3 a, vec3 b, float r, vec3 p) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h) - r;\n}\nfloat sdEllipsoidB(vec3 r, vec3 p) {\n  float k0 = length(p / r);\n  float k1 = length(p / (r * r));\n  return k0 * (k0 - 1.0) / k1;\n}\nfloat sdOctahedronB(float s, vec3 p) {\n  p = abs(p);\n  return (p.x + p.y + p.z - s) * 0.57735027;\n}\nfloat donutc(float r0, float r1, vec3 p) {\n  vec3 closestCenter = vec3(normalize(p.xy) * r0, 0.0);\n  return distance(closestCenter, p) - r1;\n}\n\nfloat sdCappedCylinder(float h, float r, vec3 p) {\n  vec2 d = vec2(length(p.xy), abs(p.z)) - vec2(r, h);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\nfloat smoothmin(float r, float a, float b) {\n  float h = smoothstep(-r, r, a - b);\n  return mix(a, b, h) - r * h * (1.0 - h);\n}\nfloat queen(vec3 p) {\n  float lxy = length(p.xy);\n  float d;\n  d = lxy - 1.1;\n  d += 0.16 * p.z;\n  d -= -c * (1.0 - pow(sin01(b + p.z * 2.5), 1.5));\n  d += 0.1 * normalize(p.xy).x * smoothstep(2.0, 0.5, p.z);\n  d +=\n    0.02 * sin(15.0 * atan(p.y, p.x) - p.z * 5.0) * smoothstep(2.0, 0.5, p.z);\n  //    float d = sdCappedCylinder(a, b, p);\n  d = max(d, -p.z);\n  d = max(d, p.z - 4.0);\n\n  float head = sdSphere(0.55, p - vec3(0.0, 0.0, 4.4));\n  d = smoothmin(0.15, d, head);\n  float crown = sdCone(\n    fromPolar(vec2(1.0, 1.15)),\n    1.0,\n    -(p - vec3(0.0, 0.0, 4.5)).yzx\n  );\n  d = min(d, crown);\n  d *= 0.5;\n  return d;\n}\n\nvec2 project(vec2 a, vec2 onto1) {\n  return onto1 * (dot(a, onto1) / dot(onto1, onto1));\n}\n\nvec3 reject(vec3 a, vec3 b1) {\n  return a - b1 * dot(a, b1);\n}\n\nRMHit sdf(vec3 p) {\n  const vec4 red = vec4(0.2, 0.0, 0.0, 1.0);\n  //  RMHit d = RMHit(block(vec3(-1.0, -1.0, -1.0), vec3(1.0, 1.0, 1.0), p), black);\n  //    RMHit d = RMHit(sphere(2., p), black);\n  //    RMHit d = RMHit(betterBox(vec3(1.), p), black);\n  //    RMHit d = RMHit(roundedBlock(vec3(1.), 0.1, p), black);\n  //    RMHit d = RMHit(donut(2., 0.5, p), black);\n  //    RMHit d = RMHit(sdCapsule(vec3(-a,-a,0.), vec3(a,a,0.), b, p), black);\n  //    RMHit d = RMHit(sdEllipsoidB(vec3(-a,-b,1.), p), black);\n  //    RMHit d = RMHit(sdOctahedron(1., p)-a, red) ;\n  //    RMHit d = RMHit(queen(p), black) ;\n  //    RMHit d = RMHit(lego(p), black) ;\n  //- vec3(0.0, 0.0, 1.0)\n  vec3 h = vec3(0.5, 0.0, 0.0);\n  vec3 q = abs(p) - h;\n  //    vec2 pyr = sdPyramid(\n  //        vec3(2.0, 2.0, -2.0),\n  //        opElongate(h,\n  //            rotZ(highResTimeStamp/1000.) *\n  //                rotX(c) *\n  //                opRepLim(p - vec3(-8., -8., 2.), vec3(8.), vec3(2., 2., 0.))));\n  vec3 p2 = rotX(highResTimeStamp * 0.0) * p;\n  vec2 xx = vec2(sdIcosahedron(d, p2) - c, 1.0);\n  vec4 cc = red;\n  cc.xyz = cc.xyz * xx.y * 0.1;\n  RMHit d = RMHit(xx.x, cc);\n  //    RMHit d = RMHit(sdCone(fromPolar(vec2(1., a)), b, p.yzx - vec3(0.,2., 0.)), black);\n  //    d.distance = abs(d.distance) - 0.4;\n  //    d.distance = abs(d.distance) - 0.1;\n  //    d.distance = abs(d.distance) - 0.02;\n  float s = length(p - vec3(1.0, 1.0, 0.0)) - 1.0;\n  //    d.distance = s;\n  //    d.distance = max(d.distance, -s);\n\n  vec3 color = 0.1 * sin(abs(vec3(0.0, PI, 0.0) + vec3(d.distance * PI * 2.0)));\n  //    color.z = .1*xx.y;\n  RMHit base = RMHit(sdBox(vec3(10.0, 10.0, 0.0), p), vec4(color, 1.0));\n\n  //    d = base;\n  d = add(base, d);\n  if (b > 1.0) {\n    d = base;\n  }\n  //    d.distance *=0.5;\n  return d;\n}\nfloat sdff(vec3 p) {\n  return sdf(p).distance;\n}\nfloat ambientOcclusion(vec3 pWC, vec3 n1WC) {\n  float k = 1.0;\n  float distance = sdff(pWC + n1WC * k);\n  return clamp(distance / k, 0.0, 1.0);\n}\n\nstruct RMResult {\n  float distance;\n  vec3 pos;\n  vec4 color;\n};\nRMResult raymarching2(vec3 start, vec3 dir1) {\n  vec3 pos = start;\n  RMHit hit;\n  for (int i = 0; i < 200; i++) {\n    hit = sdf(pos);\n    if (hit.distance < 0.0001 * hit.distance) break;\n    pos = pos + dir1 * hit.distance;\n  }\n  return RMResult(hit.distance, pos, hit.color);\n}\n\nfloat softshadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {\n  float res = 1.0;\n  float t = 0.1;\n  for (int i = 0; i < 1000 && t < maxt; i++) {\n    float h = sdff(ro + rd * t);\n    if (h < 0.001) return 0.0;\n    res = min(res, k * h / t);\n    t += h;\n  }\n  return res;\n}\n\nconst float eps = 1e-4;\nvec3 sdfNormal1(vec3 p, float d) {\n  return normalize(\n    vec3(\n      sdff(p + vec3(eps, 0.0, 0.0)),\n      sdff(p + vec3(0.0, eps, 0.0)),\n      sdff(p + vec3(0.0, 0.0, eps))\n    ) -\n      vec3(sdff(p))\n  );\n}\n\n//layout (depth_greater) out float gl_FragDepth;\nvoid main() {\n  vec3 light = normalize(vec3(-1.0, -2.0, -2));\n\n  vec3 a = vec3(coord, -1.0);\n  vec3 b = vec3(coord, 1.0);\n  vec3 aWC = transform(llli, a);\n  vec3 bWC = transform(llli, b);\n  vec3 lookDir1 = normalize(bWC - aWC);\n\n  RMResult hitWC = raymarching2(aWC, lookDir1);\n  vec3 hitn1 = sdfNormal1(hitWC.pos, hitWC.distance);\n  float dWC = distance(aWC, hitWC.pos);\n  vec3 hitNDC = transform(lll, hitWC.pos);\n  vec3 p = hitWC.pos;\n  float inSun = softshadow(\n    hitWC.pos + hitn1 * 0.05,\n    -light,\n    0.0001,\n    300.0,\n    8.0\n  );\n  //    float inSun=1.;\n\n  vec3 material = hitWC.color.xyz;\n  if (dWC > 100.0) {\n    material = vec3(0.0, 0.0, 0.0);\n    //    } else if (p.z >= 0.001) {\n    //        material = vec3(0.2, 0.0, 0.0);\n    //    } else {\n    //        vec2 c = vec2(4.0, 2.0);\n    //        vec2 id = floor(((p.xy - c * 0.5) / c) );\n    //        material += .15 * cos(vec3(id.x, id.y + 2., id.x + id.y + 4.));\n  }\n\n  const vec3 sunlightColor = vec3(8.0, 6.0, 1.0);\n\n  float aOcc = ambientOcclusion(hitWC.pos, hitn1);\n\n  vec3 reflectionDirection = reflect(light, hitn1);\n\n  vec3 color = vec3(0.0);\n  color += material * aOcc;\n  color += inSun * sunlightColor * material * max(0.0, dot(-light, hitn1));\n  //    color = (hitn1);\n\n  vec3 camPos = aWC;\n\n  vec3 eyeDirection = -lookDir1;\n  float uMaterialShininess = 256.0;\n  float specularLightWeighting = pow(\n    max(dot(reflectionDirection, eyeDirection), 0.0),\n    uMaterialShininess\n  );\n  color += specularLightWeighting;\n  //    float lightIntensity = 0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.);\n  //    float lightIntensity =\n  //        0.2 + 0.5*clamp( -dot(light, hitn1),0., 1.) + 0.3*specularLightWeighting;\n  //    fragColor = visualize(blue, red, mix(0.5, 1.0, inSun) * lightIntensity);\n  //    fragColor = mix(hitWC.color, colorBackground, mix(0.5, 1.0, inSun) * clamp(lightIntensity, 0., 1.));\n  color = pow(color, vec3(1.0 / 2.2)); // gamma correction\n  fragColor = vec4(color, 1.0);\n}\n"},2416:(n,t,e)=>{e.d(t,{Z:()=>o});const o="#version 300 es\n\nprecision highp float;\n// START ../common/visualize.glsl\nvec4 visualize(vec4 lowColor, vec4 highColor, float t) {\n  float isLow = float(t < 0.0);\n  float isHigh = float(t > 1.0);\n  float isMid = 1.0 - isLow - isHigh;\n  return lowColor * isLow + isMid * vec4(t, t, t, 1.0) + highColor * isHigh;\n}\n\nvec4 visualize(float t) {\n  const vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\n  const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\n  return visualize(BLUE, RED, t);\n}\n\n// #pragma glslify: export(visualize)\n\n\n// END ../common/visualize.glsl\n// START ../common/banded.glsl\nfloat banded(float bandCount, float t) {\n  return floor(t * float(bandCount)) / float(bandCount - 1.0);\n}\nfloat banded(int bandCount, float t) {\n  return banded(float(bandCount), t);\n}\n\n// #pragma glslify: export(banded)\n\n\n// END ../common/banded.glsl\n\nuniform vec4 color;\n\nout vec4 fragColor;\n\nvoid main() {\n  fragColor = color;\n}\n"},1692:(n,t,e)=>{e.d(t,{Z:()=>o});const o="#version 300 es\nprecision highp float;\n\nuniform mat4 ts_ModelViewProjectionMatrix;\nuniform float normalOffset;\nin vec3 ts_Normal;\nin vec4 ts_Vertex;\n\nvoid main() {\n  gl_Position =\n    ts_ModelViewProjectionMatrix *\n    (ts_Vertex + normalOffset * vec4(ts_Normal, 0.0));\n}\n"},5583:(n,t,e)=>{e.d(t,{Z:()=>r});var o=setTimeout;function a(n,t){var e=t.useCachedSetTimeout?o:setTimeout;return new Promise((function(t){e(t,n)}))}const r=function(n){var t=a(n,{useCachedSetTimeout:(arguments.length>1&&void 0!==arguments[1]?arguments[1]:{}).useCachedSetTimeout});function e(n){return t.then((function(){return n}))}return e.then=function(){return t.then.apply(t,arguments)},e.catch=Promise.resolve().catch,e}},492:(n,t,e)=>{function o(n,t){for(var e=0;e<t.length;e++){var o=t[e];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(n,"symbol"==typeof(a=function(n,t){if("object"!=typeof n||null===n)return n;var e=n[Symbol.toPrimitive];if(void 0!==e){var o=e.call(n,"string");if("object"!=typeof o)return o;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(n)}(o.key))?a:String(a),o)}var a}function a(n){return function(n){if(Array.isArray(n))return i(n)}(n)||function(n){if("undefined"!=typeof Symbol&&null!=n[Symbol.iterator]||null!=n["@@iterator"])return Array.from(n)}(n)||r(n)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function r(n,t){if(n){if("string"==typeof n)return i(n,t);var e=Object.prototype.toString.call(n).slice(8,-1);return"Object"===e&&n.constructor&&(e=n.constructor.name),"Map"===e||"Set"===e?Array.from(n):"Arguments"===e||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e)?i(n,t):void 0}}function i(n,t){(null==t||t>n.length)&&(t=n.length);for(var e=0,o=new Array(t);e<t;e++)o[e]=n[e];return o}function l(n,t){var e="undefined"!=typeof Symbol&&n[Symbol.iterator]||n["@@iterator"];if(!e){if(Array.isArray(n)||(e=r(n))||t&&n&&"number"==typeof n.length){e&&(n=e);var o=0,a=function(){};return{s:a,n:function(){return o>=n.length?{done:!0}:{done:!1,value:n[o++]}},e:function(n){throw n},f:a}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var i,l=!0,s=!1;return{s:function(){e=e.call(n)},n:function(){var n=e.next();return l=n.done,n},e:function(n){s=!0,i=n},f:function(){try{l||null==e.return||e.return()}finally{if(s)throw i}}}}e.d(t,{Z:()=>u});var s=0;function c(n){return"__private_"+s+++"_"+n}function d(n,t){if(!Object.prototype.hasOwnProperty.call(n,t))throw new TypeError("attempted to use private field on non-instance");return n}var f=c("charaters"),p=c("styleDict"),m=c("styleReverseMap"),u=function(){function n(){!function(n,t){if(!(n instanceof t))throw new TypeError("Cannot call a class as a function")}(this,n)}return t=n,e=[{key:"format",value:function(t,e){return e in d(n,p)[p]||(d(n,p)[p][e]=n._generateMap(n.styles[e])),function(n,t){var e,o="",a=l(n);try{for(a.s();!(e=a.n()).done;){var r=e.value;o+=t.get(r)||r}}catch(n){a.e(n)}finally{a.f()}return o}(t,d(n,p)[p][e])}},{key:"_generateMap",value:function(t){var e,o=new Map,r=t.hasOwnProperty("exceptions");if(r)for(var i in e=[],Object.keys(t.exceptions).forEach((function(n){e=[].concat(a(e),a(n))})),t.exceptions){var s,c=t.exceptions[i],p=0,m=l(i);try{for(m.s();!(s=m.n()).done;){var u=s.value,h=String.fromCodePoint(p+c);o.set(u,h),p++}}catch(n){m.e(n)}finally{m.f()}}for(var v in!t.hasOwnProperty("upper")&&t.hasOwnProperty("lower")?t.upper=t.lower:!t.hasOwnProperty("lower")&&t.hasOwnProperty("upper")&&(t.lower=t.upper),d(n,f)[f])if("number"==typeof t[v]){var g,y=l(d(n,f)[f][v].chars);try{for(y.s();!(g=y.n()).done;){var x=g.value;if(!r||!e.includes(x)){var b=x.codePointAt(0),C=String.fromCodePoint(b+t[v]-d(n,f)[f][v]["lower-bound"]);o.set(x,C)}}}catch(n){y.e(n)}finally{y.f()}}return o}},{key:"unformat",value:function(t){void 0===d(n,m)[m]&&n._generateReverseMap();var e,o="",a=l(t);try{for(a.s();!(e=a.n()).done;){var r=e.value;o+=d(n,m)[m].get(r)||r}}catch(n){a.e(n)}finally{a.f()}return o}},{key:"_generateReverseMap",value:function(){for(var t={},e=arguments.length,o=new Array(e),a=0;a<e;a++)o[a]=arguments[a];if(0===o.length)for(var i in t=n.styles,d(n,f)[f]){var s=d(n,f)[f][i]["lower-bound"];t.normal=s}else o.forEach((function(e){t.push(n.styles[e])}));for(var c in d(n,m)[m]=new Map,t){var u,h=l(c in d(n,p)[p]?d(n,p)[p][c]:n._generateMap(t[c]));try{for(h.s();!(u=h.n()).done;){var v=(x=u.value,2,function(n){if(Array.isArray(n))return n}(x)||function(n,t){var e=null==n?null:"undefined"!=typeof Symbol&&n[Symbol.iterator]||n["@@iterator"];if(null!=e){var o,a,r,i,l=[],s=!0,c=!1;try{for(r=(e=e.call(n)).next,0;!(s=(o=r.call(e)).done)&&(l.push(o.value),2!==l.length);s=!0);}catch(n){c=!0,a=n}finally{try{if(!s&&null!=e.return&&(i=e.return(),Object(i)!==i))return}finally{if(c)throw a}}return l}}(x)||r(x,2)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()),g=v[0],y=v[1];d(n,m)[m].set(y,g)}}catch(n){h.e(n)}finally{h.f()}}var x}}],null&&o(t.prototype,null),e&&o(t,e),Object.defineProperty(t,"prototype",{writable:!1}),n;var t,e}();u.styles={"serf-bold":{upper:119808,lower:119834,digits:120783,zero:120782},"serf-italic":{upper:119860,lower:119886,exceptions:{h:8462}},"serf-bold-italic":{upper:119912,lower:119938},"sans-serf":{upper:120224,lower:120250,digits:120803,zero:120802},"sans-serf-bold":{upper:120276,lower:120302,digits:120813,zero:120812},"sans-serf-italic":{upper:120328,lower:120354},"sans-serf-bold-italic":{upper:120380,lower:120406},script:{upper:119964,lower:119990,exceptions:{B:8492,EF:8496,H:8459,I:8464,L:8466,M:8499,R:8475,e:8495,g:8458,o:8500}},"script-bold":{upper:120016,lower:120042},fraktur:{upper:120068,lower:120094,exceptions:{C:8493,H:8460,I:8465,R:8476,Z:8488}},"fraktur-bold":{upper:120172,lower:120198},monospace:{upper:120432,lower:120458,digits:120823,zero:120822},"double-struck":{upper:120120,lower:120146,digits:120793,zero:120792,exceptions:{C:8450,H:8461,N:8469,P:8473,Q:8474,R:8477,Z:8484}},circled:{upper:9398,lower:9424,digits:9312,zero:127243},"negative-circled":{upper:127312,zero:9471},"parenthesized-small":{lower:9372,digits:9332},"parenthesized-large":{upper:127248},squared:{upper:127280},"negative-squared":{upper:127344}},Object.defineProperty(u,f,{writable:!0,value:{lower:{chars:"abcdefghijklmnopqrstuvwxyz","lower-bound":97},upper:{chars:"ABCDEFGHIJKLMNOPQRSTUVWXYZ","lower-bound":65},digits:{chars:"123456789","lower-bound":49},zero:{chars:"0","lower-bound":48}}}),Object.defineProperty(u,p,{writable:!0,value:{}}),Object.defineProperty(u,m,{writable:!0,value:void 0})}}]);